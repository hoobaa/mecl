(#Y(si::bytecodes nil nil (14 0 19 1 1 29) #A(t (2) (:sockets require)) #1=#P"/Users/strobolights/dev/mecl/ecl-build-for-ios64/compile.lsp" 0) #Y(si::bytecodes nil nil (15 0 77 77 15 1 77 77 15 2 77 77 77 19 10 3 29) #A(t (4) ("ECL-CURL" ("SB-BSD-SOCKETS" "CL") ("DOWNLOAD-URL-TO-FILE" "DOWNLOAD-ERROR" "DOWNLOAD-URL" "DOWNLOAD-RESPONSE") si::dodefpackage)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("ECL-CURL" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 77 19 4 3 1 0 73 29) #A(t (4) (ecl-curl::http-transfer-error (error) ((:readers (ecl-curl::download-url) :initargs (:url) :name ecl-curl::url)) clos::load-defclass)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 14 2 1 10 12 1 11 7 3 12 1 12 6 2 12 77 19 4 13 1 0 73 29) #2=#A(t (14) (ecl-curl::download-error (ecl-curl::http-transfer-error) :initfunction ecl-curl::c ecl-curl::s #3="Server responded ~A for GET ~A" ecl-curl::download-response ecl-curl::download-url format #Y(nil nil nil (24 45 3 24 45 4 26 13 0 15 5 13 1 19 1 6 12 13 1 19 1 7 12 19 4 8 29) #2# #1# 0) #Y(nil nil nil (26 34 9 73 29) #2# #1# 0) (:initform (lambda (ecl-curl::c ecl-curl::s) (format ecl-curl::s #3# (ecl-curl::download-response ecl-curl::c) (ecl-curl::download-url ecl-curl::c))) :name si::report-function) (:readers (ecl-curl::download-response) :initargs (:response) :name ecl-curl::response) clos::load-defclass)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 8192 52 0 1 0 73 29) #A(t (3) (ecl-curl::*stream-buffer-size* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #4=#A(t (19) (ecl-curl::copy-stream ecl-curl::from ecl-curl::to stream-element-type subtypep "Incompatible streams ~A and ~A." error ecl-curl::*stream-buffer-size* :element-type make-array ecl-curl::buf 0 read-sequence ecl-curl::pos zerop :end write-sequence #Y(ecl-curl::copy-stream nil nil (24 45 1 24 45 2 26 10 0 16 3 12 10 1 16 3 12 19 2 4 76 39 10 15 5 13 1 13 0 19 3 6 14 7 14 8 10 1 16 3 12 19 3 9 45 10 58 60 44 57 11 61 1 1 13 2 13 4 19 2 12 45 13 10 0 16 14 39 5 75 73 36 2 13 3 13 4 14 15 13 0 19 4 16 43 1 35 0 0 62 73 63 43 1 29) #4# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 1 0 73 29) #5=#A(t (24) (ecl-curl::make-stream-from-url ecl-curl::url sb-bsd-sockets::inet-socket :type :stream :protocol :tcp make-instance ecl-curl::s ecl-curl::url-host sb-bsd-sockets::get-host-by-name sb-bsd-sockets::host-ent-addresses ecl-curl::url-port sb-bsd-sockets::socket-connect :input t :output :buffering :full :external-format :iso-8859-1 sb-bsd-sockets::socket-make-stream #Y(ecl-curl::make-stream-from-url nil nil (24 45 1 26 15 2 14 3 14 4 14 5 14 6 19 5 7 45 8 13 0 13 1 19 1 9 12 19 1 10 12 19 1 11 4 12 13 1 19 1 12 12 19 3 13 13 0 14 14 14 15 14 16 14 15 14 17 14 18 14 19 14 20 19 9 21 43 1 29) #5# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #6=#A(t (18) (ecl-curl::url-host ecl-curl::url (string-equal ecl-curl::url #7="http://" :end1 7) si::assert-failure #7# :end1 string-equal #\: :start position ecl-curl::port-start #\/ length min ecl-curl::host-end subseq #Y(ecl-curl::url-host nil nil (24 45 1 26 38 6 15 2 19 1 3 13 0 15 4 14 5 9 7 19 4 6 76 40 -18 15 7 13 0 14 8 9 7 19 4 9 45 10 15 11 13 1 14 8 9 7 19 4 9 73 40 5 10 1 16 12 12 10 0 73 40 5 10 1 16 12 12 19 2 13 45 14 13 2 9 7 13 0 19 3 15 43 2 29) #6# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #8=#A(t (17) (ecl-curl::url-port ecl-curl::url (string-equal ecl-curl::url #9="http://" :end1 7) si::assert-failure #9# :end1 string-equal #\: :start position ecl-curl::port-start 1+ :junk-allowed t parse-integer #Y(ecl-curl::url-port nil nil (24 45 1 26 38 6 15 2 19 1 3 13 0 15 4 14 5 9 7 19 4 6 76 40 -18 15 7 13 0 14 8 9 7 19 4 9 45 10 10 0 39 19 13 1 14 8 10 0 16 11 12 14 12 14 13 19 5 14 38 4 8 80 73 43 1 29) #8# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 2 52 0 1 0 73 29) #A(t (3) (ecl-curl::*encode-table* si::*make-special "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=")) #1# 0) #Y(si::bytecodes nil nil (15 0 1 32 12 19 2 33 1 0 73 29) #10=#A(t (34) (ecl-curl::base64-encode string length + / truncate * :element-type base-char make-array ecl-curl::result ecl-curl::value ecl-curl::chars ecl-curl::didx ecl-curl::sidx char char-code logand ash si::%dotimes-var ecl-curl::n < logior #:g25165 = 1+ ecl-curl::*encode-table* > elt si::elt-set >= t #Y(ecl-curl::base64-encode nil nil (24 45 1 26 9 4 9 2 10 0 16 2 12 19 2 3 12 9 3 19 2 4 12 19 1 5 12 19 2 6 6 1 12 14 7 15 8 19 3 9 45 10 9 0 9 0 9 2 77 46 11 46 12 46 13 46 14 38 301 9 255 13 5 10 0 17 15 16 16 12 19 2 17 12 8 8 17 18 51 3 8 2 45 19 8 0 45 20 38 88 13 2 13 0 9 1 19 3 3 12 10 7 16 2 12 19 2 21 39 45 13 5 9 255 13 7 13 2 13 0 9 1 19 3 3 17 15 16 16 12 19 2 17 12 19 2 22 51 5 8 1 45 23 13 5 13 0 19 2 3 51 5 43 1 13 0 9 0 19 2 24 39 9 13 5 8 8 17 18 51 5 10 0 16 25 51 0 13 0 13 1 19 2 21 40 -95 43 2 13 4 13 1 9 3 19 2 3 12 14 26 13 2 9 3 19 2 27 39 10 13 3 9 63 19 2 17 38 3 8 64 17 28 12 19 3 29 13 3 8 -6 17 18 51 3 13 4 13 1 9 2 19 2 3 12 14 26 13 2 9 2 19 2 27 39 10 13 3 9 63 19 2 17 38 3 8 64 17 28 12 19 3 29 13 3 8 -6 17 18 51 3 13 4 13 1 9 1 19 2 3 12 14 26 13 3 9 63 19 2 17 17 28 12 19 3 29 13 3 8 -6 17 18 51 3 13 4 13 1 14 26 13 3 9 63 19 2 17 17 28 12 19 3 29 13 0 9 3 19 2 3 12 13 1 9 4 19 2 3 12 9 2 77 53 3 53 2 53 1 53 0 13 0 10 5 16 2 12 19 2 30 39 -311 11 31 43 4 10 0 73 43 1 29) #10# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 7 1 3 16 4 52 0 1 0 73 29) #A(t (5) (ecl-curl::*proxy* si::*make-special boundp "http_proxy" ext::getenv)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (ecl-curl::*proxy-user* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (ecl-curl::*proxy-passwd* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #11=#A(t (16) (ecl-curl::request-uri ecl-curl::url (string-equal ecl-curl::url #12="http://" :end1 7) si::assert-failure #12# :end1 string-equal ecl-curl::*proxy* #\/ :start position ecl-curl::path-start subseq "/index.html" #Y(ecl-curl::request-uri nil nil (24 45 1 26 38 6 15 2 19 1 3 13 0 15 4 14 5 9 7 19 4 6 76 40 -18 11 7 39 6 10 0 73 38 32 15 8 13 0 14 9 9 7 19 4 10 45 11 10 0 39 10 13 1 13 0 19 2 12 38 4 1 13 73 43 1 29) #11# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #13=#A(t (12) (ecl-curl::header-pair ecl-curl::name ecl-curl::headers :test ecl-curl::a ecl-curl::b symbol-name string-equal #Y(nil nil nil (24 45 4 24 45 5 26 10 1 16 6 12 10 0 16 6 12 19 2 7 29) #13# #1# 0) assoc #Y(ecl-curl::header-pair nil nil (24 45 1 24 45 2 26 13 1 13 0 14 3 34 8 12 19 4 9 29) #13# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #14=#A(t (6) (ecl-curl::header-value ecl-curl::name ecl-curl::headers ecl-curl::header-pair #Y(ecl-curl::header-value nil nil (24 45 1 24 45 2 26 13 1 13 0 19 2 3 5 73 29) #14# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 46 12 19 2 47 1 0 73 29) #15=#A(t (48) (ecl-curl::url-connection ecl-curl::url ecl-curl::*proxy* ecl-curl::make-stream-from-url ecl-curl::url-host ecl-curl::host stream "GET ~A HTTP/1.0~C~CHost: ~A~C~C" ecl-curl::request-uri #\Return #\Newline format ecl-curl::*proxy-passwd* ecl-curl::*proxy-user* "Proxy-Authorization: Basic ~A~C~C" "~A:~A" ecl-curl::base64-encode "~C~C" force-output read-line ecl-curl::l #\  position space :start 1+ :junk-allowed t parse-integer ecl-curl::line #:loop-list-head25184 #:loop-list-tail25185 0 length zerop elt code-char eql #\: ecl-curl::colon subseq string-upcase :keyword intern string-trim rplacd #Y(ecl-curl::url-connection nil nil (24 45 1 26 11 2 73 40 4 10 0 73 12 19 1 3 12 13 0 19 1 4 12 46 5 46 6 13 0 15 7 13 2 19 1 8 12 15 9 15 10 13 1 15 9 15 10 19 8 11 11 12 39 3 11 13 39 27 13 0 15 14 77 15 15 14 13 14 12 19 4 11 12 19 1 16 12 15 9 15 10 19 5 11 13 0 15 17 15 9 15 10 19 4 11 13 0 19 1 18 13 0 19 1 19 45 20 15 21 13 0 19 2 22 45 23 13 1 14 24 10 0 16 25 12 14 26 14 27 19 5 28 12 43 2 58 60 134 75 45 29 75 6 1 45 30 10 0 45 31 57 32 61 2 2 103 13 5 19 1 19 51 3 10 3 76 40 22 10 3 16 33 16 34 40 14 13 3 8 0 17 35 12 8 13 16 36 17 37 39 4 35 0 1 13 1 15 38 13 3 19 2 22 45 39 13 4 9 0 13 0 19 3 40 12 19 1 41 12 14 42 19 2 43 12 15 21 8 13 16 36 6 2 12 13 4 10 0 16 25 12 19 2 40 17 44 3 43 1 6 1 51 1 17 45 35 0 0 10 2 5 73 36 4 62 73 43 2 43 1 63 12 13 0 72 3 43 2 29) #15# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 47 12 19 2 48 1 0 73 29) #16=#A(t (49) (ecl-curl::download-url-to-file ecl-curl::url ecl-curl::file-name (nil :quiet) ecl-curl::quiet 0 ecl-curl::url-connection stream ecl-curl::headers ecl-curl::response (301 302) member close :location ecl-curl::header-value >= ecl-curl::download-error :url :response error :content-length "" :junk-allowed t parse-integer length "~&;;; Downloading ~A bytes from ~A to ~A ...~%" "some unknown number of" format force-output ecl-curl::o ecl-curl::ok? :direction :output :if-exists :supersede :external-format :latin-1 open :element-type stream-element-type make-array ecl-curl::buf read-sequence write-sequence ecl-curl::copy-stream :abort #Y(ecl-curl::download-url-to-file nil nil (24 45 1 24 45 2 28 3 22 40 2 77 46 4 58 60 61 57 5 61 1 1 13 4 19 1 6 47 2 7 47 1 8 45 9 13 0 15 10 19 2 11 76 39 11 13 0 13 1 13 2 72 3 36 4 13 2 19 1 12 14 13 13 1 19 2 14 51 7 43 3 35 0 0 62 73 63 47 2 7 47 1 8 45 9 13 0 9 400 19 2 15 39 14 15 16 14 17 13 5 14 18 13 0 19 5 19 14 20 13 1 19 2 14 73 40 4 1 21 73 12 14 22 14 23 19 3 24 45 25 10 4 76 39 21 14 23 15 26 10 0 73 40 4 1 27 73 12 13 6 13 5 19 5 28 19 0 29 77 77 46 30 46 31 64 68 13 7 14 32 14 33 14 34 14 35 14 36 14 37 19 7 38 51 1 10 2 39 33 13 2 14 39 10 5 16 40 12 19 3 41 45 42 13 0 13 6 19 2 43 13 0 13 2 19 2 44 43 1 38 8 13 5 13 1 19 2 45 11 23 51 0 65 10 1 39 12 13 1 14 46 10 0 76 12 19 3 12 66 43 2 43 1 13 2 19 1 12 43 3 13 2 72 1 29) #16# #1# 0) si::fset)) #1# 0))
