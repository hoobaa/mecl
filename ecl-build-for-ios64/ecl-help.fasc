(#Y(si::bytecodes nil nil (15 0 77 77 15 1 77 77 15 2 77 77 77 19 10 3 29) #A(t (4) ("ECL-CDB" ("CL") ("WITH-OUTPUT-TO-CDB" "ADD-RECORD" "LOOKUP-CDB") si::dodefpackage)) #1=#P"/Users/strobolights/dev/mecl/ecl-build-for-ios64/compile.lsp" 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("ECL-CDB" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 77 77 77 15 5 9 5 77 77 15 6 19 15 7 15 0 19 1 19 78 15 15 8 1 17 12 19 2 18 1 0 73 29) #2=#A(t (20) (ecl-cdb::cdb "CDB-" (stream pathname ecl-cdb::word-buffer ecl-cdb::tables ecl-cdb::temporary-pathname) ((stream nil t nil 0 nil) (pathname nil t nil 1 nil) (ecl-cdb::word-buffer nil t nil 2 nil) (ecl-cdb::tables nil t nil 3 nil) (ecl-cdb::temporary-pathname nil t nil 4 nil)) ecl-cdb::copy-cdb (ecl-cdb::make-cdb) ecl-cdb::cdb-p si::define-structure ecl-cdb::make-cdb (nil :temporary-pathname :tables :word-buffer :pathname :stream) #:stream #:pathname #:word-buffer #:tables #:temporary-pathname 0 si::make-structure #Y(ecl-cdb::make-cdb nil nil (28 9 22 40 2 77 46 10 22 40 2 77 46 11 22 40 2 77 46 12 22 40 2 77 46 13 22 40 2 77 46 14 15 15 13 4 13 3 13 2 13 1 13 0 19 6 16 29) #2# #1# 0) si::fset find-class)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #3=#A(t (7) (ecl-cdb::read-word stream read-byte ash logior #Y(ecl-cdb::read-word nil nil (24 45 1 26 13 0 19 1 2 12 13 0 19 1 2 12 8 8 17 3 12 13 0 19 1 2 12 8 16 17 3 12 13 0 19 1 2 12 8 24 17 3 12 19 4 4 29) #3# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #4=#A(t (8) (ecl-cdb::write-word byte stream logand write-byte ash #Y(ecl-cdb::write-word nil nil (24 45 1 24 45 2 26 9 255 13 1 19 2 3 12 10 0 17 4 9 255 13 1 8 -8 17 5 12 19 2 3 12 10 0 17 4 9 255 13 1 8 -16 17 5 12 19 2 3 12 10 0 17 4 9 255 13 1 8 -24 17 5 12 19 2 3 12 10 0 17 4 29) #4# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #5=#A(t (15) (ecl-cdb::write-vector vector stream #:loop-across-list18763 #:loop-across-index-18762 #:loop-across-vector-18761 ecl-cdb::v 0 length >= aref 1+ ecl-cdb::write-word #Y(ecl-cdb::write-vector nil nil (24 45 1 24 45 2 26 77 13 1 9 0 9 0 46 3 46 4 46 5 46 6 57 7 61 2 8 44 10 2 16 8 51 4 13 3 13 4 19 2 9 39 4 35 0 1 13 2 13 3 19 2 10 51 1 10 3 16 11 51 3 13 1 13 5 19 2 12 35 0 0 62 73 43 4 29) #5# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #6=#A(t (20) (ecl-cdb::to-cdb-hash ecl-cdb::key-vector ecl-cdb::h #:loop-across-list18770 #:loop-across-index-18769 #:loop-across-vector-18768 byte 0 length >= aref 1+ 4294967295 134217727 logand ash + logxor #Y(ecl-cdb::to-cdb-hash nil nil (24 45 1 26 58 60 107 8 5381 45 2 9 0 13 2 9 0 9 0 46 3 46 4 46 5 46 6 57 7 61 2 8 69 10 2 16 8 51 4 13 3 13 4 19 2 9 39 4 35 0 1 13 2 13 3 19 2 10 51 1 10 3 16 11 51 3 15 12 15 13 13 5 19 2 14 12 8 5 17 15 12 13 5 19 2 16 12 19 2 14 12 13 1 19 2 17 51 5 35 0 0 10 5 73 36 6 62 73 43 4 43 1 63 29) #6# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 29 12 19 2 30 1 0 73 29) #7=#A(t (31) (ecl-cdb::%make-cdb ecl-cdb::cdb-pathname ecl-cdb::temporary-pathname :direction :output :if-exists :supersede :if-does-not-exist :create :element-type (unsigned-byte 8) open stream file-position * si::%dotimes-var ecl-cdb::i ecl-cdb::write-word 1+ < :stream :pathname :tables :initial-element make-array :temporary-pathname ecl-cdb::make-cdb "Unable to create CDB at filename ~A" error #Y(ecl-cdb::%make-cdb nil nil (24 45 1 24 45 2 26 13 0 14 3 14 4 14 5 14 6 14 7 14 8 14 9 15 10 19 9 11 45 12 10 0 39 75 13 0 9 0 19 2 13 9 256 9 2 19 2 14 45 15 8 0 45 16 38 14 9 0 13 2 19 2 17 10 0 16 18 51 0 13 0 13 1 19 2 19 40 -21 43 2 14 20 13 0 14 21 13 2 14 22 9 256 14 23 77 19 3 24 12 14 25 13 1 19 8 26 38 8 15 27 13 1 19 2 28 43 1 29) #7# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 14 19 9 2 19 4 20 1 0 73 29) #8=#A(t (21) (ecl-cdb::with-output-to-cdb #:g18773 #:g18772 #:g18774 si::dm-too-few-arguments #:g18775 #:g18776 ecl-cdb::cdb ecl-cdb::cdb-pathname ecl-cdb::temporary-pathname ecl-cdb::body si::dm-too-many-arguments let unwind-protect progn setf ecl-cdb::%make-cdb ecl-cdb::close-cdb #Y(ecl-cdb::with-output-to-cdb nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 5 19 1 4 10 1 4 12 10 1 5 51 1 22 45 8 10 2 76 39 6 13 6 19 1 4 10 2 4 12 10 2 5 51 2 22 45 9 10 5 45 10 10 4 39 6 13 8 19 1 11 15 12 10 3 6 1 12 15 13 15 14 15 15 13 3 15 16 13 2 10 1 6 3 6 3 12 10 0 7 3 12 15 17 10 3 6 2 6 3 6 3 73 29) #8# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #9=#A(t (23) (ecl-cdb::add-record ecl-cdb::key ecl-cdb::value ecl-cdb::cdb ecl-cdb::to-cdb-hash ecl-cdb::hash-key logand ecl-cdb::table-index ecl-cdb::cdb-stream stream file-position #:g18784 ecl-cdb::cdb-tables #:g18781 #:g18782 aref #:g18783 si::aset length ecl-cdb::write-word write-sequence #Y(ecl-cdb::add-record nil nil (24 45 1 24 45 2 24 45 3 26 13 2 19 1 4 45 5 9 255 13 0 19 2 6 45 7 13 2 19 1 8 45 9 13 2 13 0 19 1 10 3 45 11 13 4 19 1 12 45 13 10 3 45 14 13 2 13 1 13 0 19 2 15 3 45 16 13 2 13 1 13 0 19 3 17 43 4 10 5 16 18 12 13 0 19 2 19 10 4 16 18 12 13 0 19 2 19 13 5 13 0 19 2 20 13 4 13 0 19 2 20 43 3 29) #9# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 29 12 19 2 30 1 0 73 29) #10=#A(t (31) (ecl-cdb::dump-table ecl-cdb::table stream length * :initial-element :element-type (unsigned-byte 32) make-array vector #:loop-list18799 ecl-cdb::pos ecl-cdb::hash-key ecl-cdb::index 0 #:loop-desetq-temp ash mod #:loop-limit18800 ecl-cdb::disp ecl-cdb::i ecl-cdb::record-pos >= + 1+ aref zerop si::aset ecl-cdb::write-vector #Y(ecl-cdb::dump-table nil nil (24 45 1 24 45 2 26 58 60 236 9 2 10 2 16 3 12 19 2 4 45 3 9 2 13 0 19 2 4 12 14 5 9 0 14 6 15 7 19 5 8 45 9 77 77 13 4 46 10 46 11 46 12 75 45 13 57 14 61 2 2 161 10 4 2 39 4 35 0 1 10 4 4 45 15 10 0 4 51 3 10 0 5 51 0 10 0 51 4 43 1 10 4 5 51 4 13 2 8 -8 17 16 12 10 6 17 17 51 1 9 0 13 6 46 18 46 19 75 45 20 75 45 21 57 14 61 2 2 63 13 3 13 4 19 2 22 39 4 35 0 1 9 2 13 3 13 6 19 2 23 12 10 11 17 17 12 19 2 4 51 2 13 10 10 2 16 24 12 19 2 25 51 1 10 1 16 26 39 4 35 0 1 10 3 16 24 51 3 35 0 0 13 10 13 2 13 7 19 3 27 13 10 10 2 16 24 12 13 8 19 3 27 62 43 1 43 1 43 2 35 0 0 13 5 13 8 19 2 28 10 6 73 36 7 62 73 43 1 43 3 43 1 43 1 63 29) #10# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #11=#A(t (27) (ecl-cdb::dump-cdb ecl-cdb::cdb ecl-cdb::cdb-stream stream * :element-type (unsigned-byte 32) make-array ecl-cdb::index ecl-cdb::cdb-tables #:loop-across-list18830 #:loop-across-index-18829 #:loop-across-vector-18828 ecl-cdb::table ecl-cdb::i 0 length >= aref 1+ file-position si::aset ecl-cdb::dump-table + ecl-cdb::write-vector #Y(ecl-cdb::dump-cdb nil nil (24 45 1 26 13 0 19 1 2 45 3 9 2 9 256 19 2 4 12 14 5 15 6 19 3 7 45 8 77 13 2 19 1 9 12 9 0 9 0 46 10 46 11 46 12 46 13 8 0 45 14 57 15 61 2 35 104 10 3 16 16 51 5 13 4 13 5 19 2 17 39 4 35 0 1 13 3 13 4 19 2 18 51 2 10 4 16 19 51 4 13 6 13 1 13 7 19 1 20 12 19 3 21 13 6 10 1 16 19 12 13 2 13 7 19 2 22 12 19 3 21 13 4 13 5 19 2 17 39 4 35 0 1 13 3 13 4 19 2 18 51 2 10 4 16 19 51 4 13 1 9 2 19 2 23 51 1 35 0 0 62 43 1 43 4 13 1 9 0 19 2 20 13 0 13 1 19 2 24 43 2 29) #11# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #12=#A(t (12) (ecl-cdb::close-cdb ecl-cdb::cdb ecl-cdb::cdb-stream stream open-stream-p ecl-cdb::dump-cdb close ecl-cdb::cdb-pathname ecl-cdb::cdb-temporary-pathname rename-file #Y(ecl-cdb::close-cdb nil nil (24 45 1 26 13 0 19 1 2 45 3 10 0 16 4 73 39 34 13 1 19 1 5 13 0 19 1 6 13 1 19 1 7 73 39 16 13 1 19 1 8 12 13 1 19 1 7 12 19 2 9 43 1 29) #12# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #13=#A(t (6) (ecl-cdb::cdb-error stream "Error when reading CDB database ~A" error #Y(ecl-cdb::cdb-error nil nil (24 45 1 26 15 2 13 0 19 2 3 29) #13# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #14=#A(t (22) (ecl-cdb::values-coincide position ecl-cdb::key-vector stream ecl-cdb::return-position-p file-position ecl-cdb::cdb-error ecl-cdb::read-word ecl-cdb::key-length length = ecl-cdb::value-length :element-type (unsigned-byte 8) make-array ecl-cdb::other-key read-sequence equalp (unsigned-byte 8) ecl-cdb::value #Y(ecl-cdb::values-coincide nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 1 13 3 19 2 5 76 39 6 13 1 19 1 6 13 1 19 1 7 45 8 13 0 10 3 16 9 12 19 2 10 73 39 71 13 2 19 1 7 45 11 13 1 14 12 15 13 19 3 14 45 15 13 0 13 4 19 2 16 13 0 10 5 17 17 73 39 35 10 3 39 8 13 4 19 1 5 38 24 13 1 14 12 15 18 19 3 14 45 19 13 0 13 5 19 2 16 10 0 73 43 1 43 2 43 1 29) #14# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 42 12 19 2 43 1 0 73 29) #15=#A(t (44) (ecl-cdb::lookup-cdb ecl-cdb::key stream ecl-cdb::return-position-p streamp ecl-cdb::to-cdb-hash ecl-cdb::hash logand ecl-cdb::table * file-position ecl-cdb::cdb-error ecl-cdb::read-word ecl-cdb::start length ash mod ecl-cdb::index ecl-cdb::reset #:loop-limit18846 ecl-cdb::i ecl-cdb::rounded-i position 0 t >= + ecl-cdb::other-hash ecl-cdb::record-position zerop = ecl-cdb::values-coincide ecl-cdb::output 1+ :direction :input :element-type (unsigned-byte 8) open ecl-cdb::s close :abort #Y(ecl-cdb::lookup-cdb nil nil (24 45 1 24 45 2 25 40 2 77 46 3 26 10 1 16 4 39 253 13 2 19 1 5 45 6 9 255 13 0 19 2 7 45 8 13 3 13 0 9 8 19 2 9 12 19 2 10 76 39 6 13 3 19 1 11 13 3 19 1 12 45 13 13 4 19 1 12 45 14 13 3 8 -8 17 15 12 10 0 17 16 45 17 58 60 180 75 45 18 9 0 13 3 46 19 46 20 75 45 21 75 45 22 57 23 61 2 6 146 11 24 51 5 13 3 13 4 19 2 25 39 4 35 0 1 13 7 13 3 19 2 26 12 10 8 17 16 51 2 13 9 9 8 13 2 19 2 9 12 19 2 26 51 1 10 5 39 19 13 13 13 1 19 2 10 76 39 6 13 13 19 1 11 75 51 5 13 13 19 1 12 45 27 13 14 19 1 12 45 28 10 0 16 29 39 5 75 73 36 8 13 1 13 13 19 2 30 39 31 13 0 13 16 13 15 13 14 19 4 31 45 32 10 0 39 8 10 0 73 36 9 38 5 11 24 51 8 43 1 43 2 11 24 51 5 10 3 16 33 51 3 35 0 0 62 73 43 1 43 1 43 2 43 1 63 43 3 43 2 38 55 13 1 14 34 14 35 14 36 15 37 19 5 38 45 39 64 22 13 3 13 0 13 1 19 3 0 69 10 0 39 6 13 0 19 1 40 70 65 10 0 39 10 13 0 14 41 14 24 19 3 40 66 43 1 29) #15# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 43 12 19 2 44 1 0 73 29) #16=#A(t (45) (ecl-cdb::map-cdb function stream streamp * :element-type (unsigned-byte 32) make-array ecl-cdb::index file-position ecl-cdb::cdb-error read-sequence length = #:loop-limit18852 ecl-cdb::i ecl-cdb::table-position ecl-cdb::table-length 0 >= aref 1+ #:loop-limit18854 position ecl-cdb::record-hash ecl-cdb::record-position ecl-cdb::read-word zerop ecl-cdb::key-length ecl-cdb::value-length (unsigned-byte 8) ecl-cdb::key (unsigned-byte 8) ecl-cdb::value + :direction :input (unsigned-byte 8) open ecl-cdb::s close :abort t #Y(ecl-cdb::map-cdb nil nil (24 45 1 24 45 2 26 10 0 16 3 39 346 9 256 9 2 19 2 4 12 14 5 15 6 19 3 7 45 8 13 1 9 0 19 2 9 76 39 6 13 1 19 1 10 13 0 13 1 19 2 11 12 10 0 16 12 12 19 2 13 76 39 6 13 1 19 1 10 9 0 10 0 16 12 12 46 14 46 15 75 45 16 75 45 17 57 18 61 2 2 255 13 3 13 4 19 2 19 39 4 35 0 1 13 5 13 3 19 2 20 51 2 13 5 10 3 16 21 12 19 2 20 51 1 13 6 13 2 19 2 9 76 39 6 13 6 19 1 10 9 0 13 1 46 22 46 15 10 4 45 23 75 45 24 75 45 25 57 18 61 2 14 162 13 4 13 5 19 2 19 39 4 35 0 1 13 12 19 1 26 51 2 13 12 19 1 26 51 1 10 1 16 27 76 39 99 13 12 13 1 19 2 9 76 39 6 13 12 19 1 10 13 12 19 1 26 45 28 13 13 19 1 26 45 29 13 1 14 5 15 30 19 3 7 45 31 13 1 14 5 15 32 19 3 7 45 33 13 1 13 16 19 2 11 12 13 3 19 2 13 39 14 13 0 13 16 19 2 11 12 13 2 19 2 13 76 39 6 13 16 19 1 10 13 17 13 1 13 0 20 2 23 43 4 10 4 16 21 51 4 13 4 13 5 19 2 19 39 4 35 0 1 13 3 9 8 19 2 34 51 3 35 0 0 62 43 1 43 1 43 1 43 2 13 3 9 2 19 2 34 51 3 35 0 0 62 73 43 1 43 1 43 2 43 1 38 53 13 0 14 35 14 36 14 5 15 37 19 5 38 45 39 64 20 13 2 13 0 19 2 0 69 10 0 39 6 13 0 19 1 40 70 65 10 0 39 10 13 0 14 41 14 42 19 3 40 66 43 1 29) #16# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (14 0 19 1 1 29) #A(t (2) (:ecl-cdb provide)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("SYSTEM" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 24 12 19 2 25 1 0 73 29) #17=#A(t (26) (si::to-cdb-vector si::object :adjustable t :fill-pointer :element-type (unsigned-byte 8) :initial-element make-array vector :external-format :utf-8 ext::make-sequence-output-stream stream si::+io-syntax-progv-list+ #:%progv-list "CL" find-package si::*print-package* :stream :pretty :readably :escape write #Y(si::to-cdb-vector nil nil (24 45 1 26 9 128 14 2 14 3 14 4 9 0 14 5 15 6 14 7 9 0 19 9 8 45 9 13 0 14 10 14 11 19 3 12 45 13 11 14 45 15 10 0 4 12 10 0 5 67 1 16 16 17 48 18 13 3 14 19 13 1 14 20 77 14 21 77 14 22 14 3 19 9 23 44 1 68 43 1 10 1 73 43 2 29) #17# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #18=#A(t (9) (si::from-cdb-vector vector :external-format :utf-8 ext::make-sequence-input-stream stream read #Y(si::from-cdb-vector nil nil (24 45 1 26 13 0 14 2 14 3 19 3 4 45 5 13 0 77 77 77 19 4 6 43 1 29) #18# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #19=#A(t (10) (si::search-help-file string si::path si::to-cdb-vector si::key ecl-cdb::lookup-cdb si::value si::from-cdb-vector #Y(si::search-help-file nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 13 0 13 1 19 2 5 45 6 10 0 73 39 6 13 0 19 1 7 43 2 29) #19# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 32 12 19 2 33 1 0 73 29) #20=#A(t (34) (si::dump-help-file hash-table si::path merge si::test "DUMP-HELP-FILE does not suport yet the third argument" error si::cdb ecl-cdb::%make-cdb si::v #:loop-hashtab-18881 si::k #:loop-it-18883 si::hash-table-iterator #:loop-hashtab-next-18882 0 #:loop-hash-val-temp-18884 #:loop-hash-key-temp-18885 #:loop-hash-predicate-var-18886 si::to-cdb-vector ecl-cdb::add-record ecl-cdb::close-cdb #:loop-hashtab-18893 #:loop-it-18895 #:loop-hashtab-next-18894 si::other-value #:loop-hash-val-temp-18896 #:loop-hash-key-temp-18897 #:loop-hash-predicate-var-18898 si::search-help-file equalp "Symbol ~A not found in database ~A" #Y(si::dump-help-file nil nil (24 45 1 24 45 2 25 40 2 77 46 3 25 40 2 77 46 4 26 10 1 39 6 15 5 19 1 6 75 45 7 64 97 77 13 3 19 2 8 51 0 77 77 13 4 77 46 9 46 10 46 11 46 12 10 2 16 13 45 14 57 15 61 2 2 58 13 1 20 0 23 47 2 16 47 1 17 45 18 10 0 39 9 10 2 51 8 10 1 51 6 10 0 51 5 43 3 76 39 4 35 0 1 13 3 19 1 19 12 13 5 19 1 19 12 13 6 19 3 20 35 0 0 62 43 1 43 4 65 13 0 19 1 21 66 43 1 10 0 73 39 108 77 77 13 3 77 46 9 46 22 46 11 46 23 10 2 16 13 45 24 75 45 25 57 15 61 2 2 72 13 2 20 0 23 47 2 26 47 1 27 45 28 10 0 39 9 10 2 51 9 10 1 51 7 10 0 51 6 43 3 76 39 4 35 0 1 13 4 13 9 19 2 29 51 1 10 1 39 7 13 1 10 6 17 30 76 39 10 15 31 13 4 13 9 19 3 6 35 0 0 62 73 43 1 43 1 43 4 29) #20# #1# 0) si::fset)) #1# 0))
