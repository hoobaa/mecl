static const char compiler_data_text[] = 
":unsafe :inline-unsafe :safe :inline-safe :always :inline-always c::should-be-in"
 "lined :arg-rep-types :return-rep-type :return-type :arg-types :exact-return-type"
 " :multiple-values :one-liner :expansion c::def-inline c::*in-all-symbols-functio"
 "ns* si::c-export-fname si::typecase-error-string si::find-documentation si::find"
 "-declarations si::search-keyword si::check-keyword si::dm-too-many-arguments si:"
 ":dm-too-few-arguments si::remove-documentation si::get-documentation si::set-doc"
 "umentation si::expand-set-documentation si::packages-iterator si::pprint-logical"
 "-block-helper si::pprint-pop-helper si::make-seq-iterator si::seq-iterator-ref s"
 "i::seq-iterator-set si::seq-iterator-next si::structure-type-error si::define-st"
 "ructure si::coerce-to-list si::coerce-to-vector 0 :one-liner :exact-return-type "
 ":inline-or-warn :multiple-values c::lisp-type->rep-type c::rep-type->lisp-type c"
 "::make-inline-info ((aref :unsafe (t t t) t \"@0;ecl_aref_unsafe(#0,ecl_fixnum(#1"
 ")*(#0)->array.dims[1]+ecl_fixnum(#2))\") (aref :unsafe ((array t) t t) t \"@0;(#0)"
 "->array.self.t[ecl_fixnum(#1)*(#0)->array.dims[1]+ecl_fixnum(#2)]\") (aref :unsaf"
 "e ((array bit) t t) :fixnum \"@0;ecl_aref_bv(#0,ecl_fixnum(#1)*(#0)->array.dims[1"
 "]+ecl_fixnum(#2))\") (aref :unsafe ((array t) fixnum fixnum) t \"@0;(#0)->array.se"
 "lf.t[#1*(#0)->array.dims[1]+#2]\") (aref :unsafe ((array bit) fixnum fixnum) :fix"
 "num \"@0;ecl_aref_bv(#0,(#1)*(#0)->array.dims[1]+#2)\") (aref :unsafe ((array base"
 "-char) fixnum fixnum) :unsigned-char \"@0;(#0)->base_string.self[#1*(#0)->array.d"
 "ims[1]+#2]\") (aref :unsafe ((array double-float) fixnum fixnum) :double \"@0;(#0)"
 "->array.self.df[#1*(#0)->array.dims[1]+#2]\") (aref :unsafe ((array single-float)"
 " fixnum fixnum) :float \"@0;(#0)->array.self.sf[#1*(#0)->array.dims[1]+#2]\") (are"
 "f :unsafe ((array fixnum) fixnum fixnum) :fixnum \"@0;(#0)->array.self.fix[#1*(#0"
 ")->array.dims[1]+#2]\") (aref :always (t t) t \"ecl_aref1(#0,ecl_to_size(#1))\") (a"
 "ref :always (t fixnum) t \"ecl_aref1(#0,#1)\") (aref :unsafe (t t) t \"ecl_aref1(#0"
 ",ecl_fixnum(#1))\") (aref :unsafe ((array bit) t) :fixnum \"ecl_aref_bv(#0,ecl_fix"
 "num(#1))\") (aref :unsafe ((array bit) fixnum) :fixnum \"ecl_aref_bv(#0,#1)\") (are"
 "f :unsafe ((array character) fixnum) :wchar \"(#0)->string.self[#1]\") (aref :unsa"
 "fe ((array base-char) fixnum) :unsigned-char \"(#0)->base_string.self[#1]\") (aref"
 " :unsafe ((array double-float) fixnum) :double \"(#0)->array.self.df[#1]\") (aref "
 ":unsafe ((array single-float) fixnum) :float \"(#0)->array.self.sf[#1]\") (aref :u"
 "nsafe ((array fixnum) fixnum) :fixnum \"(#0)->array.self.fix[#1]\") (row-major-are"
 "f :always (t t) t \"ecl_aref(#0,ecl_to_size(#1))\") (row-major-aref :always (t fix"
 "num) t \"ecl_aref(#0,#1)\") (row-major-aref :unsafe (t t) t \"ecl_aref_unsafe(#0,ec"
 "l_fixnum(#1))\") (row-major-aref :unsafe (t fixnum) t \"ecl_aref_unsafe(#0,#1)\") ("
 "row-major-aref :unsafe ((array bit) t) :fixnum \"ecl_aref_bv(#0,ecl_fixnum(#1))\")"
 " (row-major-aref :unsafe ((array bit) fixnum) :fixnum \"ecl_aref_bv(#0,#1)\") (row"
 "-major-aref :unsafe ((array character) fixnum) :wchar \"(#0)->string.self[#1]\") ("
 "row-major-aref :unsafe ((array base-char) fixnum) :unsigned-char \"(#0)->base_str"
 "ing.self[#1]\") (row-major-aref :unsafe ((array ext::byte8) fixnum) :uint8-t \"(#0"
 ")->vector.self.b8[#1]\") (row-major-aref :unsafe ((array ext::integer8) fixnum) :"
 "int8-t \"(#0)->vector.self.i8[#1]\") (row-major-aref :unsafe ((array ext::byte16) "
 "fixnum) :uint16-t \"(#0)->vector.self.b16[#1]\") (row-major-aref :unsafe ((array e"
 "xt::integer16) fixnum) :int16-t \"(#0)->vector.self.i16[#1]\") (row-major-aref :un"
 "safe ((array ext::byte32) fixnum) :uint32-t \"(#0)->vector.self.b32[#1]\") (row-ma"
 "jor-aref :unsafe ((array ext::integer32) fixnum) :int32-t \"(#0)->vector.self.i32"
 "[#1]\") (row-major-aref :unsafe ((array ext::byte64) fixnum) :uint64-t \"(#0)->vec"
 "tor.self.b64[#1]\") (row-major-aref :unsafe ((array ext::integer64) fixnum) :int6"
 "4-t \"(#0)->vector.self.i64[#1]\") (row-major-aref :unsafe ((array double-float) f"
 "ixnum) :double \"(#0)->array.self.df[#1]\") (row-major-aref :unsafe ((array single"
 "-float) fixnum) :float \"(#0)->array.self.sf[#1]\") (row-major-aref :unsafe ((arra"
 "y fixnum) fixnum) :fixnum \"(#0)->array.self.fix[#1]\") (si::row-major-aset :alway"
 "s (t t t) t \"ecl_aset(#0,ecl_to_size(#1),#2)\") (si::row-major-aset :always (t fi"
 "xnum t) t \"ecl_aset(#0,#1,#2)\") (si::row-major-aset :unsafe (t t t) t \"ecl_aset_"
 "unsafe(#0,ecl_fixnum(#1),#2)\") (si::row-major-aset :unsafe (t fixnum t) t \"ecl_a"
 "set_unsafe(#0,#1,#2)\") (si::row-major-aset :unsafe ((array t) fixnum t) t \"(#0)-"
 ">vector.self.t[#1]= #2\") (si::row-major-aset :unsafe ((array bit) fixnum t) :fix"
 "num \"ecl_aset_bv(#0,#1,ecl_fixnum(#2))\") (si::row-major-aset :unsafe ((array bit"
 ") fixnum fixnum) :fixnum \"ecl_aset_bv(#0,#1,#2)\") (si::row-major-aset :unsafe (("
 "array base-char) fixnum base-char) :unsigned-char \"(#0)->base_string.self[#1]= #"
 "2\") (si::row-major-aset :unsafe ((array character) fixnum character) :wchar \"(#0"
 ")->string.self[#1]= #2\") (si::row-major-aset :unsafe ((array ext::byte8) fixnum "
 "ext::byte8) :uint8-t \"(#0)->vector.self.b8[#1]= #2\") (si::row-major-aset :unsafe"
 " ((array ext::integer8) fixnum ext::integer8) :int8-t \"(#0)->vector.self.i8[#1]="
 " #2\") (si::row-major-aset :unsafe ((array ext::byte16) fixnum ext::byte16) :uint"
 "16-t \"(#0)->vector.self.b16[#1]= #2\") (si::row-major-aset :unsafe ((array ext::i"
 "nteger16) fixnum ext::integer16) :int16-t \"(#0)->vector.self.i16[#1]= #2\") (si::"
 "row-major-aset :unsafe ((array ext::byte32) fixnum ext::byte32) :uint32-t \"(#0)-"
 ">vector.self.b32[#1]= #2\") (si::row-major-aset :unsafe ((array ext::integer32) f"
 "ixnum ext::integer32) :int32-t \"(#0)->vector.self.i32[#1]= #2\") (si::row-major-a"
 "set :unsafe ((array ext::byte64) fixnum ext::byte64) :uint64-t \"(#0)->vector.sel"
 "f.b64[#1]= #2\") (si::row-major-aset :unsafe ((array ext::integer64) fixnum ext::"
 "integer64) :int64-t \"(#0)->vector.self.i64[#1]= #2\") (si::row-major-aset :unsafe"
 " ((array double-float) fixnum double-float) :double \"(#0)->array.self.df[#1]= #2"
 "\") (si::row-major-aset :unsafe ((array single-float) fixnum single-float) :float"
 " \"(#0)->array.self.sf[#1]= #2\") (si::row-major-aset :unsafe ((array fixnum) fixn"
 "um fixnum) :fixnum \"(#0)->array.self.fix[#1]= #2\") (si::copy-subarray :always (a"
 "rray ext::array-index array ext::array-index ext::array-index) array \"@0;(ecl_co"
 "py_subarray(#0,#1,#2,#3,#4),#0)\") (array-rank :unsafe (array) :fixnum \"@0;(((#0)"
 "->d.t == t_array)?(#0)->array.rank:1)\") (array-rank :always (array) :fixnum \"ecl"
 "_array_rank(#0)\") (array-dimension :always (t t) fixnum \"ecl_array_dimension(#0,"
 "ecl_to_size(#1))\") (array-dimension :always (t fixnum) fixnum \"ecl_array_dimensi"
 "on(#0,#1)\") (array-total-size :unsafe (t) :fixnum \"((#0)->array.dim)\") (adjustab"
 "le-array-p :always (t) :bool \"@0;(ECL_ARRAYP(#0)? (void)0: FEtype_error_array(#0"
 "),ECL_ADJUSTABLE_ARRAY_P(#0))\") (adjustable-array-p :unsafe (array) :bool \"ECL_A"
 "DJUSTABLE_ARRAY_P(#0)\") (svref :always (t t) t \"ecl_aref1(#0,ecl_to_size(#1))\") "
 "(svref :always (t fixnum) t \"ecl_aref1(#0,#1)\") (svref :unsafe (t t) t \"(#0)->ve"
 "ctor.self.t[ecl_fixnum(#1)]\") (svref :unsafe (t fixnum) t \"(#0)->vector.self.t[#"
 "1]\") (si::svset :always (t t t) t \"ecl_aset1(#0,ecl_to_size(#1),#2)\") (si::svset"
 " :always (t fixnum t) t \"ecl_aset1(#0,#1,#2)\") (si::svset :unsafe (t t t) t \"((#"
 "0)->vector.self.t[ecl_fixnum(#1)]=(#2))\") (si::svset :unsafe (t fixnum t) t \"(#0"
 ")->vector.self.t[#1]= #2\") (array-has-fill-pointer-p :always (t) :bool \"@0;(ECL_"
 "ARRAYP(#0)?(void)0:FEtype_error_array(#0),ECL_ARRAY_HAS_FILL_POINTER_P(#0))\") (a"
 "rray-has-fill-pointer-p :unsafe (array) :bool \"ECL_ARRAY_HAS_FILL_POINTER_P(#0)\""
 ") (fill-pointer :unsafe (t) :fixnum \"((#0)->vector.fillp)\") (si::fill-pointer-se"
 "t :unsafe (t fixnum) :fixnum \"((#0)->vector.fillp)=(#1)\") (standard-char-p :alwa"
 "ys (character) :bool \"ecl_standard_char_p(#0)\") (graphic-char-p :always (charact"
 "er) :bool \"ecl_graphic_char_p(#0)\") (alpha-char-p :always (character) :bool \"ecl"
 "_alpha_char_p(#0)\") (upper-case-p :always (character) :bool \"ecl_upper_case_p(#0"
 ")\") (lower-case-p :always (character) :bool \"ecl_lower_case_p(#0)\") (both-case-p"
 " :always (character) :bool \"ecl_both_case_p(#0)\") (alphanumericp :always (charac"
 "ter) :bool \"ecl_alphanumericp(#0)\") (char= :always (t t) :bool \"ecl_char_code(#0"
 ")==ecl_char_code(#1)\") (char= :always (character character) :bool \"(#0)==(#1)\") "
 "(char/= :always (t t) :bool \"ecl_char_code(#0)!=ecl_char_code(#1)\") (char/= :alw"
 "ays (character character) :bool \"(#0)!=(#1)\") (char< :always (character characte"
 "r) :bool \"(#0)<(#1)\") (char> :always (character character) :bool \"(#0)>(#1)\") (c"
 "har<= :always (character character) :bool \"(#0)<=(#1)\") (char>= :always (charact"
 "er character) :bool \"(#0)>=(#1)\") (char-code :always (character) :fixnum \"#0\") ("
 "code-char :always (fixnum) :wchar \"#0\") (char-upcase :always (base-char) :unsign"
 "ed-char \"ecl_char_upcase(#0)\") (char-upcase :always (character) :wchar \"ecl_char"
 "_upcase(#0)\") (char-downcase :always (base-char) :unsigned-char \"ecl_char_downca"
 "se(#0)\") (char-downcase :always (character) :wchar \"ecl_char_downcase(#0)\") (cha"
 "r-int :always (character) :fixnum \"#0\") (si::foreign-data-p :always (t) :bool \"@"
 "0;ECL_FOREIGN_DATA_P(#0)\") (input-stream-p :always (stream) :bool \"ecl_input_str"
 "eam_p(#0)\") (output-stream-p :always (stream) :bool \"ecl_output_stream_p(#0)\") ("
 "gethash :always (t t t) t \"ecl_gethash_safe(#0,#1,#2)\" :multiple-values nil) (ge"
 "thash :always (t t) t \"ecl_gethash_safe(#0,#1,ECL_NIL)\" :multiple-values nil) (c"
 "ar :unsafe (cons) t \"ECL_CONS_CAR(#0)\") (car :unsafe (t) t \"_ecl_car(#0)\") (si::"
 "cons-car :always (t) t \"_ecl_car(#0)\") (si::cons-car :unsafe (t) t \"ECL_CONS_CAR"
 "(#0)\") (cdr :unsafe (cons) t \"ECL_CONS_CDR(#0)\") (cdr :unsafe (t) t \"_ecl_cdr(#0"
 ")\") (si::cons-cdr :always (t) t \"_ecl_cdr(#0)\") (si::cons-cdr :unsafe (t) t \"ECL"
 "_CONS_CDR(#0)\") (car :always (t) t \"ecl_car(#0)\") (car :unsafe (t) t \"_ecl_car(#"
 "0)\") (cdr :always (t) t \"ecl_cdr(#0)\") (cdr :unsafe (t) t \"_ecl_cdr(#0)\") (caar "
 ":always (t) t \"ecl_caar(#0)\") (caar :unsafe (t) t \"_ecl_caar(#0)\") (cdar :always"
 " (t) t \"ecl_cdar(#0)\") (cdar :unsafe (t) t \"_ecl_cdar(#0)\") (cadr :always (t) t "
 "\"ecl_cadr(#0)\") (cadr :unsafe (t) t \"_ecl_cadr(#0)\") (cddr :always (t) t \"ecl_cd"
 "dr(#0)\") (cddr :unsafe (t) t \"_ecl_cddr(#0)\") (caaar :always (t) t \"ecl_caaar(#0"
 ")\") (caaar :unsafe (t) t \"_ecl_caaar(#0)\") (cdaar :always (t) t \"ecl_cdaar(#0)\")"
 " (cdaar :unsafe (t) t \"_ecl_cdaar(#0)\") (cadar :always (t) t \"ecl_cadar(#0)\") (c"
 "adar :unsafe (t) t \"_ecl_cadar(#0)\") (cddar :always (t) t \"ecl_cddar(#0)\") (cdda"
 "r :unsafe (t) t \"_ecl_cddar(#0)\") (caadr :always (t) t \"ecl_caadr(#0)\") (caadr :"
 "unsafe (t) t \"_ecl_caadr(#0)\") (cdadr :always (t) t \"ecl_cdadr(#0)\") (cdadr :uns"
 "afe (t) t \"_ecl_cdadr(#0)\") (caddr :always (t) t \"ecl_caddr(#0)\") (caddr :unsafe"
 " (t) t \"_ecl_caddr(#0)\") (cdddr :always (t) t \"ecl_cdddr(#0)\") (cdddr :unsafe (t"
 ") t \"_ecl_cdddr(#0)\") (caaaar :always (t) t \"ecl_caaaar(#0)\") (caaaar :unsafe (t"
 ") t \"_ecl_caaaar(#0)\") (cdaaar :always (t) t \"ecl_cdaaar(#0)\") (cdaaar :unsafe ("
 "t) t \"_ecl_cdaaar(#0)\") (cadaar :always (t) t \"ecl_cadaar(#0)\") (cadaar :unsafe "
 "(t) t \"_ecl_cadaar(#0)\") (cddaar :always (t) t \"ecl_cddaar(#0)\") (cddaar :unsafe"
 " (t) t \"_ecl_cddaar(#0)\") (caadar :always (t) t \"ecl_caadar(#0)\") (caadar :unsaf"
 "e (t) t \"_ecl_caadar(#0)\") (cdadar :always (t) t \"ecl_cdadar(#0)\") (cdadar :unsa"
 "fe (t) t \"_ecl_cdadar(#0)\") (caddar :always (t) t \"ecl_caddar(#0)\") (caddar :uns"
 "afe (t) t \"_ecl_caddar(#0)\") (cdddar :always (t) t \"ecl_cdddar(#0)\") (cdddar :un"
 "safe (t) t \"_ecl_cdddar(#0)\") (caaadr :always (t) t \"ecl_caaadr(#0)\") (caaadr :u"
 "nsafe (t) t \"_ecl_caaadr(#0)\") (cdaadr :always (t) t \"ecl_cdaadr(#0)\") (cdaadr :"
 "unsafe (t) t \"_ecl_cdaadr(#0)\") (cadadr :always (t) t \"ecl_cadadr(#0)\") (cadadr "
 ":unsafe (t) t \"_ecl_cadadr(#0)\") (cddadr :always (t) t \"ecl_cddadr(#0)\") (cddadr"
 " :unsafe (t) t \"_ecl_cddadr(#0)\") (caaddr :always (t) t \"ecl_caaddr(#0)\") (caadd"
 "r :unsafe (t) t \"_ecl_caaddr(#0)\") (cdaddr :always (t) t \"ecl_cdaddr(#0)\") (cdad"
 "dr :unsafe (t) t \"_ecl_cdaddr(#0)\") (cadddr :always (t) t \"ecl_cadddr(#0)\") (cad"
 "ddr :unsafe (t) t \"_ecl_cadddr(#0)\") (cddddr :always (t) t \"ecl_cddddr(#0)\") (cd"
 "dddr :unsafe (t) t \"_ecl_cddddr(#0)\") (cons :always (t t) t \"CONS(#0,#1)\") (endp"
 " :safe (t) :bool \"ecl_endp(#0)\") (endp :unsafe (t) :bool \"#0==ECL_NIL\") (nth :al"
 "ways (t t) t \"ecl_nth(ecl_to_size(#0),#1)\") (nth :always (fixnum t) t \"ecl_nth(#"
 "0,#1)\") (nth :unsafe (t t) t \"ecl_nth(ecl_fixnum(#0),#1)\") (nth :unsafe (fixnum "
 "t) t \"ecl_nth(#0,#1)\") (nthcdr :always (t t) t \"ecl_nthcdr(ecl_to_size(#0),#1)\")"
 " (nthcdr :always (fixnum t) t \"ecl_nthcdr(#0,#1)\") (nthcdr :unsafe (t t) t \"ecl_"
 "nthcdr(ecl_fixnum(#0),#1)\") (nthcdr :unsafe (fixnum t) t \"ecl_nthcdr(#0,#1)\") (l"
 "ast :always (t) t \"ecl_last(#0,1)\") (list :always nil t \"ECL_NIL\") (list :always"
 " (t) t \"ecl_list1(#0)\") (list* :always (t) t \"#0\") (list* :always (t t) t \"CONS("
 "#0,#1)\") (append :always (t t) t \"ecl_append(#0,#1)\") (nconc :always (t t) t \"ec"
 "l_nconc(#0,#1)\") (butlast :always (t) t \"ecl_butlast(#0,1)\") (nbutlast :always ("
 "t) t \"ecl_nbutlast(#0,1)\") (1+ :always (t) t \"ecl_one_plus(#0)\") (1+ :always (fi"
 "xnum) t \"ecl_make_integer((#0)+1)\") (1+ :always (c::double-loat) :double \"(doubl"
 "e)(#0)+1\") (1+ :always (single-float) :float \"(float)(#0)+1\") (1+ :always (fixnu"
 "m) :fixnum \"(#0)+1\" :exact-return-type t) (1- :always (t) t \"ecl_one_minus(#0)\")"
 " (1- :always (fixnum) t \"ecl_make_integer((#0)-1)\") (1- :always (double-float) :"
 "double \"(double)(#0)-1\") (1- :always (single-float) :float \"(float)(#0)-1\") (1- "
 ":always (fixnum) :fixnum \"(#0)-1\" :exact-return-type t) (float :always (t single"
 "-float) :float \"ecl_to_float(#0)\") (float :always (t double-float) :double \"ecl_"
 "to_double(#0)\") (float :always (t long-float) :long-double \"ecl_to_long_double(#"
 "0)\") (float :always (c::fixnum-float) :double \"((double)(#0))\" :exact-return-typ"
 "e t) (float :always (c::fixnum-float) :float \"((float)(#0))\" :exact-return-type "
 "t) (numerator :unsafe (integer) integer \"(#0)\") (numerator :unsafe (ratio) integ"
 "er \"(#0)->ratio.num\") (denominator :unsafe (integer) integer \"ecl_make_fixnum(1)"
 "\") (denominator :unsafe (ratio) integer \"(#0)->ratio.den\") (floor :always (t) (v"
 "alues &rest t) \"ecl_floor1(#0)\") (floor :always (t t) (values &rest t) \"ecl_floo"
 "r2(#0,#1)\") (ceiling :always (t) (values &rest t) \"ecl_ceiling1(#0)\") (ceiling :"
 "always (t t) (values &rest t) \"ecl_ceiling2(#0,#1)\") (truncate :always (t) (valu"
 "es &rest t) \"ecl_truncate1(#0)\") (truncate :always (t t) (values &rest t) \"ecl_t"
 "runcate2(#0,#1)\") (round :always (t) (values &rest t) \"ecl_round1(#0)\") (round :"
 "always (t t) (values &rest t) \"ecl_round2(#0,#1)\") (mod :always (t t) t \"(ecl_fl"
 "oor2(#0,#1),cl_env_copy->values[1])\") (mod :always (fixnum fixnum) :fixnum \"@01;"
 "(#0>=0&&#1>0?(#0)%(#1):ecl_imod(#0,#1))\") (rem :always (t t) t \"(ecl_truncate2(#"
 "0,#1),cl_env_copy->values[1])\") (rem :always (fixnum fixnum) :fixnum \"(#0)%(#1)\""
 ") (= :always (t t) :bool \"ecl_number_equalp(#0,#1)\") (= :always (c::fixnum-float"
 " c::fixnum-float) :bool \"(#0)==(#1)\") (/= :always (t t) :bool \"!ecl_number_equal"
 "p(#0,#1)\") (/= :always (c::fixnum-float c::fixnum-float) :bool \"(#0)!=(#1)\") (< "
 ":always (t t) :bool \"ecl_number_compare(#0,#1)<0\") (< :always (c::fixnum-float c"
 "::fixnum-float) :bool \"(#0)<(#1)\") (< :always (c::fixnum-float c::fixnum-float c"
 "::fixnum-float) :bool \"@012;((#0)<(#1) && (#1)<(#2))\") (> :always (t t) :bool \"e"
 "cl_number_compare(#0,#1)>0\") (> :always (c::fixnum-float c::fixnum-float) :bool "
 "\"(#0)>(#1)\") (> :always (c::fixnum-float c::fixnum-float c::fixnum-float) :bool "
 "\"@012;((#0)>(#1) && (#1)>(#2))\") (<= :always (t t) :bool \"ecl_number_compare(#0,"
 "#1)<=0\") (<= :always (c::fixnum-float c::fixnum-float) :bool \"(#0)<=(#1)\") (<= :"
 "always (c::fixnum-float c::fixnum-float c::fixnum-float) :bool \"@012;((#0)<=(#1)"
 " && (#1)<=(#2))\") (>= :always (t t) :bool \"ecl_number_compare(#0,#1)>=0\") (>= :a"
 "lways (c::fixnum-float c::fixnum-float) :bool \"(#0)>=(#1)\") (>= :always (c::fixn"
 "um-float c::fixnum-float c::fixnum-float) :bool \"@012;((#0)>=(#1) && (#1)>=(#2))"
 "\") (max :always (t t) t \"@01;(ecl_number_compare(#0,#1)>=0?#0:#1)\") (max :always"
 " (fixnum fixnum) :fixnum \"@01;(#0)>=(#1)?#0:#1\") (min :always (t t) t \"@01;(ecl_"
 "number_compare(#0,#1)<=0?#0:#1)\") (min :always (fixnum fixnum) :fixnum \"@01;(#0)"
 "<=(#1)?#0:#1\") (logand :always nil t \"ecl_make_fixnum(-1)\") (logand :always nil "
 ":fixnum \"-1\") (logand :always (t t) t \"ecl_boole(ECL_BOOLAND,(#0),(#1))\") (logan"
 "d :always (fixnum fixnum) :fixnum \"((#0) & (#1))\") (logandc1 :always (t t) t \"ec"
 "l_boole(ECL_BOOLANDC1,(#0),(#1))\") (logandc1 :always (fixnum fixnum) :fixnum \"(~"
 "(#0) & (#1))\") (logandc2 :always (t t) t \"ecl_boole(ECL_BOOLANDC2,(#0),(#1))\") ("
 "logandc2 :always (fixnum fixnum) :fixnum \"((#0) & ~(#1))\") (logeqv :always nil t"
 " \"ecl_make_fixnum(-1)\") (logeqv :always nil :fixnum \"-1\") (logeqv :always (t t) "
 "t \"ecl_boole(ECL_BOOLEQV,(#0),(#1))\") (logeqv :always (fixnum fixnum) :fixnum \"("
 "~( (#0) ^ (#1) ))\") (logior :always nil t \"ecl_make_fixnum(0)\") (logior :always "
 "nil :fixnum \"0\") (logior :always (t t) t \"ecl_boole(ECL_BOOLIOR,(#0),(#1))\") (lo"
 "gior :always (fixnum fixnum) :fixnum \"((#0) | (#1))\") (lognand :always (t t) t \""
 "ecl_boole(ECL_BOOLNAND,(#0),(#1))\") (lognand :always (fixnum fixnum) :fixnum \"(~"
 "( (#0) & (#1) ))\") (lognor :always (t t) t \"ecl_boole(ECL_BOOLNOR,(#0),(#1))\") ("
 "lognor :always (fixnum fixnum) :fixnum \"(~( (#0) | (#1) ))\") (lognot :always (t)"
 " t \"ecl_boole(ECL_BOOLXOR,(#0),ecl_make_fixnum(-1))\") (lognot :always (fixnum) :"
 "fixnum \"(~(#0))\") (logorc1 :always (t t) t \"ecl_boole(ECL_BOOLORC1,(#0),(#1))\") "
 "(logorc1 :always (fixnum fixnum) :fixnum \"(~(#0) | (#1))\") (logorc2 :always (t t"
 ") t \"ecl_boole(ECL_BOOLORC2,(#0),(#1))\") (logorc2 :always (fixnum fixnum) :fixnu"
 "m \"((#0) | ~(#1))\") (logxor :always nil t \"ecl_make_fixnum(0)\") (logxor :always "
 "nil :fixnum \"0\") (logxor :always (t t) t \"ecl_boole(ECL_BOOLXOR,(#0),(#1))\") (lo"
 "gxor :always (fixnum fixnum) :fixnum \"((#0) ^ (#1))\") (boole :always (fixnum t t"
 ") t \"ecl_boole((#0),(#1),(#2))\") (logbitp :always ((integer -29 29) fixnum) :boo"
 "l \"(#1 >> #0) & 1\") (integer-length :always (t) :cl-index \"ecl_integer_length(#0"
 ")\") (zerop :always (t) :bool \"ecl_zerop(#0)\") (zerop :always (c::fixnum-float) :"
 "bool \"(#0)==0\") (plusp :always (t) :bool \"ecl_plusp(#0)\") (plusp :always (c::fix"
 "num-float) :bool \"(#0)>0\") (minusp :always (t) :bool \"ecl_minusp(#0)\") (minusp :"
 "always (c::fixnum-float) :bool \"(#0)<0\") (oddp :always (t) :bool \"ecl_oddp(#0)\")"
 " (oddp :always (fixnum fixnum) :bool \"(#0) & 1\") (evenp :always (t) :bool \"ecl_e"
 "venp(#0)\") (evenp :always (fixnum fixnum) :bool \"~(#0) & 1\") (abs :always (t t) "
 "t \"ecl_abs(#0,#1)\") (exp :always (t) t \"ecl_exp(#0)\") (expt :always (t t) t \"ecl"
 "_expt(#0,#1)\") (expt :always ((integer 2 2) (integer 0 29)) :fixnum \"(1<<(#1))\")"
 " (expt :always ((integer 0 0) t) :fixnum \"0\") (expt :always ((integer 1 1) t) :f"
 "ixnum \"1\") (log :always (c::fixnum-float) :double \"log((double)(#0))\" :exact-ret"
 "urn-type t) (log :always (c::fixnum-float) :float \"(float)log((double)(#0))\" :ex"
 "act-return-type t) (sqrt :always (number) number \"ecl_sqrt(#0)\") (sqrt :always ("
 "(long-float #1=0.0 *)) :double \"sqrt((double)(#0))\") (sqrt :always ((double-floa"
 "t #1# *)) :double \"sqrt((double)(#0))\") (sqrt :always ((single-float #1# *)) :fl"
 "oat \"(float)sqrt((double)(#0))\") (sqrt :always ((short-float #1# *)) :float \"(fl"
 "oat)sqrt((double)(#0))\") (sin :always (number) number \"ecl_sin(#0)\") (sin :alway"
 "s (c::fixnum-float) :double \"sin((double)(#0))\" :exact-return-type t) (sin :alwa"
 "ys (c::fixnum-float) :float \"(float)sin((double)(#0))\" :exact-return-type t) (co"
 "s :always (t) number \"ecl_cos(#0)\") (cos :always (c::fixnum-float) :double \"cos("
 "(double)(#0))\" :exact-return-type t) (cos :always (c::fixnum-float) :float \"(flo"
 "at)cos((double)(#0))\" :exact-return-type t) (tan :always (t) number \"ecl_tan(#0)"
 "\") (tan :always (c::fixnum-float) :double \"tan((double)(#0))\" :exact-return-type"
 " t) (tan :always (c::fixnum-float) :float \"(float)tan((double)(#0))\" :exact-retu"
 "rn-type t) (sinh :always (t) number \"ecl_sinh(#0)\") (sinh :always (c::fixnum-flo"
 "at) :double \"sinh((double)(#0))\" :exact-return-type t) (sinh :always (c::fixnum-"
 "float) :float \"(float)sinh((double)(#0))\" :exact-return-type t) (cosh :always (t"
 ") number \"ecl_cosh(#0)\") (cosh :always (c::fixnum-float) :double \"cosh((double)("
 "#0))\" :exact-return-type t) (cosh :always (c::fixnum-float) :float \"(float)cosh("
 "(double)(#0))\" :exact-return-type t) (tanh :always (t) number \"ecl_tanh(#0)\") (t"
 "anh :always (c::fixnum-float) :double \"tanh((double)(#0))\" :exact-return-type t)"
 " (tanh :always (c::fixnum-float) :float \"(float)tanh((double)(#0))\" :exact-retur"
 "n-type t) (null :always (t) :bool \"#0==ECL_NIL\") (symbolp :always (t) :bool \"@0;"
 "ECL_SYMBOLP(#0)\") (atom :always (t) :bool \"@0;ECL_ATOM(#0)\") (consp :always (t) "
 ":bool \"@0;ECL_CONSP(#0)\") (listp :always (t) :bool \"@0;ECL_LISTP(#0)\") (numberp "
 ":always (t) :bool \"ecl_numberp(#0)\") (integerp :always (t) :bool \"@0;ECL_FIXNUMP"
 "(#0)||ECL_BIGNUMP(#0)\") (floatp :always (t) :bool \"floatp(#0)\") (characterp :alw"
 "ays (t) :bool \"ECL_CHARACTERP(#0)\") (c::base-char-p :always (character) :bool \"E"
 "CL_BASE_CHAR_P(#0)\") (stringp :always (t) :bool \"@0;ECL_STRINGP(#0)\") (c::base-s"
 "tring-p :always (t) :bool \"@0;ECL_BASE_STRINGP(#0)\") (bit-vector-p :always (t) :"
 "bool \"@0;ECL_BIT_VECTOR_P(#0)\") (vectorp :always (t) :bool \"@0;ECL_VECTORP(#0)\")"
 " (arrayp :always (t) :bool \"@0;ECL_ARRAYP(#0)\") (eq :always (t t) :bool \"(#0)==("
 "#1)\") (eq :always (fixnum fixnum) :bool \"(#0)==(#1)\") (eql :always (t t) :bool \""
 "ecl_eql(#0,#1)\") (eql :always (character t) :bool \"(ECL_CODE_CHAR(#0)==(#1))\") ("
 "eql :always (t character) :bool \"((#0)==ECL_CODE_CHAR(#1))\") (eql :always (chara"
 "cter character) :bool \"(#0)==(#1)\") (eql :always ((not (or complex bignum ratio "
 "float)) t) :bool \"(#0)==(#1)\") (eql :always (t (not (or complex bignum ratio flo"
 "at))) :bool \"(#0)==(#1)\") (eql :always (fixnum fixnum) :bool \"(#0)==(#1)\") (equa"
 "l :always (t t) :bool \"ecl_equal(#0,#1)\") (equal :always (fixnum fixnum) :bool \""
 "(#0)==(#1)\") (equalp :always (t t) :bool \"ecl_equalp(#0,#1)\") (equalp :always (f"
 "ixnum fixnum) :bool \"(#0)==(#1)\") (not :always (t) :bool \"(#0)==ECL_NIL\") (clear"
 "-output :always (stream) null \"(ecl_clear_output(#0),ECL_NIL)\") (finish-output :"
 "always (stream) null \"(ecl_finish_output(#0),ECL_NIL)\") (finish-output :always ("
 "stream) null \"(ecl_force_output(#0),ECL_NIL)\") (write-char :always (t) t \"@0;(ec"
 "l_princ_char(ecl_char_code(#0),ECL_NIL),(#0))\") (clear-input :always (stream) nu"
 "ll \"(ecl_clear_input(#0),ECL_NIL)\") (copy-readtable :always (null null) t \"stand"
 "ard_readtable\") (boundp :always (t) :bool \"ecl_boundp(cl_env_copy,#0)\") (boundp "
 ":unsafe ((and symbol (not null))) :bool \"ECL_SYM_VAL(cl_env_copy,#0)!=OBJNULL\") "
 "(elt :always (t t) t \"ecl_elt(#0,ecl_fixnum(#1))\") (elt :always (t fixnum) t \"ec"
 "l_elt(#0,#1)\") (elt :always (vector t) t \"ecl_aref1(#0,ecl_fixnum(#1))\") (elt :a"
 "lways (vector fixnum) t \"ecl_aref1(#0,#1)\") (elt :unsafe (t t) t \"ecl_elt(#0,ecl"
 "_fixnum(#1))\") (elt :unsafe (t fixnum) t \"ecl_elt(#0,#1)\") (elt :unsafe (vector "
 "t) t \"ecl_aref_unsafe(#0,ecl_fixnum(#1))\") (elt :unsafe (vector fixnum) t \"ecl_a"
 "ref_unsafe(#0,#1)\") (aref :unsafe ((array bit) t) :fixnum \"ecl_aref_bv(#0,ecl_fi"
 "xnum(#1))\") (aref :unsafe ((array bit) fixnum) :fixnum \"ecl_aref_bv(#0,#1)\") (ar"
 "ef :unsafe ((array character) fixnum) :wchar \"(#0)->string.self[#1]\") (aref :uns"
 "afe ((array base-char) fixnum) :unsigned-char \"(#0)->base_string.self[#1]\") (are"
 "f :unsafe ((array double-float) fixnum) :double \"(#0)->array.self.df[#1]\") (aref"
 " :unsafe ((array single-float) fixnum) :float \"(#0)->array.self.sf[#1]\") (aref :"
 "unsafe ((array fixnum) fixnum) :fixnum \"(#0)->array.self.fix[#1]\") (si::elt-set "
 ":always (t t t) t \"ecl_elt_set(#0,ecl_to_size(#1),#2)\") (si::elt-set :always (t "
 "fixnum t) t \"ecl_elt_set(#0,#1,#2)\") (si::elt-set :always (vector t t) t \"ecl_as"
 "et1(#0,ecl_to_size(#1),#2)\") (si::elt-set :always (vector fixnum t) t \"ecl_aset1"
 "(#0,#1,#2)\") (si::elt-set :unsafe (t t t) t \"ecl_elt_set(#0,ecl_fixnum(#1),#2)\")"
 " (si::elt-set :unsafe (vector t t) t \"ecl_aset_unsafe(#0,ecl_to_size(#1),#2)\") ("
 "si::elt-set :unsafe (vector fixnum t) t \"ecl_aset_unsafe(#0,#1,#2)\") (length :al"
 "ways (t) :fixnum \"ecl_length(#0)\") (length :unsafe (vector) :fixnum \"(#0)->vecto"
 "r.fillp\") (copy-seq :always (t) t \"ecl_copy_seq(#0)\") (char :always (t fixnum) t"
 " \"ecl_aref1(#0,#1)\") (char :always (t fixnum) :wchar \"ecl_char(#0,#1)\") (char :u"
 "nsafe (base-string fixnum) :unsigned-char \"(#0)->base_string.self[#1]\") (char :u"
 "nsafe (ext::extended-string fixnum) :wchar \"(#0)->string.self[#1]\") (si::char-se"
 "t :always (t t t) t \"si_char_set(#0,#1,#2)\") (si::char-set :always (t fixnum t) "
 "t \"ecl_aset1(#0,#1,#2)\") (si::char-set :always (t fixnum character) :wchar \"ecl_"
 "char_set(#0,#1,#2)\") (si::char-set :unsafe (base-string t t) t \"@2;((#0)->base_s"
 "tring.self[ecl_fixnum(#1)]=ecl_char_code(#2),(#2))\") (si::char-set :unsafe (base"
 "-string fixnum base-char) :unsigned-char \"(#0)->base_string.self[#1]= #2\") (si::"
 "char-set :unsafe (ext::extended-string t t) t \"@2;((#0)->string.self[ecl_fixnum("
 "#1)]=ecl_char_code(#2),(#2))\") (si::char-set :unsafe (ext::extended-string fixnu"
 "m character) :unsigned-char \"(#0)->string.self[#1]= #2\") (schar :always (t t) t "
 "\"ecl_elt(#0,ecl_to_size(#1))\") (schar :always (t fixnum) t \"ecl_elt(#0,#1)\") (sc"
 "har :always (t fixnum) :wchar \"ecl_char(#0,#1)\") (schar :unsafe (base-string t) "
 "t \"ECL_CODE_CHAR((#0)->base_string.self[ecl_fixnum(#1)])\") (schar :unsafe (base-"
 "string fixnum) :unsigned-char \"(#0)->base_string.self[#1]\") (schar :unsafe (ext:"
 ":extended-string fixnum) :wchar \"(#0)->string.self[#1]\") (si::schar-set :always "
 "(t t t) t \"ecl_elt_set(#0,ecl_to_size(#1),#2)\") (si::schar-set :always (t fixnum"
 " t) t \"ecl_elt_set(#0,#1,#2)\") (si::schar-set :always (t fixnum character) :wcha"
 "r \"ecl_char_set(#0,#1,#2)\") (si::schar-set :unsafe (base-string t t) t \"@2;((#0)"
 "->base_string.self[ecl_fixnum(#1)]=ecl_char_code(#2),(#2))\") (si::schar-set :uns"
 "afe (base-string fixnum base-char) :unsigned-char \"(#0)->base_string.self[#1]= #"
 "2\") (si::schar-set :unsafe (ext::extended-string fixnum t) :wchar \"@2;((#0)->str"
 "ing.self[#1]= ecl_char_code(#2),(#2))\") (si::schar-set :unsafe (ext::extended-st"
 "ring fixnum character) :wchar \"(#0)->string.self[#1]= #2\") (string= :always (str"
 "ing string) :bool \"ecl_string_eq(#0,#1)\") (si::structure-name :always (structure"
 ") symbol \"ECL_STRUCT_NAME(#0)\") (si::structure-ref :always (t t fixnum) t \"ecl_s"
 "tructure_ref(#0,#1,#2)\") (si::structure-set :always (t t fixnum t) t \"ecl_struct"
 "ure_set(#0,#1,#2,#3)\") (get :always (t t t) t \"ecl_get(#0,#1,#2)\") (get :always "
 "(t t) t \"ecl_get(#0,#1,ECL_NIL)\") (symbol-name :always (t) string \"ecl_symbol_na"
 "me(#0)\") (c::shift>> :always (fixnum fixnum) :fixnum \"((#0) >> (- (#1)))\") (c::s"
 "hift<< :always (fixnum fixnum) :fixnum \"((#0) << (#1))\") (c::short-float-p :alwa"
 "ys (t) :bool \"@0;ECL_SINGLE_FLOAT_P(#0)\") (c::single-float-p :always (t) :bool \""
 "@0;ECL_SINGLE_FLOAT_P(#0)\") (c::double-float-p :always (t) :bool \"@0;ECL_DOUBLE_"
 "FLOAT_P(#0)\") (c::long-float-p :always (t) :bool \"@0;ECL_LONG_FLOAT_P(#0)\") (ext"
 "::fixnump :always (t) :bool \"ECL_FIXNUMP(#0)\") (ext::fixnump :always (fixnum) :b"
 "ool \"1\") (c::ldb1 :always (fixnum fixnum fixnum) :fixnum \"((((~((cl_fixnum)-1 <<"
 " (#0))) << (#1)) & (cl_fixnum)(#2)) >> (#1))\") (c::ldb1 :always (fixnum fixnum f"
 "ixnum) t \"ecl_make_fixnum((((~((cl_fixnum)-1 << (#0))) << (#1)) & (cl_fixnum)(#2"
 ")) >> (#1))\") (mp::lock-count :unsafe (mp::lock) fixnum \"((#0)->lock.count)\") (s"
 "i::instance-ref :always (t fixnum) t \"ecl_instance_ref((#0),(#1))\") (si::instanc"
 "e-ref :unsafe (standard-object fixnum) t \"(#0)->instance.slots[#1]\") (si::instan"
 "ce-sig :unsafe (standard-object) list \"(#0)->instance.sig\") (si::instance-set :u"
 "nsafe (t fixnum t) t \"ecl_instance_set((#0),(#1),(#2))\") (si::instance-set :unsa"
 "fe (standard-object fixnum t) t \"(#0)->instance.slots[#1]=(#2)\") (si::instance-c"
 "lass :always (standard-object) t \"ECL_CLASS_OF(#0)\") (class-of :unsafe (standard"
 "-object) t \"ECL_CLASS_OF(#0)\") (si::instancep :always (t) :bool \"@0;ECL_INSTANCE"
 "P(#0)\") (si::unbound :always nil t \"ECL_UNBOUND\") (si::sl-boundp :always (t) :bo"
 "ol \"(#0)!=ECL_UNBOUND\") (clos::standard-instance-access :always (t t) t \"ecl_ins"
 "tance_ref((#0),ecl_to_size(#1))\") (clos::standard-instance-access :always (t fix"
 "num) t \"ecl_instance_ref((#0),(#1))\") (clos::standard-instance-access :unsafe (s"
 "tandard-object fixnum) t \"(#0)->instance.slots[#1]\") (clos::funcallable-standard"
 "-instance-access :always (t t) t \"ecl_instance_ref((#0),ecl_to_size(#1))\") (clos"
 "::funcallable-standard-instance-access :always (t fixnum) t \"ecl_instance_ref((#"
 "0),(#1))\") (clos::funcallable-standard-instance-access :unsafe (clos::funcallabl"
 "e-standard-object fixnum) t \"(#0)->instance.slots[#1]\")) (method-combination-err"
 "or invalid-method-error clos::std-compute-applicable-methods clos::std-compute-e"
 "ffective-method clos::compute-effective-method-function si::subclassp si::of-cla"
 "ss-p slot-boundp slot-makunbound slot-value clos::slot-value-set slot-exists-p c"
 "los::need-to-make-load-form-p clos::load-defclass) (ext::array-index-p ext::nega"
 "tive-fixnum-p ext::non-negative-fixnum-p ext::non-positive-fixnum-p ext::positiv"
 "e-fixnum-p ext::negative-integer-p ext::non-negative-integer-p ext::non-positive"
 "-integer-p ext::positive-integer-p ext::negative-rational-p ext::non-negative-ra"
 "tional-p ext::non-positive-rational-p ext::positive-rational-p ext::negative-rat"
 "io-p ext::non-negative-ratio-p ext::non-positive-ratio-p ext::positive-ratio-p e"
 "xt::negative-real-p ext::non-negative-real-p ext::non-positive-real-p ext::posit"
 "ive-real-p ext::negative-float-p ext::non-negative-float-p ext::non-positive-flo"
 "at-p ext::positive-float-p ext::negative-short-float-p ext::non-negative-short-f"
 "loat-p ext::non-positive-short-float-p ext::positive-short-float-p ext::negative"
 "-single-float-p ext::non-negative-single-float-p ext::non-positive-single-float-"
 "p ext::positive-single-float-p ext::negative-double-float-p ext::non-negative-do"
 "uble-float-p ext::non-positive-double-float-p ext::positive-double-float-p ext::"
 "negative-long-float-p ext::non-negative-long-float-p ext::non-positive-long-floa"
 "t-p ext::positive-long-float-p) (si::format-princ si::format-prin1 si::format-pr"
 "int-named-character si::format-print-integer si::format-print-cardinal si::forma"
 "t-print-ordinal si::format-print-old-roman si::format-print-roman si::format-fix"
 "ed si::format-exponential si::format-general si::format-dollars si::format-relat"
 "ive-tab si::format-absolute-tab si::format-justification) (clos::ensure-class cl"
 "os::standard-instance-get clos::standard-instance-set clos::find-slot-definition"
 " clos::simple-code-walker clos::standard-instance-set clos::install-method clos:"
 ":default-initargs-of clos::associate-methods-to-gfun clos::pop-next-method) ";
#define compiler_data_text_size 30476
