(#Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 77 77 15 4 77 77 77 19 10 5 29) #A(t (6) (#1="SB-RT" ("RT" "REGRESSION-TEST" "RTEST") "The MIT regression tester" ("CL") ("*DO-TESTS-WHEN-DEFINED*" "*TEST*" "CONTINUE-TESTING" "DEFTEST" "DO-TEST" "DO-TESTS" "GET-TEST" "PENDING-TESTS" "REM-ALL-TESTS" "REM-TEST") si::dodefpackage)) #2=#P"/Users/strobolights/dev/mecl/ecl-build-for-ios64/compile.lsp" 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) (#1# si::select-package)) #2# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (sb-rt::*test* si::*make-special boundp)) #2# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (sb-rt::*do-tests-when-defined* si::*make-special boundp)) #2# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (sb-rt::*entries* si::*make-special boundp (nil))) #2# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (sb-rt::*in-test* si::*make-special boundp)) #2# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (sb-rt::*debug* si::*make-special boundp)) #2# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 1 0 73 29) #A(t (4) (sb-rt::*catch-errors* si::*make-special boundp t)) #2# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (sb-rt::*print-circle-on-failure* si::*make-special boundp)) #2# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (sb-rt::*compile-tests* si::*make-special boundp)) #2# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (sb-rt::*optimization-settings* si::*make-special boundp ((safety 3)))) #2# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (sb-rt::*expected-failures* si::*make-special boundp)) #2# 0) #Y(si::bytecodes nil nil (15 0 77 15 1 77 15 2 15 3 15 4 77 77 77 15 5 9 3 77 77 77 19 15 6 15 7 1 12 12 19 2 13 1 0 73 29) #3=#A(t (14) (sb-rt::entry list (sb-rt::pend sb-rt::name sb-rt::form) ((sb-rt::pend nil t nil 0 nil) (sb-rt::name nil t nil 1 nil) (sb-rt::form nil t nil 2 nil)) sb-rt::copy-entry (sb-rt::make-entry) si::define-structure sb-rt::make-entry (nil :form :name :pend) #:pend #:name #:form #Y(sb-rt::make-entry nil nil (28 8 22 40 2 77 46 9 22 40 2 77 46 10 22 40 2 77 46 11 13 2 13 1 10 0 6 3 73 29) #3# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 14 9 9 2 19 4 10 1 0 73 29) #4=#A(t (11) (sb-rt::vals #:g25548 #:g25547 #:g25549 si::dm-too-few-arguments sb-rt::entry si::dm-too-many-arguments cdddr #Y(sb-rt::vals nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 39 6 13 3 19 1 6 15 7 10 0 6 2 73 29) #4# #2# 0) t si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 14 9 9 2 19 4 10 1 0 73 29) #5=#A(t (11) (sb-rt::defn #:g25551 #:g25550 #:g25552 si::dm-too-few-arguments sb-rt::entry si::dm-too-many-arguments cdr #Y(sb-rt::defn nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 39 6 13 3 19 1 6 15 7 10 0 6 2 73 29) #5# #2# 0) t si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #6=#A(t (9) (sb-rt::pending-tests sb-rt::*entries* sb-rt::r sb-rt::l sb-rt::pend sb-rt::name nreverse #Y(sb-rt::pending-tests nil nil (26 11 1 5 12 77 46 2 46 3 38 29 10 0 4 12 19 1 4 39 14 10 0 4 12 19 1 5 12 10 1 3 51 1 10 0 5 12 53 0 10 0 76 39 -32 10 1 16 6 43 2 29) #6# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 1 0 73 29) #7=#A(t (4) (sb-rt::rem-all-tests sb-rt::*entries* #Y(sb-rt::rem-all-tests nil nil (26 75 6 1 52 1 75 73 29) #7# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #8=#A(t (13) (sb-rt::rem-test sb-rt::*test* sb-rt::name sb-rt::*entries* sb-rt::l cadr equal #:g25559 cddr #:g25560 rplacd #Y(sb-rt::rem-test nil nil (25 40 3 14 1 46 2 26 58 60 66 11 3 45 4 38 49 10 0 16 5 12 19 1 2 12 10 2 17 6 39 28 10 0 45 7 10 1 16 8 45 9 13 1 10 0 17 10 10 0 43 1 43 1 10 2 73 36 1 10 0 5 12 53 0 10 0 5 76 39 -53 75 73 43 1 63 29) #8# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #9=#A(t (6) (sb-rt::get-test sb-rt::*test* sb-rt::name sb-rt::get-entry #Y(sb-rt::get-test nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 5 73 29) #9# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #10=#A(t (13) (sb-rt::get-entry sb-rt::name sb-rt::*entries* :key :test equal find sb-rt::entry t "~%No test with name ~:@(~S~)." sb-rt::report-error #Y(sb-rt::get-entry nil nil (24 45 1 26 13 0 11 2 5 12 14 3 33 1 12 14 4 33 5 12 19 6 6 45 7 10 0 76 39 10 14 8 15 9 13 1 19 3 10 10 0 73 43 1 29) #10# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 14 10 9 3 19 4 12 1 0 73 29) #11=#A(t (13) (sb-rt::deftest #:g25562 #:g25561 #:g25563 si::dm-too-few-arguments sb-rt::name sb-rt::form values sb-rt::add-entry quote t #Y(sb-rt::deftest nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 45 7 15 8 15 9 15 10 13 2 13 1 10 0 7 4 6 2 6 2 73 29) #11# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #12=#A(t (21) (sb-rt::add-entry sb-rt::entry copy-list sb-rt::*entries* sb-rt::l #:g25568 #:g25569 rplacd cadr sb-rt::name equal #:g25570 #:g25571 rplaca "Redefining test ~:@(~S~)" sb-rt::report-error sb-rt::*do-tests-when-defined* sb-rt::do-entry sb-rt::*test* #Y(sb-rt::add-entry nil nil (24 45 1 26 10 0 16 2 51 0 58 60 107 11 3 45 4 38 95 10 0 5 76 39 27 10 0 45 5 10 3 6 1 45 6 13 1 10 0 17 7 10 0 43 1 43 1 75 73 36 1 10 0 16 8 12 19 1 9 12 13 2 19 1 9 17 10 39 39 10 0 45 11 10 3 45 12 10 1 5 12 10 0 17 13 10 0 43 1 43 1 77 15 14 13 2 19 1 9 12 19 3 15 75 73 36 1 10 0 5 12 53 0 75 39 -96 43 1 63 11 16 39 6 13 0 19 1 17 13 0 19 1 9 52 18 73 29) #12# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #13=#A(t (11) (sb-rt::report-error sb-rt::error? sb-rt::args sb-rt::*debug* format t apply error warn #Y(sb-rt::report-error nil nil (24 45 1 27 45 2 11 3 39 23 33 4 12 14 5 13 0 19 3 6 10 1 73 39 6 15 3 75 73 37 38 23 10 1 39 11 33 7 12 13 0 19 2 6 38 9 33 8 12 13 0 19 2 6 29) #13# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #14=#A(t (7) (sb-rt::do-test sb-rt::*test* sb-rt::name sb-rt::get-entry sb-rt::do-entry #Y(sb-rt::do-test nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 12 19 1 4 29) #14# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 34 12 19 2 35 1 0 73 29) #15=#A(t (36) (sb-rt::equalp-with-case sb-rt::x sb-rt::y eq t consp array typep array-rank = aref vector length sb-rt::y-len sb-rt::x-len eql #:loop-across-list25581 #:loop-across-index-25580 #:loop-across-vector-25579 sb-rt::e1 #:loop-across-list25584 #:loop-across-index-25583 #:loop-across-vector-25582 sb-rt::e2 0 >= 1+ array-dimensions equal array-total-size sb-rt::size #:loop-limit25585 sb-rt::i row-major-aref #Y(sb-rt::equalp-with-case nil nil (24 45 1 24 45 2 26 13 1 10 0 17 3 39 6 11 4 73 38 404 10 1 16 5 39 35 10 0 16 5 73 39 26 10 1 4 12 10 0 4 12 19 2 0 73 39 12 10 1 5 12 10 0 5 12 19 2 0 38 364 13 1 15 6 19 2 7 39 11 10 1 16 8 12 9 0 19 2 9 39 18 13 1 19 1 10 12 13 0 19 1 10 12 19 2 0 38 326 13 1 15 11 19 2 7 39 172 13 0 15 11 19 2 7 73 39 160 10 1 16 12 12 10 0 16 12 12 46 13 46 14 13 0 10 1 17 15 73 39 135 58 60 132 77 13 4 9 0 9 0 46 16 46 17 46 18 46 19 77 13 7 9 0 9 0 46 20 46 21 46 22 46 23 57 24 61 2 14 84 10 6 16 12 51 8 10 2 16 12 51 4 13 7 13 8 19 2 25 39 4 35 0 1 13 6 13 7 19 2 10 51 5 10 7 16 26 51 7 13 3 13 4 19 2 25 39 4 35 0 1 13 2 13 3 19 2 10 51 1 10 3 16 26 51 3 13 5 13 1 19 2 0 76 39 5 75 73 36 9 35 0 0 11 4 73 36 9 62 73 43 4 43 4 63 43 2 38 146 13 1 15 6 19 2 7 39 24 13 0 15 6 19 2 7 39 15 13 1 19 1 27 12 13 0 19 1 27 17 28 76 39 5 75 73 38 108 13 1 15 6 19 2 7 39 93 13 0 15 6 19 2 7 73 39 81 10 1 16 29 45 30 58 60 70 9 0 13 1 46 31 46 32 57 24 61 2 2 46 13 1 13 2 19 2 25 39 4 35 0 1 13 6 10 1 17 33 12 13 5 10 1 17 33 12 19 2 0 76 39 5 75 73 36 3 10 1 16 26 51 1 35 0 0 11 4 73 36 3 62 73 43 2 63 43 1 38 7 13 1 10 0 17 15 29) #15# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 45 12 19 2 46 1 0 73 29) #16=#A(t (47) (sb-rt::do-entry sb-rt::entry *standard-output* sb-rt::s sb-rt::*in-test* sb-rt::name sb-rt::*test* #:g25593 t #:g25594 si::elt-set sb-rt::aborted sb-rt::r sb-rt::*compile-tests* list lambda declare optimize sb-rt::*optimization-settings* sb-rt::form compile eval #Y(sb-rt::%do nil nil (26 11 13 39 38 15 14 77 15 15 77 15 16 15 17 11 18 7 2 6 2 12 13 5 19 1 19 6 4 12 19 2 20 12 20 0 23 69 21 23 38 13 15 14 13 5 19 1 19 16 21 69 21 23 29) #16# #2# 0) sb-rt::*catch-errors* style-warning muffle-warning error sb-rt::c #Y(nil nil nil (24 45 27 26 11 8 51 4 10 0 6 1 51 3 75 73 36 2 29) #16# #2# 0) si::*handler-clusters* #:g25598 cdddr sb-rt::equalp-with-case #:g25599 sb-rt::pend sb-rt::*print-circle-on-failure* *print-circle* "~&Test ~:@(~S~) failed~
                   ~%Form: ~S~
                   ~%Expected value~P: ~
                      ~{~S~^~%~17t~}~%" length format "Actual value~P: ~
                      ~{~S~^~%~15t~}.~%" sb-rt::x condition typep "~&Condition: ~A" #Y(sb-rt::do-entry nil nil (24 45 1 25 40 3 14 2 46 3 26 1 4 59 60 206 13 2 19 1 5 52 6 10 2 45 7 11 8 45 9 13 1 9 0 13 0 19 3 10 43 1 43 1 11 8 48 4 75 45 11 75 45 12 57 11 60 44 30 1 22 11 23 39 28 15 24 33 25 3 12 15 26 34 28 3 6 2 12 11 29 3 48 29 32 0 18 0 44 1 38 5 32 0 18 0 43 1 51 1 63 10 4 45 30 10 2 40 12 13 1 10 5 16 31 12 19 2 32 76 45 33 13 1 9 0 13 0 19 3 10 43 1 43 1 13 4 19 1 34 73 39 74 11 35 48 36 13 3 15 37 14 6 13 4 19 1 19 12 10 4 16 31 16 38 12 10 4 16 31 12 19 6 39 13 3 15 40 10 0 16 38 12 13 0 19 4 39 10 0 4 45 41 13 0 15 42 19 2 43 73 39 10 13 4 15 44 13 0 19 3 39 43 1 44 1 43 2 44 1 63 13 1 19 1 34 76 73 39 4 11 6 73 29) #16# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #17=#A(t (6) (sb-rt::continue-testing sb-rt::*in-test* *standard-output* sb-rt::do-entries #Y(sb-rt::continue-testing nil nil (26 11 1 39 8 15 1 75 73 37 38 6 14 2 19 1 3 29) #17# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #18=#A(t (20) (sb-rt::do-tests *standard-output* sb-rt::out sb-rt::*entries* si::%dolist-var sb-rt::entry #:g25606 t #:g25607 si::elt-set streamp sb-rt::do-entries :direction :output open stream close :abort #Y(sb-rt::do-tests nil nil (25 40 3 14 1 46 2 26 11 3 5 45 4 75 45 5 38 32 10 1 4 51 0 10 0 45 6 11 7 45 8 13 1 9 0 13 0 19 3 9 43 1 43 1 10 1 5 51 1 10 1 40 -34 43 2 10 0 16 10 39 8 13 0 19 1 11 38 47 13 0 14 12 14 13 19 3 14 45 15 64 18 13 0 19 1 11 69 10 0 39 6 13 0 19 1 16 70 65 10 0 39 10 13 0 14 17 14 7 19 3 16 66 43 1 29) #18# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 1 35 12 19 2 36 1 0 73 29) #19=#A(t (37) (sb-rt::do-entries sb-rt::s "~&Doing ~A pending test~:P ~
             of ~A tests total.~%" t sb-rt::*entries* :key sb-rt::pend count length format si::%dolist-var sb-rt::entry "~@[~<~%~:; ~:@(~S~)~>~]" sb-rt::do-entry sb-rt::pending-tests :test equal make-hash-table sb-rt::expected-table sb-rt::pending sb-rt::*expected-failures* sb-rt::ex si::hash-set #:loop-list25623 #:loop-list-head25624 #:loop-list-tail25625 0 gethash rplacd sb-rt::new-failures "~&No tests failed." "~&~A out of ~A ~
                   total tests failed: ~
                   ~:@(~{~<~%   ~1:;~S~>~
                         ~^, ~}~)." "~&No unexpected failures." "~&~A unexpected failures: ~
                   ~:@(~{~<~%   ~1:;~S~>~
                         ~^, ~}~)." finish-output #Y(sb-rt::do-entries nil nil (24 45 1 26 13 0 15 2 14 3 11 4 5 12 14 5 33 6 12 19 4 7 12 11 4 5 16 8 12 19 4 9 11 4 5 45 10 75 45 11 38 33 10 1 4 51 0 13 0 19 1 6 39 16 13 2 15 12 13 0 13 2 19 2 13 12 19 3 9 10 1 5 51 1 10 1 40 -35 43 2 19 0 14 12 14 15 33 16 12 19 2 17 12 46 18 46 19 11 20 45 10 75 45 21 38 20 10 1 4 51 0 13 0 13 3 14 3 19 3 22 10 1 5 51 1 10 1 40 -22 43 2 58 60 76 77 13 1 46 23 46 6 75 6 1 45 24 10 0 45 25 57 26 61 2 2 42 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 3 13 7 19 2 27 76 39 11 13 1 10 3 6 1 51 1 17 28 35 0 0 10 2 5 73 36 5 62 43 2 43 2 63 45 29 10 1 76 39 10 13 3 15 30 19 2 9 38 53 13 3 15 31 10 1 16 8 12 11 4 5 16 8 12 13 1 19 5 9 10 0 76 39 10 13 3 15 32 19 2 9 38 19 11 20 39 15 13 3 15 33 10 0 16 8 12 13 0 19 4 9 13 3 19 1 34 10 1 76 73 43 1 43 2 29) #19# #2# 0) si::fset)) #2# 0) #Y(si::bytecodes nil nil (15 0 19 1 1 29) #A(t (2) (#:rt provide)) #2# 0))
