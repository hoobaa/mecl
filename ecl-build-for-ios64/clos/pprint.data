static const char compiler_data_text[] = 
"si::column si::posn si::initial-buffer-size si::default-line-length si::pretty-s"
 "tream :sealedp si::pretty-stream-p :target :buffer-start-column si::make-pretty-"
 "stream si::index-posn si::posn-index si::posn-column :literal si::logical-block "
 "si::copy-logical-block si::logical-block-p si::index si::section-start-line si::"
 "suffix-length si::prefix-length si::per-line-prefix-end si::section-column si::s"
 "tart-column 0 si::make-logical-block :start-column :section-column :per-line-pre"
 "fix-end :prefix-length :suffix-length :section-start-line si::queued-op si::copy"
 "-queued-op si::queued-op-p 0 si::make-queued-op si::section-start si::copy-secti"
 "on-start si::section-start-p si::newline si::block-end (or null si::newline si::"
 "block-end) si::section-end si::depth 0 si::make-section-start si::copy-newline s"
 "i::newline-p (:linear :fill :miser :literal :mandatory) (member :linear :fill :m"
 "iser :literal :mandatory) si::kind 0 si::make-newline :posn :kind :depth :mandat"
 "ory si::indentation si::copy-indentation si::indentation-p si::amount (:block . "
 "#1=(:current)) :current #1# (member :block :current) 0 si::make-indentation :amo"
 "unt si::block-start si::copy-block-start si::block-start-p (or null string) si::"
 "suffix si::prefix (or null si::block-end) 0 si::make-block-start :prefix :suffix"
 " si::copy-block-end si::block-end-p 0 si::make-block-end si::tab si::copy-tab si"
 "::tab-p si::colinc si::colnum (t . #2=(nil)) #2# (member t nil) si::relativep si"
 "::sectionp 0 si::make-tab :line-relative :section :section-relative (:line :line"
 "-relative :section :section-relative) :sectionp :relativep :colnum :colinc 0 0 :"
 "linear 0 :miser :fill 0 :dont-know (t nil :dont-know) (:linear :mandatory :liter"
 "al :miser :fill) (si::newline si::indentation si::block-start si::block-end si::"
 "tab) :from-end si::line-limit-abbreviation-happened si::pprint-pop-helper si::pp"
 "rint-logical-block-helper :per-line-prefix (:suffix :per-line-prefix :prefix) pp"
 "rint-logical-block pprint-exit-if-list-exhausted pprint-pop #3=(:linear . #4=(:m"
 "iser . #5=(:fill . #6=(:mandatory)))) #4# #5# #6# (member . #3#) (or stream (mem"
 "ber t nil)) #7=(:line . #8=(:section . #9=(:line-relative . #10=(:section-relati"
 "ve)))) #8# #9# #10# (member . #7#) si::*initial-pprint-dispatch* si::pprint-disp"
 "atch-entry si::copy-pprint-dispatch-entry si::%print-pprint-dispatch-entry si::p"
 "print-dispatch-entry-p (or function symbol) si::initial-p si::priority 0 si::mak"
 "e-pprint-dispatch-entry si::%print-pprint-dispatch-entry si::pprint-dispatch-tab"
 "le si::copy-pprint-dispatch-table si::%print-pprint-dispatch-table si::pprint-di"
 "spatch-table-p si::entries 0 si::make-pprint-dispatch-table si::%print-pprint-di"
 "spatch-table (or si::pprint-dispatch-table null) :entries si::default-pprint-dis"
 "patch (or null function symbol) :priority si::pprint-array si::pprint-vector :op"
 "tional 0 0 0 0 (:required :key :optional) si::pprint-lambda-list :complaint si::"
 "pprint-lambda si::pprint-block si::pprint-flet si::pprint-let si::pprint-progn s"
 "i::pprint-progv si::pprint-quote si::pprint-setq si::pprint-tagbody si::pprint-c"
 "ase si::pprint-defun si::pprint-destructuring-bind si::pprint-do si::pprint-doli"
 "st si::pprint-typecase si::pprint-prog si::pprint-function-call 0 0 0 0 0 0 si::"
 "logical-block-per-line-prefix-end si::logical-block-prefix-length si::logical-bl"
 "ock-suffix-length 0 0 :posn :depth :section-end 0 si::required-argument :posn :d"
 "epth :section-end :kind si::section-start-section-end si::section-start-depth 0 "
 ":posn :kind :amount 0 :posn :depth :section-end :block-end :prefix :suffix 0 :po"
 "sn :suffix si::block-start-suffix 0 :posn :sectionp :relativep :colnum :colinc s"
 "i::tab-colnum si::tab-colinc si::tab-sectionp si::tab-relativep si::logical-bloc"
 "k-section-column si::queued-op-posn si::tab-posn si::newline-kind si::logical-bl"
 "ock-section-start-line si::newline-section-end si::indentation-kind si::logical-"
 "block-start-column si::indentation-posn si::indentation-amount si::block-start-s"
 "ection-end si::block-start-block-end si::block-start-posn si::block-start-prefix"
 " si::newline-posn 0 0 0 0 0 0 :type :priority :initial-p :function 0 si::pprint-"
 "dispatch-entry-type si::pprint-dispatch-entry-priority si::pprint-dispatch-entry"
 "-initial-p 0 :entries :cons-entries 0 si::pprint-dispatch-table-entries si::ppri"
 "nt-dispatch-table-cons-entries 0 si::pprint-dispatch-entry-function 0 0 0 0 0 0 "
 "0 0 0 0 0 0 0 0 0 0 0 0 0 0 ((optimize (safety 0) (speed 3) (debug 0) (space 0))"
 ") (deftype si::column nil '#11=(and fixnum unsigned-byte)) #11# (deftype si::pos"
 "n nil 'fixnum) (gray::fundamental-character-output-stream) (:writers ((setf si::"
 "pretty-stream-target)) :readers (si::pretty-stream-target) :type stream :initfor"
 "m t :initargs (:target) :name si::target) (:writers ((setf si::pretty-stream-lin"
 "e-length)) :readers (si::pretty-stream-line-length) :type si::column :initform ("
 "or *print-right-margin* si::default-line-length) :name si::line-length) (:writer"
 "s ((setf si::pretty-stream-buffer)) :readers (si::pretty-stream-buffer) :type si"
 "mple-string :initform (make-string si::initial-buffer-size) :name si::buffer) (:"
 "writers ((setf si::pretty-stream-buffer-fill-pointer)) :readers (si::pretty-stre"
 "am-buffer-fill-pointer) :type si::index :initform 0 :name si::buffer-fill-pointe"
 "r) (:writers ((setf si::pretty-stream-buffer-offset)) :readers (si::pretty-strea"
 "m-buffer-offset) :type si::posn :initform 0 :name si::buffer-offset) (:writers ("
 "(setf si::pretty-stream-buffer-start-column)) :readers (si::pretty-stream-buffer"
 "-start-column) :type si::column :initargs (:buffer-start-column) :name si::buffe"
 "r-start-column) (:writers ((setf si::pretty-stream-line-number)) :readers (si::p"
 "retty-stream-line-number) :type si::index :initform 0 :name si::line-number) (:w"
 "riters ((setf si::pretty-stream-blocks)) :readers (si::pretty-stream-blocks) :ty"
 "pe list :initform (list (si::make-logical-block)) :name si::blocks) (:writers (("
 "setf si::pretty-stream-prefix)) :readers (si::pretty-stream-prefix) :type string"
 " :initform (make-string si::initial-buffer-size) :name si::prefix) (:writers ((s"
 "etf si::pretty-stream-suffix)) :readers (si::pretty-stream-suffix) :type string "
 ":initform (make-string si::initial-buffer-size) :name si::suffix) (:writers ((se"
 "tf si::pretty-stream-queue-tail)) :readers (si::pretty-stream-queue-tail) :type "
 "list :initform nil :name si::queue-tail) (:writers ((setf si::pretty-stream-queu"
 "e-head)) :readers (si::pretty-stream-queue-head) :type list :initform nil :name "
 "si::queue-head) (:writers ((setf si::pretty-stream-pending-blocks)) :readers (si"
 "::pretty-stream-pending-blocks) :type list :initform nil :name si::pending-block"
 "s) (t) (si::pretty-stream t) (si::pretty-stream stream) ((inline si::index-posn "
 "si::posn-index si::posn-column)) (stream char) (si::pretty-stream) (stream) ((si"
 "::start-column 0 :type si::column) (si::section-column 0 :type si::column) (si::"
 "per-line-prefix-end 0 :type si::index) (si::prefix-length 0 :type si::index) (si"
 "::suffix-length 0 :type si::index) (si::section-start-line 0 :type si::index)) ("
 "(si::start-column 0 si::column nil 0 nil) (si::section-column 0 si::column nil 1"
 " nil) (si::per-line-prefix-end 0 si::index nil 2 nil) (si::prefix-length 0 si::i"
 "ndex nil 3 nil) (si::suffix-length 0 si::index nil 4 nil) (si::section-start-lin"
 "e 0 si::index nil 5 nil)) (si::make-logical-block) ((si::posn 0 :type si::posn))"
 " ((si::posn 0 si::posn nil 0 nil)) (si::make-queued-op) ((si::depth 0 :type si::"
 "index) (si::section-end nil :type #12=(or null si::newline si::block-end))) (#13"
 "=(si::posn 0 si::posn nil 0 si::queued-op-posn) (si::depth 0 si::index nil 1 nil"
 ") (si::section-end nil #12# nil 2 nil)) (si::make-section-start) ((si::kind #14="
 "(si::required-argument) :type #15=(member :linear :fill :miser :literal :mandato"
 "ry))) (#16=(si::posn 0 si::posn nil 0 si::section-start-posn) #17=(si::depth 0 s"
 "i::index nil 1 si::section-start-depth) #18=(si::section-end nil (or null si::ne"
 "wline si::block-end) nil 2 si::section-start-section-end) (si::kind #14# #15# ni"
 "l 3 nil)) (si::make-newline) ((si::kind #19=(si::required-argument) :type #20=(m"
 "ember :block :current)) (si::amount 0 :type fixnum)) (#13# (si::kind #19# #20# n"
 "il 1 nil) (si::amount 0 fixnum nil 2 nil)) (si::make-indentation) ((si::block-en"
 "d nil :type #21=(or null si::block-end)) (si::prefix nil :type #22=(or null stri"
 "ng)) (si::suffix nil :type #23=(or null string))) (#16# #17# #18# (si::block-end"
 " nil #21# nil 3 nil) (si::prefix nil #22# nil 4 nil) (si::suffix nil #23# nil 5 "
 "nil)) (si::make-block-start) ((si::suffix nil :type #24=(or null string))) (#13#"
 " (si::suffix nil #24# nil 1 nil)) (si::make-block-end) ((si::sectionp nil :type "
 "#25=(member t nil)) (si::relativep nil :type #26=(member t nil)) (si::colnum 0 :"
 "type si::column) (si::colinc 0 :type si::column)) (#13# (si::sectionp nil #25# n"
 "il 1 nil) (si::relativep nil #26# nil 2 nil) (si::colnum 0 si::column nil 3 nil)"
 " (si::colinc 0 si::column nil 4 nil)) (si::make-tab) ((type #27=(si::required-ar"
 "gument) :type t) (si::priority 0 :type real) (si::initial-p #28=(not (boundp 'si"
 "::*initial-pprint-dispatch*)) :type #29=(member t nil)) (function #30=(si::requi"
 "red-argument) :type #31=(or function symbol))) ((type #27# t nil 0 nil) (si::pri"
 "ority 0 real nil 1 nil) (si::initial-p #28# #29# nil 2 nil) (function #30# #31# "
 "nil 3 nil)) (si::make-pprint-dispatch-entry) ((si::entries nil :type list) (si::"
 "cons-entries #32=(make-hash-table :test #'eql))) ((si::entries nil list nil 0 ni"
 "l) (si::cons-entries #32# t nil 1 nil)) (si::make-pprint-dispatch-table) (cons ("
 "and symbol (satisfies fboundp))) ((lambda si::pprint-lambda) (block si::pprint-b"
 "lock) (catch si::pprint-block) (ext::compiler-let si::pprint-let) (eval-when si:"
 ":pprint-block) (flet si::pprint-flet) #'si::pprint-quote (labels si::pprint-flet"
 ") (let si::pprint-let) (let* si::pprint-let) (locally si::pprint-progn) (macrole"
 "t si::pprint-flet) (multiple-value-call si::pprint-block) (multiple-value-prog1 "
 "si::pprint-block) (progn si::pprint-progn) (progv si::pprint-progv) 'si::pprint-"
 "quote (return-from si::pprint-block) (setq si::pprint-setq) (symbol-macrolet si:"
 ":pprint-let) (tagbody si::pprint-tagbody) (throw si::pprint-block) (unwind-prote"
 "ct si::pprint-block) (case si::pprint-case) (ccase si::pprint-case) (ctypecase s"
 "i::pprint-typecase) (defconstant si::pprint-block) (define-modify-macro si::ppri"
 "nt-defun) (define-setf-expander si::pprint-defun) (defmacro si::pprint-defun) (d"
 "efparameter si::pprint-block) (defsetf si::pprint-defun) (defstruct si::pprint-b"
 "lock) (deftype si::pprint-defun) (defun si::pprint-defun) (defvar si::pprint-blo"
 "ck) (destructuring-bind si::pprint-destructuring-bind) (do si::pprint-do) (do* s"
 "i::pprint-do) (do-all-symbols si::pprint-dolist) (do-external-symbols si::pprint"
 "-dolist) (do-symbols si::pprint-dolist) (dolist si::pprint-dolist) (dotimes si::"
 "pprint-dolist) (ecase si::pprint-case) (etypecase si::pprint-typecase) (multiple"
 "-value-bind si::pprint-progv) (multiple-value-setq si::pprint-block) (pprint-log"
 "ical-block si::pprint-block) (print-unreadable-object si::pprint-block) (prog si"
 "::pprint-prog) (prog* si::pprint-prog) (prog1 si::pprint-block) (prog2 si::pprin"
 "t-progv) (psetf si::pprint-setq) (psetq si::pprint-setq) (setf si::pprint-setq) "
 "(step si::pprint-progn) (time si::pprint-progn) (typecase si::pprint-typecase) ("
 "unless si::pprint-block) (when si::pprint-block) (with-compilation-unit si::ppri"
 "nt-block) (with-hash-table-iterator si::pprint-block) (with-input-from-string si"
 "::pprint-block) (with-open-file si::pprint-block) (with-open-stream si::pprint-b"
 "lock) (with-output-to-string si::pprint-block) (with-package-iterator si::pprint"
 "-block) (with-simple-restart si::pprint-block) (with-standard-io-syntax si::ppri"
 "nt-progn)) ";
#define compiler_data_text_size 11611
