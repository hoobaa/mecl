static const char compiler_data_text[] = 
"si::*quit-tags* si::*break-level* si::*break-env* si::*ihs-base* si::*ihs-top* s"
 "i::*ihs-current* si::*frs-base* si::*frs-top* si::*tpl-continuable* si::*tpl-pro"
 "mpt-hook* si::*eof* si::*last-error* si::*break-message* si::*break-readtable* s"
 "i::*tpl-level* si::*break-hidden-functions* si::*break-hidden-packages* si::tpl-"
 "commands si::*tpl-commands* si::break-commands si::*lisp-initialized* si::top-le"
 "vel si::*console-lock* si::*console-available* si::*console-owner* si::*console-"
 "waiting-list* si::candidate-to-get-console-p si::register-in-waiting-list si::de"
 "lete-from-waiting-list si::grab-console si::release-console (si::register-in-wai"
 "ting-list mp::*current-process*) (si::grab-console mp::*current-process*) ((si::"
 "delete-from-waiting-list mp::*current-process*) (si::release-console mp::*curren"
 "t-process*)) si::with-grabbed-console si::*allow-recursive-debug* si::*debug-sta"
 "tus* si::simple-terminal-interrupt si::show-process-list si::query-process si::*"
 "interrupt-lonely-threads-p* si::single-threaded-terminal-interrupt 0 0 :report-f"
 "unction :interactive-function si::terminal-interrupt si::restart-toplevel si::re"
 "start-debugger si::tpl si::user si::tpl-prompt 0 0 0 0 0 :newline (#\\  #\\Tab #\\N"
 "ewline #\\Return :eof) :help si::tpl-read si::*debug-tpl-commands* si::tpl-comman"
 "d ((error (lambda (condition) (unless si::*debug-tpl-commands* (format t \"~&Comm"
 "and aborted.~%Received condition of type: ~A~%~A\" (type-of condition) condition)"
 " (clear-input) (return-from si::tpl-command nil))))) si::harden-command si::tpl-"
 "unknown-command :restart :eval :string :constant si::tpl-make-command si::tpl-pa"
 "rse-forms si::tpl-parse-strings si::tpl-print si::tpl-unknown-command si::tpl-po"
 "p-command si::tpl-quit-command si::tpl-previous si::tpl-next si::tpl-go si::tpl-"
 "print-message si::tpl-disassemble-command si::tpl-lambda-expression-command ext:"
 ":function-lambda-list si::decode-env-elt si::decode-ihs-env si::ihs-environment "
 "si::tpl-print-variables si::tpl-variables-command si::tpl-inspect-command si::tp"
 "l-bds-command si::tpl-backtrace si::tpl-frs-command si::print-frs si::break-wher"
 "e si::tpl-print-current si::tpl-hide si::tpl-unhide si::tpl-unhide-package si::t"
 "pl-unhide-all si::tpl-hide-package si::ihs-visible si::name :zombi si::ihs-fname"
 " si::set-current-ihs si::set-break-env si::ihs-search si::tpl-backward-search si"
 "::tpl-forward-search si::tpl-apropos-command si::tpl-document-command si::tpl-st"
 "ep-command si::tpl-trace-command si::tpl-untrace-command si::*tpl-last-load* si:"
 ":tpl-load-command si::*tpl-last-compile* si::tpl-compile-command si::tpl-help-co"
 "mmand si::tpl-help-stack-command :keyword si::compute-restart-commands si::updat"
 "e-debug-commands si::*default-debugger-maximum-depth* si::check-default-debugger"
 "-runaway si::tpl-switch-command si::tpl-waiting-command :display :commands si::d"
 "efault-debugger invoke-debugger 0 0 0 0 0 0 0 0 0 0 0 si::make-restart 0 :proces"
 "s :correctablep 0 :commands :prompt-hook :broken-at :quiet 0 0 0 0 0 0 0 0 0 0 0"
 " 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 si::help 0 si::"
 "step* 0 si::trace* 0 si::untrace* 0 0 0 0 0 0 0 si::exit-process 0 0 0 0 (si::*b"
 "reak-readtable* si::*break-on-warnings* si::*tpl-evalhook* si::*tpl-prompt-hook*"
 ") (error cerror apply funcall invoke-debugger) ((\"Top level commands\" ((:cf :com"
 "pile-file) si::tpl-compile-command :string \":cf\t\tCompile file\" \":compile-file &s"
 "tring &rest files\t\t[Top level command]~@\n\t:cf &string &rest files\t\t\t\t[Abbreviati"
 "on]~@\n\t~@\n\tCompile files.  With no arguments, uses values from latest :cf~@\n\tcom"
 "mand.  File extensions are optional.~%\") ((:exit :eof) ext::quit :eval \":exit or"
 " ^D\tExit Lisp\" \":exit &eval &optional (status 0)\t\t[Top level command]~@\n\t~@\n\tExi"
 "t Lisp without further confirmation.~%\") ((:ld :load) si::tpl-load-command :stri"
 "ng \":ld\t\tLoad file\" \":load &string &rest files\t\t\t[Top level command]~@\n\t:ld &str"
 "ing &rest files\t\t\t\t[Abbreviation]~@\n\t~@\n\tLoad files.  With no arguments, uses va"
 "lues from latest :ld~@\n\tor :cf command. File extensions are optional.~%\") ((:ste"
 "p) si::tpl-step-command nil \":step\t\tSingle step form\" \":step form\t\t\t\t\t[Top level"
 " command]~@\n\t~@\n\tEvaluate form in single step mode.  While stepping, a new break"
 "~@\n\tlevel is invoked before every evaluation.  Extra commands are~@\n\tavailable a"
 "t this time to control stepping and form evaluation.~%\") ((:tr :trace) si::tpl-t"
 "race-command nil \":tr(ace)\tTrace function\" \":trace &rest functions\t\t\t\t[Top level"
 " command]~@\n\t:tr &rest functions\t\t\t\t[Abbreviation]~@\n\t~@\n\tTrace specified functi"
 "ons.  With no arguments, show currently~@\n\ttraced functions.~@\n\t~@\n\tSee also: :u"
 "ntrace.~%\") ((:untr :untrace) si::tpl-untrace-command nil \":untr(ace)\tUntrace fu"
 "nction\" \":untrace &rest functions\t\t\t[Top level command]~@\n\t:untr &rest functions"
 "\t\t\t\t[Abbreviation]~@\n\t~@\n\tUntrace specified functions.  With no arguments, untra"
 "ce~@\n\tall functions.~@\n\t~@\n\tSee also: :trace.~%\") ((:s :switch) si::tpl-switch-c"
 "ommand nil \":s(witch)       Switch to next process to debug\" \":switch process   "
 "                              [Break command]~@\n        :s processs             "
 "                        [Abbreviation]~@\n        ~@\n        Switch to next proce"
 "ss in need to debugger attention. Argument~@\n        process, when provided, mus"
 "t be an integer indicating the rank~@\n        of the process in the debugger wai"
 "ting list.~%\") ((:br :break) si::tpl-interrupt-command nil \":br(eak)        Stop"
 " a given process\" \":break process                                  [Break comman"
 "d]~@\n        :br processs                                    [Abbreviation]~@\n  "
 "      ~@\n        Interrupt a given process. Argument process, must be provided a"
 "nd\n        it must be an integer indicating the rank~@\n        of the process in"
 " the debugger waiting list (:waiting).~%\") ((:w :waiting) si::tpl-waiting-comman"
 "d nil \":w(aiting)      Display list of active toplevels\" \":waiting              "
 "                          [Break command]~@\n        :w                          "
 "                    [Abbreviation]~@\n        ~@\n        Display list of active t"
 "oplevels, including open debug sessions.~%\")) (\"Help commands\" ((:apropos) si::t"
 "pl-apropos-command nil \":apropos\tApropos\" \":apropos string &optional package\t\t[T"
 "op level command]~@\n\t~@\n\tFinds all available symbols whose print names contain s"
 "tring.~@\n\tIf a non NIL package is specified, only symbols in that package are co"
 "nsidered.~@\n\t~%\") ((:doc si::document) si::tpl-document-command nil \":doc(ument)"
 "\tDocument\" \":document symbol\t\t\t\t[Top level command]~@\n\t~@\n\tDisplays documentatio"
 "n about function, print names contain string.~%\") ((si::? :h :help) si::tpl-help"
 "-command nil \":h(elp) or ?\tHelp.  Type \\\":help help\\\" for more information\" \":he"
 "lp &optional topic\t\t\t\t[Top level command]~@\n\t:h &optional topic\t\t\t\t[Abbrevation]"
 "~@\n      \t~@\n\tPrint information on specified topic.  With no arguments, print~@\n"
 "\tquick summery of top level commands.~@\n\t~@\n\tHelp information for top level comm"
 "ands follows the documentation~@\n\tstyle found in \\\"Common Lisp, the Language\\\"; "
 "and, in general, the~@\n\tcommands themselves follow the conventions of Common Lis"
 "p functions,~@\n\twith the exception that arguments are normally not evaluated.~@\n"
 "\tThose commands that do evaluate their arguments are indicated by the~@\n\tkeyword"
 " &eval in their description.  A third class of commands~@\n\ttreat their arguments"
 " as whitespace-separated, case-sensitive~@\n\tstrings, requiring double quotes onl"
 "y when necessary.  This style~@\n\tof argument processing is indicated by the keyw"
 "ord &string.~@\n\tFor example, the :load command accepts a list of file names:\n\t~@"
 "\n\t:load &string &rest files\t\t\t[Top level Command]~@\n\t~@\n\twhereas :exit, which re"
 "quires an optional evaluated argument, is~@\n\t~@\n\t:exit &eval &optional status\t\t\t"
 "[Top level Command]~%\"))) (\"Break commands\" ((:q :quit) si::tpl-quit-command nil"
 " \":q(uit)\t\tReturn to some previous break level\" \":quit &optional n\t\t\t\t[Break com"
 "mand]~@\n\t:q &optional n\t\t\t\t\t[Abbreviation]~@\n\t~@\n\tWithout argument, return to to"
 "p level;~@\n\totherwise return to break level n.~%\") ((:pop) (si::tpl-pop-command)"
 " :constant \":pop\t\tPop to previous break level\" \":pop\t\t\t\t\t\t[Break command]~@\n\t~@\n"
 "\tPop to previous break level, or if already in top level,~@\n\texit Lisp after con"
 "firmation.~%\") ((:c :continue) continue nil \":c(ontinue)\tContinue execution\" \":c"
 "ontinue\t\t\t\t\t[Break command]~@\n\t:c\t\t\t\t\t\t[Abbreviation]~@\n\t~@\n\tContinue execution."
 "  Return from current break level to the caller.~@\n\tThis command is only availab"
 "le when the break level is continuable~@\n\t(e.g., called from a correctable error"
 " or the function break).~%\") ((:b :backtrace) si::tpl-backtrace nil \":b(acktrace"
 ")\tPrint backtrace\" \":backtrace &optional n\t\t\t\t[Break command]~@\n\t:b &optional n\t"
 "\t\t\t\t[Abbreviation]~@\n\t~@\n\tShow function call history.  Only those functions call"
 "ed since~@\n\tthe previous break level are shown.  In addition, functions compiled"
 "~@\n\tin-line or explicitly hidden are not displayed.  Without an argument,~@\n\ta c"
 "oncise backtrace is printed with the current function in upper~@\n\tcase.  With in"
 "teger argument n, the n functions above and including~@\n\tthe current one are pri"
 "nted in a verbose format.~@\n\t~@\n\tSee also: :function, :previous, :next.~%\") ((:f"
 " :function) si::tpl-print-current nil \":f(unction)\tShow current function\" \":func"
 "tion\t\t\t\t\t[Break command]~@\n\t:f\t\t\t\t\t\t[Abbreviation]~@\n\t~@\n\tShow current function."
 "  The current function is the implicit focus~@\n\tof attention for several other c"
 "ommands.  When it is an interpreted~@\n \tfunction, its lexical environment is ava"
 "ilable for inspection and~@\n\tbecomes the environment for evaluating user input f"
 "orms.~@\n\t~@\n\tSee also: :backtrace, :next, previous, :disassemble, :variables.~%\""
 ") ((:p :previous) si::tpl-previous nil \":p(revious)\tGo to previous function\" \":p"
 "revious &optional (n 1)\t\t\t[Break command]~@\n\t:p &optional (n 1)\t\t\t\t[Abbreviation"
 "]~@\n\t~@\n\tMove to the nth previous visible function in the backtrace.~@\n \tIt beco"
 "mes the new current function.~@\n\t~@\n\tSee also: :backtrace, :function, :go, :next"
 ".~%\") ((:d :down) si::tpl-previous nil \":d(own)         Alias to :previous\" \"\") "
 "((:n :next) si::tpl-next nil \":n(ext)\t\tGo to next function\" \":next &optional (n "
 "1)\t\t\t\t[Break command]~@\n\t:n &optional (n 1)\t\t\t\t[Abbreviation]~@\n\t~@\n\tMove to the"
 " nth next visible function in the backtrace.  It becomes~@\n\tthe new current func"
 "tion.~@\n\t~@\n\tSee also: :backtrace, :function, :go, :previous.~%\") ((:u :up) si::"
 "tpl-next nil \":u(p)           Alias to :next\" \"\") ((:g :go) si::tpl-go nil \":g(o"
 ")\t\tGo to next function\" \":go &optional (n 1)\t\t\t\t[Break command]~@\n\t:g &optional "
 "(n 1)\t\t\t\t[Abbreviation]~@\n\t~@\n\tMove to the function at IHS[i].~@\n\tSee also: :bac"
 "ktrace, :function, :next, :previous.~%\") ((:fs :forward-search) si::tpl-forward-"
 "search :string \":fs             Search forward for function\" \":forward-search &s"
 "tring substring\t\t[Break command]~@\n\t:fs &string substring\t\t\t\t[Abbreviation]~@\n\t~"
 "@\n\tSearch forward in the backtrace for function containing substring.~@\n\tThe mat"
 "ch is case insensitive.~@\n\t~@\n\tSee also: :backtrace, :function, :next.~%\") ((:bs"
 " :backward-search) si::tpl-backward-search :string \":bs             Search backw"
 "ard for function\" \":backward-search &string substring\t\t[Break command]~@\n\t:bs &s"
 "tring substring\t\t\t\t[Abbreviation]~@\n\t~@\n\tSearch backward in the backtrace for fu"
 "nction containing substring.~@\n\tThe match is case insensitive.~@\n\t~@\n\tSee also: "
 ":backtrace, :function, :previous.~%\") ((:disassemble) si::tpl-disassemble-comman"
 "d nil \":disassemble\tDisassemble current function\" \":disassemble\t\t\t\t\t[Break comma"
 "nd]~@\n\t:disassemble\t\t\t\t\t[Abbreviation]~@\n\t~@\n\tDisassemble the current function. "
 "Currently, only interpreted functions~@\n\tcan be disassembled.~%\") ((:le :lambda-"
 "expression) si::tpl-lambda-expression-command nil \":l(ambda-)e(expression)\tShow "
 "lisp code for current function\" \":lambda-expression\t\t\t\t[Break command]~@\n\t:le\t\t\t"
 "\t\t\t[Abbreviation]~@\n\t~@\n\tShow the lisp code of the current function. Only works "
 "for interpreted~@\n        functions.~%\") ((:v :variables) si::tpl-variables-comm"
 "and nil \":v(ariables)\tShow local variables, functions, blocks, and tags\" \":varia"
 "bles &optional no-values\t\t\t[Break command]~@\n\t:v &optional no-values\t\t\t\t[Abbrevi"
 "ation]~@\n\t~@\n\tShow lexical variables, functions, block names, and tags local~@\n\t"
 "to the current function.  The current function must be interpreted.~@\n\tThe value"
 "s of local variables and functions are also shown,~@\n\tunless the argument is non"
 "-null.~%\") ((:hide) si::tpl-hide nil \":hide\t\tHide function\" \":hide function\t\t\t\t\t"
 "[Break command]~@\n\t~@\n\tHide function.  A hidden function is not displayed in a b"
 "acktrace.~@\n\t~@\n\tSee also: :backtrace, :unhide, :hide-package.~%\") ((:unhide) si"
 "::tpl-unhide nil \":unhide\t\tUnhide function\" \":unhide function\t\t\t\t[Break command]"
 "~@\n\t~@\n\tUnhide function.  The specified function will be displayed in future~@\n\t"
 "backtraces, unless its home package is also hidden.~@\n\t~@\n\tSee also: :backtrace,"
 " :hide, :unhide-package.~%\") ((:hp :hide-package) si::tpl-hide-package nil \":hp\t"
 "\tHide package\" \":hide-package package\t\t\t\t[Break command]~@\n\t:hp package\t\t\t\t\t[Abb"
 "reviation]~@\n\t~@\n\tHide package.  Functions in a hidden package are not displayed"
 "~@\n\tin a backtrace.~@\n\t~@\n\tSee also: :backtrace, :unhide-package.~%\") ((:unhp :u"
 "nhide-package) si::tpl-unhide-package nil \":unhp\t\tUnhide package\" \":unhide-packa"
 "ge package\t\t\t\t[Break command]~@\n\t:unhp package\t\t\t\t\t[Abbreviation]~@\n\t~@\n\tUnhide "
 "package.  Functions in the specified package will be displayed~@\n\tin future back"
 "traces, unless they are individually hidden.~@\n\t~@\n\tSee also: :backtrace, :hide-"
 "package, :hide, :unhide.~%\") ((:unhide-all) si::tpl-unhide-all nil \":unhide-all "
 "    Unhide all variables and packages\" \":unhide-all\t\t\t\t\t[Break command]~@\n\t~@\n\tU"
 "nhide all variables and packages.  All functions will be displayed~@\n\tin future "
 "backtraces.~@\n\t~@\n\tSee also: :hide, :unhide, :hide-package, :unhide-package.~%\")"
 " ((:bds :binding-stack) si::tpl-bds-command nil \":bds            Show binding st"
 "ack\" \":binding-stack &optional variable\t\t[Break command]~@\n\t:bds &optional varia"
 "ble\t\t\t\t[Abbreviation]~@\n\t~@\n\tWithout an argument, show the entire binding stack "
 "since the previous~@\n\tbreak level.  With a variable name, print nothing, but ret"
 "urn the~@\n\tvalue of the given variable on the binding stack.~%\") ((:frs :frame-s"
 "tack) si::tpl-frs-command nil \":frs            Show frame stack\" \"\") ((:m :messa"
 "ge) si::tpl-print-message nil \":m(essage)      Show error message\" \":message\t\t\t\t"
 "\t[Break command]~@\n\t:m\t\t\t\t\t\t[Abbreviation]~@\n\t~@\n\tShow current error message.~%\""
 ") ((:hs :help-stack) si::tpl-help-stack-command nil \":hs\t\tHelp stack\" \":help-sta"
 "ck\t\t\t\t\t[Break command]~@\n\t:hs\t\t\t\t\t\t[Abbrevation]~@\n\t~@\n\tLists the functions to a"
 "ccess the LISP system stacks.~%\") ((:i :inspect) si::tpl-inspect-command nil \":i"
 "(nspect)      Inspect value of local variable\" \":inspect var-name               "
 "                [Break command]~@\n        :i var-name                           "
 "          [Abbreviation]~@\n        ~@\n        Inspect value of local variable na"
 "med by var-name. Argument~@\n        var-name can be a string or a symbol whose n"
 "ame string will~@\n        then be used regardless of of the symbol's package.~@\n"
 "        ~@\n        See also: :variables.~%\")) ";
#define compiler_data_text_size 15086
