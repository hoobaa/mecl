all_symbols.d:/* -*- mode: c; c-basic-offset: 8 -*- */
all_symbols.d:	while (l--) {
all_symbols.d:		} else if (c == '-' || c == '_') {
all_symbols.d:		output->base_string.self[output->base_string.fillp++] = c;
all_symbols.d:	return &output->base_string.self[output->base_string.fillp];
all_symbols.d:@(defun si::mangle-name (symbol &optional as_function)
all_symbols.d:		p  = (cl_symbol_initializer*)symbol - cl_symbols;
all_symbols.d:		cl_object fun = symbol->symbol.gfdef;
all_symbols.d:		if ((t == t_cfun || t == t_cfunfixed) && fun->cfun.block == OBJNULL) {
all_symbols.d:					if (fun->cfun.narg >= 0) {
all_symbols.d:					    maxarg = ecl_make_fixnum(fun->cfun.narg);
all_symbols.d:		package = package->pack.name;
all_symbols.d:	l      = symbol->base_string.fillp;
all_symbols.d:	source = symbol->base_string.self;
all_symbols.d:		if (l > 2 && source[l-1] == '*') l--;
all_symbols.d:		l--;
all_symbols.d:	} else if (is_symbol && l > 2 && source[0] == '+' && source[l-1] == '+') {
all_symbols.d:		l-= 2;
all_symbols.d:	output->base_string.fillp = 0;
all_symbols.d:		if (!mangle_name(output, package->base_string.self, package->base_string.fillp))
all_symbols.d:	output->base_string.self[output->base_string.fillp++] = c;
all_symbols.d:	if (dest[-1] == '_')
all_symbols.d:		dest[-1] = 'M';
all_symbols.d:	s->symbol.t = t_symbol;
all_symbols.d:	s->symbol.dynamic = 0;
all_symbols.d:	s->symbol.binding = ECL_MISSING_SPECIAL_BINDING;
all_symbols.d:	s->symbol.plist = ECL_NIL;
all_symbols.d:	s->symbol.hpack = ECL_NIL;
all_symbols.d:	s->symbol.stype = stp;
all_symbols.d:	s->symbol.hpack = package;
all_symbols.d:	s->symbol.name = make_constant_base_string(name);
all_symbols.d:		package->pack.external =
all_symbols.d:                        _ecl_sethash(s->symbol.name, package->pack.external, s);
all_symbols.d:		if (ecl_find_symbol(s->symbol.name, package, &intern_flag) != ECL_NIL
all_symbols.d:		s->symbol.stype |= ecl_stp_special_form;
alloc.d:/* -*- mode: c; c-basic-offset: 8 -*- */
alloc.d:    alloc.c --	Memory allocation.
alloc.d: ***  is the Boehm-Weiser garbage collector and it is dealt with in           ***
alloc.d:    +------+--------------------+ - - - + - - --------+
alloc.d:    +------+--------------------+ - - - + - - --------+
alloc.d:#error "Internal error: ECL cannot be built with --disable-boehm and --enable-smallcons"
alloc.d:/******************************* ------- ******************************/
alloc.d:	bytes = (bytes + PAGESIZE-1) / PAGESIZE;
alloc.d:			      MAP_ANON | MAP_FIXED | MAP_PRIVATE, -1 ,0);
alloc.d:			ecl_internal_error("Cannot allocate memory. Good-bye!");
alloc.d:		m = (data_end - heap_end)/LISP_PAGESIZE;
alloc.d:			      MAP_ANON | MAP_FIXED | MAP_PRIVATE, -1, 0);
alloc.d:			ecl_internal_error("Cannot resize memory pool. Good-bye!");
alloc.d:			cl_dealloc(heap_end, data_end - heap_end);
alloc.d:		holepage = (last_addr - heap_end) / LISP_PAGESIZE;
alloc.d:	m = (data_end - heap_end)/LISP_PAGESIZE;
alloc.d:		e = sbrk((n -= m) * LISP_PAGESIZE);
alloc.d:		cl_dealloc(heap_end, data_end - heap_end);
alloc.d:		e = sbrk(n * LISP_PAGESIZE + (data_end - e));
alloc.d:		ecl_internal_error("Can't allocate.  Good-bye!");
alloc.d:	holepage -= n;
alloc.d: * tagged as useless. Since these bytes are at least 4, x->m points to
alloc.d: * data within the page and we can mark this object setting x->m=FREE.
alloc.d:	t = tm->tm_type;
alloc.d:	f = tm->tm_free;
alloc.d:	for (i = tm->tm_nppage; i > 0; --i, p += tm->tm_size) {
alloc.d:		((struct freelist *)x)->t = (short)t;
alloc.d:		((struct freelist *)x)->m = FREE;
alloc.d:		((struct freelist *)x)->f_link = f;
alloc.d:	if (tm->tm_size * tm->tm_nppage < LISP_PAGESIZE) {
alloc.d:		x->d.m = FREE;
alloc.d:	tm->tm_free = f;
alloc.d:	tm->tm_nfree += tm->tm_nppage;
alloc.d:	tm->tm_npage++;
alloc.d:	obj = tm->tm_free;
alloc.d:		if (tm->tm_npage >= tm->tm_maxpage)
alloc.d:		obj = tm->tm_free;
alloc.d:		if (tm->tm_npage >= tm->tm_maxpage)
alloc.d:	tm->tm_free = ((struct freelist *)obj)->f_link;
alloc.d:	--(tm->tm_nfree);
alloc.d:	(tm->tm_nused)++;
alloc.d:	obj->d.t = (short)t;
alloc.d:	obj->d.m = FALSE;
alloc.d:	  obj->ratio.num = OBJNULL;
alloc.d:	  obj->ratio.den = OBJNULL;
alloc.d:	  obj->complex.imag = OBJNULL;
alloc.d:	  obj->complex.real = OBJNULL;
alloc.d:	  obj->symbol.plist = OBJNULL;
alloc.d:	  obj->symbol.gfdef = OBJNULL;
alloc.d:	  obj->symbol.value = OBJNULL;
alloc.d:	  obj->symbol.name = OBJNULL;
alloc.d:	  obj->symbol.hpack = OBJNULL;
alloc.d:	  obj->pack.name = OBJNULL;
alloc.d:	  obj->pack.nicknames = OBJNULL;
alloc.d:	  obj->pack.shadowings = OBJNULL;
alloc.d:	  obj->pack.uses = OBJNULL;
alloc.d:	  obj->pack.usedby = OBJNULL;
alloc.d:	  obj->pack.internal = OBJNULL;
alloc.d:	  obj->pack.external = OBJNULL;
alloc.d:	  obj->cons.car = OBJNULL;
alloc.d:	  obj->cons.cdr = OBJNULL;
alloc.d:	  obj->hash.rehash_size = OBJNULL;
alloc.d:	  obj->hash.threshold = OBJNULL;
alloc.d:	  obj->hash.data = NULL;
alloc.d:	  obj->array.dims = NULL;
alloc.d:	  obj->array.displaced = ECL_NIL;
alloc.d:	  obj->array.elttype = (short)ecl_aet_object;
alloc.d:	  obj->array.self.t = NULL;
alloc.d:	  obj->array.displaced = ECL_NIL;
alloc.d:	  obj->array.elttype = (short)ecl_aet_object;
alloc.d:	  obj->array.self.t = NULL;
alloc.d:	  obj->base_string.displaced = ECL_NIL;
alloc.d:	  obj->base_string.self = NULL;
alloc.d:	  obj->vector.displaced = ECL_NIL;
alloc.d:	  obj->vector.self.bit = NULL;
alloc.d:	  obj->str.name = OBJNULL;
alloc.d:	  obj->str.self = NULL;
alloc.d:	  obj->stream.mode = (short)ecl_smm_broadcast;
alloc.d:	  obj->stream.file.descriptor = -1;
alloc.d:	  obj->stream.object0 = OBJNULL;
alloc.d:	  obj->stream.object1 = OBJNULL;
alloc.d:	  obj->stream.buffer = NULL;
alloc.d:	  obj->readtable.table = NULL;
alloc.d:	  obj->pathname.host = OBJNULL;
alloc.d:	  obj->pathname.device = OBJNULL;
alloc.d:	  obj->pathname.directory = OBJNULL;
alloc.d:	  obj->pathname.name = OBJNULL;
alloc.d:	  obj->pathname.type = OBJNULL;
alloc.d:	  obj->pathname.version = OBJNULL;
alloc.d:	  obj->bytecodes.lex = ECL_NIL;
alloc.d:	  obj->bytecodes.name = ECL_NIL;
alloc.d:	  obj->bytecodes.definition = ECL_NIL;
alloc.d:	  obj->bytecodes.specials = ECL_NIL;
alloc.d:	  obj->bytecodes.code_size = 0;
alloc.d:	  obj->bytecodes.code = NULL;
alloc.d:	  obj->bytecodes.data = NULL;
alloc.d:	  obj->bclosure.code =
alloc.d:	  obj->bclosure.lex = ECL_NIL;
alloc.d:	  obj->cfun.name = OBJNULL;
alloc.d:	  obj->cfun.block = NULL;
alloc.d:	  obj->cclosure.env = OBJNULL;
alloc.d:	  obj->cclosure.block = NULL;
alloc.d:	  obj->process.name = OBJNULL;
alloc.d:	  obj->process.function = OBJNULL;
alloc.d:	  obj->process.args = OBJNULL;
alloc.d:	  obj->process.env = NULL;
alloc.d:	  obj->process.interrupt = OBJNULL;
alloc.d:	  obj->lock.mutex = OBJNULL;
alloc.d:	  obj->condition_variable.cv = OBJNULL;
alloc.d:          obj->semaphore.handle = NULL;
alloc.d:	  obj->instance.length = 0;
alloc.d:	  obj->instance.sig = ECL_NIL;
alloc.d:	  obj->instance.isgf = 0;
alloc.d:	  obj->instance.slots = NULL;
alloc.d:	  obj->cblock.locked = 0;
alloc.d:	  obj->cblock.name = ECL_NIL;
alloc.d:	  obj->cblock.handle = NULL;
alloc.d:	  obj->cblock.entry = NULL;
alloc.d:	  obj->cblock.data = NULL;
alloc.d:	  obj->cblock.data_size = 0;
alloc.d:	  obj->cblock.data_text = NULL;
alloc.d:	  obj->cblock.data_text_size = 0;
alloc.d:	  obj->cblock.links = ECL_NIL;
alloc.d:	  obj->cblock.next = ECL_NIL;
alloc.d:	  obj->foreign.tag = ECL_NIL;
alloc.d:	  obj->foreign.size = 0;
alloc.d:	  obj->foreign.data = NULL;
alloc.d:	ecl_gc(tm->tm_type);
alloc.d:	if (tm->tm_nfree != 0 &&
alloc.d:		(float)tm->tm_nfree * 10.0 >= (float)tm->tm_nused)
alloc.d:		if (tm->tm_maxpage/2 <= 0)
alloc.d:			tm->tm_maxpage += 1;
alloc.d:			tm->tm_maxpage += tm->tm_maxpage/2;
alloc.d:	{ cl_object s = ecl_make_simple_base_string(tm_table[(int)t].tm_name+1, -1);
alloc.d:		2, s, MAKE_FIXNUM(tm->tm_npage));
alloc.d:	obj = tm->tm_free;
alloc.d:		if (tm->tm_npage >= tm->tm_maxpage)
alloc.d:		obj = tm->tm_free;
alloc.d:		if (tm->tm_npage >= tm->tm_maxpage)
alloc.d:	tm->tm_free = ((struct freelist *)obj)->f_link;
alloc.d:	--(tm->tm_nfree);
alloc.d:	(tm->tm_nused)++;
alloc.d:	obj->d.t = (short)t_cons;
alloc.d:	obj->d.m = FALSE;
alloc.d:	obj->cons.car = a;
alloc.d:	obj->cons.cdr = d;
alloc.d:	if ((tm->tm_nfree != 0) && (tm->tm_nfree * 10.0 >= tm->tm_nused))
alloc.d:		if (tm->tm_maxpage/2 <= 0)
alloc.d:			tm->tm_maxpage += 1;
alloc.d:			tm->tm_maxpage += tm->tm_maxpage/2;
alloc.d:		1, MAKE_FIXNUM(tm->tm_npage));
alloc.d:	i->instance.slots = (cl_object*)ecl_alloc(sizeof(cl_object) * slots);
alloc.d:	i->instance.length = slots;
alloc.d:	for (cbpp = &cb_pointer; (*cbpp) != NULL; cbpp = &(*cbpp)->cb_link) 
alloc.d:		if ((*cbpp)->cb_size >= n) {
alloc.d:			i = (*cbpp)->cb_size - n;
alloc.d:			*cbpp = (*cbpp)->cb_link;
alloc.d:			--ncb;
alloc.d:Use ALLOCATE-CONTIGUOUS-PAGES to expand the space.",
alloc.d:	cl_dealloc(p+n, LISP_PAGESIZE*m - n);
alloc.d:	cbp->cb_size = s;
alloc.d:	for (cbpp = &cb_pointer; *cbpp != NULL; cbpp = &((*cbpp)->cb_link))
alloc.d:		if ((*cbpp)->cb_size >= s) {
alloc.d:			cbp->cb_link = *cbpp;
alloc.d:	cbp->cb_link = NULL;
alloc.d:	align--;
alloc.d:	  output = (void*)(((cl_index)ecl_alloc(size + align) + align - 1) & ~align);
alloc.d:	tm->tm_name = name;
alloc.d:	for (i = (int)t_start, j = i-1;  i < (int)t_end;  i++)
alloc.d:		tm->tm_type = (cl_type)j;
alloc.d:	tm->tm_type = t;
alloc.d:	tm->tm_size = round_up(elsize);
alloc.d:	tm->tm_nppage = LISP_PAGESIZE/round_up(elsize);
alloc.d:	tm->tm_free = OBJNULL;
alloc.d:	tm->tm_nfree = 0;
alloc.d:	tm->tm_nused = 0;
alloc.d:	tm->tm_npage = 0;
alloc.d:	tm->tm_maxpage = maxpage;
alloc.d:	tm->tm_gccount = 0;
alloc.d:	  sbrk(LISP_PAGESIZE - i);
alloc.d:	init_tm(t_singlefloat, "FSINGLE-FLOAT", /* 8 */
alloc.d:	init_tm(t_doublefloat, "LDOUBLE-FLOAT", /* 16 */
alloc.d:	init_tm(t_base_string, "\"BASE-STRING", sizeof(struct ecl_base_string), 64); /* 20 */
alloc.d:	init_tm(t_hashtable, "hHASH-TABLE", sizeof(struct ecl_hashtable), 1);
alloc.d:	init_tm(t_bitvector, "bBIT-VECTOR", sizeof(struct ecl_vector), 1);
alloc.d:	init_tm(t_random, "$RANDOM-STATE", sizeof(struct ecl_random), 1);
alloc.d:	init_tm(t_condition_variable, "tCONDITION-VARIABLE",
alloc.d:     if (tm->tm_name &&
alloc.d:	 strncmp((tm->tm_name)+1, type->base_string.self, type->base_string.fillp) == 0)
alloc.d:	if (tm->tm_npage > i) i = tm->tm_npage;
alloc.d:	tm->tm_maxpage = i;
alloc.d:	if (now == ECL_NIL || tm->tm_maxpage <= tm->tm_npage)
alloc.d:	if (available_pages() < tm->tm_maxpage - tm->tm_npage ||
alloc.d:	    (pp = alloc_page(tm->tm_maxpage - tm->tm_npage)) == NULL)
alloc.d:		  make_constant_base_string(tm->tm_name+1));
alloc.d:	for (;  tm->tm_npage < tm->tm_maxpage;  pp += LISP_PAGESIZE)
alloc.d:@(defun si::maximum-allocatable-pages (type)
alloc.d:	@(return MAKE_FIXNUM(tm_of(t_from_type(type))->tm_maxpage))
alloc.d:@(defun si::allocated-pages (type)
alloc.d:	@(return MAKE_FIXNUM(tm_of(t_from_type(type))->tm_npage))
alloc.d:@(defun si::allocate-contiguous-pages (qty &optional (now ECL_NIL))
alloc.d:	m = maxcbpage - ncbpage;
alloc.d:@(defun si::allocated-contiguous-pages ()
alloc.d:@(defun si::maximum-contiguous-pages ()
alloc.d:@(defun si::get-hole-size ()
alloc.d:@(defun si::set-hole-size (size)
alloc.d:@(defun si::ignore-maximum-pages (&optional (flag OBJNULL))
alloc.d:  x = alloc_simple_base_string(size-1);
alloc.d:  x->base_string.self = (char *)ecl_alloc(size);
alloc.d:  return(x->base_string.self);
alloc.d:      if ((CAR((*p)))->base_string.self == ptr) {
alloc.d:	cl_dealloc(CAR((*p))->base_string.self, CAR((*p))->base_string.dim+1);
alloc.d:	CAR((*p))->base_string.self = NULL;
alloc.d:    if (CAR(x)->base_string.self == ptr) {
alloc.d:      if (x->base_string.dim >= size) {
alloc.d:	x->base_string.fillp = size;
alloc.d:	j = x->base_string.dim;
alloc.d:	x->base_string.self = (char *)ecl_alloc(size);
alloc.d:	x->base_string.fillp = x->base_string.dim = size;
alloc.d:	memcpy(x->base_string.self, ptr, j);
alloc.d:	return(x->base_string.self);
alloc.d:	   ((align) * (((unsigned)(f)(size + (size ? (align) - 1 : 0)) + (align) - 1)/(align))))
alloc.d:  return x->base_string.self;
alloc_2.d:/* -*- mode: c; c-basic-offset: 8 -*- */
alloc_2.d:    alloc_2.c -- Memory allocation based on the Boehmn GC.
alloc_2.d:#include <ecl/ecl-inl.h>
alloc_2.d:        int interrupts = the_env->disable_interrupts;
alloc_2.d:	the_env->string_pool = ECL_NIL;
alloc_2.d:                        the_env->string_pool = ECL_NIL;
alloc_2.d:        case 0:	cl_error(1, @'ext::storage-exhausted');
alloc_2.d:                          @'ext::storage-exhausted');
alloc_2.d:        op = GC_MALLOC_ATOMIC(type_info->size);
alloc_2.d:        op->d.t = type_info->t;
alloc_2.d:        op = GC_MALLOC(type_info->size);
alloc_2.d:        op->d.t = type_info->t;
alloc_2.d:        op = GC_malloc_explicitly_typed(type_info->size, type_info->descriptor);
alloc_2.d:        op->d.t = type_info->t;
alloc_2.d:#define TYPD_EXTRA_BYTES (sizeof(word) - EXTRA_BYTES)
alloc_2.d:	lb = type_info->size + TYPD_EXTRA_BYTES;
alloc_2.d:        ((word *)op)[GRANULES_TO_WORDS(lg) - 1] = type_info->descriptor;
alloc_2.d:        ((cl_object)op)->d.t = type_info->t;
alloc_2.d:	cl_type t = ((cl_object)addr)->d.t;
alloc_2.d:		GC_word d = info->descriptor;
alloc_2.d:	switch (o->d.t) {
alloc_2.d:                MAYBE_MARK(o->ratio.num);
alloc_2.d:                MAYBE_MARK(o->ratio.den);
alloc_2.d:                MAYBE_MARK(o->complex.real);
alloc_2.d:                MAYBE_MARK(o->complex.imag);
alloc_2.d:                MAYBE_MARK(o->symbol.hpack);
alloc_2.d:                MAYBE_MARK(o->symbol.name);
alloc_2.d:                MAYBE_MARK(o->symbol.plist);
alloc_2.d:                MAYBE_MARK(o->symbol.gfdef);
alloc_2.d:                MAYBE_MARK(o->symbol.value);
alloc_2.d:                MAYBE_MARK(o->pack.external);
alloc_2.d:                MAYBE_MARK(o->pack.internal);
alloc_2.d:                MAYBE_MARK(o->pack.usedby);
alloc_2.d:                MAYBE_MARK(o->pack.uses);
alloc_2.d:                MAYBE_MARK(o->pack.shadowings);
alloc_2.d:                MAYBE_MARK(o->pack.nicknames);
alloc_2.d:                MAYBE_MARK(o->pack.name);
alloc_2.d:                MAYBE_MARK(o->hash.threshold);
alloc_2.d:                MAYBE_MARK(o->hash.rehash_size);
alloc_2.d:                MAYBE_MARK(o->hash.data);
alloc_2.d:                MAYBE_MARK(o->array.dims);
alloc_2.d:                MAYBE_MARK(o->vector.self.t);
alloc_2.d:                MAYBE_MARK(o->vector.displaced);
alloc_2.d:                MAYBE_MARK(o->stream.format_table);
alloc_2.d:                MAYBE_MARK(o->stream.format);
alloc_2.d:                MAYBE_MARK(o->stream.buffer);
alloc_2.d:                MAYBE_MARK(o->stream.byte_stack);
alloc_2.d:                MAYBE_MARK(o->stream.object1);
alloc_2.d:                MAYBE_MARK(o->stream.object0);
alloc_2.d:                MAYBE_MARK(o->stream.ops);
alloc_2.d:                MAYBE_MARK(o->random.value);
alloc_2.d:                MAYBE_MARK(o->readtable.hash);
alloc_2.d:                MAYBE_MARK(o->readtable.table);
alloc_2.d:                MAYBE_MARK(o->pathname.version);
alloc_2.d:                MAYBE_MARK(o->pathname.type);
alloc_2.d:                MAYBE_MARK(o->pathname.name);
alloc_2.d:                MAYBE_MARK(o->pathname.directory);
alloc_2.d:                MAYBE_MARK(o->pathname.device);
alloc_2.d:                MAYBE_MARK(o->pathname.host);
alloc_2.d:                MAYBE_MARK(o->bytecodes.file_position);
alloc_2.d:                MAYBE_MARK(o->bytecodes.file);
alloc_2.d:                MAYBE_MARK(o->bytecodes.data);
alloc_2.d:                MAYBE_MARK(o->bytecodes.code);
alloc_2.d:                MAYBE_MARK(o->bytecodes.definition);
alloc_2.d:                MAYBE_MARK(o->bytecodes.name);
alloc_2.d:                MAYBE_MARK(o->bclosure.lex);
alloc_2.d:                MAYBE_MARK(o->bclosure.code);
alloc_2.d:                MAYBE_MARK(o->cfun.file_position);
alloc_2.d:                MAYBE_MARK(o->cfun.file);
alloc_2.d:                MAYBE_MARK(o->cfun.block);
alloc_2.d:                MAYBE_MARK(o->cfun.name);
alloc_2.d:                MAYBE_MARK(o->cfunfixed.file_position);
alloc_2.d:                MAYBE_MARK(o->cfunfixed.file);
alloc_2.d:                MAYBE_MARK(o->cfunfixed.block);
alloc_2.d:                MAYBE_MARK(o->cfunfixed.name);
alloc_2.d:                MAYBE_MARK(o->cclosure.file_position);
alloc_2.d:                MAYBE_MARK(o->cclosure.file);
alloc_2.d:                MAYBE_MARK(o->cclosure.block);
alloc_2.d:                MAYBE_MARK(o->cclosure.env);
alloc_2.d:                MAYBE_MARK(o->structure.name);
alloc_2.d:                MAYBE_MARK(o->structure.self);
alloc_2.d:                MAYBE_MARK(o->instance.slots);
alloc_2.d:                MAYBE_MARK(o->instance.sig);
alloc_2.d:                MAYBE_MARK(o->instance.clas);
alloc_2.d:                MAYBE_MARK(o->process.queue_record);
alloc_2.d:                MAYBE_MARK(o->process.start_spinlock);
alloc_2.d:                MAYBE_MARK(o->process.woken_up);
alloc_2.d:                MAYBE_MARK(o->process.exit_values);
alloc_2.d:                MAYBE_MARK(o->process.exit_barrier);
alloc_2.d:                MAYBE_MARK(o->process.parent);
alloc_2.d:                MAYBE_MARK(o->process.initial_bindings);
alloc_2.d:                MAYBE_MARK(o->process.interrupt);
alloc_2.d:                MAYBE_MARK(o->process.args);
alloc_2.d:                MAYBE_MARK(o->process.function);
alloc_2.d:                MAYBE_MARK(o->process.name);
alloc_2.d:                if (o->process.env && o->process.env != ECL_NIL)
alloc_2.d:                        ecl_mark_env(o->process.env);
alloc_2.d:                MAYBE_MARK(o->lock.queue_list);
alloc_2.d:                MAYBE_MARK(o->lock.queue_spinlock);
alloc_2.d:                MAYBE_MARK(o->lock.owner);
alloc_2.d:                MAYBE_MARK(o->lock.name);
alloc_2.d:                MAYBE_MARK(o->condition_variable.queue_spinlock);
alloc_2.d:                MAYBE_MARK(o->condition_variable.queue_list);
alloc_2.d:                MAYBE_MARK(o->condition_variable.lock);
alloc_2.d:		MAYBE_MARK(o->rwlock.name);
alloc_2.d:		MAYBE_MARK(o->rwlock.mutex);
alloc_2.d:                MAYBE_MARK(o->semaphore.queue_list);
alloc_2.d:                MAYBE_MARK(o->semaphore.queue_spinlock);
alloc_2.d:                MAYBE_MARK(o->semaphore.name);
alloc_2.d:                MAYBE_MARK(o->barrier.queue_list);
alloc_2.d:                MAYBE_MARK(o->barrier.queue_spinlock);
alloc_2.d:                MAYBE_MARK(o->barrier.name);
alloc_2.d:                MAYBE_MARK(o->mailbox.data);
alloc_2.d:		MAYBE_MARK(o->mailbox.name);
alloc_2.d:		MAYBE_MARK(o->mailbox.reader_semaphore);
alloc_2.d:		MAYBE_MARK(o->mailbox.writer_semaphore);
alloc_2.d:                MAYBE_MARK(o->cblock.error);
alloc_2.d:                MAYBE_MARK(o->cblock.source);
alloc_2.d:                MAYBE_MARK(o->cblock.links);
alloc_2.d:                MAYBE_MARK(o->cblock.name);
alloc_2.d:                MAYBE_MARK(o->cblock.next);
alloc_2.d:                MAYBE_MARK(o->cblock.temp_data);
alloc_2.d:                MAYBE_MARK(o->cblock.data);
alloc_2.d:                MAYBE_MARK(o->foreign.tag);
alloc_2.d:                MAYBE_MARK(o->foreign.data);
alloc_2.d:                MAYBE_MARK(o->frame.env);
alloc_2.d:                MAYBE_MARK(o->frame.base);
alloc_2.d:                MAYBE_MARK(o->frame.stack);
alloc_2.d:        op = GC_generic_malloc(type_info->size, cl_object_kind);
alloc_2.d:        op->d.t = type_info->t;
alloc_2.d:                return ti->allocator(ti);
alloc_2.d:                obj->d.t = t;
alloc_2.d:                obj->d.t = t;
alloc_2.d:        x->array.t = t;
alloc_2.d:        x->array.displaced = (void*)(((char*)x) + size);
alloc_2.d:	obj->car = a;
alloc_2.d:	obj->cdr = d;
alloc_2.d:	obj->t = t_list;
alloc_2.d:	obj->car = a;
alloc_2.d:	obj->cdr = d;
alloc_2.d:	obj->car = a;
alloc_2.d:	obj->cdr = ECL_NIL;
alloc_2.d:	obj->t = t_list;
alloc_2.d:	obj->car = a;
alloc_2.d:	obj->cdr = ECL_NIL;
alloc_2.d:	i->instance.slots = (cl_object *)ecl_alloc(sizeof(cl_object) * slots);
alloc_2.d:	i->instance.length = slots;
alloc_2.d:        i->instance.entry = FEnot_funcallable_vararg;
alloc_2.d:        i->instance.sig = ECL_UNBOUND;
alloc_2.d:        cl_index n = (char*)y - (char*)x;
alloc_2.d:                                           (((word)WORDS_TO_BYTES(-1)) | GC_DS_PER_OBJECT),
alloc_2.d:	init_tm(t_singlefloat, "SINGLE-FLOAT", sizeof(struct ecl_singlefloat), 0);
alloc_2.d:	init_tm(t_doublefloat, "DOUBLE-FLOAT", sizeof(struct ecl_doublefloat), 0);
alloc_2.d:	init_tm(t_longfloat, "LONG-FLOAT", sizeof(struct ecl_long_float), 0);
alloc_2.d:	init_tm(t_package, "PACKAGE", sizeof(struct ecl_package), -1); /* 36 */
alloc_2.d:	init_tm(t_hashtable, "HASH-TABLE", sizeof(struct ecl_hashtable), 3);
alloc_2.d:	init_tm(t_hashtable, "HASH-TABLE", sizeof(struct ecl_hashtable), 4);
alloc_2.d:	init_tm(t_base_string, "BASE-STRING", sizeof(struct ecl_base_string), 2);
alloc_2.d:	init_tm(t_bitvector, "BIT-VECTOR", sizeof(struct ecl_vector), 2);
alloc_2.d:	init_tm(t_random, "RANDOM-STATE", sizeof(struct ecl_random), -1);
alloc_2.d:	init_tm(t_pathname, "PATHNAME", sizeof(struct ecl_pathname), -1);
alloc_2.d:	init_tm(t_bytecodes, "BYTECODES", sizeof(struct ecl_bytecodes), -1);
alloc_2.d:	init_tm(t_cfun, "CFUN", sizeof(struct ecl_cfun), -1);
alloc_2.d:	init_tm(t_cfunfixed, "CFUNFIXED", sizeof(struct ecl_cfunfixed), -1);
alloc_2.d:	init_tm(t_cclosure, "CCLOSURE", sizeof(struct ecl_cclosure), -1);
alloc_2.d:	init_tm(t_condition_variable, "CONDITION-VARIABLE",
alloc_2.d:	init_tm(t_codeblock, "CODEBLOCK", sizeof(struct ecl_codeblock), -1);
alloc_2.d:	init_tm(t_frame, "STACK-FRAME", sizeof(struct ecl_stack_frame), 2);
alloc_2.d:	init_tm(t_weak_pointer, "WEAK-POINTER", sizeof(struct ecl_weak_pointer), 0);
alloc_2.d:	init_tm(t_sse_pack, "SSE-PACK", sizeof(struct ecl_sse_pack), 0);
alloc_2.d:                        GC_word mask = (1 << (bits-1)) - 1;
alloc_2.d:	switch (o->d.t) {
alloc_2.d:		GC_unregister_disappearing_link((void**)&(o->weak.value));
alloc_2.d:		pthread_rwlock_destroy(&o->rwlock.mutex);
alloc_2.d:				ecl_make_fixnum(o->symbol.binding));
alloc_2.d:		mpz_init2(cl_core.bytes_consed->big.big_num, 128);
alloc_2.d:		mpz_init2(cl_core.gc_counter->big.big_num, 128);
alloc_2.d:                mpz_set_ui(cl_core.bytes_consed->big.big_num, 0);
alloc_2.d:                mpz_set_ui(cl_core.gc_counter->big.big_num, 0);
alloc_2.d:		mpz_add_ui(cl_core.bytes_consed->big.big_num,
alloc_2.d:			   cl_core.bytes_consed->big.big_num,
alloc_2.d:			wrapped = ~((cl_index)0) - bytes;
alloc_2.d:			mpz_add_ui(cl_core.bytes_consed->big.big_num,
alloc_2.d:				   cl_core.bytes_consed->big.big_num,
alloc_2.d:		mpz_add_ui(cl_core.bytes_consed->big.big_num,
alloc_2.d:			   cl_core.bytes_consed->big.big_num,
alloc_2.d:			   new_bytes - bytes);
alloc_2.d:		mpz_add_ui(cl_core.gc_counter->big.big_num,
alloc_2.d:			   cl_core.gc_counter->big.big_num,
alloc_2.d:	if (env->stack) {
alloc_2.d:		GC_push_conditional((void *)env->stack, (void *)env->stack_top, 1);
alloc_2.d:		GC_set_mark_bit((void *)env->stack);
alloc_2.d:	if (env->frs_top) {
alloc_2.d:		GC_push_conditional((void *)env->frs_org, (void *)(env->frs_top+1), 1);
alloc_2.d:		GC_set_mark_bit((void *)env->frs_org);
alloc_2.d:	if (env->bds_top) {
alloc_2.d:		GC_push_conditional((void *)env->bds_org, (void *)(env->bds_top+1), 1);
alloc_2.d:		GC_set_mark_bit((void *)env->bds_org);
alloc_2.d:	/*memset(env->values[env->nvalues], 0, (64-env->nvalues)*sizeof(cl_object));*/
alloc_2.d:			if (dll->cblock.locked) {
alloc_2.d:				GC_push_conditional((void *)dll, (void *)(&dll->cblock + 1), 1);
alloc_2.d:		for (i = 0, size = l->vector.dim; i < size; i++) {
alloc_2.d:			cl_object process = l->vector.self.t[i];
alloc_2.d:				cl_env_ptr env = process->process.env;
alloc_2.d:	obj->t = t_weak_pointer;
alloc_2.d:	obj->value = o;
alloc_2.d:                GC_general_register_disappearing_link((void**)&(obj->value), (void*)o);
alloc_2.d:	return o->weak.value;
alloc_2.d:		FEwrong_type_only_arg(@[ext::weak-pointer-value], o,
alloc_2.d:                                      @[ext::weak-pointer]);
apply.d:/* -*- mode: c; c-basic-offset: 8 -*- */
apply.d:    nlogd(">>FUCK APPLY-fixed n:%d", n);
apply.d:            // nlogd("x:%d", (*x)->d.t);
apply.d:            nlogd("0:%d", x[0]->d.t);
apply.d:                    cl_object name = x[0]->symbol.name;
apply.d:                    nlogd(">>namet(%d)", name->d.t);
apply.d:                    nlogd(">>namedisplay(%s)", name->base_string.self);
apply.d:            nlogd("1:%d", x[1]->d.t);
apply.d:            nlogd("2:%d", x[2]->d.t);
apply.d.gen.pl:/* -*- mode: c; c-basic-offset: 8 -*- */
apply.d.gen.pl:    nlogd(">>FUCK APPLY-fixed n:%d", n);
apply.d.org.c:/* -*- mode: c; c-basic-offset: 8 -*- */
apply.d.org.c:    apply.c -- Interface to C call mechanism.
array.d:/* -*- mode: c; c-basic-offset: 8 -*- */
array.d:    array.c --  Array routines
array.d:        @'single-float',      /* ecl_aet_sf */
array.d:        @'double-float',      /* ecl_aet_df */
array.d:        @'ext::cl-fixnum',    /* ecl_aet_fix */
array.d:        @'ext::cl-index',     /* ecl_aet_index */
array.d:        @'base-char'          /* ecl_aet_bc */
array.d:                                 ecl_make_fixnum(x->array.dim));
array.d:                                      @':initial-element', @'*');
array.d:	cl_index r = narg - 1;
array.d:		if (r != x->array.rank)
array.d:                                                   x->array.dims[i]);
array.d:			j = j*(x->array.dims[i]) + s;
array.d:		j = checked_index(@[aref], x, -1, ecl_va_arg(indx), x->vector.dim);
array.d:	switch (x->array.elttype) {
array.d:		return x->array.self.t[index];
array.d:		return ECL_CODE_CHAR(x->base_string.self[index]);
array.d:                return ECL_CODE_CHAR(x->string.self[index]);
array.d:		index += x->vector.offset;
array.d:		if (x->vector.self.bit[index/CHAR_BIT] & (0200>>index%CHAR_BIT))
array.d:		return ecl_make_integer(x->array.self.fix[index]);
array.d:		return ecl_make_unsigned_integer(x->array.self.index[index]);
array.d:		return(ecl_make_single_float(x->array.self.sf[index]));
array.d:		return(ecl_make_double_float(x->array.self.df[index]));
array.d:		return ecl_make_uint8_t(x->array.self.b8[index]);
array.d:		return ecl_make_int8_t(x->array.self.i8[index]);
array.d:		return ecl_make_uint16_t(x->array.self.b16[index]);
array.d:		return ecl_make_int16_t(x->array.self.i16[index]);
array.d:		return ecl_make_uint32_t(x->array.self.b32[index]);
array.d:		return ecl_make_int32_t(x->array.self.i32[index]);
array.d:		return ecl_make_uint64_t(x->array.self.b64[index]);
array.d:		return ecl_make_int64_t(x->array.self.i64[index]);
array.d:        if (ecl_unlikely(index >= x->array.dim)) {
array.d:                FEwrong_index(@[row-major-aref], x, -1, ecl_make_fixnum(index),
array.d:                              x->array.dim);
array.d:        if (ecl_unlikely(index >= x->array.dim)) {
array.d:                FEwrong_index(@[aref], x, -1, ecl_make_fixnum(index),
array.d:                              x->array.dim);
array.d:	elt_type = x->array.elttype;
array.d:        if (ecl_unlikely(bytes > 0 && offset + bytes > x->array.dim*elt_size)) {
array.d:                FEwrong_index(@[row-major-aref], x, -1, ecl_make_fixnum(index),
array.d:                              x->array.dim);
array.d:	return x->array.self.b8 + offset;
array.d:	cl_index r = narg - 2;
array.d:		if (ecl_unlikely(r != x->array.rank))
array.d:                                                   x->array.dims[i]);
array.d:			j = j*(x->array.dims[i]) + s;
array.d:		j = checked_index(@[si::aset], x, -1, ecl_va_arg(dims),
array.d:                                  x->vector.dim);
array.d:	switch (x->array.elttype) {
array.d:		x->array.self.t[index] = value;
array.d:		x->base_string.self[index] = ecl_char_code(value);
array.d:		x->string.self[index] = ecl_char_code(value);
array.d:		index += x->vector.offset;
array.d:			x->vector.self.bit[index/CHAR_BIT] &= ~(0200>>index%CHAR_BIT);
array.d:			x->vector.self.bit[index/CHAR_BIT] |= 0200>>index%CHAR_BIT;
array.d:		x->array.self.fix[index] = ecl_to_fix(value);
array.d:		x->array.self.index[index] = ecl_to_size(value);
array.d:		x->array.self.sf[index] = ecl_to_float(value);
array.d:		x->array.self.df[index] = ecl_to_double(value);
array.d:		x->array.self.b8[index] = ecl_to_uint8_t(value);
array.d:		x->array.self.i8[index] = ecl_to_int8_t(value);
array.d:		x->array.self.b16[index] = ecl_to_uint16_t(value);
array.d:		x->array.self.i16[index] = ecl_to_int16_t(value);
array.d:		x->array.self.b32[index] = ecl_to_uint32_t(value);
array.d:		x->array.self.i32[index] = ecl_to_int32_t(value);
array.d:		x->array.self.b64[index] = ecl_to_uint64_t(value);
array.d:		x->array.self.i64[index] = ecl_to_int64_t(value);
array.d:        if (ecl_unlikely(index >= x->array.dim)) {
array.d:        if (ecl_unlikely(index >= x->array.dim)) {
array.d:		(si:make-pure-array dimension-list element-type adjustable
array.d:			            displaced-to displaced-index-offset)
array.d:                FEwrong_type_nth_arg(@[make-array], 1, dims,
array.d:		FEerror(":FILL-POINTER may not be specified for an array of rank ~D",
array.d:	x->array.displaced = ECL_NIL;
array.d:	x->array.self.t = NULL;		/* for GC sake */
array.d:	x->array.rank = r;
array.d:	x->array.elttype = (short)ecl_symbol_to_elttype(etype);
array.d:	x->array.flags = 0; /* no fill pointer, no adjustable */
array.d:	x->array.dims = (cl_index *)ecl_alloc_atomic_align(sizeof(cl_index)*r, sizeof(cl_index));
array.d:                        FEwrong_type_nth_arg(@[make-array], 1, d, type);
array.d:		s *= (x->array.dims[i] = j);
array.d:                        FEwrong_type_key_arg(@[make-array], @[array-total-size],
array.d:	x->array.dim = s;
array.d:                x->array.flags |= ECL_FLAG_ADJUSTABLE;
array.d:		(si:make-vector element-type dimension adjustable fill-pointer
array.d:				displaced-to displaced-index-offset)
array.d:                FEwrong_type_nth_arg(@[make-array], 1, dim, type);
array.d:                x->base_string.elttype = (short)aet;
array.d:                x->vector.elttype = (short)aet;
array.d:                x->string.elttype = (short)aet;
array.d:		x->vector.elttype = (short)aet;
array.d:	x->vector.self.t = NULL;		/* for GC sake */
array.d:	x->vector.displaced = ECL_NIL;
array.d:	x->vector.dim = d;
array.d:        x->vector.flags = 0;
array.d:                x->vector.flags |= ECL_FLAG_ADJUSTABLE;
array.d:		x->vector.flags |= ECL_FLAG_HAS_FILL_POINTER;
array.d:		x->vector.flags |= ECL_FLAG_HAS_FILL_POINTER;
array.d:		fillp = ecl_type_error(@'make-array',"fill pointer",fillp,
array.d:	x->vector.fillp = f;
array.d:        for (i = 0; l--;)
array.d:        cl_elttype t = x->array.elttype;
array.d:	cl_index d = x->array.dim;
array.d:		x->array.self.t = alloc_pointerfull_memory(d);
array.d:                // x->vector.self.t = alloc_pointerfull_memory(d);
array.d:		x->string.self = elts;
array.d:		x->vector.self.bc = (ecl_base_char *)ecl_alloc_atomic(d+1);
array.d:		x->vector.self.bc[d] = 0;
array.d:                d = (d + (CHAR_BIT-1)) / CHAR_BIT;
array.d:                x->vector.self.bit = (byte *)ecl_alloc_atomic(d);
array.d:                x->vector.offset = 0;
array.d:                x->vector.self.bc = (ecl_base_char *)ecl_alloc_atomic_align(d, elt_size);
array.d:                x->base_string.self = ECL_COMPACT_OBJECT_EXTRA(x);
array.d:		x->base_string.self[l] = 0;
array.d:                x->string.self = ECL_COMPACT_OBJECT_EXTRA(x);
array.d:                cl_index bytes = (l + (CHAR_BIT-1))/CHAR_BIT;
array.d:                x->vector.self.bit = ECL_COMPACT_OBJECT_EXTRA(x);
array.d:		x->vector.offset = 0;
array.d:                x->vector.self.t = alloc_pointerfull_memory(l);
array.d:                x->vector.self.bc = ECL_COMPACT_OBJECT_EXTRA(x);
array.d:        x->base_string.elttype = aet;
array.d:        x->base_string.flags = 0; /* no fill pointer, not adjustable */
array.d:        x->base_string.displaced = ECL_NIL;
array.d:        x->base_string.dim = x->base_string.fillp = l;
array.d:	if (x == @'base-char')
array.d:	else if (x == @'ext::cl-fixnum')
array.d:	else if (x == @'ext::cl-index')
array.d:	else if (x == @'single-float' || x == @'short-float')
array.d:	else if (x == @'double-float')
array.d:	else if (x == @'long-float') {
array.d:                type->array.elttype :
array.d:	Displace(from, to, offset) displaces the from-array
array.d:	to the to-array (the original array) by the specified offset.
array.d:	The field is a cons; the car of the from-array points to
array.d:	the to-array and the cdr of the to-array is a list of arrays
array.d:	displaced to the to-array, so the from-array is pushed to the
array.d:	cdr of the to-array's array.displaced.
array.d:	fromtype = from->array.elttype;
array.d:                FEwrong_type_key_arg(@[adjust-array], @[:displaced-index-offset],
array.d:		base = to->foreign.data;
array.d:		from->array.displaced = to;
array.d:		totype = to->array.elttype;
array.d:                maxdim = to->array.dim - from->array.dim;
array.d:                                "because the total size of the to-array"
array.d:                        FEwrong_type_key_arg(@[adjust-array], @[:displaced-index-offset],
array.d:		from->array.displaced = ecl_list1(to);
array.d:			cl_object track_list = to->array.displaced;
array.d:				to->array.displaced =
array.d:			j += to->vector.offset;
array.d:			from->vector.offset = j%CHAR_BIT;
array.d:			from->vector.self.bit = to->vector.self.bit + j/CHAR_BIT;
array.d:		base = to->array.self.t;
array.d:	from->array.self.t = address_inc(base, j, fromtype);
array.d:        cl_index total_size = x->vector.dim * ecl_aet_size[et];
array.d:                FEerror("EXT:ARRAY-RAW-DATA can not get data "
array.d:        data = x->vector.self.b8;
array.d:        to_array = x->array.displaced;
array.d:			used_size = x->vector.fillp * ecl_aet_size[et];
array.d:                output->vector.elttype = ecl_aet_b8;
array.d:                output->vector.self.b8 = data;
array.d:                output->vector.dim = total_size;
array.d:		output->vector.fillp = used_size;
array.d:                output->vector.flags = flags;
array.d:                output->vector.displaced = ECL_NIL;
array.d:                cl_index displ = data - to_array->vector.self.b8;
array.d:			fillp = ecl_make_fixnum(x->vector.fillp * ecl_aet_size[et]);
array.d:        return x->array.elttype;
array.d:		return a->array.rank;
array.d:                FEwrong_type_only_arg(@[array-dimension], a, @[array]);
array.d:                if (ecl_unlikely(index > a->array.rank))
array.d:		return a->array.dims[index];
array.d:		return a->vector.dim;
array.d:                FEwrong_type_only_arg(@[array-dimension], a, @[array]);
array.d:                FEwrong_type_only_arg(@[array-total-size], a, @[array]);
array.d:	@(return ecl_make_fixnum(a->array.dim))
array.d:                FEwrong_type_only_arg(@[adjustable-array-p], a, @[array]);
array.d:                FEwrong_type_only_arg(@[array-displacement], a, @[array]);
array.d:	to_array = a->array.displaced;
array.d:	} else if (Null(to_array = CAR(a->array.displaced))) {
array.d:		switch (a->array.elttype) {
array.d:			offset = a->array.self.t - to_array->array.self.t;
array.d:			offset = a->array.self.bc - to_array->array.self.bc;
array.d:			offset = a->array.self.c - to_array->array.self.c;
array.d:			offset = a->array.self.bit - to_array->array.self.bit;
array.d:			offset = offset * CHAR_BIT + a->array.offset
array.d:				- to_array->array.offset;
array.d:			offset = a->array.self.fix - to_array->array.self.fix;
array.d:			offset = a->array.self.fix - to_array->array.self.fix;
array.d:			offset = a->array.self.sf - to_array->array.self.sf;
array.d:			offset = a->array.self.df - to_array->array.self.df;
array.d:			offset = a->array.self.b8 - to_array->array.self.b8;
array.d:			offset = a->array.self.b16 - to_array->array.self.b16;
array.d:			offset = a->array.self.b32 - to_array->array.self.b32;
array.d:			offset = a->array.self.b64 - to_array->array.self.b64;
array.d:                         (x->vector.flags & (ECL_FLAG_ADJUSTABLE | ECL_FLAG_HAS_FILL_POINTER)) ||
array.d:                         CAR(x->vector.displaced) != ECL_NIL ||
array.d:                         (cl_elttype)x->vector.elttype != ecl_aet_object))
array.d:                FEwrong_type_nth_arg(@[svref],1,x,@[simple-vector]);
array.d:        i = checked_index(@[svref], x, -1, index, x->vector.dim);
array.d:	ecl_return1(the_env, x->vector.self.t[i]);
array.d:                         (x->vector.flags & (ECL_FLAG_ADJUSTABLE | ECL_FLAG_HAS_FILL_POINTER)) ||
array.d:                         CAR(x->vector.displaced) != ECL_NIL ||
array.d:                         (cl_elttype)x->vector.elttype != ecl_aet_object))
array.d:		FEwrong_type_nth_arg(@[si::svset],1,x,@[simple-vector]);
array.d:        i = checked_index(@[svref], x, -1, index, x->vector.dim);
array.d:	ecl_return1(the_env, x->vector.self.t[i] = v);
array.d:                FEwrong_type_nth_arg(@[array-has-fill-pointer-p],1,a,@[array]);
array.d:                FEwrong_type_only_arg(@[fill-pointer], a, @[vector]);
array.d:                const char *type = "(AND VECTOR (SATISFIES ARRAY-HAS-FILL-POINTER-P))";
array.d:		FEwrong_type_nth_arg(@[fill-pointer], 1, a, ecl_read_from_cstring(type));
array.d:	ecl_return1(the_env, ecl_make_fixnum(a->vector.fillp));
array.d:                const char *type = "(AND VECTOR (SATISFIES ARRAY-HAS-FILL-POINTER-P))";
array.d:		FEwrong_type_nth_arg(@[adjust-array], 1, a,
array.d:                         (i > a->vector.dim))) {
array.d:                                                       ecl_make_fixnum(a->vector.dim-1));
array.d:                FEwrong_type_key_arg(@[adjust-array], @[:fill-pointer], fp, type);
array.d:        a->vector.fillp = i;
array.d:		(si:replace-array old-array new-array).
array.d:	Used in ADJUST-ARRAY.
array.d:	    || (ecl_t_of(olda) == t_array && olda->array.rank != newa->array.rank))
array.d:	for (dlist = CDR(olda->array.displaced); dlist != ECL_NIL; dlist = CDR(dlist)) {
array.d:		olda->array = newa->array;
array.d:		olda->base_string = newa->base_string;
array.d:	if (i0 + l > dest->array.dim) {
array.d:		l = dest->array.dim - i0;
array.d:	if (i1 + l > orig->array.dim) {
array.d:		l = orig->array.dim - i1;
array.d:                        for (i0 += l, i1 += l; l--; ) {
array.d:                                ecl_aset_unsafe(dest, --i0,
array.d:                                                ecl_aref_unsafe(orig, --i1));
array.d:                        while (l--) {
array.d:                 * but gcc-4.6 breaks this code even when i0 < i1 if the regions
array.d:                memmove(dest->array.self.bc + i0 * elt_size,
array.d:                        orig->array.self.bc + i1 * elt_size,
array.d:	if (x->array.dim == 0) {
array.d:	if (i1 >= x->array.dim) {
array.d:		i1 = x->array.dim;
array.d:		for (i = i0, j = i1-1;  i < j;  i++, --j) {
array.d:			cl_object y = x->vector.self.t[i];
array.d:			x->vector.self.t[i] = x->vector.self.t[j];
array.d:			x->vector.self.t[j] = y;
array.d:		for (i = i0, j = i1-1;  i < j;  i++, --j) {
array.d:			float y = x->array.self.sf[i];
array.d:			x->array.self.sf[i] = x->array.self.sf[j];
array.d:			x->array.self.sf[j] = y;
array.d:		for (i = i0, j = i1-1;  i < j;  i++, --j) {
array.d:			double y = x->array.self.df[i];
array.d:			x->array.self.df[i] = x->array.self.df[j];
array.d:			x->array.self.df[j] = y;
array.d:		for (i = i0, j = i1-1;  i < j;  i++, --j) {
array.d:			ecl_base_char y = x->array.self.bc[i];
array.d:			x->array.self.bc[i] = x->array.self.bc[j];
array.d:                        x->array.self.bc[j] = y;
array.d:		for (i = i0, j = i1-1;  i < j;  i++, --j) {
array.d:			ecl_uint8_t y = x->array.self.b8[i];
array.d:			x->array.self.b8[i] = x->array.self.b8[j];
array.d:			x->array.self.b8[j] = y;
array.d:		for (i = i0, j = i1-1;  i < j;  i++, --j) {
array.d:			ecl_uint16_t y = x->array.self.b16[i];
array.d:			x->array.self.b16[i] = x->array.self.b16[j];
array.d:			x->array.self.b16[j] = y;
array.d:		for (i = i0, j = i1-1;  i < j;  i++, --j) {
array.d:			ecl_uint32_t y = x->array.self.b32[i];
array.d:			x->array.self.b32[i] = x->array.self.b32[j];
array.d:			x->array.self.b32[j] = y;
array.d:		for (i = i0, j = i1-1;  i < j;  i++, --j) {
array.d:			ecl_uint64_t y = x->array.self.b64[i];
array.d:			x->array.self.b64[i] = x->array.self.b64[j];
array.d:			x->array.self.b64[j] = y;
array.d:		for (i = i0, j = i1-1;  i < j;  i++, --j) {
array.d:			ecl_character y = x->array.self.c[i];
array.d:			x->array.self.c[i] = x->array.self.c[j];
array.d:                        x->array.self.c[j] = y;
array.d:		for (i = i0 + x->vector.offset,
array.d:		     j = i1 + x->vector.offset - 1;
array.d:		     i++, --j) {
array.d:			int k = x->array.self.bit[i/CHAR_BIT]&(0200>>i%CHAR_BIT);
array.d:			if (x->array.self.bit[j/CHAR_BIT]&(0200>>j%CHAR_BIT))
array.d:				x->array.self.bit[i/CHAR_BIT]
array.d:				x->array.self.bit[i/CHAR_BIT]
array.d:				x->array.self.bit[j/CHAR_BIT]
array.d:				x->array.self.bit[j/CHAR_BIT]
array.d:        cl_index last = Null(end)? x->array.dim : ecl_to_size(end);
array.d:                cl_object *p = x->vector.self.t + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = elt; }
array.d:                ecl_base_char *p = x->vector.self.bc + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                ecl_character *p = x->vector.self.c + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                cl_fixnum *p = x->vector.self.fix + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                cl_index *p = x->vector.self.index + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                float *p = x->vector.self.sf + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                double *p = x->vector.self.df + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                uint8_t *p = x->vector.self.b8 + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                int8_t *p = x->vector.self.i8 + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                ecl_uint16_t *p = x->vector.self.b16 + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                ecl_int16_t *p = x->vector.self.i16 + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                ecl_uint32_t *p = x->vector.self.b32 + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                ecl_int32_t *p = x->vector.self.i32 + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                ecl_uint64_t *p = x->vector.self.b64 + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:                ecl_int64_t *p = x->vector.self.i64 + first;
array.d:		for (first = last - first; first; --first, ++p) { *p = e; }
array.d:		for (last -= first, first += x->vector.offset; last; --last, ++first) {
array.d:                                x->vector.self.bit[first/CHAR_BIT] &= ~mask;
array.d:                                x->vector.self.bit[first/CHAR_BIT] |= mask;
assignment.d:/* -*- mode: c; c-basic-offset: 8 -*- */
assignment.d:    assignment.c  -- Assignment.
assignment.d:	unlikely_if (var->symbol.stype & ecl_stp_constant)
assignment.d:        cl_object name = the_env->function->cclosure.env;
assignment.d:	if (pack != ECL_NIL && pack->pack.locked) {
assignment.d:			si_rem_sysprop(sym, @'si::pretty-print-format');
assignment.d:			si_put_sysprop(sym, @'si::pretty-print-format', pprint);
assignment.d:	if (pack != ECL_NIL && pack->pack.locked) {
assignment.d:		si_rem_sysprop(sym, @'si::setf-method');
assignment.d:		funcall(2, @'si::clear-compiler-properties', sym);
backq.d:/* -*- mode: c; c-basic-offset: 8 -*- */
backq.d:    backq.c -- Backquote mechanism.
backq.d:/******************************* ------- ******************************/
backq.d:	if (CAR(x) == @'si::unquote-splice' || CAR(x) == @'si::unquote-nsplice')
backq.d:	if (CAR(x) == @'si::unquote-splice') {
backq.d:	if (CAR(x) == @'si::unquote-nsplice') {
big.d:/* -*- mode: c; c-basic-offset: 8 -*- */
big.d:    big.c -- Bignum routines.
big.d:                mpz_realloc2(x->big.big_num, ECL_BIG_REGISTER_SIZE * GMP_LIMB_BITS);
big.d:        mpz_init2(new_big->big.big_num, limbs * GMP_LIMB_BITS);
big.d:        cl_index dim = (size < 0)? (-size) : size;
big.d:	} else if (s == -1) {
big.d:                if (y <= -MOST_NEGATIVE_FIXNUM)
big.d:                        return ecl_make_fixnum(-y);
big.d:	} else if (s == -1) {
big.d:                if (y <= -MOST_NEGATIVE_FIXNUM)
big.d:                        return ecl_make_fixnum(-y);
big.d:static const int limbs_per_fixnum = (FIXNUM_BITS + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;
big.d:	(ECL_BIGNUM_SIZE(x)<0? -ECL_BIGNUM_SIZE(x) : ECL_BIGNUM_SIZE(x))
big.d:        mpz_sub(z->big.big_num, a->big.big_num, b->big.big_num);
big.d:        mpz_sub(z->big.big_num, z->big.big_num, b->big.big_num);
big.d:        mpz_neg(z->big.big_num, a->big.big_num);
big.d:        cl_fixnum size_z = size_a - size_b + 1;
big.d:        mpz_tdiv_q(z->big.big_num,a->big.big_num,b->big.big_num);
big.d:        mpz_gcd(z->big.big_num, a->big.big_num, b->big.big_num);
big.d:        mpz_cdiv_qr(q->big.big_num, r->big.big_num, a->big.big_num, b->big.big_num);
big.d:        mpz_fdiv_qr(q->big.big_num, r->big.big_num, a->big.big_num, b->big.big_num);
big.d:                if (mpz_fits_slong_p(x->big.big_num)) {
big.d:                        return mpz_get_si(x->big.big_num);
big.d:                if (mpz_fits_ulong_p(x->big.big_num)) {
big.d:                        return mpz_get_ui(x->big.big_num);
big.d:        mpz_set_si((x)->big.big_num,(f));
big.d:        mpz_set_ui((x)->big.big_num,(f));
big.d:	return mpz_get_si((x)->big.big_num);
big.d:	return mpz_get_ui((x)->big.big_num);
big.d:                mpz_set_si(x->big.big_num, 0);
big.d:                ECL_BIGNUM_SIZE(x) = -1;
big.d:                ECL_BIGNUM_LIMBS(x)[0] = -f;
big.d:                mpz_set_si(x->big.big_num, 0);
big.d:	return (ECL_BIGNUM_SIZE(x) > 0) ? output : -output;
big.d:	return (ECL_BIGNUM_SIZE(x) > 0)? output : ~(output - 1);
big.d:        int i, l = mpz_size(o->big.big_num), exp = 0;
big.d:                output += ldexpl(mpz_getlimbn(o->big.big_num, i), exp);
big.d:        return (mpz_sgn(o->big.big_num) < 0)? -output : output;
big.d:	mpz_ior(out->big.big_num, i->big.big_num, j->big.big_num);
big.d:	mpz_xor(out->big.big_num, i->big.big_num, j->big.big_num);
big.d:	mpz_and(out->big.big_num, i->big.big_num, j->big.big_num);
big.d:	mpz_xor(out->big.big_num, i->big.big_num, j->big.big_num);
big.d:	mpz_com(out->big.big_num, out->big.big_num);
big.d:	mpz_and(out->big.big_num, i->big.big_num, j->big.big_num);
big.d:	mpz_com(out->big.big_num, out->big.big_num);
big.d:	mpz_ior(out->big.big_num, i->big.big_num, j->big.big_num);
big.d:	mpz_com(out->big.big_num, out->big.big_num);
big.d:	mpz_com(out->big.big_num, i->big.big_num);
big.d:	mpz_and(out->big.big_num, out->big.big_num, j->big.big_num);
big.d:	mpz_com(out->big.big_num, i->big.big_num);
big.d:	mpz_ior(out->big.big_num, out->big.big_num, j->big.big_num);
big.d:	mpz_com(out->big.big_num, out->big.big_num);
big.d:	mpz_com(out->big.big_num, out->big.big_num);
big.d:	mpz_set_si(out->big.big_num, 0);
big.d:	mpz_set_si(o->big.big_num, -1);
big.d:                mpz_set(out->big.big_num, i->big.big_num);
big.d:	mpz_set(out->big.big_num, j->big.big_num);
big.d:	mpz_com(out->big.big_num, i->big.big_num);
big.d:	mpz_com(out->big.big_num, j->big.big_num);
big_ll.d:/* -*- mode: c; c-basic-offset: 8 -*- */
big_ll.d:    big_ll.c -- Bignum emulation with long long.
big_ll.d:        new_big->big.big_num = old->big.big_num;
big_ll.d:	if (x->big.big_num == 0ll)
big_ll.d:        if (x->big.big_num <= MOST_POSITIVE_FIXNUM && x->big.big_num >= MOST_NEGATIVE_FIXNUM)
big_ll.d:                return(ecl_make_fixnum(x->big.big_num));
big_ll.d:	if (x->big.big_num == 0ll)
big_ll.d:        if (x->big.big_num <= MOST_POSITIVE_FIXNUM && x->big.big_num >= MOST_NEGATIVE_FIXNUM)
big_ll.d:                return(ecl_make_fixnum(x->big.big_num));
big_ll.d:	x->big.big_num = 0ll;
big_ll.d:        y->big.big_num = x->big.big_num;
big_ll.d:        big_num_t i = x->big.big_num, j = y->big.big_num;
big_ll.d:                        gcd->big.big_num = k;
big_ll.d:	return ( x == (big_num_t)0 ) ? 0 : (x < (big_num_t)0) ? -1 : 1;
big_ll.d:        z->big.big_num = x->big.big_num * y->big.big_num;
big_ll.d:        z->big.big_num = x->big.big_num * y;
big_ll.d:        z->big.big_num = x->big.big_num + y->big.big_num;
big_ll.d:        z->big.big_num = x->big.big_num + y;
big_ll.d:        z->big.big_num = x * y;
big_ll.d:        q->big.num = x->big.num / y->big.big_num;
big_ll.d:        r->big.num = x->big.num % y->big.big_num;
big_ll.d:        q->big.num = x->big.num / y->big.big_num;
big_ll.d:        r->big.num = x->big.num % y->big.big_num;
big_ll.d:        z->big.big_num = -x->big.big_num;
cfun.d:/* -*- mode: c; c-basic-offset: 8 -*- */
cfun.d:    cfun.c -- Compiled functions.
cfun.d:	cf->cfunfixed.entry = dispatch_table[narg];
cfun.d:	cf->cfunfixed.entry_fixed = c_function;
cfun.d:	cf->cfunfixed.name = name;
cfun.d:	cf->cfunfixed.block = cblock;
cfun.d:        cf->cfunfixed.file = ECL_NIL;
cfun.d:        cf->cfunfixed.file_position = ecl_make_fixnum(-1);
cfun.d:	cf->cfunfixed.narg = narg;
cfun.d:	cf->cfun.entry = c_function;
cfun.d:	cf->cfun.name = name;
cfun.d:	cf->cfun.block = cblock;
cfun.d:	cf->cfun.narg = -1;
cfun.d:        cf->cfun.file = ECL_NIL;
cfun.d:        cf->cfun.file_position = ecl_make_fixnum(-1);
cfun.d:	cc->cclosure.entry = c_function;
cfun.d:	cc->cclosure.env = env;
cfun.d:	cc->cclosure.block = block;
cfun.d:        cc->cclosure.file = ECL_NIL;
cfun.d:        cc->cclosure.file_position = ecl_make_fixnum(-1);
cfun.d:		fun = fun->bclosure.code;
cfun.d:		output = fun->bytecodes.name; break;
cfun.d:		output = fun->cfun.name; break;
cfun.d:		lex = fun->bclosure.lex;
cfun.d:		fun = fun->bclosure.code;
cfun.d:		name = fun->bytecodes.name;
cfun.d:		output = fun->bytecodes.definition;
cfun.d:		    output = @list*(3, @'ext::lambda-block', name, output);
cfun.d:		name = fun->cfun.name;
cfun.d:		if (fun->instance.isgf) {
cfun.d:	       output = fun->cfun.block; break;
cfun.d:	       output = fun->cfunfixed.block; break;
cfun.d:	       output = fun->cclosure.block; break;
cfun.d:                b = b->bclosure.code;
cfun.d:		ecl_return2(the_env, b->bytecodes.file, b->bytecodes.file_position);
cfun.d:		ecl_return2(the_env, b->cfun.file, b->cfun.file_position);
cfun.d:		ecl_return2(the_env, b->cfunfixed.file, b->cfunfixed.file_position);
cfun.d:		ecl_return2(the_env, b->cclosure.file, b->cclosure.file_position);
cfun.d:                b = b->bclosure.code;
cfun.d:                b->bytecodes.file = source;
cfun.d:                b->bytecodes.file_position = position;
cfun.d:                b->cfun.file = source;
cfun.d:                b->cfun.file_position = position;
cfun.d:                b->cfunfixed.file = source;
cfun.d:                b->cfunfixed.file_position = position;
cfun.d:                b->cclosure.file = source;
cfun.d:                b->cclosure.file_position = position;
cfun.d:	si_fset(3, fun->cfun.name, fun, ECL_T);
cfun.d:	si_fset(2, fun->cfun.name, fun);
cfun_dispatch.d:/* -*- mode: c; c-basic-offset: 8 -*- */
cfun_dispatch.d:    cfun_dispatch.c -- Trampolines for functions
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed();
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61);
cfun_dispatch.d:  cl_object fun = the_env->function;
cfun_dispatch.d:  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62);
char_ctype.d:/* -*- mode: c; c-basic-offset: 8 -*- */
char_ctype.d:    char_ctype.d -- Character properties.
char_ctype.d: * 21-bits Unicode (0 to #x110000 char codes)
char_ctype.d: * 16-bits Unicode (0 to #x110000 char codes)
character.d:/* -*- mode: c; c-basic-offset: 8 -*- */
character.d:    character.d -- Character routines.
character.d:                FEwrong_type_only_arg(@[char-code], c, @[character]);
character.d:	FEwrong_type_only_arg(@[char-code], c, @[base-char]);
character.d:	const ecl_base_char *text = (ecl_base_char*)s->base_string.self;
character.d:	for (i = 0, upcase = 0; i <= s->base_string.dim; i++) {
character.d:			upcase = -1;
character.d:                FEwrong_type_nth_arg(@[digit-char-p], 2, radix,
character.d:	If i is not a digit, -1 is returned.
character.d:		return i - '0';
character.d:	if (('A' <= i) && (10 < r) && (i < 'A' + (r - 10)))
character.d:		return i - 'A' + 10;
character.d:	if (('a' <= i) && (10 < r) && (i < 'a' + (r - 10)))
character.d:		return i - 'a' + 10;
character.d:	return -1;
character.d:	while (--narg)
character.d:	for (; --narg; c = d) {
character.d:	return ecl_char_code(x) - ecl_char_code(y);
character.d:	return Lchar_cmp(the_env, narg,-1, 1, args);
character.d:	return Lchar_cmp(the_env, narg,-1, 0, args);
character.d:	for (narg--, i = 0;  i < narg;  i++) {
character.d:@(defun char-not-equal (&rest cs)
character.d:		FEwrong_num_arguments(@[char-not-equal]);
character.d:	for (; --narg; c = d) {
character.d:		return(-1);
character.d:@(defun char-lessp (&rest args)
character.d:@(defun char-greaterp (&rest args)
character.d:	return Lchar_compare(the_env, narg,-1, 1, args);
character.d:@(defun char-not-greaterp (&rest args)
character.d:@(defun char-not-lessp (&rest args)
character.d:	return Lchar_compare(the_env, narg,-1, 0, args);
character.d:		return cl_character(x->symbol.name);
character.d:		if (x->string.fillp == 1) {
character.d:			x = ECL_CODE_CHAR(x->string.self[0]);
character.d:		if (x->base_string.fillp == 1) {
character.d:			x = ECL_CODE_CHAR(x->base_string.self[0]);
character.d:                FEwrong_type_nth_arg(@[character], 1, x, ecl_read_from_cstring("(OR CHARACTER SYMBOL (ARRAY CHARACTER (1)) (ARRAY BASE-CHAR (1)))"));
character.d:                FEwrong_type_only_arg(@[code-char], c, @[integer]);
character.d:                FEwrong_type_nth_arg(@[digit-char], 2, radix,
character.d:                FEwrong_type_nth_arg(@[digit-char],1,weight,@[integer]);
character.d:		return(-1);
character.d:		return(w - 10 + 'A');
character.d:			cl_index end = name->base_string.fillp;
character.d:			if (!ECL_FIXNUMP(c) || (used_l == (l - 1))) {
cinit.d:/* -*- mode: c; c-basic-offset: 4 -*- */
cinit.d:    init.c  -- Lisp Initialization.
cinit.d:        nlogd("------------------------------");
cinit.d:        nlogd("------------------------------");
cinit.d:	return _ecl_funcall2(@'upgraded-array-element-type', type);
cinit.d:                return _ecl_funcall4(@'ext::safe-eval', form, env, err_value);
cinit.d:        return _ecl_funcall3(@'ext::safe-eval', form, env);
cinit.d:	return _ecl_funcall3(@'slot-value', instance, name);
cinit.d:	return _ecl_funcall4(@'clos::slot-value-set', value, instance, name);
cinit.d:	return _ecl_funcall3(@'clos::std-compute-applicable-methods', gf, arglist);
cinit.d:	if (ECL_SYM_FUN(@'si::bind-simple-restarts') != Cnil)
cinit.d:		return _ecl_funcall3(@'si::bind-simple-restarts', tag, names);
cinit.d:		return ECL_SYM_VAL(ecl_process_env(), @'si::*restart-clusters*');
cinit.d:	if (ECL_SYM_FUN(@'si::bind-simple-handlers') != Cnil)
cinit.d:		return _ecl_funcall3(@'si::bind-simple-handlers', tag, names);
cinit.d:		return ECL_SYM_VAL(ecl_process_env(), @'si::*handler-clusters*');
cinit.d:	return _ecl_funcall4(@'clos::std-compute-effective-method', gf, combination, methods_list);
cinit.d:	return _ecl_funcall4(@'clos::compute-effective-method-function', gf, combination, methods_list);
cinit.d:                return _ecl_funcall3(@'si::string-to-object', string, err_value);
cinit.d:        return _ecl_funcall2(@'si::string-to-object', string);
cinit.d:	return cl_apply(6, @'si::signal-simple-error', condition, continuable,
cinit.d:	return funcall(2, @'ARRAY-DIMENSIONS', array);
cinit.d:	return _ecl_funcall3(@'si::wrong-type-argument', object, type);
cinit.d:                        nlogd("---- read befor");
cinit.d:                        nlogd("---- sentence");
cinit.d:	ECL_SET(@'*load-verbose*', ECL_NIL);
cinit.d:	features = CONS(ecl_make_keyword("ECL-MIN"), features);
cinit.d:	top_level = _ecl_intern("TOP-LEVEL", cl_core.system_package);
cmpaux.d:/* -*- mode: c; c-basic-offset: 8 -*- */
cmpaux.d:    cmpaux.c -- Auxiliaries used in compiled Lisp code.
cmpaux.d:#include <ecl/ecl-inl.h>
cmpaux.d:			return(-((-x+y-1))/y);
cmpaux.d:			return(-((x-y-1)/(-y)));
cmpaux.d:			return((-x)/(-y));
cmpaux.d:	return(x - ecl_ifloor(x, y)*y);
cmpaux.d: * ----------------------------------------------------------------------
cmpaux.d: * ----------------------------------------------------------------------
cmpaux.d:  index += x->vector.offset;
cmpaux.d:  return ((x->vector.self.bit[index/CHAR_BIT] & (0200>>index%CHAR_BIT)) != 0);
cmpaux.d:  index += x->vector.offset;
cmpaux.d:    x->vector.self.bit[index/CHAR_BIT] &= ~(0200>>index%CHAR_BIT);
cmpaux.d:    x->vector.self.bit[index/CHAR_BIT] |= 0200>>index%CHAR_BIT;
cmpaux.d:		FEcontrol_error("RETURN-FROM: The block ~S with id ~S is missing.",
cmpaux.d:	the_env->values[0] = label;
cmpaux.d:	the_env->nvalues = 1;
cmpaux.d:     cl_object *vars,		/* where to put values (vars[0..nkey-1])
cmpaux.d:				   and suppliedp (vars[nkey..2*nkey-1]) */
cmpaux.d:		if (keyword == @':allow-other-keys') {
compiler.d:/* -*- mode: c; c-basic-offset: 8 -*- */
compiler.d:    compiler.c -- Bytecode compiler
compiler.d:#include <ecl/ecl-inl.h>
compiler.d:#define ECL_SPECIAL_VAR_REF	-2
compiler.d:#define ECL_UNDEFINED_VAR_REF	-1
compiler.d:#define asm_ref(env,n) (cl_fixnum)((env)->stack[n])
compiler.d:/* -------------------- SAFE LIST HANDLING -------------------- */
compiler.d:/* ------------------------------ ASSEMBLER ------------------------------ */
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:        cl_object file = ECL_SYM_VAL(env,@'ext::*source-location*'), position;
compiler.d:                file = ECL_SYM_VAL(env,@'*load-truename*');
compiler.d:	code_size = current_pc(env) - beginning;
compiler.d:	bytecodes->bytecodes.name = @'si::bytecodes';
compiler.d:        bytecodes->bytecodes.definition = definition;
compiler.d:	bytecodes->bytecodes.code_size = code_size;
compiler.d:	bytecodes->bytecodes.code = ecl_alloc_atomic(code_size * sizeof(cl_opcode));
compiler.d:	bytecodes->bytecodes.data = c_env->constants;
compiler.d:	for (i = 0, code = (cl_opcode *)bytecodes->bytecodes.code; i < code_size; i++) {
compiler.d:		code[i] = (cl_opcode)(cl_fixnum)(env->stack[beginning+i]);
compiler.d:        bytecodes->bytecodes.entry =  _ecl_bytecodes_dispatch_vararg;
compiler.d:	if (ecl_unlikely(n < -MAX_OPARG || MAX_OPARG < n))
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:	cl_object constants = c_env->constants;
compiler.d:	return constants->vector.fillp-1;
compiler.d:	cl_fixnum delta = current_pc(env) - pc;  /* [1] */
compiler.d:	if (ecl_unlikely(op && (asm_ref(env, pc-1) != op)))
compiler.d:		FEprogram_error_noreturn("Non matching codes in ASM-COMPLETE2", 0);
compiler.d:	else if (ecl_unlikely(delta < -MAX_OPARG || delta > MAX_OPARG))
compiler.d:		env->stack[pc] = (cl_object)(cl_fixnum)high;
compiler.d:		env->stack[pc+1] = (cl_object)(cl_fixnum)low;
compiler.d:		env->stack[pc] = (cl_object)(cl_fixnum)low;
compiler.d:		env->stack[pc+1] = (cl_object)(cl_fixnum)high;
compiler.d:		env->stack[pc] = (cl_object)(cl_fixnum)delta;
compiler.d:/* ------------------------------ COMPILER ------------------------------ */
compiler.d:  {@'ext::compiler-let', c_compiler_let, 0},
compiler.d:  {@'eval-when', c_eval_when, 0},
compiler.d:  {@'load-time-value', c_load_time_value, 1},
compiler.d:  {@'multiple-value-bind', c_multiple_value_bind, 1},
compiler.d:  {@'multiple-value-call', c_multiple_value_call, 1},
compiler.d:  {@'multiple-value-prog1', c_multiple_value_prog1, 1},
compiler.d:  {@'multiple-value-setq', c_multiple_value_setq, 1},
compiler.d:  {@'nth-value', c_nth_value, 1},
compiler.d:  {@'return-from', c_return_from, 1},
compiler.d:  {@'symbol-macrolet', c_symbol_macrolet, 0},
compiler.d:  {@'ext::truly-the', c_the, 0},
compiler.d:  {@'unwind-protect', c_unwind_protect, 1},
compiler.d:  {@'ext::with-backend', c_with_backend, 0},
compiler.d:  {@'si::cons-car', c_car, 1},
compiler.d:  {@'si::cons-cdr', c_cdr, 1},
compiler.d:/* ----------------- LEXICAL ENVIRONMENT HANDLING -------------------- */
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:	cl_object p = c_env->constants;
compiler.d:	for (n = 0; n < p->vector.fillp; n++) {
compiler.d:		if (ecl_eql(p->vector.self.t[n], c)) {
compiler.d:	return -1;
compiler.d: * well as CMP-ENV-REGISTER-MACROLET (lsp/defmacro.lsp)
compiler.d: * env->variables, the other one stored in env->macros.
compiler.d: * variable-record =	(:block block-name [used-p | block-object] location) |
compiler.d: *			(:tag ({tag-name}*) [NIL | tag-object] location) |
compiler.d: *			(:function function-name used-p [location]) |
compiler.d: *			(var-name {:special | nil} bound-p [location]) |
compiler.d: *			(symbol si::symbol-macro macro-function) |
compiler.d: *			CB | LB | UNWIND-PROTECT |
compiler.d: *			(:declare declaration-arguments*)
compiler.d: * macro-record =	(function-name FUNCTION [| function-object]) |
compiler.d: *			(macro-name si::macro macro-function)
compiler.d: *			CB | LB | UNWIND-PROTECT
compiler.d: * A *-NAME is a symbol. A TAG-ID is either a symbol or a number. A
compiler.d: * MACRO-FUNCTION is a function that provides us with the expansion
compiler.d: * for that local macro or symbol macro. BOUND-P is true when the
compiler.d: * the variable-record corresponds just to a special declaration.
compiler.d: * CB, LB and UNWIND-PROTECT are only used by the C compiler and they
compiler.d: * denote closure, lexical environment and unwind-protect boundaries.
compiler.d: * The BLOCK-, TAG- and FUNCTION- objects are proper of the compiler
compiler.d: * match those of Common-Lisp.
compiler.d:	return CONS(ecl_make_fixnum(c_env->env_depth),
compiler.d:                    ecl_make_fixnum(c_env->env_size++));
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:	c_env->variables = CONS(cl_list(4, @':block', name, ECL_NIL, loc),
compiler.d:                                c_env->variables);
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:	c_env->variables = CONS(cl_list(4, @':tag', all_tags, ECL_NIL, loc),
compiler.d:                                c_env->variables);
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:	c_env->variables = CONS(cl_list(4, @':function', name, ECL_NIL,
compiler.d:                                c_env->variables);
compiler.d:	c_env->macros = CONS(cl_list(2, name, @'function'), c_env->macros);
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:	return cl_macroexpand_1(2, stmt, CONS(c_env->variables, c_env->macros));
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:	c_env->variables = CONS(cl_list(3, name, @'si::symbol-macro', exp_fun),
compiler.d:                                c_env->variables);
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:	c_env->macros = CONS(cl_list(3, name, @'si::macro', exp_fun), c_env->macros);
compiler.d:	const cl_compiler_ptr c_env = env->c_env;
compiler.d:	c_env->variables = CONS(cl_list(4, var,
compiler.d:				c_env->variables);
compiler.d:	the_env->c_env = new;
compiler.d:		new->env_depth = old->env_depth + 1;
compiler.d:		new->code_walker = ECL_SYM_VAL(the_env, @'si::*code-walker*');
compiler.d:		new->constants = si_make_vector(ECL_T, ecl_make_fixnum(16),
compiler.d:		new->stepping = 0;
compiler.d:		new->lexical_level = 0;
compiler.d:		new->load_time_forms = ECL_NIL;
compiler.d:		new->env_depth = 0;
compiler.d:		new->macros = CDR(env);
compiler.d:		new->variables = CAR(env);
compiler.d:		for (env = new->variables; !Null(env); env = CDR(env)) {
compiler.d:			if (ECL_SYMBOLP(CAR(record)) && CADR(record) != @'si::symbol-macro') {
compiler.d:				new->lexical_level = 1;
compiler.d:                new->mode = FLAG_EXECUTE;
compiler.d:	new->env_size = 0;
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:	for (l = c_env->variables; CONSP(l); l = ECL_CONS_CDR(l)) {
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:	for (l = c_env->variables; CONSP(l); l = ECL_CONS_CDR(l)) {
compiler.d:		} else if (special == @'si::symbol-macro') {
compiler.d:				return -1;
compiler.d:		l = ecl_symbol_value(@'ext::*action-on-undefined-variable*');
compiler.d:	@si::process-declarations(1, body);
compiler.d:        const cl_compiler_ptr c_env = the_env->c_env;
compiler.d:	for (env = c_env->variables; env != old_vars && !Null(env); env = ECL_CONS_CDR(env))
compiler.d:		} else if (special != @'si::symbol-macro') {
compiler.d:	c_env->variables = env;
compiler.d: *	FLAG_PUSH		-> FLAG_VALUES
compiler.d: *	FLAG_VALUES		-> FLAG_VALUES
compiler.d: *	FLAG_REG0		-> FLAG_REG0
compiler.d: *	FLAG_IGNORE		-> FLAG_IGNORE
compiler.d: *	FLAG_PUSH		-> FLAG_VALUES
compiler.d: *	FLAG_VALUES		-> FLAG_VALUES
compiler.d: *	FLAG_REG0		-> FLAG_VALUES
compiler.d: *	FLAG_IGNORE		-> FLAG_IGNORE
compiler.d: *	FLAG_PUSH		-> FLAG_REG0
compiler.d: *	FLAG_VALUES		-> FLAG_REG0
compiler.d: *	FLAG_REG0		-> FLAG_REG0
compiler.d: *	FLAG_IGNORE		-> FLAG_IGNORE
compiler.d:/* -------------------- THE COMPILER -------------------- */
compiler.d:	old_env = *(env->c_env);
compiler.d:	constants = old_env.constants->vector.fillp;
compiler.d:	block_record = ECL_CONS_CAR(env->c_env->variables);
compiler.d:		/* some of them might be from load-time-value */
compiler.d:		old_env.constants->vector.fillp = constants;
compiler.d:		*(env->c_env) = old_env;
compiler.d:			if (f->cfun.narg == 1 && n == 1) {
compiler.d:			} else if (f->cfun.narg == 2 && n == 2) {
compiler.d:	if (env->c_env->stepping) {
compiler.d:	if (env->c_env->stepping) {
compiler.d:			while (n-- > 1) {
compiler.d:	old_env = env->c_env->variables;
compiler.d:	cl_index old_bds_top_index = env->bds_top - env->bds_org;
compiler.d:	asm_arg(env, labelb - current_pc(env));
compiler.d:                else if (keyword == @':load-toplevel')
compiler.d:                else if (keyword == @':compile-toplevel')
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:	int mode = c_env->mode;
compiler.d:        } else if (c_env->lexical_level) {
compiler.d:                        env->c_env->mode = FLAG_COMPILE;
compiler.d:                        env->c_env->mode = FLAG_LOAD;
compiler.d:                        env->c_env->mode = FLAG_ONLY_LOAD;
compiler.d:                        env->c_env->mode = FLAG_LOAD;
compiler.d:	cl_object old_vars = env->c_env->variables;
compiler.d:	cl_object old_funs = env->c_env->macros;
compiler.d:	env->c_env->macros = old_funs;
compiler.d:                } else if (kind == @'ext::lambda-block') {
compiler.d:			const cl_compiler_ptr c_env = env->c_env;
compiler.d:				 (Null(c_env->variables) &&
compiler.d:				  Null(c_env->macros))?
compiler.d:	(if a b) -> (cond (a b))
compiler.d:	(if a b c) -> (cond (a b) (t c))
compiler.d:	1) Refer to the n-th variable in the lexical environment
compiler.d:        3) Push the value of the n-th variable of the lexical environment
compiler.d:	cl_object old_variables = env->c_env->variables;
compiler.d:	specials = env->values[3];
compiler.d:	const cl_compiler_ptr c_env = env->c_env;
compiler.d:		FEprogram_error_noreturn("LOAD-TIME-VALUE: Wrong number of arguments.", 0);
compiler.d:        if (c_env->mode != FLAG_LOAD && c_env->mode != FLAG_ONLY_LOAD) {
compiler.d:		 * copies of the same load-time-value form */
compiler.d:		c_env->load_time_forms =
compiler.d:				 c_env->load_time_forms);
compiler.d:	cl_object old_env = env->c_env->variables;
compiler.d:	c_declare_specials(env, env->values[3]);
compiler.d:        const cl_compiler_ptr c_env = the_env->c_env;
compiler.d:	cl_object old_env = c_env->macros;
compiler.d:	cl_object env = funcall(3, @'si::cmp-env-register-macrolet', pop(&args),
compiler.d:				CONS(c_env->variables, c_env->macros));
compiler.d:	c_env->macros = CDR(env);
compiler.d:	c_env->macros = old_env;
compiler.d:                cl_object old_variables = env->c_env->variables;
compiler.d:                cl_object specials = env->values[3];
compiler.d:		for (vars=cl_reverse(vars); n--; ) {
compiler.d:	cl_object old_variables = env->c_env->variables;
compiler.d:			 * transform MULTIPLE-VALUE-SETQ into (SETF (VALUES ...))
compiler.d:		FEprogram_error_noreturn("MULTIPLE-VALUE-SETQ: Too many arguments.", 0);
compiler.d:		FEprogram_error_noreturn("NTH-VALUE: Too many arguments.",0);
compiler.d:	   N-th position
compiler.d:	   variable in the N-th position.
compiler.d:		FEprogram_error_noreturn("RETURN-FROM: Unknown block name ~S.", 1, name);
compiler.d:		FEprogram_error_noreturn("RETURN-FROM: Too many arguments.", 0);
compiler.d:	cl_object old_variables = env->c_env->variables;
compiler.d:	specials = env->values[3];
compiler.d:			FEprogram_error_noreturn("SYMBOL-MACROLET: Symbol ~A cannot be \
compiler.d:declared special and appear in a symbol-macrolet.", 1, name);
compiler.d:	cl_object old_env = env->c_env->variables;
compiler.d:	for (i = nt; i; i--)
compiler.d:                return _ecl_funcall3(@'clos::need-to-make-load-form-p', o, ECL_NIL)
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:        if (c_env->mode != FLAG_LOAD && c_env->mode != FLAG_ONLY_LOAD)
compiler.d:        make = _ecl_funcall2(@'make-load-form', constant);
compiler.d:        init = (env->nvalues > 1)? env->values[1] : ECL_NIL;
compiler.d:        c_env->load_time_forms = ecl_cons(cl_list(3, constant, make, init),
compiler.d:                                          c_env->load_time_forms);
compiler.d:                           && n >= -MAX_OPARG) {
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:	ecl_bds_bind(env, @'si::*current-form*', stmt);
compiler.d:	if (c_env->code_walker != OBJNULL) {
compiler.d:		stmt = funcall(3, c_env->code_walker, stmt,
compiler.d:			       CONS(c_env->variables, c_env->macros));
compiler.d:			c_env->lexical_level += l->lexical_increment;
compiler.d:			if (c_env->stepping && function != @'function' &&
compiler.d:			    c_env->lexical_level)
compiler.d:			new_flags = (*(l->compiler))(env, ECL_CONS_CDR(stmt), flags);
compiler.d:			if (c_env->stepping && function != @'function' &&
compiler.d:			    c_env->lexical_level)
compiler.d:			c_env->lexical_level -= l->lexical_increment;
compiler.d:	if (c_env->stepping)
compiler.d:        c_env->lexical_level++;
compiler.d:        c_env->lexical_level--;
compiler.d:		PUSH		PUSH			---
compiler.d:		VALUES		VALUES			---
compiler.d:		REG0		VALUES			---
compiler.d:		REG0		REG0			---
compiler.d:        const cl_compiler_ptr old_c_env = env->c_env;
compiler.d:        env->nvalues = 0;
compiler.d:        env->values[0] = ECL_NIL;
compiler.d:        env->c_env = &new_c_env;
compiler.d:                env->values[0] = ecl_interpret((cl_object)&frame,
compiler.d:                GC_free(bytecodes->bytecodes.code);
compiler.d:        env->c_env = old_c_env;
compiler.d:                env->values[0] = form;
compiler.d:                env->nvalues = 1;
compiler.d:        cl_index l = end - start;
compiler.d:        for (*(p++) = l; end > start; end--, p++) {
compiler.d:        for (l = *p; l; l--) {
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:        if (c_env->load_time_forms != ECL_NIL) {
compiler.d:                cl_object p, forms_list = c_env->load_time_forms;
compiler.d:		c_env->load_time_forms = ECL_NIL;
compiler.d:			c_env->constants->vector.self.t[loc] = ecl_make_fixnum(0);
compiler.d:        const cl_compiler_ptr c_env = env->c_env;
compiler.d:        if (!c_env->lexical_level) {
compiler.d:                if (c_env->mode == FLAG_EXECUTE)
compiler.d:/* ------------------------ INLINED FUNCTIONS -------------------------------- */
compiler.d:/* ----------------------------- PUBLIC INTERFACE ---------------------------- */
compiler.d:/* ------------------------------------------------------------
compiler.d:	{block-name | NIL}
compiler.d:	{variable-env | NIL}
compiler.d:	{function-env | NIL}
compiler.d:	{block-env | NIL}
compiler.d:	{rest-var NIL}			; rest variable
compiler.d:	documentation-string
compiler.d:	list-of-declarations
compiler.d:   ------------------------------------------------------------ */
compiler.d:@(defun si::process-declarations (body &optional doc)
compiler.d:	declarations = @si::process-declarations(2, body, ECL_T);
compiler.d:	body = env->values[1];
compiler.d:	documentation = env->values[2];
compiler.d:	specials = env->values[3];
compiler.d:        cl_index n = env->nvalues;
compiler.d:	env->values[0] = lambda_list;
compiler.d:	env->values[n++] = documentation;
compiler.d:	env->values[n++] = specials;
compiler.d:	env->values[n++] = declarations;
compiler.d:	env->values[n++] = body;
compiler.d:        env->nvalues = n;
compiler.d: * (si::process-lambda-list lambda-list context)
compiler.d: * FTYPE, FUNCTION, METHOD or DESTRUCTURING-BIND, and determines the
compiler.d: * VALUES(2) = rest-var				; rest-variable, if any
compiler.d: * VALUES(3) = key-flag				; T if &key was supplied
compiler.d: * VALUES(5) = allow-other-keys			; flag &allow-other-keys
compiler.d:	if (v == @'&rest' || (v == @'&body' && (context == @'si::macro' || context == @'destructuring-bind'))) {
compiler.d:	if (v == @'&allow-other-keys') {
compiler.d:	ecl_bds_bind(env, @'si::*current-form*',
compiler.d:		     @list*(3, @'ext::lambda-block', name, lambda));
compiler.d:	old_c_env = env->c_env;
compiler.d:	opts = env->values[1];
compiler.d:	rest = env->values[2];
compiler.d:	key  = env->values[3];
compiler.d:	keys = env->values[4];
compiler.d:	allow_other_keys = env->values[5];
compiler.d:	auxs = env->values[6];
compiler.d:	doc  = env->values[7];
compiler.d:	specials = env->values[8];
compiler.d:	decl = env->values[9];
compiler.d:	body = env->values[10];
compiler.d:	 * environment and when code-walking */
compiler.d:	c_register_var(env, @'si::function-boundary', TRUE, FALSE);
compiler.d:	c_undo_bindings(env, old_c_env->variables, 1);
compiler.d:        if (Null(ecl_symbol_value(@'si::*keep-definitions*')))
compiler.d:	output->bytecodes.name = name;
compiler.d:	old_c_env->load_time_forms = env->c_env->load_time_forms;
compiler.d:	env->c_env = old_c_env;
compiler.d:	volatile cl_compiler_env_ptr old_c_env = the_env->c_env;
compiler.d:		the_env->c_env = old_c_env;
compiler.d:@(defun si::eval-with-env (form &optional (env ECL_NIL) (stepping ECL_NIL)
compiler.d:	old_c_env = the_env->c_env;
compiler.d:                        the_env->values[0] = asm_end(the_env, handle, form);
compiler.d:                        the_env->nvalues = 1;
compiler.d:		the_env->c_env = old_c_env;
compiler.d:	return the_env->values[0];
cons.d:/* -*- mode: c; c-basic-offset: 8 -*- */
cons.d:    cons.d -- list manipulation macros & functions
cons.d:    Copyright (c) 2011, Juan Jose Garcia-Ripoll
cons.d:/* BEGIN-GENERATED (gen-cons-d) */
cons.d:/* END-GENERATED */
disassembler.d:/* -*- mode: c; c-basic-offset: 8 -*- */
disassembler.d:    disassembler.c -- Byte compiler and function evaluator
disassembler.d:#include <ecl/ecl-inl.h>
disassembler.d:	ecl_bds_bind(env, @'*print-pretty*', ECL_NIL);
disassembler.d:	data = bytecodes->bytecodes.data->vector.self.t;
disassembler.d:	cl_print(1,bytecodes->bytecodes.data);
disassembler.d:	print_arg("\nName:\t\t", bytecodes->bytecodes.name);
disassembler.d:	if (bytecodes->bytecodes.name == OBJNULL ||
disassembler.d:	    bytecodes->bytecodes.name == @'si::bytecodes') {
disassembler.d:	base = vector = (cl_opcode *)bytecodes->bytecodes.code;
disassembler.d:/* -------------------- DISASSEMBLER CORE -------------------- */
disassembler.d:	cl_object *data = bytecodes->bytecodes.data->vector.self.t;
disassembler.d:	while (nfun--) {
disassembler.d:		print_arg("\n\tFLET\t", fun->bytecodes.name);
disassembler.d:	cl_object *data = bytecodes->bytecodes.data->vector.self.t;
disassembler.d:	while (nfun--) {
disassembler.d:		print_arg("\n\tLABELS\t", fun->bytecodes.name);
disassembler.d:		ecl_princ(ecl_make_fixnum(destination - base), ECL_T);
disassembler.d:	cl_object *data = bytecodes->bytecodes.data->vector.self.t;
disassembler.d:	if (cl_fboundp(@'si::formatter-aux') != ECL_NIL)
disassembler.d:		line_no = ecl_make_fixnum(vector-base);
disassembler.d:		Sets NVALUES=1 and VALUES(0) to the value of the n-th local.
disassembler.d:		Pushes the value of the n-th local onto the stack.
disassembler.d:	/* OP_GO	n{arg}, tag-ndx{arg}
disassembler.d:	   OP_QUOTE	tag-name{symbol}
disassembler.d:		Jumps to the tag which is defined at the n-th position in
disassembler.d:		the lexical environment. TAG-NAME is kept for debugging
disassembler.d:		occuppies the n-th position.
disassembler.d:				n = vector + m - OPARG_SIZE - base;
disassembler.d:				n = vector + m - OPARG_SIZE - base;
disassembler.d:		to the n-th value of VALUES(...).
disassembler.d:	   OP_SETQS	var-name{symbol}
disassembler.d:	   OP_PSETQS	var-name{symbol}
disassembler.d:		Sets either the n-th local or a special variable VAR-NAME,
disassembler.d:		Set VALUES(0) to the N-th value of the VALUES(...) list.
disassembler.d:		The index N-th is extracted from the top of the stack.
disassembler.d:		FEerror("Unknown code ~S", 1, ecl_make_fixnum(*(vector-1)));
disassembler.d:		v = v->bclosure.code;
disassembler.d:		b = b->bclosure.code;
disassembler.d:		lex = b->bclosure.lex;
disassembler.d:                vector = ecl_alloc_simple_vector(b->bytecodes.code_size *
disassembler.d:                vector->vector.self.b8 = (uint8_t*)b->bytecodes.code;
disassembler.d:                data = cl_copy_seq(b->bytecodes.data);
disassembler.d:                name = b->bytecodes.name;
disassembler.d:                output->bclosure.code = si_bc_join(ECL_NIL, code, data, name);
disassembler.d:                output->bclosure.lex = lex;
disassembler.d:                output->bclosure.entry = _ecl_bclosure_dispatch_vararg;
disassembler.d:                             (code->vector.elttype != ecl_aet_b8)) {
disassembler.d:                        FEwrong_type_nth_arg(@[si::bc-join],
disassembler.d:                                                     @'simple-array',
disassembler.d:                             (data->vector.elttype != ecl_aet_object)) {
disassembler.d:                        FEwrong_type_nth_arg(@[si::bc-join],
disassembler.d:                                                     @'simple-array',
disassembler.d:                output->bytecodes.name = ECL_NIL;
disassembler.d:                output->bytecodes.definition = ECL_NIL;
disassembler.d:                output->bytecodes.entry = _ecl_bytecodes_dispatch_vararg;
disassembler.d:                output->bytecodes.code_size = code->vector.fillp / sizeof(cl_opcode);
disassembler.d:                output->bytecodes.code = (void*)code->vector.self.b8;
disassembler.d:                output->bytecodes.data = data;
disassembler.d:                output->bytecodes.file = ECL_NIL;
disassembler.d:                output->bytecodes.file_position = ECL_NIL;
dosdummy.d:/* -*- mode: c; c-basic-offset: 8 -*- */
dostimes.d:/* -*- mode: c; c-basic-offset: 8 -*- */
dostimes.d:  x->tms_utime = hz;
dostimes.d:  x->tms_stime = hz;
dpp.c:/* -*- mode: c; c-basic-offset: 8 -*- */
dpp.c:    dpp.c -- Defun preprocessor.
dpp.c:		dpp [in-file [out-file]]
dpp.c:	The file named in-file is preprocessed and the output will be
dpp.c:	written to the file whose name is out-file. If in-file is "-"
dpp.c:	program is read from standard input, while if out-file is "-"
dpp.c:	C-program is written to standard output.
dpp.c:		C-declaration
dpp.c:		C-body
dpp.c:	Each supplied-p parameter becomes a boolean C variable.
dpp.c:	If an expression contains non-alphanumeric characters,
dpp.c:		--lineno;
dpp.c:		--tab;
dpp.c:	while (n--)
dpp.c:			c[i] = '-';
dpp.c:		if (c == '_') c = '-';
dpp.c:		if (c == '_') c = '-';
dpp.c:				left_paren--;
dpp.c:				poolp--;
dpp.c:				poolp--;
dpp.c:		error("illegal lambda-list keyword");
dpp.c:			error("illegal lambda-list keyword");
dpp.c:		rest_var, rest_var, ((nreq > 0) ? required[nreq-1] : "narg"));
dpp.c:		rest_var, rest_var, ((nreq > 0) ? required[nreq-1] : "narg"),
dpp.c:          fprintf(out, "the_env->nvalues = 0; return ECL_NIL;\n");
dpp.c:	  fprintf(out, "the_env->nvalues = %d;\n", nres);
dpp.c:	  for (i = nres-1;  i > 0;  i--) {
dpp.c:		fprintf(out, "the_env->values[%d] = __value%d;\n", i, i);
dpp.c:	if (argc < 2 || !strcmp(argv[1],"-")) {
dpp.c:	  strcpy(filename, "-");
dpp.c:	if (argc < 3 || !strcmp(argv[2],"-")) {
dpp.c:	  strncpy(outfile, "-", BUFSIZ);
dpp.c:	printf("dpp: %s -> %s\n", filename, outfile);
earith.d:/* -*- mode: c; c-basic-offset: 8 -*- */
earith.d:    earith.c -- Support for bignum arithmetic.
earith.d:	D, Q, and R are 32 bit non-negative integers and HP and LP are
earith.d:	the locations QP and RP, respectively.  D, H, L are 32 bit non-negative
earith.d:	represented as 32 bit non-negative integer.
earith.d:  asm(" mttbiu r2,0");		/* Do add-back if necessary. */
earith.d:	asm("	move.l	d2,-(sp)
earith.d:  asm("subu	$15, $5, $4");	/* t = h - d */
earith.d:		movl	d2,a7@-
earith.d:	save	%sp,-96,%sp
earith.d:      h -= d;
earith.d:    if (i--)
earith.d:  l = - l - 1;
earith.d:	asm("	rotl	$-1,r0,r0");
earith.d:	asm("	ashq	$-1,r0,r0");
ecl_constants.h:/* -*- mode: c; c-basic-offset: 8 -*- */
ecl_constants.h:    ecl_constants.c -- constant values for all_symbols.d
ecl_constants.h:#include <ecl/ecl-inl.h>
ecl_constants.h:ecl_def_ct_single_float(flt_max_neg,-FLT_MAX,static,const);
ecl_constants.h:ecl_def_ct_single_float(flt_min_neg,-FLT_MIN,static,const);
ecl_constants.h:ecl_def_ct_double_float(dbl_max_neg,-DBL_MAX,static,const);
ecl_constants.h:ecl_def_ct_double_float(dbl_min_neg,-DBL_MIN,static,const);
ecl_constants.h:ecl_def_ct_long_float(ldbl_max_neg,-LDBL_MAX,static,const);
ecl_constants.h:ecl_def_ct_long_float(ldbl_min_neg,-LDBL_MIN,static,const);
ecl_features.h:/* -*- mode: c; c-basic-offset: 8 -*- */
ecl_features.h:    features.h -- names of features compiled into ECL
ecl_features.h:        ecl_def_string_array_elt("PREFIXED-API"),
ecl_features.h:        ecl_def_string_array_elt("IEEE-FLOATING-POINT"),
ecl_features.h:        ecl_def_string_array_elt("COMMON-LISP"),
ecl_features.h:        ecl_def_string_array_elt("ANSI-CL"),
ecl_features.h:	ecl_def_string_array_elt("BOEHM-GC"),
ecl_features.h:	ecl_def_string_array_elt("OLD-LOOP"),
ecl_features.h:	ecl_def_string_array_elt("ECL-PDE"),
ecl_features.h:	ecl_def_string_array_elt("SYSTEM-V"),
ecl_features.h:	ecl_def_string_array_elt("MS-DOS"),
ecl_features.h:	ecl_def_string_array_elt("CMU-FORMAT"),
ecl_features.h:	ecl_def_string_array_elt("CLOS-STREAMS"),
ecl_features.h:	ecl_def_string_array_elt("LONG-FLOAT"),
ecl_features.h:	ecl_def_string_array_elt("RELATIVE-PACKAGE-NAMES"),
ecl_features.h:        ecl_def_string_array_elt("UINT16-T"),
ecl_features.h:        ecl_def_string_array_elt("UINT32-T"),
ecl_features.h:        ecl_def_string_array_elt("UINT64-T"),
ecl_features.h:        ecl_def_string_array_elt("LONG-LONG"),
ecl_features.h:	ecl_def_string_array_elt("ECL-READ-WRITE-LOCK"),
ecl_features.h:	ecl_def_string_array_elt("BIG-ENDIAN"),
ecl_features.h:	ecl_def_string_array_elt("LITTLE-ENDIAN"),
ecl_features.h:	ecl_def_string_array_elt("ECL-WEAK-HASH"),
error.d:/* -*- mode: c; c-basic-offset: 8 -*- */
error.d:    error.c -- Error handling.
error.d:#include <ecl/ecl-inl.h>
error.d:        tag = ECL_SYM_VAL(the_env, @'si::*quit-tag*');
error.d:        the_env->nvalues = 0;
error.d:	if (the_env->frs_org <= the_env->frs_top) {
error.d:		destination = ecl_process_env()->frs_org;
error.d:	funcall(4, @'si::universal-error-handler',
error.d:	return funcall(4, @'si::universal-error-handler',
error.d:		       make_constant_base_string(err),	/*  continue-format-string  */
error.d:	if (cl_boundp(@'si::*current-form*') != ECL_NIL) {
error.d:	    cl_object stmt = ecl_symbol_value(@'si::*current-form*');
error.d:			       @'program-error', /* condition name */
error.d:	if (cl_boundp(@'si::*current-form*') != ECL_NIL) {
error.d:	    cl_object stmt = ecl_symbol_value(@'si::*current-form*');
error.d:			       @'program-error', /* condition name */
error.d:			       @'control-error', /* condition name */
error.d:                                       @'parse-error', /* condition name */
error.d:                                       @'reader-error', /* condition name */
error.d:	cl_error(3, @'file-error', @':pathname', fn);
error.d:	cl_error(3, @'end-of-file', @':stream', strm);
error.d:	cl_error(3, @'stream-error', @':stream', strm);
error.d:	return cl_error(5, @'type-error', @':expected-type', type,
error.d:        if (!Null(function) && env->ihs_top && env->ihs_top->function != function) {
error.d:                               @'type-error', /* condition name */
error.d:                               @':expected-type', type,
error.d:        if (!Null(function) && env->ihs_top && env->ihs_top->function != function) {
error.d:                               @'type-error', /* condition name */
error.d:                               @':expected-type', type,
error.d:        if (!Null(function) && env->ihs_top && env->ihs_top->function != function) {
error.d:                               @'type-error', /* condition name */
error.d:                               @':expected-type', type,
error.d:        cl_object limit = ecl_make_integer(nonincl_limit-1);
error.d:        if (!Null(function) && env->ihs_top && env->ihs_top->function != function) {
error.d:                 @'simple-type-error', /* condition name */
error.d:                 @':format-control', message,
error.d:                 @':format-arguments',
error.d:                 @':expected-type', type,
error.d:	cl_error(3, @'unbound-variable', @':name', sym);
error.d:	cl_error(3, @'undefined-function', @':name', fname);
error.d:	cl_error(3, @'print-not-readable', @':object', x);
error.d:	cl_error(9, @'simple-type-error', @':format-control',
error.d:		 @':format-arguments', cl_list(1, fname),
error.d:		 @':expected-type', cl_list(2, @'satisfies', @'si::valid-function-name-p'),
error.d:                ecl_bds_bind(the_env, @'*print-readably*', ECL_NIL);
error.d:                ecl_bds_bind(the_env, @'*print-level*', ecl_make_fixnum(3));
error.d:                ecl_bds_bind(the_env, @'*print-length*', ecl_make_fixnum(3));
error.d:                ecl_bds_bind(the_env, @'*print-circle*', ECL_NIL);
error.d:                ecl_bds_bind(the_env, @'*print-base*', ecl_make_fixnum(10));
error.d:	cl_error(5, @'division-by-zero', @':operation', @'/',
error.d:	funcall(4, @'si::universal-error-handler', ECL_NIL, eformat,
error.d:	return funcall(4, @'si::universal-error-handler', cformat, eformat,
error.d:	ecl_def_c_function(@'si::universal-error-handler',
eval.d:/* -*- mode: c; c-basic-offset: 8 -*- */
eval.d:    eval.c -- Eval.
eval.d:#include <ecl/ecl-inl.h>
eval.d:	return ecl_process_env()->stack_top - narg;
eval.d:	cl_object *sp = frame->frame.base;
eval.d:	cl_index narg = frame->frame.size;
eval.d:        frame->frame.env->function = fun;
eval.d:		if (ecl_unlikely(narg != (cl_index)fun->cfun.narg))
eval.d:		return APPLY_fixed(narg, fun->cfunfixed.entry_fixed, sp);
eval.d:		return APPLY(narg, fun->cfun.entry, sp);
eval.d:		return APPLY(narg, fun->cclosure.entry, sp);
eval.d:		switch (fun->instance.isgf) {
eval.d:			fun = fun->instance.slots[fun->instance.length - 1];
eval.d:			return APPLY(narg, fun->instance.entry, sp);
eval.d:		if (ecl_unlikely(fun->symbol.stype & ecl_stp_macro))
eval.d:		return ecl_interpret(frame, fun->bclosure.lex, fun->bclosure.code);
eval.d:		env->function = fun;
eval.d:		return fun->cfunfixed.entry;
eval.d:		env->function = fun;
eval.d:		return fun->cfun.entry;
eval.d:		env->function = fun;
eval.d:		return fun->cclosure.entry;
eval.d:                env->function = fun;
eval.d:                return fun->instance.entry;
eval.d:		if (ecl_unlikely(fun->symbol.stype & ecl_stp_macro))
eval.d:		env->function = fun;
eval.d:                return fun->bytecodes.entry;
eval.d:		env->function = fun;
eval.d:                return fun->bclosure.entry;
eval.d:        --narg;
eval.d:							     narg -= 2);
eval.d:                        for (i = 0; i < lastarg->frame.size; i++) {
eval.d:				ecl_stack_frame_push(frame, lastarg->frame.base[i]);
eval.d:				FEprogram_error_noreturn("CALL-ARGUMENTS-LIMIT exceeded",0);
eval.d:		flag = (arg->symbol.stype & ecl_stp_constant) ? ECL_T : ECL_NIL;
ffi.d:/* -*- mode: c; c-basic-offset: 8 -*- */
ffi.d:    ffi.c -- User defined data types and foreign functions interface.
ffi.d:        @':int32-t', /* ecl_aet_fix */
ffi.d:        @':uint32-t', /* ecl_aet_index */
ffi.d:        @':int64-t', /* ecl_aet_fix */
ffi.d:        @':uint64-t', /* ecl_aet_index */
ffi.d:	@':uint8-t', /* ecl_aet_b8 */
ffi.d:        @':int8-t', /* ecl_aet_i8 */
ffi.d:        @':uint16-t', /* ecl_aet_b16 */
ffi.d:        @':int16-t', /* ecl_aet_i16 */
ffi.d:        @':uint32-t', /* ecl_aet_b32 */
ffi.d:        @':int32-t', /* ecl_aet_i32 */
ffi.d:        @':uint64-t', /* ecl_aet_b64 */
ffi.d:        @':int64-t', /* ecl_aet_i64 */
ffi.d:	@':int32-t', /* ecl_aet_ch */
ffi.d:  {symbol, sizeof(type), (AUX_PTR(type)->b.d - AUX_PTR(type)->a)}
ffi.d:#define ALIGNMENT(tag) (ecl_foreign_type_table[tag].d - ecl_foreign_type_table[tag].a)
ffi.d:  {symbol, sizeof(type), AUX_PTR(type)->b.d, AUX_PTR(type)->a}
ffi.d:	FFI_DESC(@':unsigned-char', unsigned char),
ffi.d:        FFI_DESC(@':unsigned-byte', ecl_uint8_t),
ffi.d:	FFI_DESC(@':unsigned-short', unsigned short),
ffi.d:	FFI_DESC(@':unsigned-int', unsigned int),
ffi.d:	FFI_DESC(@':unsigned-long', unsigned long),
ffi.d:        FFI_DESC(@':int8-t', ecl_int8_t),
ffi.d:        FFI_DESC(@':uint8-t', ecl_uint8_t),
ffi.d:        FFI_DESC(@':int16-t', ecl_int16_t),
ffi.d:        FFI_DESC(@':uint16-t', ecl_uint16_t),
ffi.d:        FFI_DESC(@':int32-t', ecl_int32_t),
ffi.d:        FFI_DESC(@':uint32-t', ecl_uint32_t),
ffi.d:        FFI_DESC(@':int64-t', ecl_int64_t),
ffi.d:        FFI_DESC(@':uint64-t', ecl_uint64_t),
ffi.d:        FFI_DESC(@':long-long', long long),
ffi.d:        FFI_DESC(@':unsigned-long-long', unsigned long long),
ffi.d:	FFI_DESC(@':pointer-void', void *),
ffi.d:	&ffi_type_uchar, /*@':unsigned-char',*/
ffi.d:	&ffi_type_uint8, /*@':unsigned-byte',*/
ffi.d:	&ffi_type_ushort, /*@':unsigned-short',*/
ffi.d:	&ffi_type_uint, /*@':unsigned-int',*/
ffi.d:	&ffi_type_ulong, /*@':unsigned-long',*/
ffi.d:        &ffi_type_sint8, /*@':int8-t',*/
ffi.d:        &ffi_type_uint8, /*@':uint8-t',*/
ffi.d:        &ffi_type_sint16, /*@':int16-t',*/
ffi.d:        &ffi_type_uint16, /*@':uint16-t',*/
ffi.d:        &ffi_type_sint32, /*@':int32-t',*/
ffi.d:        &ffi_type_uint32, /*@':uint32-t',*/
ffi.d:        &ffi_type_sint64, /*@':int64-t',*/
ffi.d:        &ffi_type_uint64, /*@':uint64-t',*/
ffi.d:        &ffi_type_sint64, /*@':long-long',*/ /*FIXME! libffi does not have long long */
ffi.d:        &ffi_type_uint64, /*@':unsigned-long-long',*/
ffi.d:	&ffi_type_pointer, /*@':pointer-void',*/
ffi.d:	output->foreign.tag = tag == ECL_NIL ? @':void' : tag;
ffi.d:	output->foreign.size = size;
ffi.d:	output->foreign.data = (char*)data;
ffi.d:	output->foreign.tag = tag;
ffi.d:	output->foreign.size = size;
ffi.d:	output->foreign.data = (char*)ecl_alloc_atomic(size);
ffi.d:                FEwrong_type_only_arg(@[si::foreign-data-pointer], f,
ffi.d:                                      @[si::foreign-data]);
ffi.d:	return f->foreign.data;
ffi.d:	f = ecl_check_cl_type(@'si::make-foreign-data-from-array', f, t_base_string);
ffi.d:	s = f->base_string.self;
ffi.d:                         s[f->base_string.fillp] != 0)) {
ffi.d:	f = ecl_check_cl_type(@'si::make-foreign-data-from-array', f, t_base_string);
ffi.d:            f->base_string.self[f->base_string.fillp] != 0) {
ffi.d:	output->foreign.tag = tag;
ffi.d:	output->foreign.size = bytes;
ffi.d:	output->foreign.data = bytes? ecl_alloc_uncollectable(bytes) : NULL;
ffi.d:                FEwrong_type_only_arg(@[si::free-foreign-data], f,
ffi.d:                                      @[si::foreign-data]);
ffi.d:	if (f->foreign.size) {
ffi.d:		ecl_free_uncollectable(f->foreign.data);
ffi.d:	f->foreign.size = 0;
ffi.d:	f->foreign.data = NULL;
ffi.d:                FEwrong_type_only_arg(@[si::make-foreign-data-from-array], array,
ffi.d:        tag = ecl_aet_to_ffi_table[array->array.elttype];
ffi.d:                        ecl_elttype_to_symbol(array->array.elttype));
ffi.d:	@(return ecl_make_foreign_data(tag, 0, array->array.self.bc));
ffi.d:                FEwrong_type_only_arg(@[si::foreign-data-address], f,
ffi.d:                                      @[si::foreign-data]);
ffi.d:	@(return ecl_make_unsigned_integer((cl_index)f->foreign.data))
ffi.d:                FEwrong_type_only_arg(@[si::foreign-data-tag], f,
ffi.d:                                      @[si::foreign-data]);
ffi.d:	@(return f->foreign.tag);
ffi.d:                FEwrong_type_only_arg(@[si::foreign-data-address], f1,
ffi.d:                                      @[si::foreign-data]);
ffi.d:                FEwrong_type_only_arg(@[si::foreign-data-address], f2,
ffi.d:                                      @[si::foreign-data]);
ffi.d:	@(return ((f1->foreign.data == f2->foreign.data)? ECL_T : ECL_NIL))
ffi.d:                FEwrong_type_only_arg(@[si::foreign-data-pointer], f,
ffi.d:                                      @[si::foreign-data]);
ffi.d:	if (ecl_unlikely(ndx >= f->foreign.size || (f->foreign.size - ndx) < size)) {
ffi.d:	output->foreign.tag = tag;
ffi.d:	output->foreign.size = size;
ffi.d:	output->foreign.data = f->foreign.data + ndx;
ffi.d:                FEwrong_type_nth_arg(@[si::foreign-data-ref], 1, f,
ffi.d:                                     @[si::foreign-data]);
ffi.d:	if (ecl_unlikely(ndx >= f->foreign.size || (f->foreign.size - ndx) < size)) {
ffi.d:	memcpy(output->foreign.data, f->foreign.data + ndx, size);
ffi.d:                FEwrong_type_nth_arg(@[si::foreign-data-set], 1, f,
ffi.d:                                     @[si::foreign-data]);
ffi.d:                FEwrong_type_nth_arg(@[si::foreign-data-set], 3, value,
ffi.d:                                     @[si::foreign-data]);
ffi.d:	size = value->foreign.size;
ffi.d:	limit = f->foreign.size;
ffi.d:	if (ecl_unlikely(ndx >= limit || (limit - ndx) < size)) {
ffi.d:	memcpy(f->foreign.data + ndx, value->foreign.data, size);
ffi.d:        return -1;
ffi.d:		return ecl_make_foreign_data(@':pointer-void', 0, *(void **)p);
ffi.d:                        ecl_make_simple_base_string(*(char **)p, -1) : ECL_NIL;
ffi.d:		*(char **)p = value == ECL_NIL ? NULL : (char*)value->base_string.self;
ffi.d:	cl_index limit = f->foreign.size;
ffi.d:                FEwrong_type_nth_arg(@[si::foreign-data-ref-elt], 1, f,
ffi.d:                                     @[si::foreign-data]);
ffi.d:	@(return ecl_foreign_data_ref_elt((void*)(f->foreign.data + ndx), tag))
ffi.d:	cl_index limit = f->foreign.size;
ffi.d:                FEwrong_type_nth_arg(@[si::foreign-data-set-elt], 1, f,
ffi.d:                                     @[si::foreign-data]);
ffi.d:	ecl_foreign_data_set_elt((void*)(f->foreign.data + ndx), tag, value);
ffi.d:                FEwrong_type_only_arg(@[si::null-pointer-p], f,
ffi.d:                                      @[si::foreign-data]);
ffi.d:	@(return ((f->foreign.data == NULL)? ECL_T : ECL_NIL))
ffi.d:                FEwrong_type_nth_arg(@[si::foreign-data-recast], 1, f,
ffi.d:                                     @[si::foreign-data]);
ffi.d:	f->foreign.size = ecl_to_size(size);
ffi.d:	f->foreign.tag = tag;
ffi.d:	FEerror("SI:LOAD-FOREIGN-MODULE does not work when ECL is statically linked", 0);
ffi.d:	mp_get_lock(1, ecl_symbol_value(@'mp::+load-compile-lock+'));
ffi.d:	if (output->cblock.handle == NULL) {
ffi.d:	mp_giveup_lock(ecl_symbol_value(@'mp::+load-compile-lock+'));
ffi.d:		FEerror("LOAD-FOREIGN-MODULE: Could not load "
ffi.d:        output->cblock.locked |= 1;
ffi.d:	FEerror("SI:FIND-FOREIGN-SYMBOL does not work when ECL is statically linked", 0);
ffi.d:	sym = ecl_library_symbol(block, (char*)var->base_string.self, 1);
ffi.d:		FEerror("FIND-FOREIGN-SYMBOL: Could not load "
ffi.d:	FEerror("Stack overflow on SI:CALL-CFUN", 0);
ffi.d:	fficall->buffer_sp = fficall->buffer;
ffi.d:	fficall->buffer_size = 0;
ffi.d:	fficall->cstring = ECL_NIL;
ffi.d:	fficall->cc = ecl_foreign_cc_code(cc_type);
ffi.d:        fficall->registers = ecl_fficall_prepare_extra(fficall->registers);
ffi.d:	fficall->buffer_size += bytes;
ffi.d:	if (fficall->buffer_size >= ECL_FFICALL_LIMIT)
ffi.d:	memcpy(fficall->buffer_sp, (char*)data, bytes);
ffi.d:	fficall->buffer_sp += bytes;
ffi.d:		size_t sp = fficall->buffer_sp - fficall->buffer;
ffi.d:		size_t mask = data - 1;
ffi.d:		fficall->buffer_sp = fficall->buffer + new_sp;
ffi.d:		fficall->buffer_size = new_sp;
ffi.d:@(defun si::call-cfun (fun return_type arg_types args &optional (cc_type @':cdecl'))
ffi.d:			FEerror("In SI:CALL-CFUN, mismatch between argument types and argument list: ~A vs ~A", 0);
ffi.d:				fficall->cstring =
ffi.d:					CONS(object, fficall->cstring);
ffi.d:		ecl_foreign_data_set_elt(&fficall->output, type, object);
ffi.d:		ecl_fficall_push_arg(&fficall->output, type);
ffi.d:	object = ecl_foreign_data_ref_elt(&fficall->output, return_type_tag);
ffi.d:	fficall->buffer_size = 0;
ffi.d:	fficall->buffer_sp = fficall->buffer;
ffi.d:	fficall->cstring = ECL_NIL;
ffi.d:@(defun si::make-dynamic-callback (fun sym rtype argtypes &optional (cctype @':cdecl'))
ffi.d:	cbk  = ecl_make_foreign_data(@':pointer-void', 0, ecl_dynamic_callback_make(data, ecl_foreign_cc_code(cctype)));
ffi.d:        memcpy(types, env->ffi_types, env->ffi_args_limit * sizeof(ffi_type*));
ffi.d:        memcpy(values, env->ffi_values, env->ffi_args_limit *
ffi.d:        env->ffi_args_limit = new_size;
ffi.d:        ecl_dealloc(env->ffi_types);
ffi.d:        env->ffi_types = types;
ffi.d:        ecl_dealloc(env->ffi_values);
ffi.d:        env->ffi_values = values;
ffi.d:        ecl_dealloc(env->ffi_values_ptrs);
ffi.d:        env->ffi_values_ptrs = values_ptrs;
ffi.d:        if (!the_env->ffi_args_limit)
ffi.d:        the_env->ffi_types[0] = ecl_type_to_libffi_type[type];
ffi.d:                        FEerror("In CALL-CFUN, types lists is not a proper list", 0);
ffi.d:                if (n >= the_env->ffi_args_limit) {
ffi.d:                the_env->ffi_types[++n] = ecl_type_to_libffi_type[type];
ffi.d:                        ecl_foreign_data_set_elt(the_env->ffi_values + n, type, object);
ffi.d:                memcpy(types, the_env->ffi_types, bytes);
ffi.d:                types = the_env->ffi_types;
ffi.d:                        FEerror("In CALL-CFUN, not a valid ABI: ~A", 1,
ffi.d:                        FEerror("In CALL-CFUN, wrong or malformed argument types", 0);
ffi.d:@(defun si::call-cfun (fun return_type arg_types args &optional (cc_type @':default'))
ffi.d:        ffi_call(&cif, cfun, the_env->ffi_values, (void **)the_env->ffi_values_ptrs);
ffi.d:	object = ecl_foreign_data_ref_elt(the_env->ffi_values,
ffi.d:@(defun si::make-dynamic-callback (fun sym return_type arg_types
ffi.d:        cl_object closure_object = ecl_make_foreign_data(@':pointer-void',
ffi.d:        si_set_finalizer(closure_object, @'si::free-ffi-closure');
ffi.d:                                 ecl_make_foreign_data(@':pointer-void',
ffi.d:                                 ecl_make_foreign_data(@':pointer-void',
file.d:/* -*- mode: c; c-basic-offset: 4 -*- */
file.d:  file.d -- File interface.
file.d:  IMPLEMENTATION-DEPENDENT
file.d:#include <ecl/ecl-inl.h>
file.d: * This currently corresponds to (4 + 2) for the ISO-2022-JP-* encodings
file.d:    return -1;
file.d:    return -1;
file.d:    return -1;
file.d:    FEerror("file-position not implemented for stream ~S", 1, strm);
file.d:    FEerror("file-position not implemented for stream ~S", 1, strm);
file.d:    if (strm->stream.ops->read_byte8(strm, &c, 1) < 1) {
file.d:    strm->stream.ops->write_byte8(strm, &c, 1);
file.d:    if (strm->stream.ops->read_byte8(strm, (unsigned char *)&c, 1) < 1)
file.d:    strm->stream.ops->write_byte8(strm, (unsigned char *)&c, 1);
file.d:    read_byte8 = strm->stream.ops->read_byte8;
file.d:    bs = strm->stream.byte_size;
file.d:    for (nb = 0; bs >= 8; bs -= 8, nb += 8) {
file.d:        if (bs <= 8 && (strm->stream.flags & ECL_STREAM_SIGNED_BYTES))
file.d:    write_byte8 = strm->stream.ops->write_byte8;
file.d:    bs = strm->stream.byte_size;
file.d:        c = cl_ash(c, ecl_make_fixnum(-8));
file.d:        bs -= 8;
file.d:    read_byte8 = strm->stream.ops->read_byte8;
file.d:    bs = strm->stream.byte_size;
file.d:    for (; bs >= 8; bs -= 8) {
file.d:        } else if (strm->stream.flags & ECL_STREAM_SIGNED_BYTES) {
file.d:    write_byte8 = strm->stream.ops->write_byte8;
file.d:    bs = strm->stream.byte_size;
file.d:        bs -= 8;
file.d:        b = cl_logand(2, ecl_make_fixnum(0xFF), bs? cl_ash(c, ecl_make_fixnum(-bs)) : c);
file.d:    struct ecl_file_ops *ops = strm->stream.ops;
file.d:        ops->read_byte8 = closed_stream_read_byte8;
file.d:        ops->read_char = closed_stream_read_char;
file.d:        ops->unread_char = closed_stream_unread_char;
file.d:        ops->listen = closed_stream_listen;
file.d:        ops->clear_input = closed_stream_clear_input;
file.d:        ops->write_byte8 = closed_stream_write_byte8;
file.d:        ops->write_char = closed_stream_write_char;
file.d:        ops->clear_output = closed_stream_clear_output;
file.d:        ops->force_output = closed_stream_force_output;
file.d:        ops->finish_output = closed_stream_finish_output;
file.d:    ops->get_position = closed_stream_get_position;
file.d:    ops->set_position = closed_stream_set_position;
file.d:    ops->length = closed_stream_length;
file.d:    ops->close = generic_close;
file.d:    strm->stream.closed = 1;
file.d:        ecl_character (*write_char)(cl_object, ecl_character) = ops->write_char;            
file.d:        void (*write_byte)(cl_object, cl_object) = ops->write_byte;
file.d:    if (expected_type == @'base-char' || expected_type == @'character') {
file.d:        ecl_character (*read_char)(cl_object) = ops->read_char;            
file.d:        cl_object (*read_byte)(cl_object) = ops->read_byte;
file.d:    unlikely_if (c != strm->stream.last_char) {
file.d:        cl_object l = strm->stream.byte_stack;
file.d:        cl_fixnum i = strm->stream.last_code[0];
file.d:            ndx += strm->stream.encoder(strm, buffer, i);
file.d:        i = strm->stream.last_code[1];
file.d:            ndx += strm->stream.encoder(strm, buffer+ndx, i);
file.d:            l = CONS(ecl_make_fixnum(buffer[--ndx]), l);
file.d:        strm->stream.byte_stack = l;
file.d:        strm->stream.last_char = EOF;
file.d:    ecl_character c = strm->stream.decoder(strm);
file.d:    unlikely_if (c == strm->stream.eof_char)
file.d:        strm->stream.last_char = c;
file.d:        strm->stream.last_code[0] = c;
file.d:        strm->stream.last_code[1] = EOF;
file.d:    nbytes = strm->stream.encoder(strm, buffer, c);
file.d:    strm->stream.ops->write_byte8(strm, buffer, nbytes);
file.d:        strm->stream.column = 0;
file.d:        strm->stream.column = (strm->stream.column & ~((cl_index)07)) + 8;
file.d:        strm->stream.column++;
file.d:        strm->stream.last_char = c;
file.d:        strm->stream.column = 0;
file.d:            strm->stream.last_code[0] = ECL_CHAR_CODE_RETURN;
file.d:            strm->stream.last_code[1] = c;
file.d:            strm->stream.last_code[0] = c;
file.d:            strm->stream.last_code[1] = EOF;
file.d:        strm->stream.last_char = c;
file.d:        strm->stream.column = 0;
file.d: * If we use Unicode, this is LATIN-1, ISO-8859-1, that is the 256
file.d: * US ASCII, that is the 128 (0-127) lowest codes of Unicode
file.d: * UCS-4 BIG ENDIAN
file.d: * UCS-4 LITTLE ENDIAN
file.d: * UCS-4 BOM ENDIAN
file.d:        stream->stream.decoder = ucs_4be_decoder;
file.d:        stream->stream.encoder = ucs_4be_encoder;
file.d:        stream->stream.decoder = ucs_4le_decoder;
file.d:        stream->stream.encoder = ucs_4le_encoder;
file.d:        stream->stream.decoder = ucs_4be_decoder;
file.d:        stream->stream.encoder = ucs_4be_encoder;
file.d:    stream->stream.decoder = ucs_4be_decoder;
file.d:    stream->stream.encoder = ucs_4be_encoder;
file.d: * UTF-16 BIG ENDIAN
file.d:        c -= 0x10000;
file.d: * UTF-16 LITTLE ENDIAN
file.d:        c -= 0x10000;
file.d: * UTF-16 BOM ENDIAN
file.d:        stream->stream.decoder = ucs_2be_decoder;
file.d:        stream->stream.encoder = ucs_2be_encoder;
file.d:        stream->stream.decoder = ucs_2le_decoder;
file.d:        stream->stream.encoder = ucs_2le_encoder;
file.d:        stream->stream.decoder = ucs_2be_decoder;
file.d:        stream->stream.encoder = ucs_2be_encoder;
file.d:    stream->stream.decoder = ucs_2be_decoder;
file.d:    stream->stream.encoder = ucs_2be_encoder;
file.d:    cl_object table = stream->stream.format_table;
file.d:    cl_object byte = ecl_gethash_safe(ECL_CODE_CHAR(c), stream->stream.format_table, ECL_NIL);
file.d:    cl_object table_list = stream->stream.format_table;
file.d:            stream->stream.format_table = table_list = character;
file.d:    cl_object table_list = stream->stream.format_table;
file.d:                stream->stream.format_table = p;
file.d: * UTF-8
file.d:        cl_object byte = _ecl_funcall2(@'gray::stream-read-byte', strm);
file.d:        cl_object byte = _ecl_funcall3(@'gray::stream-write-byte', strm,
file.d:    cl_object b = _ecl_funcall2(@'gray::stream-read-byte', strm);
file.d:    _ecl_funcall3(@'gray::stream-write-byte', strm, c);
file.d:    cl_object output = _ecl_funcall2(@'gray::stream-read-char', strm);
file.d:        value = -1;
file.d:    _ecl_funcall3(@'gray::stream-write-char', strm, ECL_CODE_CHAR(c));
file.d:    _ecl_funcall3(@'gray::stream-unread-char', strm, ECL_CODE_CHAR(c));
file.d:    cl_object out = _ecl_funcall2(@'gray::stream-peek-char', strm);
file.d:    return !Null(_ecl_funcall2(@'gray::stream-listen', strm));
file.d:    _ecl_funcall2(@'gray::stream-clear-input', strm);
file.d:    _ecl_funcall2(@'gray::stream-clear-output', strm);
file.d:    _ecl_funcall2(@'gray::stream-force-output', strm);
file.d:    _ecl_funcall2(@'gray::stream-finish-output', strm);
file.d:    return !Null(_ecl_funcall2(@'gray::input-stream-p', strm));
file.d:    return !Null(_ecl_funcall2(@'gray::output-stream-p', strm));
file.d:    return !Null(_ecl_funcall2(@'gray::stream-interactive-p', strm));
file.d:    return _ecl_funcall2(@'gray::stream-element-type', strm);
file.d:    return _ecl_funcall2(@'gray::stream-file-position', strm);
file.d:    return _ecl_funcall3(@'gray::stream-file-position', strm, pos);
file.d:    cl_object col = _ecl_funcall2(@'gray::stream-line-column', strm);
file.d:    int column = strm->stream.column;
file.d:        strm->stream.column = 0;
file.d:        strm->stream.column = (column&~(cl_index)7) + 8;
file.d:        strm->stream.column++;
file.d:        return @'base-char';
file.d:    return ecl_make_unsigned_integer(STRING_OUTPUT_STRING(strm)->base_string.fillp);
file.d:        disp = strm->base_string.dim;
file.d:    if (disp < string->base_string.fillp) {
file.d:        string->base_string.fillp = disp;
file.d:        disp -= string->base_string.fillp;
file.d:        while (disp-- > 0)
file.d:    return strm->stream.column;
file.d:    generic_void, /* clear-output */
file.d:    generic_void, /* finish-output */
file.d:    generic_void, /* force-output */
file.d:        FEerror("~S is not a -string with a fill-pointer.", 1, s);
file.d:    strm->stream.ops = duplicate_dispatch_table(&str_out_ops);
file.d:    strm->stream.mode = (short)ecl_smm_string_output;
file.d:    strm->stream.column = 0;
file.d:    strm->stream.format = @':pass-through';
file.d:    strm->stream.flags = ECL_STREAM_DEFAULT_FORMAT;
file.d:    strm->stream.byte_size = 8;
file.d:        strm->stream.format = @':latin-1';
file.d:        strm->stream.flags = ECL_STREAM_LATIN_1;
file.d:        strm->stream.byte_size = 8;
file.d:        strm->stream.format = @':ucs-4';
file.d:        strm->stream.flags = ECL_STREAM_UCS_4;
file.d:        strm->stream.byte_size = 32;
file.d:@(defun make-string-output-stream (&key (element_type @'character'))
file.d:  if (element_type == @'base-char') {
file.d:  } else if (!Null(_ecl_funcall3(@'subtypep', element_type, @'base-char'))) {
file.d:      FEerror("In MAKE-STRING-OUTPUT-STREAM, the argument :ELEMENT-TYPE (~A) must be a subtype of character",
file.d:        FEwrong_type_only_arg(@[get-output-stream-string],
file.d:                              strm, @[string-stream]);
file.d:    STRING_OUTPUT_STRING(strm)->base_string.fillp = 0;
file.d:    STRING_INPUT_POSITION(strm) = curr_pos - 1;
file.d:        return @'base-char';
file.d:    generic_void, /* clear-input */
file.d:    strm->stream.ops = duplicate_dispatch_table(&str_in_ops);
file.d:    strm->stream.mode = (short)ecl_smm_string_input;
file.d:    strm->stream.format = @':pass-through';
file.d:    strm->stream.flags = ECL_STREAM_DEFAULT_FORMAT;
file.d:    strm->stream.byte_size = 8;
file.d:        strm->stream.format = @':latin-1';
file.d:        strm->stream.flags = ECL_STREAM_LATIN_1;
file.d:        strm->stream.byte_size = 8;
file.d:        strm->stream.format = @':ucs-4';
file.d:        strm->stream.flags = ECL_STREAM_UCS_4;
file.d:        strm->stream.byte_size = 32;
file.d:  p = ecl_vector_start_end(@[make-string-input-stream], strng, istart, iend);
file.d:    return stream_dispatch_table(strm)->read_vector(strm, data, start, n);
file.d:    return stream_dispatch_table(strm)->write_vector(strm, data, start, n);
file.d:    if (strm->stream.flags & ECL_STREAM_CLOSE_COMPONENTS) {
file.d:    strm->stream.format = cl_stream_external_format(istrm);
file.d:    strm->stream.mode = (short)ecl_smm_two_way;
file.d:    strm->stream.ops = duplicate_dispatch_table(&two_way_ops);
file.d:        FEwrong_type_only_arg(@[two-way-stream-input-stream],
file.d:                              strm, @[two-way-stream]);
file.d:        FEwrong_type_only_arg(@[two-way-stream-output-stream],
file.d:                              strm, @[two-way-stream]);
file.d:    if (strm->stream.flags & ECL_STREAM_CLOSE_COMPONENTS) {
file.d:  x->stream.format = @':default';
file.d:  x->stream.ops = duplicate_dispatch_table(&broadcast_ops);
file.d:  x->stream.mode = (short)ecl_smm_broadcast;
file.d:        FEwrong_type_only_arg(@[broadcast-stream-streams],
file.d:                              strm, @[broadcast-stream]);
file.d:    ecl_character c = strm->stream.last_code[0];
file.d:        strm->stream.last_code[0] = EOF;
file.d:    unlikely_if (strm->stream.last_code[0] != EOF) {
file.d:    strm->stream.last_code[0] = c;
file.d:    ecl_character c = strm->stream.last_code[0];
file.d:    if (strm->stream.flags & ECL_STREAM_CLOSE_COMPONENTS) {
file.d:    strm->stream.format = cl_stream_external_format(strm1);
file.d:    strm->stream.mode = (short)ecl_smm_echo;
file.d:    strm->stream.ops = duplicate_dispatch_table(&echo_ops);
file.d:        FEwrong_type_only_arg(@[echo-stream-input-stream],
file.d:                              strm, @[echo-stream]);
file.d:        FEwrong_type_only_arg(@[echo-stream-output-stream],
file.d:                              strm, @[echo-stream]);
file.d:        cl_index delta = ecl_read_byte8(ECL_CONS_CAR(l), c + out, n - out);
file.d:    if (strm->stream.flags & ECL_STREAM_CLOSE_COMPONENTS) {
file.d:      x->stream.format = @':pass-through';
file.d:      x->stream.format = cl_stream_external_format(ECL_CONS_CAR(streams));
file.d:  x->stream.mode = (short)ecl_smm_concatenated;
file.d:  x->stream.ops = duplicate_dispatch_table(&concatenated_ops);
file.d:        FEwrong_type_only_arg(@[concatenated-stream-streams],
file.d:                              strm, @[concatenated-stream]);
file.d:    return stream_dispatch_table(strm)->read_vector(strm, data, start, n);
file.d:    return stream_dispatch_table(strm)->write_vector(strm, data, start, n);
file.d:    sym = ecl_check_cl_type(@'make-synonym-stream',sym,t_symbol);
file.d:    x->stream.ops = duplicate_dispatch_table(&synonym_ops);
file.d:    x->stream.mode = (short)ecl_smm_synonym;
file.d:        FEwrong_type_only_arg(@[synonym-stream-symbol],
file.d:                              strm, @[synonym-stream]);
file.d:        cl_object l = strm->stream.byte_stack;
file.d:            return out + strm->stream.ops->read_byte8(strm, c, n);
file.d:        n--;
file.d:        strm->stream.byte_stack = l = ECL_CONS_CDR(l);
file.d:    unlikely_if (strm->stream.byte_stack != ECL_NIL) {
file.d:    unlikely_if (strm->stream.byte_stack != ECL_NIL) {
file.d:        strm->stream.byte_stack = ECL_NIL;
file.d:    if (strm->stream.byte_stack != ECL_NIL)
file.d:    if (strm->stream.flags & ECL_STREAM_MIGHT_SEEK) {
file.d:        if (disp != (ecl_off_t)-1) {
file.d:            } else if (new != (ecl_off_t)-1) {
file.d:    if (strm->stream.byte_size != 8) {
file.d:        cl_index bs = strm->stream.byte_size;
file.d:        cl_object l = strm->stream.byte_stack;
file.d:    if (strm->stream.byte_size != 8) {
file.d:        output = ecl_floor2(output, ecl_make_fixnum(strm->stream.byte_size / 8));
file.d:        if (strm->stream.byte_size != 8) {
file.d:                                   ecl_make_fixnum(strm->stream.byte_size / 8));
file.d:    return (disp == (ecl_off_t)-1)? ECL_NIL : ECL_T;
file.d:    return strm->stream.column;
file.d:    IO_FILE_DESCRIPTOR(strm) = -1;
file.d:        if (strm->stream.byte_size == 8) {
file.d:            void *aux = data->vector.self.bc + start;
file.d:            return start + strm->stream.ops->read_byte8(strm, aux, end-start);
file.d:        if (strm->stream.byte_size == sizeof(cl_fixnum)*8) {
file.d:            void *aux = data->vector.self.fix + start;
file.d:            cl_index bytes = (end - start) * sizeof(cl_fixnum);
file.d:            bytes = strm->stream.ops->read_byte8(strm, aux, bytes);
file.d:        if (strm->stream.byte_size == 8) {
file.d:            void *aux = data->vector.self.bc + start;
file.d:            return strm->stream.ops->write_byte8(strm, aux, end-start);
file.d:        if (strm->stream.byte_size == sizeof(cl_fixnum)*8) {
file.d:            void *aux = data->vector.self.fix + start;
file.d:            cl_index bytes = (end - start) * sizeof(cl_fixnum);
file.d:            bytes = strm->stream.ops->write_byte8(strm, aux, bytes);
file.d:        format = ecl_symbol_value(@'ext::*default-external-format*');
file.d:    if (format == @':LITTLE-ENDIAN') {
file.d:    if (format == @':BIG-ENDIAN') {
file.d:    if (format == @':pass-through') {
file.d:    if (format == @':UTF-8') {
file.d:    if (format == @':UCS-2') {
file.d:    if (format == @':UCS-2BE') {
file.d:    if (format == @':UCS-2LE') {
file.d:    if (format == @':UCS-4') {
file.d:    if (format == @':UCS-4BE') {
file.d:    if (format == @':UCS-4LE') {
file.d:    if (format == @':ISO-8859-1') {
file.d:    if (format == @':LATIN-1') {
file.d:    if (format == @':US-ASCII') {
file.d:        stream->stream.format_table = format;
file.d:        format = _ecl_funcall2(@'ext::make-encoding', format);
file.d:        stream->stream.format_table = format;
file.d:        byte_size = -byte_size;
file.d:        t = @'signed-byte';
file.d:        t = @'unsigned-byte';
file.d:    stream->stream.ops->read_char = eformat_read_char;
file.d:    stream->stream.ops->write_char = eformat_write_char;
file.d:            stream->stream.format = t;
file.d:            stream->stream.ops->read_char = not_character_read_char;
file.d:            stream->stream.ops->write_char = not_character_write_char;
file.d:            IO_STREAM_ELT_TYPE(stream) = @'base-char';
file.d:            stream->stream.format = @':latin-1';
file.d:            stream->stream.encoder = passthrough_encoder;
file.d:            stream->stream.decoder = passthrough_decoder;
file.d:            stream->stream.format = @':utf-8';
file.d:            stream->stream.encoder = utf_8_encoder;
file.d:            stream->stream.decoder = utf_8_decoder;
file.d:            stream->stream.format = @':ucs-2';
file.d:            stream->stream.encoder = ucs_2_encoder;
file.d:            stream->stream.decoder = ucs_2_decoder;
file.d:                stream->stream.format = @':ucs-2le';
file.d:                stream->stream.encoder = ucs_2le_encoder;
file.d:                stream->stream.decoder = ucs_2le_decoder;
file.d:                stream->stream.format = @':ucs-2be';
file.d:                stream->stream.encoder = ucs_2be_encoder;
file.d:                stream->stream.decoder = ucs_2be_decoder;
file.d:            stream->stream.format = @':ucs-4be';
file.d:            stream->stream.encoder = ucs_4_encoder;
file.d:            stream->stream.decoder = ucs_4_decoder;
file.d:                stream->stream.format = @':ucs-4le';
file.d:                stream->stream.encoder = ucs_4le_encoder;
file.d:                stream->stream.decoder = ucs_4le_decoder;
file.d:                stream->stream.format = @':ucs-4be';
file.d:                stream->stream.encoder = ucs_4be_encoder;
file.d:                stream->stream.decoder = ucs_4be_decoder;
file.d:            stream->stream.format = stream->stream.format_table;
file.d:            if (CONSP(stream->stream.format)) {
file.d:                stream->stream.encoder = user_multistate_encoder;
file.d:                stream->stream.decoder = user_multistate_decoder;
file.d:                stream->stream.encoder = user_encoder;
file.d:                stream->stream.decoder = user_decoder;
file.d:            IO_STREAM_ELT_TYPE(stream) = @'base-char';
file.d:            stream->stream.format = @':us-ascii';
file.d:            stream->stream.encoder = ascii_encoder;
file.d:            stream->stream.decoder = ascii_decoder;
file.d:            IO_STREAM_ELT_TYPE(stream) = @'base-char';
file.d:            stream->stream.format = @':pass-through';
file.d:            stream->stream.encoder = passthrough_encoder;
file.d:            stream->stream.decoder = passthrough_decoder;
file.d:    if (stream->stream.ops->write_char == eformat_write_char &&
file.d:            stream->stream.ops->read_char = eformat_read_char_crlf;
file.d:            stream->stream.ops->write_char = eformat_write_char_crlf;
file.d:            stream->stream.ops->read_char = eformat_read_char_cr;
file.d:            stream->stream.ops->write_char = eformat_write_char_cr;
file.d:    stream->stream.format = cl_list(2, stream->stream.format, t);
file.d:            stream->stream.ops->read_byte = read_byte;
file.d:            stream->stream.ops->write_byte = write_byte;
file.d:    stream->stream.flags = flags;
file.d:    stream->stream.byte_size = byte_size;
file.d:    switch (stream->stream.mode) {
file.d:                             elt_type != @'base-char')
file.d:                set_stream_elt_type(stream, stream->stream.byte_size,
file.d:                                    stream->stream.flags, format);
file.d:            stream->stream.ops = duplicate_dispatch_table(&input_file_ops);
file.d:            stream->stream.ops = duplicate_dispatch_table(&output_file_ops);
file.d:            stream->stream.ops = duplicate_dispatch_table(&io_file_ops);
file.d:    stream->stream.mode = (short)smm;
file.d:    stream->stream.closed = 0;
file.d:    stream->stream.column = 0;
file.d:    stream->stream.last_op = 0;
file.d:    unlikely_if (strm->stream.byte_stack != ECL_NIL) {
file.d:    if (strm->stream.byte_stack != ECL_NIL) {
file.d:    } else if (strm->stream.last_op > 0) {
file.d:    strm->stream.last_op = -1;
file.d:    if (strm->stream.last_op < 0) {
file.d:    strm->stream.last_op = +1;
file.d:    if (strm->stream.byte_stack != ECL_NIL)
file.d:    if (strm->stream.byte_size != 8) {
file.d:        cl_index bs = strm->stream.byte_size;
file.d:        cl_object l = strm->stream.byte_stack;
file.d:    if (strm->stream.byte_size != 8) {
file.d:        output = ecl_floor2(output, ecl_make_fixnum(strm->stream.byte_size / 8));
file.d:        if (strm->stream.byte_size != 8) {
file.d:                                   ecl_make_fixnum(strm->stream.byte_size / 8));
file.d:    return strm->stream.column;
file.d:    ecl_dealloc(strm->stream.buffer);
file.d://     unlikely_if (strm->stream.byte_stack != ECL_NIL) {
file.d://                 n -= res;
file.d://     unlikely_if (strm->stream.byte_stack != ECL_NIL) {
file.d://     unlikely_if (strm->stream.byte_stack != ECL_NIL) {
file.d://                     strm->stream.byte_stack =
file.d://                         ecl_nconc(strm->stream.byte_stack,
file.d://         output->stream.eof_char = CONTROL_Z;
file.d://         output->stream.eof_char = CONTROL_Z;
file.d:    enum ecl_smmode mode = stream->stream.mode;
file.d:    else if (buffer_mode_symbol == @':line' || buffer_mode_symbol == @':line-buffered')
file.d:    else if (buffer_mode_symbol == @':full' || buffer_mode_symbol == @':fully-buffered')
file.d:            stream->stream.buffer = new_buffer;
file.d:    stream->stream.mode = (short)smm;
file.d:    stream->stream.closed = 0;
file.d:            stream->stream.ops = duplicate_dispatch_table(&io_stream_ops);
file.d:            stream->stream.ops = duplicate_dispatch_table(&input_stream_ops);
file.d:            stream->stream.ops = duplicate_dispatch_table(&output_stream_ops);
file.d:    stream->stream.column = 0;
file.d:    stream->stream.last_op = 0;
file.d:        return -1;
file.d:    switch ((enum ecl_smmode)s->stream.mode) {
file.d:            if (output) return -1;
file.d:            if (output) return -1;
file.d:            if (!output) return -1;
file.d:            if (!output) return -1;
file.d:            return -1;
file.d:    switch ((enum ecl_smmode)s->stream.mode) {
file.d:    cl_fixnum delta = last - curr_pos;
file.d:        memcpy(c, vector->vector.self.bc + curr_pos, delta);
file.d:    SEQ_INPUT_POSITION(strm) -= ecl_length(strm->stream.byte_stack);
file.d:    strm->stream.byte_stack = ECL_NIL;
file.d:    generic_void, /* clear-input */
file.d:            FEerror("MAKE-SEQUENCE-INPUT-STREAM only accepts vectors whose element has a size of 1 byte.~%~A", 1, vector);
file.d:    strm->stream.ops = duplicate_dispatch_table(&seq_in_ops);
file.d:    strm->stream.mode = (short)ecl_smm_sequence_input;
file.d:                external_format = @':ucs-4be';
file.d:                external_format = @':ucs-4le';
file.d:    if (byte_size) strm->stream.byte_size = byte_size;
file.d:  p = ecl_vector_start_end(@[ext::make-sequence-input-stream],
file.d:        cl_fixnum last = vector->vector.dim;
file.d:        cl_fixnum delta = last - curr_pos;
file.d:            vector = _ecl_funcall3(@'adjust-array', vector,
file.d:        memcpy(vector->vector.self.bc + curr_pos, c, n);
file.d:        if (vector->vector.fillp < curr_pos)
file.d:            vector->vector.fillp = curr_pos;
file.d:        disp = vector->vector.fillp;
file.d:        if (disp >= vector->vector.dim) {
file.d:            disp = vector->vector.fillp;
file.d:    generic_void, /* clear-output */
file.d:    generic_void, /* finish-output */
file.d:    generic_void, /* force-output */
file.d:            FEerror("MAKE-SEQUENCE-OUTPUT-STREAM only accepts vectors whose element has a size of 1 byte.~%~A", 1, vector);
file.d:    strm->stream.ops = duplicate_dispatch_table(&seq_out_ops);
file.d:    strm->stream.mode = (short)ecl_smm_sequence_output;
file.d:                external_format = @':ucs-4be';
file.d:                external_format = @':ucs-4le';
file.d:    if (byte_size) strm->stream.byte_size = byte_size;
file.d:    SEQ_OUTPUT_POSITION(strm) = vector->vector.fillp;
file.d:    // nlogd(">>CLOS-STREAM :YES");
file.d:    return (const struct ecl_file_ops *)strm->stream.ops;
file.d:    return ((cl_index (*)(cl_object , unsigned char *, cl_index ))(op->read_byte8))(strm, c, n);
file.d:    return stream_dispatch_table(strm)->write_byte8(strm, c, n);
file.d:    nlogd(">>ecl_read_char1 ---------------------------------------- strm(%ld)", strm);
file.d:    //ecl_character a = ((ecl_character(*)(cl_object strm))((ops)->read_char))(strm);
file.d:    ecl_character a = ((ops)->read_char)(strm);
file.d:    nlogd(">>ecl_read_char2 ----------------------------------------");
file.d:    return stream_dispatch_table(strm)->read_byte(strm);
file.d:    stream_dispatch_table(strm)->write_byte(c, strm);
file.d:    return stream_dispatch_table(strm)->write_char(strm, c);
file.d:    stream_dispatch_table(strm)->unread_char(strm, c);
file.d:    return stream_dispatch_table(strm)->listen(strm);
file.d:    stream_dispatch_table(strm)->clear_input(strm);
file.d:    stream_dispatch_table(strm)->clear_output(strm);
file.d:    stream_dispatch_table(strm)->force_output(strm);
file.d:    stream_dispatch_table(strm)->finish_output(strm);
file.d:    return stream_dispatch_table(strm)->column(strm);
file.d:    return stream_dispatch_table(strm)->length(strm);
file.d:    return stream_dispatch_table(strm)->get_position(strm);
file.d:    return stream_dispatch_table(strm)->set_position(strm, pos);
file.d:    return stream_dispatch_table(strm)->input_p(strm);
file.d:    return stream_dispatch_table(strm)->output_p(strm);
file.d:    return stream_dispatch_table(strm)->element_type(strm);
file.d:    return stream_dispatch_table(strm)->interactive_p(strm);
file.d: * CLOS-STREAMS and S is an instance object, STREAM-READ-CHAR is invoked
file.d: * to retrieve the character. Then STREAM-READ-CHAR should either
file.d:    return stream_dispatch_table(strm)->peek_char(strm);
file.d:        int flags = stream->stream.flags;
file.d:            l += stream->stream.encoder(stream, buffer, ECL_CHAR_CODE_RETURN);
file.d:                l += stream->stream.encoder(stream, buffer,
file.d:            l += stream->stream.encoder(stream, buffer, ECL_CHAR_CODE_LINEFEED);
file.d:        l += stream->stream.encoder(stream, buffer, c);
file.d:        FEwrong_type_only_arg(@[file-string-length], stream, @[stream]);
file.d:    if (stream->stream.mode == ecl_smm_broadcast) {
file.d:            for (i = 0; i < string->base_string.fillp; i++) {
file.d:            FEwrong_type_nth_arg(@[file-string-length], 2, string, @[string]);
file.d:        FEwrong_type_key_arg(@[write-sequence], @[:start], s,
file.d:                                                   ecl_make_fixnum(limit-1)));
file.d:        FEwrong_type_key_arg(@[write-sequence], @[:end], e,
file.d:        bool ischar = (elt_type == @'base-char') || (elt_type == @'character');
file.d:                    ops->write_char(stream, ecl_char_code(elt));
file.d:                    ops->write_byte(elt, stream);
file.d:        ops->write_vector(stream, seq, start, end);
file.d:        FEwrong_type_key_arg(@[read-sequence], @[:start], s,
file.d:                                                   ecl_make_fixnum(limit-1)));
file.d:        FEwrong_type_key_arg(@[read-sequence], @[:end], e,
file.d:        bool ischar = (elt_type == @'base-char') || (elt_type == @'character');
file.d:                    int i = ops->read_char(stream);
file.d:                    c = ops->read_byte(stream);
file.d:        start = ops->read_vector(stream, seq, start, end);
file.d:@(defun file-position (file_stream &o position)
file.d:    @(return (stream_dispatch_table(strm)->interactive_p(strm)? ECL_T : ECL_NIL))
file.d:    /* ANSI and Cltl2 specify that open-stream-p should work
file.d:        return _ecl_funcall2(@'gray::open-stream-p', strm);
file.d:        FEwrong_type_only_arg(@'open-stream-p', strm, @'stream');
file.d:    @(return (strm->stream.closed ? ECL_NIL : ECL_T))
file.d:            FEwrong_type_only_arg(@[stream-external-format], strm, @[stream]);
file.d:    if (strm->stream.mode == ecl_smm_synonym) {
file.d:    output = strm->stream.format;
file.d:    if (element_type == @'signed-byte' || element_type == @'ext::integer8') {
file.d:        return -8;
file.d:    } else if (element_type == @'unsigned-byte' || element_type == @'ext::byte8') {
file.d:    } else if (element_type == @'base-char' || element_type == @'character') {
file.d:    } else if (_ecl_funcall3(@'subtypep', element_type, @'unsigned-byte') != ECL_NIL) {
file.d:    } else if (_ecl_funcall3(@'subtypep', element_type, @'signed-byte') != ECL_NIL) {
file.d:        sign = -1;
file.d:        if (CAR(element_type) == @'unsigned-byte')
file.d:        if (CAR(element_type) == @'signed-byte')
file.d:            return -ecl_to_size(cl_cadr(element_type));
file.d:        type = cl_list(2, sign>0? @'unsigned-byte' : @'signed-byte',
file.d:    char *fname = (char*)filename->base_string.self;
file.d:                FEinvalid_option(@':if-does-not-exist',
file.d:                FEinvalid_option(@':if-exists', if_exists);
file.d:                FEinvalid_option(@':if-does-not-exist',
file.d:        output->stream.flags |= ECL_STREAM_MIGHT_SEEK;
file.d:  @(return stream_dispatch_table(strm)->close(strm));
file.d:        file_libc_error(@[stream-error], stream, "Error while listening to stream.", 0);
file.d:    return -3;
file.d:    if (aux != -3)
file.d:            file_libc_error(@[file-error], stream,
file.d:            file_libc_error(@[file-error], stream,
file.d:    x->stream.closed = 0;
file.d:    x->stream.file.descriptor = -1;
file.d:    x->stream.object0 =
file.d:        x->stream.object1 = OBJNULL;
file.d:    x->stream.int0 = x->stream.int1 = 0;
file.d:    x->stream.format = ECL_NIL;
file.d:    x->stream.flags = 0;
file.d:    x->stream.byte_size = 8;
file.d:    x->stream.buffer = NULL;
file.d:    x->stream.encoder = NULL;
file.d:    x->stream.decoder = NULL;
file.d:    x->stream.last_char = EOF;
file.d:    x->stream.byte_stack = ECL_NIL;
file.d:    x->stream.last_code[0] = x->stream.last_code[1] = EOF;
file.d:    x->stream.eof_char = EOF;
file.d:    return cl_error(9, @'simple-type-error', @':format-control',
file.d:                    @':format-arguments', cl_list(1, strm),
file.d:                    @':expected-type', @'file-stream',
file.d:    cl_error(9, @'simple-type-error', @':format-control',
file.d:             @':format-arguments', cl_list(1, strm),
file.d:             @':expected-type',
file.d:             cl_list(2, @'satisfies', @'input-stream-p'),
file.d:    cl_error(9, @'simple-type-error', @':format-control',
file.d:             @':format-arguments', cl_list(1, strm),
file.d:             @':expected-type', cl_list(2, @'satisfies', @'output-stream-p'),
file.d:    cl_error(9, @'simple-type-error', @':format-control',
file.d:             @':format-arguments', cl_list(1, s),
file.d:             @':expected-type', @'character',
file.d:    cl_error(9, @'simple-type-error', @':format-control',
file.d:             @':format-arguments', cl_list(1, s),
file.d:             @':expected-type', @'integer',
file.d:    file_libc_error(@[file-error], stream, "Stream cannot be closed", 0);
file.d:    CEerror(ECL_T, "Error when using UNREAD-CHAR on stream ~D", 1, s);
file.d:    CEerror(ECL_T, "Used UNREAD-CHAR twice on stream ~D", 1, s);
file.d:    int t = strm->stream.mode;
file.d:        file_libc_error(@[stream-error], strm,
file.d:    file_libc_error(@[stream-error], strm,
file.d:    cl_object code = _ecl_funcall4(@'ext::encoding-error', stream,
file.d:        return stream->stream.encoder(stream, buffer, ecl_char_code(code));
file.d:        octets = CONS(ecl_make_fixnum(buffer[--length]), octets);
file.d:    code = _ecl_funcall4(@'ext::decoding-error', stream,
file.d:        return stream->stream.decoder(stream);
file.d:    //     external_format = cl_list(2, @':latin-1', @':crlf');
file.d:    //     external_format = cl_list(2, @':crlf', @':pass-through');
file.d:    ECL_SET(@'ext::+process-standard-input+', standard_input);
file.d:    ECL_SET(@'*standard-input*', standard_input);
file.d:    ECL_SET(@'ext::+process-standard-output+', standard_output);
file.d:    ECL_SET(@'*standard-output*', standard_output);
file.d:    ECL_SET(@'*trace-output*', standard_output);
file.d:    ECL_SET(@'ext::+process-error-output+', error_output);
file.d:    ECL_SET(@'*error-output*', error_output);
file.d:    ECL_SET(@'*terminal-io*', aux);
file.d:    aux = cl_make_synonym_stream(@'*terminal-io*');
file.d:    ECL_SET(@'*query-io*', aux);
file.d:    ECL_SET(@'*debug-io*', aux);
format.d:/* -*- mode: c; c-basic-offset: 8 -*- */
format.d:    format.c -- Format.
format.d:	if (env->fmt_aux_stream == ECL_NIL) {
format.d:		stream = env->fmt_aux_stream;
format.d:		env->fmt_aux_stream = ECL_NIL;
format.d:	cl_error(7, @'si::format-error',
format.d:		 @':format-control', make_constant_base_string(s),
format.d:		 @':control-string', fmt->ctl_str,
format.d:		 @':offset', ecl_make_fixnum(fmt->ctl_index));
format.d:	return ecl_char(fmt->aux_string,s);
format.d:	if (fmt->ctl_index >= fmt->ctl_end)
format.d:	return ecl_char(fmt->ctl_str, fmt->ctl_index++);
format.d:	if ((p = ecl_nthcdr(n, fmt->args)) == ECL_NIL)
format.d:	fmt->current = p;
format.d:	cl_object p = fmt->args, target = fmt->current;
format.d:	while (p != fmt->current) {
format.d:	fmt_go(fmt, fmt_index(fmt) - 1);
format.d:	return fmt->current != ECL_NIL;
format.d:	return ecl_length(fmt->current);
format.d:	cl_object output, l = fmt->current;
format.d:	fmt->current = CDR(l);
format.d:	fmt->current = fmt->args = cl_copy_list(l);
format.d:		case '-':
format.d:			return(fmt->ctl_index);
format.d:			--level;
format.d:			return(fmt->ctl_index);
format.d:	if (fmt->nparam > n)
format.d:	while (n-- > fmt->nparam)
format.d:		fmt->param[n] = ECL_NIL;
format.d:	if (i >= fmt->nparam || fmt->param[i] == ECL_NIL)
format.d:		 (t == INT && !cl_integerp(fmt->param[i])) ||
format.d:		 (t == CHAR && !ECL_CHARACTERP(fmt->param[i])))
format.d:	return fmt->param[i];
format.d:	if (i >= fmt->nparam || fmt->param[i] == ECL_NIL)
format.d:		return -1;
format.d:	else if (cl_integerp(fmt->param[i]) == ECL_NIL)
format.d:		cl_object p = fmt->param[i];
format.d:	fmt_copy->stream = fmt->stream;
format.d:	fmt_copy->ctl_str = fmt->ctl_str;
format.d:	fmt_copy->ctl_index = fmt->ctl_index;
format.d:	fmt_copy->ctl_end = fmt->ctl_end;
format.d:	fmt_copy->jmp_buf = fmt->jmp_buf;
format.d:	fmt_copy->indents = fmt->indents;
format.d:	fmt->aux_string->base_string.fillp = 0;
format.d:	fmt->aux_stream->stream.int0 = ecl_file_column(fmt->stream);
format.d:	fmt->aux_stream->stream.int1 = ecl_file_column(fmt->stream);
format.d:		writestr_stream("()", fmt->aux_stream);
format.d:		ecl_princ(x, fmt->stream);
format.d:		ecl_princ(x, fmt->aux_stream);
format.d:	l = fmt->aux_string->base_string.fillp;
format.d:		ecl_write_string(fmt->aux_string, fmt->stream);
format.d:		while (i-- > 0)
format.d:			ecl_write_char(padchar, fmt->stream);
format.d:		while (i-- > 0)
format.d:			ecl_write_char(padchar, fmt->stream);
format.d:		ecl_write_string(fmt->aux_string, fmt->stream);
format.d:		writestr_stream("()", fmt->aux_stream);
format.d:		ecl_prin1(x, fmt->stream);
format.d:		ecl_prin1(x, fmt->aux_stream);
format.d:	l = fmt->aux_string->base_string.fillp;
format.d:		ecl_write_string(fmt->aux_string, fmt->stream);
format.d:		while (i-- > 0)
format.d:			ecl_write_char(padchar, fmt->stream);
format.d:		while (i-- > 0)
format.d:			ecl_write_char(padchar, fmt->stream);
format.d:		ecl_write_string(fmt->aux_string, fmt->stream);
format.d:		ecl_bds_bind(env, @'*print-escape*', ECL_NIL);
format.d:		ecl_bds_bind(env, @'*print-base*', ecl_make_fixnum(radix));
format.d:		si_write_object(x, fmt->aux_stream);
format.d:		l = fmt->aux_string->base_string.fillp;
format.d:		mincol -= l;
format.d:		while (mincol-- > 0)
format.d:			ecl_write_char(padchar, fmt->stream);
format.d:		ecl_write_string(fmt->aux_string, fmt->stream);
format.d:	ecl_bds_bind(env, @'*print-radix*', ECL_NIL);
format.d:	ecl_bds_bind(env, @'*print-base*', ecl_make_fixnum(radix));
format.d:	si_write_object(x, fmt->aux_stream);
format.d:	l = l1 = fmt->aux_string->base_string.fillp;
format.d:	if (tempstr(fmt, s) == '-')
format.d:		--l1;
format.d:	mincol -= l;
format.d:		mincol -= (l1 - 1)/3;
format.d:	if (atsign && tempstr(fmt, s) != '-')
format.d:		--mincol;
format.d:	while (mincol-- > 0)
format.d:		ecl_write_char(padchar, fmt->stream);
format.d:	if (tempstr(fmt, s) == '-') {
format.d:		ecl_write_char('-', fmt->stream);
format.d:		ecl_write_char('+', fmt->stream);
format.d:	while (l1-- > 0) {
format.d:		ecl_write_char(tempstr(fmt, s++), fmt->stream);
format.d:			ecl_write_char(commachar, fmt->stream);
format.d:	writestr_stream(fmt_numeral[tempstr(fmt, s) - '0' + i], fmt->stream);
format.d:	writestr_stream(fmt_ordinal[tempstr(fmt, s) - '0' + i], fmt->stream);
format.d:			ecl_write_char(' ', fmt->stream);
format.d:		writestr_stream(" hundred", fmt->stream);
format.d:		--i;
format.d:			writestr_stream("th", fmt->stream);
format.d:		--i;
format.d:			ecl_write_char(' ', fmt->stream);
format.d:				ecl_write_char('-', fmt->stream);
format.d:			ecl_write_char(' ', fmt->stream);
format.d:	for (;  i > 3;  i -= j) {
format.d:			ecl_write_char(' ', fmt->stream);
format.d:			writestr_stream(fmt_big_numeral[(i - 1)/3 - 1],
format.d:					fmt->stream);
format.d:				writestr_stream("th", fmt->stream);
format.d:			ecl_write_char(one, fmt->stream);
format.d:		ecl_write_char(one, fmt->stream);
format.d:		ecl_write_char(five, fmt->stream);
format.d:		ecl_write_char(five, fmt->stream);
format.d:			ecl_write_char(one, fmt->stream);
format.d:		ecl_write_char(one, fmt->stream);
format.d:		ecl_write_char(ten, fmt->stream);
format.d:	if (fmt->nparam == 0) {
format.d:				i = -1;
format.d:		ecl_bds_bind(env, @'*print-radix*', ECL_NIL);
format.d:		ecl_bds_bind(env, @'*print-base*', ecl_make_fixnum(10));
format.d:		si_write_object(x, fmt->aux_stream);
format.d:		i = fmt->aux_string->base_string.fillp;
format.d:			writestr_stream("zero", fmt->stream);
format.d:				writestr_stream("th", fmt->stream);
format.d:		} else if (tempstr(fmt, s) == '-') {
format.d:			writestr_stream("minus ", fmt->stream);
format.d:			--i;
format.d:		t = fmt->aux_string->base_string.fillp;
format.d:		for (; tempstr(fmt, --t) == '0' ;) ;
format.d:		for (b = FALSE;  i > 0;  i -= j) {
format.d:				for (k = (i - 1)/30;  k > 0;  --k)
format.d:							fmt->stream);
format.d:					writestr_stream("th", fmt->stream);
format.d:			ecl_write_char('y', fmt->stream);
format.d:			writestr_stream("ies", fmt->stream);
format.d:			ecl_write_char('s', fmt->stream);
format.d:		ecl_write_char(ECL_CHAR_CODE(x), fmt->stream);
format.d:		ecl_prin1(x, fmt->aux_stream);
format.d:		for (;  i < fmt->aux_string->base_string.fillp;  i++)
format.d:			ecl_write_char(tempstr(fmt, i), fmt->stream);
format.d:   most-positive-long-float printed expression readable.
format.d:		FEerror("Can't print a non-number.", 0);
format.d:	if (n < -DBL_MAX_DIGITS)
format.d:		n = -n;
format.d:			sprintf(buff, "%- *.*" EXP_STRING, n + 1 + 1 + DBL_EXPONENT_SIZE, n-1, d);
format.d:		n--;
format.d:		sprintf(buff, "%- *.*" EXP_STRING, DBL_SIZE,
format.d:			(n <= DBL_MAX_DIGITS)? (n-1) : (DBL_MAX_DIGITS-1), d);
format.d:	*sp = (buff[0] == '-') ? -1 : +1;
format.d:	length = exponent - (buff + 2);
format.d:		if (fmt->nparam > 1) fmt->nparam = 1;
format.d:	if (exp + k > 100 || exp + k < -100 || d > 100) {
format.d:		ecl_prin1(x, fmt->stream);
format.d:			m = w - 1;
format.d:			m = w + exp + k - 2;
format.d:			--m;
format.d:		if (buff[n - 1] == '0')
format.d:			--n;
format.d:			for (i = 0;  i < (-exp) - 1 && i < d;  i++)
format.d:			for (m = d - i, i = 0;  i < m;  i++)
format.d:			for (i = 0;  i < (-exp) - 1;  i++)
format.d:			--w;
format.d:				ecl_write_char(overflowchar, fmt->stream);
format.d:		if (j < w && d < 0 && b[j-1] == '.') {
format.d:			*--b = '0';
format.d:			ecl_write_char(padchar, fmt->stream);
format.d:			*--b = '0';
format.d:		if (d < 0 && b[j-1] == '.') {
format.d:		ecl_write_char('-', fmt->stream);
format.d:		ecl_write_char('+', fmt->stream);
format.d:	writestr_stream(b, fmt->stream);
format.d:		e = -e;
format.d:		ecl_write_char('0', fmt->stream);
format.d:		e = -e;
format.d:	fmt_exponent1(fmt->stream, e);
format.d:		if (fmt->nparam > 1) fmt->nparam = 1;
format.d:			if (!(k > -d))
format.d:			m = w - 1;
format.d:			m = w + k - 1;
format.d:			--m;
format.d:			m -= e + 2;
format.d:			m -= fmt_exponent_length(e - k + 1) + 2;
format.d:		if (buff[n - 1] == '0')
format.d:			--n;
format.d:	exp = exp - k + 1;
format.d:			for (m = i + (d - k + 1);  i < m;  i++)
format.d:			for (i = 0;  i < -k && i < d;  i++)
format.d:			for (m = d - i, i = 0;  i < m;  i++)
format.d:			for (i = 0;  i < -k;  i++)
format.d:			--w;
format.d:			w -= e + 2;
format.d:			w -= i + 2;
format.d:			*--b = '0';
format.d:			ecl_write_char(padchar, fmt->stream);
format.d:		if (b[j-1] == '.') {
format.d:			*--b = '0';
format.d:		ecl_write_char('-', fmt->stream);
format.d:		ecl_write_char('+', fmt->stream);
format.d:	writestr_stream(b, fmt->stream);
format.d:	y = ecl_symbol_value(@'*read-default-float-format*');
format.d:		if (y == @'long-float') {
format.d:		} else if (y == @'double-float') {
format.d:		} else if (y == @'single-float') {
format.d:	ecl_write_char(exponentchar, fmt->stream);
format.d:		ecl_write_char('-', fmt->stream);
format.d:		ecl_write_char('+', fmt->stream);
format.d:		for (i = e - fmt_exponent_length(exp);  i > 0;  --i)
format.d:			ecl_write_char('0', fmt->stream);
format.d:		ecl_write_char(overflowchar, fmt->stream);
format.d:		if (fmt->nparam > 1) fmt->nparam = 1;
format.d:		if (buff[q - 1] == '0')
format.d:			--q;
format.d:	ww = w - ee;
format.d:	dd = d - n;
format.d:		fmt->nparam = 5;
format.d:		fmt->param[0] = ecl_make_fixnum(ww);
format.d:		fmt->param[1] = ecl_make_fixnum(dd);
format.d:		fmt->param[2] = ECL_NIL;
format.d:		fmt->param[3] = fmt->param[4];
format.d:		fmt->param[4] = fmt->param[5];
format.d:				ecl_write_char(padchar, fmt->stream);
format.d:	fmt->param[1] = ecl_make_fixnum(d);
format.d:		if (fmt->nparam < 3)
format.d:			fmt->nparam = 0;
format.d:			fmt->nparam = 1;
format.d:			fmt->param[0] = fmt->param[2];
format.d:	if (w > 100 || exp > 100 || exp < -100) {
format.d:		fmt->nparam = 6;
format.d:		fmt->param[0] = fmt->param[2];
format.d:		fmt->param[1] = ecl_make_fixnum(d + n - 1);
format.d:		fmt->param[5] = fmt->param[3];
format.d:		fmt->param[2] =
format.d:		fmt->param[3] =
format.d:		fmt->param[4] = ECL_NIL;
format.d:		--w;
format.d:			ecl_write_char('-', fmt->stream);
format.d:			ecl_write_char('+', fmt->stream);
format.d:		while (--w > n + d)
format.d:			ecl_write_char(padchar, fmt->stream);
format.d:		while (--w > n + d)
format.d:			ecl_write_char(padchar, fmt->stream);
format.d:			ecl_write_char('-', fmt->stream);
format.d:			ecl_write_char('+', fmt->stream);
format.d:	for (i = n - exp;  i > 0;  --i)
format.d:		ecl_write_char('0', fmt->stream);
format.d:		ecl_write_char((i < q ? buff[i] : '0'), fmt->stream);
format.d:	ecl_write_char('.', fmt->stream);
format.d:		ecl_write_char((i < q ? buff[i] : '0'), fmt->stream);
format.d:	while (n-- > 0) {
format.d:		ecl_write_char('\n', fmt->stream);
format.d:			for (i = fmt->indents;  i > 0;  --i)
format.d:				ecl_write_char(' ', fmt->stream);
format.d:	if (ecl_file_column(fmt->stream) != 0)
format.d:		ecl_write_char('\n', fmt->stream);
format.d:	while (--n > 0)
format.d:		ecl_write_char('\n', fmt->stream);
format.d:	fmt->indents = 0;
format.d:	while (n-- > 0)
format.d:		ecl_write_char('\f', fmt->stream);
format.d:	while (n-- > 0)
format.d:		ecl_write_char('~', fmt->stream);
format.d:		ecl_write_char('\n', fmt->stream);
format.d:	while (fmt->ctl_index < fmt->ctl_end && isspace(ecl_char(fmt->ctl_str, fmt->ctl_index))) {
format.d:			ecl_write_char(ecl_char(fmt->ctl_str, fmt->ctl_index), fmt->stream);
format.d:		fmt->ctl_index++;
format.d:		c = ecl_file_column(fmt->stream);
format.d:			writestr_stream("  ", fmt->stream);
format.d:		for (i = colnum - c;  i > 0;  --i)
format.d:			ecl_write_char(' ', fmt->stream);
format.d:		for (i = colnum;  i > 0;  --i)
format.d:			ecl_write_char(' ', fmt->stream);
format.d:		c = ecl_file_column(fmt->stream);
format.d:		for (i = colnum - c;  i > 0;  --i)
format.d:			ecl_write_char(' ', fmt->stream);
format.d:		fmt_go(fmt, fmt_index(fmt) - n);
format.d:		while (n-- > 0)
format.d:		fmt->jmp_buf = &fmt_jmp_buf0;
format.d:		fmt->ctl_str = s;
format.d:		if ((up_colon = ecl_setjmp(*fmt->jmp_buf))) {
format.d:			if (--up_colon)
format.d:			format(fmt, 0, s->base_string.fillp);
format.d:		fmt->jmp_buf = &fmt_jmp_buf0;
format.d:		fmt->ctl_str = s;
format.d:		if ((up_colon = ecl_setjmp(*fmt->jmp_buf))) {
format.d:			if (--up_colon)
format.d:			format(fmt, 0, s->base_string.fillp);
format.d:	i = fmt->ctl_index;
format.d:	if (ecl_char(fmt->ctl_str, --j) != ')' || ecl_char(fmt->ctl_str, --j) != '~')
format.d:	fmt->stream = x;
format.d:	fmt->jmp_buf = &fmt_jmp_buf0;
format.d:	if ((up_colon = ecl_setjmp(*fmt->jmp_buf)))
format.d:		for (i = 0;  i < x->base_string.fillp;  i++) {
format.d:			ecl_write_char(c, fmt->stream);
format.d:		for (b = TRUE, i = 0;  i < x->base_string.fillp;  i++) {
format.d:			} else if (ecl_digitp(c,10) == -1)
format.d:			ecl_write_char(c, fmt->stream);
format.d:		for (b = TRUE, i = 0;  i < x->base_string.fillp;  i++) {
format.d:			ecl_write_char(c, fmt->stream);
format.d:		for (i = 0;  i < x->base_string.fillp;  i++) {
format.d:			ecl_write_char(c, fmt->stream);
format.d:		ecl_longjmp(*fmt->jmp_buf, up_colon);
format.d:		i = fmt->ctl_index;
format.d:		if (ecl_char(fmt->ctl_str, --j) != ';' || ecl_char(fmt->ctl_str, --j) != '~')
format.d:		if (ecl_char(fmt->ctl_str, --k) != ']' || ecl_char(fmt->ctl_str, --k) != '~')
format.d:		i = fmt->ctl_index;
format.d:		if (ecl_char(fmt->ctl_str, --j) != ']' || ecl_char(fmt->ctl_str, --j) != '~')
format.d:		if (fmt->nparam == 0) {
format.d:		i = fmt->ctl_index;
format.d:		for (done = FALSE;;  --n) {
format.d:			for (k = j; ecl_char(fmt->ctl_str, --k) != '~';)
format.d:			if (ecl_char(fmt->ctl_str, --j) == ']') {
format.d:				if (ecl_char(fmt->ctl_str, --j) != '~')
format.d:			if (ecl_char(fmt->ctl_str, j) == ';') {
format.d:				if (ecl_char(fmt->ctl_str, --j) == '~')
format.d:				if (ecl_char(fmt->ctl_str, j) == ':')
format.d:		if (ecl_char(fmt->ctl_str, --j) != '~')
format.d:		if (ecl_char(fmt->ctl_str, --j) != ']' || ecl_char(fmt->ctl_str, --j) != '~')
format.d:	i = fmt->ctl_index;
format.d:	if (ecl_char(fmt->ctl_str, --j) != '}')
format.d:	if (ecl_char(fmt->ctl_str, --j) == ':') {
format.d:		--j;
format.d:	if (ecl_char(fmt->ctl_str, j) != '~')
format.d:		fmt->jmp_buf = &fmt_jmp_buf0;
format.d:			if (n-- <= 0)
format.d:			if ((up_colon = ecl_setjmp(*fmt->jmp_buf))) {
format.d:				if (--up_colon)
format.d:		fmt->jmp_buf = &fmt_jmp_buf0;
format.d:			if (n-- <= 0)
format.d:			if ((up_colon = ecl_setjmp(*fmt->jmp_buf))) {
format.d:				if (--up_colon)
format.d:		fmt->jmp_buf = &fmt_jmp_buf0;
format.d:			if (n-- <= 0)
format.d:			if ((up_colon = ecl_setjmp(*fmt->jmp_buf))) {
format.d:				if (--up_colon)
format.d:			if (n-- <= 0)
format.d:			fmt->jmp_buf = &fmt_jmp_buf0;
format.d:			if ((up_colon = ecl_setjmp(*fmt->jmp_buf))) {
format.d:				if (--up_colon)
format.d:		i = fmt->ctl_index;
format.d:		while (ecl_char(fmt->ctl_str, --j) != '~')
format.d:		fmt->jmp_buf = &fmt_jmp_buf0;
format.d:		if ((up_colon = ecl_setjmp(*fmt->jmp_buf))) {
format.d:			if (--up_colon)
format.d:			while (ecl_char(fmt->ctl_str, --j0) != '>')
format.d:			if (ecl_char(fmt->ctl_str, --j0) != '~')
format.d:		fmt->stream = this_field;
format.d:		if (ecl_char(fmt->ctl_str, --j0) == '>') {
format.d:			if (ecl_char(fmt->ctl_str, --j0) != '~')
format.d:		} else if (ecl_char(fmt->ctl_str, j0) != ';')
format.d:		else if (ecl_char(fmt->ctl_str, --j0) == ':') {
format.d:			for (j = j0; ecl_char(fmt->ctl_str, j) != '~';  --j)
format.d:			spare_spaces = fmt->spare_spaces;
format.d:			line_length = fmt->line_length;
format.d:		} else if (ecl_char(fmt->ctl_str, j0) != '~')
format.d:		l += CAR(p)->base_string.fillp;
format.d:	m = ecl_length(fields) - 1;
format.d:	    ecl_file_column(fmt->stream) + l + spare_spaces > line_length)
format.d:		ecl_princ(special, fmt->stream);
format.d:	l -= l0;
format.d:			for (j = l / m, l -= j, --m;  j > 0;  --j)
format.d:				ecl_write_char(padchar, fmt->stream);
format.d:		ecl_princ(CAR(p), fmt->stream);
format.d:		for (j = l;  j > 0;  --j)
format.d:			ecl_write_char(padchar, fmt->stream);
format.d:	if (fmt->nparam == 0) {
format.d:			ecl_longjmp(*fmt->jmp_buf, ++colon);
format.d:	} else if (fmt->nparam == 1) {
format.d:			ecl_longjmp(*fmt->jmp_buf, ++colon);
format.d:	} else if (fmt->nparam == 2) {
format.d:			ecl_longjmp(*fmt->jmp_buf, ++colon);
format.d:			ecl_longjmp(*fmt->jmp_buf, ++colon);
format.d:	fmt->spare_spaces = ecl_to_fix(set_param(fmt, 0, INT, ecl_make_fixnum(0)));
format.d:	fmt->line_length = ecl_to_fix(set_param(fmt, 1, INT, ecl_make_fixnum(72)));
format.d:@(defun si::formatter-aux (strm string &rest args)
format.d:		string = ecl_type_error(@'format', "argument", string, @'base-string');
format.d:	if (ecl_symbol_value(@'si::*indent-formatted-output*') != ECL_NIL)
format.d:		if (--colon)
format.d:		format(&fmt, 0, string->base_string.fillp);
format.d:	ecl_process_env()->fmt_aux_stream = fmt.aux_stream;
format.d:	fmt->ctl_index = start;
format.d:	fmt->ctl_end = end;
format.d:	if (fmt->ctl_index >= fmt->ctl_end)
format.d:		ecl_write_char(c, fmt->stream);
format.d:			fmt->param[n] = ECL_NIL;
format.d:		case '+':  case '-':
format.d:			i = fmt->ctl_index - 1;
format.d:			} while (ecl_digitp(c,10) != -1);
format.d:			x = ecl_parse_integer(fmt->ctl_str, i, fmt->ctl_index, &i, 10);
format.d:				fmt->param[n] = ecl_make_fixnum(FMT_VALUE_UPPER_LIMIT);
format.d:				fmt->param[n] = ecl_make_fixnum(FMT_VALUE_LOWER_LIMIT);
format.d:				fmt->param[n] = x;
format.d:				fmt->param[n] = x;
format.d:				fmt->param[n] = ecl_make_fixnum(MOST_POSITIVE_FIXNUM);
format.d:				fmt->param[n] = ecl_make_fixnum(MOST_NEGATIVE_FIXNUM);
format.d:			fmt->param[n] = ECL_CODE_CHAR(ctl_advance(fmt));
format.d:				fmt->param[n] = x;
format.d:			fmt->param[n] = ecl_make_fixnum(fmt_args_left(fmt));
format.d:	fmt->nparam = n;
format.d:		strm = ecl_symbol_value(@'*standard-output*');
format.d:			cl_error(7, @'si::format-error',
format.d:				 @':format-control',
format.d:				 @':control-string', string,
format.d:		_ecl_funcall4(@'si::formatter-aux', strm, string,
gbc-new.d:/* -*- mode: c; c-basic-offset: 8 -*- */
gbc-new.d:    gbc.c -- Garbage collector.
gbc-new.d:/******************************* ------- ******************************/
gbc-new.d:   mark_table[m]:i represents word w = 128*m + 4*i, where m = addr-DATA_START.
gbc-new.d:	int m = (w - DATA_START) >> 7;
gbc-new.d:	int m = (w - DATA_START) >> 7;
gbc-new.d:/*----------------------------------------------------------------------
gbc-new.d: *----------------------------------------------------------------------
gbc-new.d:		  char *limbs = (char *)x->big.big_limbs;
gbc-new.d:		  size_t size = x->big.big_dim * sizeof(mp_limb_t);
gbc-new.d:		mark_object(x->ratio.num);
gbc-new.d:		mark_next(x->ratio.den);
gbc-new.d:		mark_object(x->complex.imag);
gbc-new.d:		mark_next(x->complex.real);
gbc-new.d:		mark_object(x->symbol.name);
gbc-new.d:		mark_object(x->symbol.plist);
gbc-new.d:		mark_object(x->pack.name);
gbc-new.d:		mark_object(x->pack.nicknames);
gbc-new.d:		mark_object(x->pack.shadowings);
gbc-new.d:		mark_object(x->pack.uses);
gbc-new.d:		mark_object(x->pack.usedby);
gbc-new.d:		mark_object(x->pack.internal);
gbc-new.d:		mark_next(x->pack.external);
gbc-new.d:		mark_object(x->hash.rehash_size);
gbc-new.d:		mark_object(x->hash.threshold);
gbc-new.d:		if (x->hash.data == NULL)
gbc-new.d:		for (i = 0, j = x->hash.size;  i < j;  i++) {
gbc-new.d:			mark_object(x->hash.data[i].key);
gbc-new.d:			mark_object(x->hash.data[i].value);
gbc-new.d:		mark_contblock(x->hash.data, j * sizeof(struct hashtable_entry));
gbc-new.d:		mark_contblock(x->array.dims, sizeof(x->array.dims[0])*x->array.rank);
gbc-new.d:		if ((y = x->array.displaced) != ECL_NIL)
gbc-new.d:		cp = (char *)x->array.self.t;
gbc-new.d:		switch ((enum aelttype)x->array.elttype) {
gbc-new.d:			if (x->array.displaced == ECL_NIL || CAR(x->array.displaced) == ECL_NIL) {
gbc-new.d:				cl_object *p = x->array.self.t;
gbc-new.d:				if (x->array.t == t_vector && x->vector.hasfillp)
gbc-new.d:					i = x->vector.fillp;
gbc-new.d:					i = x->vector.dim;
gbc-new.d:				while (i-- > 0)
gbc-new.d:			j = sizeof(cl_object)*x->array.dim;
gbc-new.d:			j = x->array.dim;
gbc-new.d:			j = sizeof(int) * ((x->vector.offset + x->vector.dim + W_SIZE -1)/W_SIZE);
gbc-new.d:			j = x->array.dim * sizeof(cl_fixnum);
gbc-new.d:			j = x->array.dim * sizeof(float);
gbc-new.d:			j = x->array.dim * sizeof(double);
gbc-new.d:		if ((y = x->base_string.displaced) != ECL_NIL)
gbc-new.d:		cp = x->base_string.self;
gbc-new.d:		j = x->base_string.dim;
gbc-new.d:		if ((y = x->vector.displaced) != ECL_NIL)
gbc-new.d:		cp = x->vector.self.bit;
gbc-new.d:		j= sizeof(int) * ((x->vector.offset + x->vector.dim + W_SIZE -1)/W_SIZE);
gbc-new.d:		mark_object(x->str.name);
gbc-new.d:		p = x->str.self;
gbc-new.d:		for (i = 0, j = x->str.length;  i < j;  i++)
gbc-new.d:		switch ((enum smmode)x->stream.mode) {
gbc-new.d:			mark_next(x->stream.object1);
gbc-new.d:			mark_object(x->stream.object0);
gbc-new.d:			mark_object(x->stream.object1);
gbc-new.d:			mark_contblock(x->stream.buffer, BUFSIZ);
gbc-new.d:			mark_next(x->stream.object0);
gbc-new.d:			mark_next(x->stream.object0);
gbc-new.d:			mark_object(x->stream.object0);
gbc-new.d:			mark_next(x->stream.object1);
gbc-new.d:			mark_next(x->stream.object0);
gbc-new.d:		if (x->readtable.table == NULL)
gbc-new.d:		mark_contblock((char *)(x->readtable.table), RTABSIZE*sizeof(struct readtable_entry));
gbc-new.d:			cl_object *p = x->readtable.table[i].dispatch_table;
gbc-new.d:			mark_object(x->readtable.table[i].macro);
gbc-new.d:		mark_object(x->pathname.host);
gbc-new.d:		mark_object(x->pathname.device);
gbc-new.d:		mark_object(x->pathname.directory);
gbc-new.d:		mark_object(x->pathname.name);
gbc-new.d:		mark_object(x->pathname.type);
gbc-new.d:		mark_object(x->pathname.version);
gbc-new.d:		size = x->bytecodes.size;
gbc-new.d:		mark_object(x->bytecodes.lex);
gbc-new.d:		mark_contblock(x->bytecodes.data, size * sizeof(cl_object));
gbc-new.d:			mark_object(x->bytecodes.data[i]);
gbc-new.d:		mark_object(x->cfun.block);
gbc-new.d:		mark_object(x->cfun.name);
gbc-new.d:		mark_object(x->cfun.block);
gbc-new.d:		mark_object(x->cclosure.env);
gbc-new.d:		mark_next(x->cn.cn_thread);
gbc-new.d: 		mark_contblock(x->thread.data, x->thread.size);
gbc-new.d:		mark_next(x->thread.entry);
gbc-new.d:		mark_object(x->instance.class);
gbc-new.d:		p = x->instance.slots;
gbc-new.d:		for (i = 0, j = x->instance.length;  i < j;  i++)
gbc-new.d:		mark_object(x->gfun.name);
gbc-new.d:		mark_object(x->gfun.method_hash);
gbc-new.d:		mark_object(x->gfun.instance);
gbc-new.d:		p = x->gfun.specializers;
gbc-new.d:		for (i = 0, j = x->gfun.arg_no;  i < j;  i++)
gbc-new.d:		mark_object(x->cblock.name);
gbc-new.d:		mark_contblock(x->cblock.start, x->cblock.size);
gbc-new.d:		if (x->cblock.data) {
gbc-new.d:			cl_index i = x->cblock.data_size;
gbc-new.d:			cl_object *p = x->cblock.data;
gbc-new.d:			while (i--)
gbc-new.d:  for (j = top ; j >= bottom ; j--) {
gbc-new.d:      x = (cl_object)(*j - (*j - (int)pagetochar(p)) % tm->tm_size);
gbc-new.d:	  for (pdp = running_head; pdp != (pd *)NULL; pdp = pdp->pd_next) {
gbc-new.d:	    clwp = pdp->pd_lpd;
gbc-new.d:	      mark_object(bdp->bds_sym);
gbc-new.d:	      mark_object(bdp->bds_val);
gbc-new.d:	      mark_object(frp->frs_val);
gbc-new.d:	      mark_object(frp->frs_lex);
gbc-new.d:	      mark_object(ihsp->ihs_function);
gbc-new.d:	      mark_object(ihsp->ihs_base);
gbc-new.d:	    mark_object(clwp->lwp_alloc_temporary);
gbc-new.d:	    mark_object(clwp->lwp_fmt_temporary_stream);
gbc-new.d:	    mark_object(clwp->lwp_PRINTstream);
gbc-new.d:	    mark_object(clwp->lwp_PRINTcase);
gbc-new.d:	    mark_object(clwp->lwp_READtable);
gbc-new.d:	    mark_object(clwp->lwp_delimiting_char);
gbc-new.d:	    mark_object(clwp->lwp_token);
gbc-new.d:	    /* (current-thread) can return it at any time
gbc-new.d:	    mark_object(clwp->lwp_thread);
gbc-new.d:	    /* now collect from the c-stack of the thread ... */
gbc-new.d:		where = (int *)pdp->pd_env[0].__jmpbuf[0].__sp;
gbc-new.d:		where = (int *)pdp->pd_env[JB_SP];
gbc-new.d:	for (k = all_keywords; k->loc != NULL; k++)
gbc-new.d:		mark_object(*(k->loc));
gbc-new.d:	for (s = all_symbols; s->loc != NULL; s++)
gbc-new.d:		mark_object(*(s->loc));
gbc-new.d:	ECL_NIL->symbol.m = FALSE;
gbc-new.d:	ECL_T->symbol.m = FALSE;
gbc-new.d:				printf("-");
gbc-new.d:			printf("%c", tm->tm_name[0]);
gbc-new.d:		f = tm->tm_free;
gbc-new.d:		for (j = tm->tm_nppage; j > 0; --j, p += tm->tm_size) {
gbc-new.d:			  ((struct freelist *)x)->f_link = f;
gbc-new.d:		tm->tm_free = f;
gbc-new.d:		tm->tm_nfree += k;
gbc-new.d:		tm->tm_nused -= k;
gbc-new.d:			dealloc(p, q - p);
gbc-new.d:		for (cbp = cb_pointer; cbp != NULL; cbp = cbp->cb_link)
gbc-new.d:			printf("0x%p %d\n", cbp, cbp->cb_size);
gbc-new.d:       tm_of(t)->tm_npage,
gbc-new.d:      running_head->pd_env[0].__jmpbuf[0].__sp = old_env[0].__jmpbuf[0].__sp;
gbc-new.d:      running_head->pd_env[JB_SP] = old_env[JB_SP];
gbc-new.d:      printf("mark ended (%d)\n", runtime() - tm);
gbc-new.d:      printf("sweep ended (%d)\n", runtime() - tm);
gbc-new.d:	printf("contblock sweep ended (%d)\n", runtime() - tm);
gbc-new.d:      Values = clwp->lwp_Values;
gbc-new.d:  gc_time += (gc_start = runtime() - gc_start);
gbc-new.d: *----------------------------------------------------------------------
gbc-new.d: * mark_contblock --
gbc-new.d: *----------------------------------------------------------------------
gbc-new.d:	int bit_start = ((int)p - DATA_START) >> 2;
gbc-new.d:	int bit_end = ((int)p + s + 3 - DATA_START) >> 2;
gbc-new.d:	int b = bit_start & (32 - 1);
gbc-new.d:	int bits = b + bit_end - bit_start;
gbc-new.d:	  bits -= 32;
gbc-new.d:	int bit_start = ((int)p - DATA_START) >> 2;
gbc-new.d:	int bits = ((int)p + s + 3 - DATA_START) >> 2 - bit_start;
gbc-new.d:	int mask = 1 << bit_start & (32 - 1);
gbc-new.d:/*----------------------------------------------------------------------
gbc-new.d: *----------------------------------------------------------------------
gbc-new.d:@(defun si::room-report ()
gbc-new.d:@(defun si::reset-gc-count ()
gbc-new.d:@(defun si::gc-time ()
gbc-new.d:	siVgc_verbose = make_si_special("*GC-VERBOSE*", ECL_NIL);
gbc-new.d:	siVgc_message = make_si_special("*GC-MESSAGE*", ECL_NIL);
gbc.d:/* -*- mode: c; c-basic-offset: 8 -*- */
gbc.d:    gbc.c -- Garbage collector.
gbc.d:/******************************* ------- ******************************/
gbc.d:   mark_table[m]:i represents word w = 128*m + 4*i, where m = addr-DATA_START.
gbc.d:#define MTword(x)	mark_table[((cl_ptr)x - heap_start) >> 7]
gbc.d:/*----------------------------------------------------------------------
gbc.d: *----------------------------------------------------------------------
gbc.d:	if (x->d.m) {
gbc.d:		if (x->d.m == FREE)
gbc.d:	x->d.m = TRUE;
gbc.d:		cl_ptr limbs = (cl_ptr)x->big.big_limbs;
gbc.d:		cl_index size = x->big.big_dim * sizeof(mp_limb_t);
gbc.d:		mark_object(x->ratio.num);
gbc.d:		mark_next(x->ratio.den);
gbc.d:		mark_object(x->complex.imag);
gbc.d:		mark_next(x->complex.real);
gbc.d:		mark_object(x->symbol.hpack);
gbc.d:		mark_object(x->symbol.name);
gbc.d:		mark_object(x->symbol.plist);
gbc.d:		mark_object(x->symbol.gfdef);
gbc.d:		mark_next(x->symbol.value);
gbc.d:		mark_object(x->pack.name);
gbc.d:		mark_object(x->pack.nicknames);
gbc.d:		mark_object(x->pack.shadowings);
gbc.d:		mark_object(x->pack.uses);
gbc.d:		mark_object(x->pack.usedby);
gbc.d:		mark_object(x->pack.internal);
gbc.d:		mark_next(x->pack.external);
gbc.d:		mark_object(x->hash.rehash_size);
gbc.d:		mark_object(x->hash.threshold);
gbc.d:		if (x->hash.data == NULL)
gbc.d:		for (i = 0, j = x->hash.size;  i < j;  i++) {
gbc.d:			mark_object(x->hash.data[i].key);
gbc.d:			mark_object(x->hash.data[i].value);
gbc.d:		mark_contblock(x->hash.data, j * sizeof(struct ecl_hashtable_entry));
gbc.d:		mark_contblock(x->array.dims, sizeof(x->array.dims[0])*x->array.rank);
gbc.d:		if ((y = x->array.displaced) != ECL_NIL)
gbc.d:		cp = (cl_ptr)x->array.self.t;
gbc.d:		switch ((cl_elttype)x->array.elttype) {
gbc.d:			if (x->array.displaced == ECL_NIL || CAR(x->array.displaced) == ECL_NIL) {
gbc.d:				i = x->vector.dim;
gbc.d:				p = x->array.self.t;
gbc.d:			j = sizeof(cl_object)*x->array.dim;
gbc.d:			j = x->array.dim;
gbc.d:			j = sizeof(int) * ((x->vector.offset + x->vector.dim + W_SIZE -1)/W_SIZE);
gbc.d:			j = x->array.dim * sizeof(cl_fixnum);
gbc.d:			j = x->array.dim * sizeof(cl_index);
gbc.d:			j = x->array.dim * sizeof(float);
gbc.d:			j = x->array.dim * sizeof(double);
gbc.d:			j = x->array.dim * sizeof(uint8_t);
gbc.d:			j = x->array.dim * sizeof(int8_t);
gbc.d:		if ((y = x->base_string.displaced) != ECL_NIL)
gbc.d:		cp = x->base_string.self;
gbc.d:		j = x->base_string.dim+1;
gbc.d:		if ((y = x->vector.displaced) != ECL_NIL)
gbc.d:		cp = x->vector.self.bit;
gbc.d:		j= sizeof(int) * ((x->vector.offset + x->vector.dim + W_SIZE -1)/W_SIZE);
gbc.d:		mark_object(x->str.name);
gbc.d:		p = x->str.self;
gbc.d:		i = x->str.length;
gbc.d:		switch ((enum ecl_smmode)x->stream.mode) {
gbc.d:			mark_contblock(x->stream.buffer, BUFSIZ);
gbc.d:			mark_object(x->stream.object0);
gbc.d:			mark_next(x->stream.object1);
gbc.d:			mark_next(x->stream.object0);
gbc.d:			mark_next(x->stream.object0);
gbc.d:			mark_object(x->stream.object0);
gbc.d:			mark_next(x->stream.object1);
gbc.d:			mark_next(x->stream.object0);
gbc.d:		if (x->readtable.table == NULL)
gbc.d:		mark_contblock((cl_ptr)(x->readtable.table),
gbc.d:			cl_object *p = x->readtable.table[i].dispatch_table;
gbc.d:			mark_object(x->readtable.table[i].macro);
gbc.d:		mark_object(x->pathname.host);
gbc.d:		mark_object(x->pathname.device);
gbc.d:		mark_object(x->pathname.version);
gbc.d:		mark_object(x->pathname.name);
gbc.d:		mark_object(x->pathname.type);
gbc.d:		mark_next(x->pathname.directory);
gbc.d:		mark_object(x->bytecodes.name);
gbc.d:		mark_object(x->bytecodes.lex);
gbc.d:		mark_object(x->bytecodes.specials);
gbc.d:		mark_object(x->bytecodes.definition);
gbc.d:		mark_contblock(x->bytecodes.code, x->bytecodes.code_size * sizeof(cl_opcode));
gbc.d:		mark_next(x->bytecodes.data);
gbc.d:		mark_object(x->bclosure.code);
gbc.d:		mark_next(x->bclosure.lex);
gbc.d:		mark_object(x->cfun.block);
gbc.d:		mark_next(x->cfun.name);
gbc.d:		mark_object(x->cfun.block);
gbc.d:		mark_next(x->cclosure.env);
gbc.d:/* Already marked by malloc: x->process.env
gbc.d:		mark_object(x->process.name);
gbc.d:		mark_object(x->process.interrupt);
gbc.d:		mark_object(x->process.function);
gbc.d:		mark_cl_env(x->process.env);
gbc.d:		mark_next(x->process.args);
gbc.d:		mark_next(x->lock.name);
gbc.d:		mark_next(x->lock.holder);
gbc.d:		mark_object(x->instance.clas);
gbc.d:		mark_object(x->instance.sig);
gbc.d:		p = x->instance.slots;
gbc.d:		i = x->instance.length;
gbc.d:		mark_object(x->cblock.name);
gbc.d:		mark_object(x->cblock.next);
gbc.d:		mark_object(x->cblock.links);
gbc.d:		p = x->cblock.temp_data;
gbc.d:			i = x->cblock.temp_data_size;
gbc.d:			while (i-- > 0)
gbc.d:		i = x->cblock.data_size;
gbc.d:		p = x->cblock.data;
gbc.d:		if (x->foreign.size)
gbc.d:			mark_contblock(x->foreign.data, x->foreign.size);
gbc.d:		mark_next(x->foreign.tag);
gbc.d:			while (i-- > 0)
gbc.d:			x = (cl_object)(aux - (aux - pagetochar(p)) % tm->tm_size);
gbc.d:			m = x->d.m;
gbc.d:	mark_object(env->lex_env);
gbc.d:	mark_contblock(env->stack, env->stack_size * sizeof(cl_object));
gbc.d:	mark_stack_conservative((cl_ptr)env->stack, (cl_ptr)env->stack_top);
gbc.d:	if ((bdp = env->bds_org)) {
gbc.d:		mark_contblock(bdp, env->bds_size * sizeof(*bdp));
gbc.d:		for (;  bdp <= env->bds_top;  bdp++) {
gbc.d:			mark_object(bdp->symbol);
gbc.d:			mark_object(bdp->value);
gbc.d:	mark_object(env->bindings_hash);
gbc.d:	if ((frp = env->frs_org)) {
gbc.d:		mark_contblock(frp, env->frs_size * sizeof(*frp));
gbc.d:		for (;  frp <= env->frs_top;  frp++) {
gbc.d:			mark_object(frp->frs_val);
gbc.d:	for (ihs = env->ihs_top; ihs; ihs = ihs->next) {
gbc.d:		mark_object(ihs->function);
gbc.d:		mark_object(ihs->lex_env);
gbc.d:	for (i=0; i<env->nvalues; i++)
gbc.d:		mark_object(env->values[i]);
gbc.d:	mark_object(env->string_pool);
gbc.d:	if (env->c_env) {
gbc.d:		mark_object(env->c_env->variables);
gbc.d:		mark_object(env->c_env->macros);
gbc.d:		mark_object(env->c_env->constants);
gbc.d:	mark_object(env->fmt_aux_stream);
gbc.d:	mark_contblock(env->queue, sizeof(short) * ECL_PPRINT_QUEUE_SIZE);
gbc.d:	mark_contblock(env->indent_stack, sizeof(short) * ECL_PPRINT_INDENTATION_STACK_SIZE);
gbc.d:	mark_object(env->big_register[0]);
gbc.d:	mark_object(env->big_register[1]);
gbc.d:	mark_object(env->big_register[2]);
gbc.d:	mark_object(env->method_hash_clear_list);
gbc.d:	mark_object(env->method_hash);
gbc.d:	mark_object(env->method_spec_vector);
gbc.d:	mark_stack_conservative((cl_ptr)(&where), (cl_ptr)env->cs_org);
gbc.d:	mark_stack_conservative((cl_ptr)env->cs_org, (cl_ptr)(&where));
gbc.d:	mark_contblock(env->fficall, sizeof(struct ecl_fficall));
gbc.d:	mark_object(((struct ecl_fficall*)env->fficall)->cstring);
gbc.d:		s->symbol.m = FALSE;
gbc.d:		for (i = 0; i < s->vector.fillp; i++) {
gbc.d:			cl_object dll = s->vector.self.t[i];
gbc.d:			if (dll->cblock.locked) {
gbc.d:		s->vector.elttype = ecl_aet_fix;
gbc.d:		s->vector.elttype = ecl_aet_object;
gbc.d:	ECL_NIL->symbol.m = FALSE;
gbc.d:	ECL_T->symbol.m = FALSE;
gbc.d:				printf("-");
gbc.d:			printf("%c", tm->tm_name[0]);
gbc.d:		f = tm->tm_free;
gbc.d:		for (j = tm->tm_nppage; j > 0; --j, p += tm->tm_size) {
gbc.d:			if (x->d.m == FREE)
gbc.d:			else if (x->d.m) {
gbc.d:				x->d.m = FALSE;
gbc.d:			switch (x->d.t) {
gbc.d:                                if (!x->stream.closed)
gbc.d:				CloseHandle(x->lock.mutex);
gbc.d:				pthread_mutex_destroy(&x->lock.mutex);
gbc.d:				CloseHandle(x->condition_variable.cv);
gbc.d:				pthread_cond_destroy(&x->condition_variable.cv);
gbc.d:			((struct freelist *)x)->f_link = f;
gbc.d:			x->d.m = FREE;
gbc.d:		tm->tm_free = f;
gbc.d:		tm->tm_nfree += k;
gbc.d:		tm->tm_nused -= k;
gbc.d:		for (cbp = cb_pointer; cbp != NULL; cbp = cbp->cb_link)
gbc.d:			printf("0x%p %d\n", cbp, cbp->cb_size);
gbc.d:	if (SYM_VAL(@'si::*gc-verbose*') != ECL_NIL) {
gbc.d:		   tm_of(t)->tm_npage,
gbc.d:	debug = ecl_symbol_value(@'si::*gc-message*') != ECL_NIL;
gbc.d:	interrupts = env->disable_interrupts;
gbc.d:	env->disable_interrupts = 1;
gbc.d:		printf("mark ended (%d)\n", ecl_runtime() - tm);
gbc.d:		printf("sweep ended (%d)\n", ecl_runtime() - tm);
gbc.d:			printf("contblock sweep ended (%d)\n", ecl_runtime() - tm);
gbc.d:	env->disable_interrupts = interrupts;
gbc.d:	gc_time += (gc_start = ecl_runtime() - gc_start);
gbc.d:	if (SYM_VAL(@'si::*gc-verbose*') != ECL_NIL) {
gbc.d:	if (env->interrupt_pending) ecl_check_pending_interrupts();
gbc.d: *----------------------------------------------------------------------
gbc.d: * mark_contblock --
gbc.d: *----------------------------------------------------------------------
gbc.d:/*----------------------------------------------------------------------
gbc.d: *----------------------------------------------------------------------
gbc.d:@(defun si::room-report ()
gbc.d:	the_env->nvalues = 8;
gbc.d:	the_env->values[0] = ecl_make_fixnum(real_maxpage);
gbc.d:	the_env->values[1] = ecl_make_fixnum(available_pages());
gbc.d:	the_env->values[2] = ecl_make_fixnum(ncbpage);
gbc.d:	the_env->values[3] = ecl_make_fixnum(maxcbpage);
gbc.d:	the_env->values[4] = ecl_make_fixnum(ncb);
gbc.d:	the_env->values[5] = ecl_make_fixnum(cbgccount);
gbc.d:	the_env->values[6] = ecl_make_fixnum(holepage);
gbc.d:	the_env->values[7] = ECL_NIL;
gbc.d:	tl = &the_env->values[7];
gbc.d:	return the_env->values[0];
gbc.d:@(defun si::reset-gc-count ()
gbc.d:@(defun si::gc-time ()
gfun.d:/* -*- mode: c; c-basic-offset: 8 -*- */
gfun.d:    gfun.c -- Dispatch for generic functions.
gfun.d:#include <ecl/ecl-inl.h>
gfun.d:        cl_object fun = env->function;
gfun.d:	cl_object fun = env->function;
gfun.d:        fun = fun->instance.slots[fun->instance.length - 1];
gfun.d:	cl_fixnum size = x->instance.length + delta;
gfun.d:        aux->instance.sig = x->instance.sig;
gfun.d:	memcpy(aux->instance.slots, x->instance.slots,
gfun.d:	       (delta < 0 ? aux->instance.length : x->instance.length) *
gfun.d:	x->instance = aux->instance;
gfun.d:                FEwrong_type_nth_arg(@[clos::set-funcallable-instance-function],
gfun.d:	if (x->instance.isgf == ECL_USER_DISPATCH) {
gfun.d:		reshape_instance(x, -1);
gfun.d:		x->instance.isgf = ECL_NOT_FUNCALLABLE;
gfun.d:		x->instance.isgf = ECL_STANDARD_DISPATCH;
gfun.d:                x->instance.entry = generic_function_dispatch_vararg;
gfun.d:	} else if (function_or_t == @'standard-generic-function') {
gfun.d:		x->instance.isgf = ECL_RESTRICTED_DISPATCH;
gfun.d:                x->instance.entry = generic_function_dispatch_vararg;
gfun.d:		x->instance.isgf = ECL_NOT_FUNCALLABLE;
gfun.d:                x->instance.entry = FEnot_funcallable_vararg;
gfun.d:	} else if (function_or_t == @'clos::standard-optimized-reader-method') {
gfun.d:		x->instance.isgf = ECL_READER_DISPATCH;
gfun.d:		x->instance.entry = (cl_objectfn)ecl_slot_reader_dispatch;
gfun.d:	} else if (function_or_t == @'clos::standard-optimized-writer-method') {
gfun.d:		x->instance.isgf = ECL_WRITER_DISPATCH;
gfun.d:		x->instance.entry = (cl_objectfn)ecl_slot_writer_dispatch;
gfun.d:		x->instance.slots[x->instance.length - 1] = function_or_t;
gfun.d:		x->instance.isgf = ECL_USER_DISPATCH;
gfun.d:                x->instance.entry = user_function_dispatch;
gfun.d:	@(return ((ECL_INSTANCEP(x) && (x->instance.isgf))? ECL_T : ECL_NIL))
gfun.d:	cl_object *args = frame->frame.base;
gfun.d:	cl_index narg = frame->frame.size;
gfun.d:	cl_object *argtype = vector->vector.self.t;
gfun.d:		unlikely_if (spec_no >= vector->vector.dim)
gfun.d:	vector->vector.fillp = spec_no;
gfun.d:	for (p = frame->frame.base + frame->frame.size, arglist = ECL_NIL;
gfun.d:             p != frame->frame.base; ) {
gfun.d:		arglist = CONS(*(--p), arglist);
gfun.d:	for (p = frame->frame.base + frame->frame.size, arglist = ECL_NIL;
gfun.d:             p != frame->frame.base; ) {
gfun.d:		arglist = CONS(cl_class_of(*(--p)), arglist);
gfun.d:	cl_object methods = _ecl_funcall3(@'clos::compute-applicable-methods-using-classes',
gfun.d:	unlikely_if (Null(memoize = env->values[1])) {
gfun.d:		methods = _ecl_funcall3(@'compute-applicable-methods',
gfun.d:			cl_object func = _ecl_funcall3(@'no-applicable-method',
gfun.d:			frame->frame.base[0] = OBJNULL;
gfun.d:			env->values[1] = ECL_NIL;
gfun.d:	env->values[1] = ECL_T;
gfun.d:		cl_object func = _ecl_funcall3(@'no-applicable-method', gf, arglist);
gfun.d:		frame->frame.base[0] = OBJNULL;
gfun.d:		env->values[1] = ECL_NIL;
gfun.d:	env->values[1] = ECL_T;
gfun.d:	if (gf->instance.isgf == ECL_RESTRICTED_DISPATCH)
gfun.d:        const cl_env_ptr env = frame->frame.env;
gfun.d:	ecl_cache_ptr cache = env->method_cache;
gfun.d:	if (frame->frame.stack == (void*)0x1) {
gfun.d:	vector = fill_spec_vector(cache->keys, frame, gf);
gfun.d:	if (e->key != OBJNULL) {
gfun.d:		func = e->value;
gfun.d:		if (env->values[1] != ECL_NIL) {
gfun.d:			if (e->key != OBJNULL) {
gfun.d:			e->key = keys;
gfun.d:			e->value = func;
gfun.d:		output = _ecl_standard_dispatch(frame, frame->frame.env->function);
gfun.d:		struct cl_env_struct *env = process->process.env;
gfun.d:			ecl_cache_remove_one(env->method_cache, what);
gfun.d:			ecl_cache_remove_one(env->slot_cache, what);
gfun.d:	ecl_cache_remove_one(the_env->method_cache, what);
gfun.d:	ecl_cache_remove_one(the_env->slot_cache, what);
hash.d:/* -*- mode: c; c-basic-offset: 8 -*- */
hash.d:    hash.d  -- Hash tables.
hash.d:#include <ecl/ecl-inl.h>
hash.d:#define SYMBOL_NAME(x) (Null(x)? ECL_NIL_SYMBOL->symbol.name : (x)->symbol.name)
hash.d:        rc = ((p)->d.t == t_hashtable);
hash.d:		FEwrong_type_nth_arg(function, narg, p, @[hash-table]);
hash.d:		h = _hash_eql(h, x->ratio.num);
hash.d:		return _hash_eql(h, x->ratio.den);
hash.d:                aux.sign = (ecl_long_float(x) < 0)? -1: 1;
hash.d:		h = _hash_eql(h, x->complex.real);
hash.d:		return _hash_eql(h, x->complex.imag);
hash.d:		return hash_string(h, x->sse.data.b8, 16);
hash.d:			return _hash_equal(depth, h, ECL_NIL_SYMBOL->symbol.name);
hash.d:		if (--depth == 0) {
hash.d:		x = x->symbol.name;
hash.d:		return hash_base_string((ecl_base_char *)x->base_string.self,
hash.d:					x->base_string.fillp, h);
hash.d:		return hash_full_string(x->string.self, x->string.fillp, h);
hash.d:		return hash_string(h, (ecl_base_char *)x->base_string.self,
hash.d:				   x->base_string.fillp);
hash.d:		h = _hash_equal(0, h, x->pathname.directory);
hash.d:		h = _hash_equal(0, h, x->pathname.name);
hash.d:		h = _hash_equal(0, h, x->pathname.type);
hash.d:		h = _hash_equal(0, h, x->pathname.host);
hash.d:		h = _hash_equal(0, h, x->pathname.device);
hash.d:		return _hash_equal(0, h, x->pathname.version);
hash.d:		return hash_string(h, x->vector.self.bc, x->vector.fillp / 8);
hash.d:		return _hash_equal(0, h, x->random.value);
hash.d:                aux.sign = (ecl_long_float(x) < 0)? -1: 1;
hash.d:		h = _hash_equal(depth, h, x->complex.real);
hash.d:		return _hash_equal(depth, h, x->complex.imag);
hash.d:			return _hash_equalp(depth, h, ECL_NIL_SYMBOL->symbol.name);
hash.d:		if (--depth == 0) {
hash.d:		len = x->vector.fillp;
hash.d:		len = x->vector.dim;
hash.d:	SCAN:	if (--depth) {
hash.d:		h = _hash_equalp(0, h, x->ratio.num);
hash.d:		return _hash_equalp(0, h, x->ratio.den);
hash.d:		h = _hash_equalp(0, h, x->complex.real);
hash.d:		return _hash_equalp(0, h, x->complex.imag);
hash.d:	cl_index hsize = hashtable->hash.size; \
hash.d:		struct ecl_hashtable_entry *e = hashtable->hash.data + i; \
hash.d:		cl_object hkey = e->key, hvalue = e->value; \
hash.d:			if (e->value == OBJNULL) { \
hash.d:					return hashtable->hash.data + j; \
hash.d:		if (HASH_TABLE_LOOP_TEST) return hashtable->hash.data + i; \
hash.d:	return hashtable->hash.data + j; \
hash.d:		if (e->key == OBJNULL) {				\
hash.d:			cl_index i = hashtable->hash.entries + 1;	\
hash.d:			if (i >= hashtable->hash.limit) {		\
hash.d:			hashtable->hash.entries = i;			\
hash.d:			e->key = store_key;				\
hash.d:		e->value = value;					\
hash.d:	return (e->key == OBJNULL)? def : e->value;
hash.d:	if (e->key == OBJNULL) {
hash.d:		e->key = OBJNULL;
hash.d:		e->value = ECL_NIL;
hash.d:		hashtable->hash.entries--;
hash.d:	return (e->key == OBJNULL)? def : e->value;
hash.d:	if (e->key == OBJNULL) {
hash.d:		e->key = OBJNULL;
hash.d:		e->value = ECL_NIL;
hash.d:		hashtable->hash.entries--;
hash.d:	return (e->key == OBJNULL)? def : e->value;
hash.d:	if (e->key == OBJNULL) {
hash.d:		e->key = OBJNULL;
hash.d:		e->value = ECL_NIL;
hash.d:		hashtable->hash.entries--;
hash.d:	return (e->key == OBJNULL)? def : e->value;
hash.d:	if (e->key == OBJNULL) {
hash.d:		e->key = OBJNULL;
hash.d:		e->value = ECL_NIL;
hash.d:		hashtable->hash.entries--;
hash.d:	return (e->key == OBJNULL)? def : e->value;
hash.d:	if (e->key == OBJNULL) {
hash.d:		e->key = OBJNULL;
hash.d:		e->value = ECL_NIL;
hash.d:		hashtable->hash.entries--;
hash.d:	switch (h->hash.test) {
hash.d:	return (void*)(e->key = e->key->weak.value);
hash.d:	return (void*)(e->value = e->value->weak.value);
hash.d:	if ((e->key = e->key->weak.value) && (e->value = e->value->weak.value))
hash.d:	if (e->key == OBJNULL) {
hash.d:		switch (h->hash.weak) {
hash.d:		h->hash.entries--;
hash.d:	cl_index hsize = hashtable->hash.size;
hash.d:		struct ecl_hashtable_entry *p = hashtable->hash.data + i;
hash.d:					return hashtable->hash.data + j;
hash.d:		switch (hashtable->hash.test) {
hash.d:	return hashtable->hash.data + j;
hash.d:	if (aux->key != OBJNULL) {
hash.d:		return aux->value;
hash.d:	if (aux->key == OBJNULL) {
hash.d:		cl_index i = hashtable->hash.entries + 1;
hash.d:		if (i >= hashtable->hash.limit) {
hash.d:		hashtable->hash.entries = i;
hash.d:		switch (hashtable->hash.weak) {
hash.d:		e->key = key;
hash.d:	e->value = value;
hash.d:	if (aux->key != OBJNULL) {
hash.d:		hashtable->hash.entries--;
hash.d:		e->key = OBJNULL;
hash.d:		e->value = ECL_NIL;
hash.d:	return hashtable->hash.get(key, hashtable, OBJNULL);
hash.d:	return hashtable->hash.get(key, hashtable, def);
hash.d:	return hashtable->hash.set(key, hashtable, value);
hash.d:	assert_type_hash_table(@[si::hash-set], 2, hashtable);
hash.d:	hashtable = hashtable->hash.set(key, hashtable, value);
hash.d:	assert_type_hash_table(@[si::hash-set], 2, hashtable);
hash.d:	old_size = hashtable->hash.size;
hash.d:	if (ECL_FIXNUMP(hashtable->hash.rehash_size)) {
hash.d:		new_size_obj = ecl_plus(hashtable->hash.rehash_size,
hash.d:		new_size_obj = ecl_times(hashtable->hash.rehash_size,
hash.d:        if (hashtable->hash.test == ecl_htt_pack) {
hash.d:                new->hash = hashtable->hash;
hash.d:                old->hash = hashtable->hash;
hash.d:	new->hash.data = NULL; /* for GC sake */
hash.d:	new->hash.entries = 0;
hash.d:	new->hash.size = new_size;
hash.d:	new->hash.limit = new->hash.size * new->hash.factor;
hash.d:	new->hash.data = (struct ecl_hashtable_entry *)
hash.d:		new->hash.data[i].key = OBJNULL;
hash.d:		new->hash.data[i].value = OBJNULL;
hash.d:			copy_entry(old->hash.data + i, old);
hash.d:			new = new->hash.set(new->hash.test == ecl_htt_pack?
hash.d:			hash->hash.weak = ecl_htt_weak_key;
hash.d:			hash->hash.weak = ecl_htt_weak_value;
hash.d:		} else if (weakness == @':key-and-value') {
hash.d:			hash->hash.weak = ecl_htt_weak_key_and_value;
hash.d:			FEwrong_type_key_arg(@[make-hash-table],
hash.d:						     @':key-and-value'),
hash.d:		hash->hash.get = _ecl_gethash_weak;
hash.d:		hash->hash.set = _ecl_sethash_weak;
hash.d:		hash->hash.rem = _ecl_remhash_weak;
hash.d:	ht->hash.entries = 0;
hash.d:	for(i = 0; i < ht->hash.size; i++) {
hash.d:		ht->hash.data[i].key = OBJNULL;
hash.d:		ht->hash.data[i].value = OBJNULL;
hash.d:		FEerror("~S is an illegal hash-table test function.",
hash.d:            FEwrong_type_key_arg(@[make-hash-table], @[:size], size,
hash.d:			ecl_type_error(@'make-hash-table',"rehash-size",
hash.d:			ecl_type_error(@'make-hash-table',"rehash-threshold",
hash.d:	h->hash.test = htt;
hash.d:	h->hash.weak = ecl_htt_not_weak;
hash.d:	h->hash.get = get;
hash.d:	h->hash.set = set;
hash.d:	h->hash.rem = rem;
hash.d:	h->hash.size = hsize;
hash.d:        h->hash.entries = 0;
hash.d:	h->hash.rehash_size = rehash_size;
hash.d:	h->hash.threshold = rehash_threshold;
hash.d:	h->hash.factor = ecl_to_double(rehash_threshold);
hash.d:	h->hash.limit = h->hash.size * h->hash.factor;
hash.d:	h->hash.data = NULL;	/* for GC sake */
hash.d:	h->hash.data = (struct ecl_hashtable_entry *)
hash.d:	switch (ht->hash.weak) {
hash.d:	case ecl_htt_weak_key_and_value: output = @':key-and-value'; break;
hash.d:		cl_object v = ht->hash.get(key, ht, OBJNULL);
hash.d:	return hashtable->hash.rem(key, hashtable);
hash.d:	if (ht->hash.entries) {
hash.d:	assert_type_hash_table(@[hash-table-test], 1, ht);
hash.d:	switch(ht->hash.test) {
hash.d:	assert_type_hash_table(@[hash-table-size], 1, ht);
hash.d:	@(return ecl_make_fixnum(ht->hash.size))
hash.d:	assert_type_hash_table(@[hash-table-count], 1, ht);
hash.d:	@(return (ecl_make_fixnum(ht->hash.entries)))
hash.d:        cl_object env = the_env->function->cclosure.env;
hash.d:			i = -1;
hash.d:		for (; ++i < ht->hash.size; ) {
hash.d:				copy_entry(ht->hash.data + i, ht);
hash.d:	assert_type_hash_table(@[si::hash-table-iterator], 1, ht);
hash.d:                                      cl_list(2, ecl_make_fixnum(-1), ht),
hash.d:                                      @'si::hash-table-iterator'))
hash.d:	assert_type_hash_table(@[hash-table-rehash-size], 1, ht);
hash.d:	@(return ht->hash.rehash_size)
hash.d:	assert_type_hash_table(@[hash-table-rehash-threshold], 1, ht);
hash.d:	@(return ht->hash.threshold)
hash.d:	const cl_index mask = ((cl_index)1 << (FIXNUM_BITS - 3)) - 1;
hash.d:@(defun si::hash-eql (&rest args)
hash.d:	for (h = 0; narg; narg--) {
hash.d:@(defun si::hash-equal (&rest args)
hash.d:	for (h = 0; narg; narg--) {
hash.d:@(defun si::hash-equalp (&rest args)
hash.d:	for (h = 0; narg; narg--) {
hash.d:	for (i = 0;  i < ht->hash.size;  i++) {
hash.d:		struct ecl_hashtable_entry e = ht->hash.data[i];
hash.d:	assert_type_hash_table(@[ext::hash-table-content], 2, ht);
hash.d:	for (i = 0;  i < ht->hash.size;  i++) {
hash.d:		struct ecl_hashtable_entry e = ht->hash.data[i];
hash.d:	assert_type_hash_table(@[ext::hash-table-fill], 2, ht);
hash.d:	memcpy(hash->hash.data, orig->hash.data,
hash.d:	       orig->hash.size * sizeof(*orig->hash.data));
hash.d:	hash->hash.entries = orig->hash.entries;
index.html:<?xml version="1.0" encoding="ISO-8859-1"?>
index.html:          PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
index.html:          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
index.html:<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
index.html:<link rel="shortcut icon" type="image/x-icon" href="../../gdb/images/archer-fish.ico" />
index.html:[<a href="../../gdb/mailing-lists/">mailing lists</a>]
index.html:<!-- NB: CURRENT / LATEST refer to the trunk -->
index.html:<!-- NB: MOST RECENT refers to the branch -->
index.html:<!-- body, update above using ../../gdb/index.sh -->
index.html:<a href="ftp://ftp.gnu.org/gnu/gnu-keyring.gpg">ftp://ftp.gnu.org/gnu/gnu-keyring.gpg</a> (see <a href="http://ftp.gnu.org/README">http://ftp.gnu.org/README</a> for more info).
index.html:They're all on-line in the GDB ftp directory in:
index.html:<a href="ftp://sourceware.org/pub/gdb/old-releases/">ftp://sourceware.org/pub/gdb/old-releases/</a> (<a href="http://sourceware.org/mirrors.html">mirrors</a>).
index.html:hardware--don't try to use these!
index.html:<!-- /body, update below using ../../gdb/index.sh -->
index.html:[<a href="../../gdb/mailing-lists/">mailing lists</a>]
index.html:<p>Copyright Free Software Foundation, Inc., 51 Franklin St - Fifth
index.html:Floor, Boston, MA 02110-1301 USA.</p>
index.html:<p>Last modified 2015-05-13.</p>
instance.d:/* -*- mode: c; c-basic-offset: 8 -*- */
instance.d:    instance.c -- CLOS interface.
instance.d:		x->instance.slots[i] = ECL_UNBOUND;
instance.d:		orig->instance.clas = clas;
instance.d:		orig->instance.length = output->instance.length;
instance.d:		orig->instance.slots = output->instance.slots;
instance.d:	@(return x->instance.sig);
instance.d:	@(return (x->instance.sig = ECL_CLASS_SLOTS(ECL_CLASS_OF(x))));
instance.d:                FEwrong_type_only_arg(@[class-of], x, @[ext::instance]);
instance.d:                FEwrong_type_nth_arg(@[si::instance-class-set], 1, x, @[ext::instance]);
instance.d:                FEwrong_type_nth_arg(@[si::instance-class-set], 2, y, @[ext::instance]);
instance.d:                FEwrong_type_nth_arg(@[si::instance-ref], 1, x, @[ext::instance]);
instance.d:	if (ecl_unlikely(i < 0 || i >= (cl_fixnum)x->instance.length))
instance.d:	return(x->instance.slots[i]);
instance.d:                FEwrong_type_nth_arg(@[si::instance-ref], 1, x, @[ext::instance]);
instance.d:		FEwrong_type_nth_arg(@[si::instance-ref], 2, index, @[fixnum]);
instance.d:	if (ecl_unlikely(i < 0 || i >= (cl_fixnum)x->instance.length))
instance.d:	@(return x->instance.slots[i])
instance.d:                FEwrong_type_nth_arg(@[si::instance-ref], 1, x, @[ext::instance]);
instance.d:		FEwrong_type_nth_arg(@[si::instance-ref], 2, index, @[fixnum]);
instance.d:	if (ecl_unlikely(i < 0 || i >= x->instance.length))
instance.d:	x = x->instance.slots[i];
instance.d:		x = _ecl_funcall4(@'slot-unbound', ECL_NIL, x, index);
instance.d:                FEwrong_type_nth_arg(@[si::instance-set], 1, x, @[ext::instance]);
instance.d:	if (ecl_unlikely(i >= x->instance.length || i < 0))
instance.d:	x->instance.slots[i] = v;
instance.d:                FEwrong_type_nth_arg(@[si::instance-set], 1, x, @[ext::instance]);
instance.d:		FEwrong_type_nth_arg(@[si::instance-set], 2, index, @[fixnum]);
instance.d:	if (ecl_unlikely(i >= (cl_fixnum)x->instance.length || i < 0))
instance.d:	x->instance.slots[i] = value;
instance.d:	@(return (ECL_INSTANCEP(x) ? ecl_make_fixnum(x->instance.length) : ECL_NIL))
instance.d:                FEwrong_type_nth_arg(@[si::sl-makunbound], 1, x, @[ext::instance]);
instance.d:		FEwrong_type_nth_arg(@[si::sl-makunbound], 2, index, @[fixnum]);
instance.d:	unlikely_if (i >= x->instance.length || i < 0)
instance.d:	x->instance.slots[i] = ECL_UNBOUND;
instance.d:                FEwrong_type_nth_arg(@[si::copy-instance], 1, x, @[ext::instance]);
instance.d:	y = ecl_allocate_instance(x->instance.clas, x->instance.length);
instance.d:	y->instance.sig = x->instance.sig;
instance.d:	memcpy(y->instance.slots, x->instance.slots,
instance.d:	       x->instance.length * sizeof(cl_object));
instance.d:@(defun find-class (name &optional (errorp ECL_T) env)
instance.d:	hash = ECL_SYM_VAL(the_env, @'si::*class-name-hash-table*');
instance.d:	return funcall(3, @'slot-value', x, slot_name);
instance.d:	cl_object slot_setter = ecl_read_from_cstring("(SETF SLOT-VALUE)");
instance.d:		/* XXX index = ECL_BUILTIN_long-float; break; */
instance.d:		if (x->symbol.hpack == cl_core.keyword_package)
instance.d:		switch (x->stream.mode) {
instance.d:		/* We have to be careful because +builtin-classes+ might be empty! */
instance.d:		/* In any case, since +builtin-classes+ is a constant, we may
instance.d:		cl_object v = @'clos::+builtin-classes+'->symbol.value;
instance.d:			v->vector.self.t[index];
interpreter.d:/* -*- mode: c; c-basic-offset: 8 -*- */
interpreter.d:    interpreter.c -- Bytecode interpreter.
interpreter.d:#include <ecl/ecl-inl.h>
interpreter.d:/* -------------------- INTERPRETER STACK -------------------- */
interpreter.d:	cl_index top = env->stack_top - env->stack;
interpreter.d:        new_size = (new_size + (LISP_PAGESIZE-1))/LISP_PAGESIZE * new_size;
interpreter.d:	old_stack = env->stack;
interpreter.d:	memcpy(new_stack, old_stack, env->stack_size * sizeof(cl_object));
interpreter.d:	env->stack_size = new_size;
interpreter.d:	env->stack = new_stack;
interpreter.d:	env->stack_top = env->stack + top;
interpreter.d:	env->stack_limit = env->stack + (new_size - 2*safety_area);
interpreter.d:                *(env->stack_top++) = ecl_make_fixnum(0);
interpreter.d:        return env->stack_top;
interpreter.d:	return ecl_stack_set_size(env, env->stack_size + env->stack_size / 2);
interpreter.d:        cl_index i = env->nvalues;
interpreter.d:        cl_object *b = env->stack_top;
interpreter.d:        if (p >= env->stack_limit) {
interpreter.d:        env->stack_top = p;
interpreter.d:        memcpy(b, env->values, i * sizeof(cl_object));
interpreter.d:        cl_object *p = env->stack_top - n;
interpreter.d:        if (ecl_unlikely(p < env->stack))
interpreter.d:        env->nvalues = n;
interpreter.d:        env->stack_top = p;
interpreter.d:        memcpy(env->values, p, n * sizeof(cl_object));
interpreter.d:	cl_object *base = env->stack_top;
interpreter.d:		if ((env->stack_limit - base) < size) {
interpreter.d:			base = ecl_stack_set_size(env, env->stack_size + size);
interpreter.d:	f->frame.t = t_frame;
interpreter.d:	f->frame.stack = env->stack;
interpreter.d:	f->frame.base = base;
interpreter.d:        f->frame.size = size;
interpreter.d:	f->frame.env = env;
interpreter.d:	env->stack_top = (base + size);
interpreter.d:	cl_env_ptr env = f->frame.env;
interpreter.d:	cl_object *top = env->stack_top;
interpreter.d:	if (top >= env->stack_limit) {
interpreter.d:	env->stack_top = ++top;
interpreter.d:        f->frame.base = top - (++(f->frame.size));
interpreter.d:        f->frame.stack = env->stack;
interpreter.d:	cl_env_ptr env = f->frame.env;
interpreter.d:        f->frame.base = env->stack_top - (f->frame.size += env->nvalues); 
interpreter.d:	f->frame.stack = env->stack;
interpreter.d:        cl_env_ptr env = f->frame.env;
interpreter.d:	cl_index n = f->frame.size % ECL_MULTIPLE_VALUES_LIMIT;
interpreter.d:        env->nvalues = n;
interpreter.d:        env->values[0] = o = ECL_NIL;
interpreter.d:	while (n--) {
interpreter.d:                env->values[n] = o = f->frame.base[n];
interpreter.d:	if (f->frame.stack) {
interpreter.d:		ECL_STACK_SET_INDEX(f->frame.env, f->frame.base - f->frame.stack);
interpreter.d:/* ------------------------------ LEXICAL ENV. ------------------------------ */
interpreter.d:		if (s-- == 0) return ECL_CONS_CAR(env);
interpreter.d:/* -------------------- AIDS TO THE INTERPRETER -------------------- */
interpreter.d:		output = ecl_interpret(frame, ECL_NIL, frame->frame.env->function);
interpreter.d:                cl_object fun = frame->frame.env->function;
interpreter.d:                output = ecl_interpret(frame, fun->bclosure.lex, fun->bclosure.code);
interpreter.d:	v->bclosure.code = fun;
interpreter.d:	v->bclosure.lex = lex;
interpreter.d:        v->bclosure.entry = _ecl_bclosure_dispatch_vararg;
interpreter.d: * INTERPRET-FUNCALL is one of the few ways to "exit" the interpreted
interpreter.d:        frame.stack = the_env->stack;                                   \
interpreter.d:        frame.base = the_env->stack_top - (frame.size = __n);           \
interpreter.d:        the_env->stack_top -= __n; }
interpreter.d:/* -------------------- THE INTERPRETER -------------------- */
interpreter.d:        const cl_env_ptr the_env = frame->frame.env;
interpreter.d:	cl_opcode *vector = (cl_opcode*)bytecodes->bytecodes.code;
interpreter.d:	cl_object *data = bytecodes->bytecodes.data->vector.self.t;
interpreter.d:		the_env->nvalues = 0;
interpreter.d:		Sets REG0 to the value of the n-th local.
interpreter.d:		while (--n) {
interpreter.d:		Pushes the value of the n-th local onto the stack.
interpreter.d:		reg0 = ECL_STACK_REF(the_env,-narg-1);
interpreter.d:		reg0 = ECL_STACK_REF(the_env,-narg-1);
interpreter.d:		frame_aux.base = the_env->stack_top - narg;
interpreter.d:			if (ecl_unlikely(narg != (cl_index)reg0->cfunfixed.narg))
interpreter.d:			reg0 = APPLY_fixed(narg, reg0->cfunfixed.entry_fixed,
interpreter.d:			reg0 = APPLY(narg, reg0->cfun.entry, frame_aux.base);
interpreter.d:			the_env->function = reg0;
interpreter.d:			reg0 = APPLY(narg, reg0->cclosure.entry, frame_aux.base);
interpreter.d:			switch (reg0->instance.isgf) {
interpreter.d:				reg0 = reg0->instance.slots[reg0->instance.length - 1];
interpreter.d:				the_env->function = reg0;
interpreter.d:				reg0 = APPLY(narg, reg0->instance.entry, frame_aux.base);
interpreter.d:			if (ecl_unlikely(reg0->symbol.stype & ecl_stp_macro))
interpreter.d:			reg0 = ecl_interpret(frame, reg0->bclosure.lex, reg0->bclosure.code);
interpreter.d:		if (ecl_unlikely(frame_index >= frame->frame.size)) {
interpreter.d:                        FEwrong_num_arguments(bytecodes->bytecodes.name);
interpreter.d:                reg0 = frame->frame.base[frame_index++];
interpreter.d:		if (frame_index >= frame->frame.size) {
interpreter.d:                        ECL_STACK_PUSH(the_env,frame->frame.base[frame_index++]);
interpreter.d:                if (ecl_unlikely(frame_index < frame->frame.size))
interpreter.d:                cl_object *first = frame->frame.base + frame_index;
interpreter.d:                cl_object *last = frame->frame.base + frame->frame.size;
interpreter.d:                        reg0 = CONS(*(--last), reg0);
interpreter.d:	/* OP_PUSHKEYS {names-list}
interpreter.d:                first = frame->frame.base + frame_index;
interpreter.d:                count = frame->frame.size - frame_index;
interpreter.d:                                        count -= 2;
interpreter.d:                                        if (*(p++) == @':allow-other-keys') {
interpreter.d:                                                count -= 2;
interpreter.d:			lex_env = bind_function(lex_env, f->bytecodes.name, f);
interpreter.d:		} while (--nfun);
interpreter.d:                                lex_env = bind_function(lex_env, f->bytecodes.name, f);
interpreter.d:                        } while (--i);
interpreter.d:                        } while (--nfun);
interpreter.d:	/* OP_LFUNCTION	n{arg}, function-name{symbol}
interpreter.d:	/* OP_GO	n{arg}, tag-ndx{arg}
interpreter.d:		frame registered at the n-th position in the lexical
interpreter.d:		environment. TAG-NDX is the number of tag in the list.
interpreter.d:		occuppies the n-th position.
interpreter.d:		the_env->values[0] = reg0;
interpreter.d:		the_env->values[0] = reg0;
interpreter.d:		vector += jump - OPARG_SIZE;
interpreter.d:			vector += jump - OPARG_SIZE;
interpreter.d:			vector += jump - OPARG_SIZE;
interpreter.d:			vector += jump - OPARG_SIZE;
interpreter.d:			vector += jump - OPARG_SIZE;
interpreter.d:		while (n--)
interpreter.d:				   (n < the_env->nvalues) ? the_env->values[n] : ECL_NIL);
interpreter.d:			     (n < the_env->nvalues) ? the_env->values[n] : ECL_NIL);
interpreter.d:	   OP_SETQS	var-name{symbol}
interpreter.d:	   OP_PSETQS	var-name{symbol}
interpreter.d:	   OP_VSETQS	var-name{symbol}, nvalue{arg}
interpreter.d:		Sets either the n-th local or a special variable VAR-NAME,
interpreter.d:		if (ecl_unlikely(var->symbol.stype & ecl_stp_constant))
interpreter.d:				    (index >= the_env->nvalues)? ECL_NIL : the_env->values[index]);
interpreter.d:		v = (index >= the_env->nvalues)? ECL_NIL : the_env->values[index];
interpreter.d:		reg1 = ecl_make_fixnum(the_env->frame_id++);
interpreter.d:		reg1 = ecl_make_fixnum(the_env->frame_id++);
interpreter.d:			reg0 = the_env->values[0];
interpreter.d:			vector = (cl_opcode *)ECL_STACK_REF(the_env,-1); /* FIXME! */
interpreter.d:			lex_env = ECL_STACK_REF(the_env,-2);
interpreter.d:			   to ntags-1, depending on the tag. These
interpreter.d:			cl_opcode *table = (cl_opcode *)ECL_STACK_REF(the_env,-1);
interpreter.d:			lex_env = ECL_STACK_REF(the_env,-2);
interpreter.d:			table = table + ecl_fixnum(the_env->values[0]) * OPARG_SIZE;
interpreter.d:		the_env->nvalues = 1;
interpreter.d:		cl_index i = the_env->nvalues;
interpreter.d:		the_env->values[0] = reg0;
interpreter.d:		memcpy(&ECL_STACK_REF(the_env, -(i+1)), the_env->values, i * sizeof(cl_object));
interpreter.d:		ECL_STACK_REF(the_env, -1) = ecl_make_fixnum(the_env->nvalues);
interpreter.d:		cl_index n = ecl_fixnum(ECL_STACK_REF(the_env,-1));
interpreter.d:		cl_index i = the_env->nvalues;
interpreter.d:		the_env->values[0] = reg0;
interpreter.d:		memcpy(&ECL_STACK_REF(the_env, -(i+1)), the_env->values, i * sizeof(cl_object));
interpreter.d:		ECL_STACK_REF(the_env, -1) = ecl_make_fixnum(n + i);
interpreter.d:		cl_object *dest = the_env->values;
interpreter.d:		int n = the_env->nvalues = ecl_fixnum(ECL_STACK_POP_UNSAFE(the_env));
interpreter.d:		the_env->nvalues = n;
interpreter.d:		memcpy(the_env->values, &ECL_STACK_REF(the_env, 0), n * sizeof(cl_object));
interpreter.d:		reg0 = the_env->values[0];
interpreter.d:		Set VALUES(0) to the N-th value of the VALUES(...) list.
interpreter.d:		The index N-th is extracted from the top of the stack.
interpreter.d:			FEerror("Wrong index passed to NTH-VAL", 1, ecl_make_fixnum(n));
interpreter.d:		} else if ((cl_index)n >= the_env->nvalues) {
interpreter.d:			reg0 = the_env->values[n];
interpreter.d:	  High level construct for UNWIND-PROTECT. The first piece of code is
interpreter.d:			reg0 = the_env->values[0];
interpreter.d:			ECL_STACK_PUSH(the_env, ecl_make_fixnum(the_env->nlj_fr - the_env->frs_top));
interpreter.d:		ecl_bds_unwind(the_env, the_env->frs_top->frs_bds_top_index);
interpreter.d:		volatile cl_fixnum n = the_env->nvalues = ecl_fixnum(ECL_STACK_POP_UNSAFE(the_env));
interpreter.d:		while (n--)
interpreter.d:			the_env->values[n] = ECL_STACK_POP_UNSAFE(the_env);
interpreter.d:		reg0 = the_env->values[0];
interpreter.d:			ecl_unwind(the_env, the_env->frs_top + n);
interpreter.d:		cl_object a = ECL_SYM_VAL(the_env, @'si::*step-action*');
interpreter.d:		the_env->values[0] = reg0;
interpreter.d:			ECL_SETQ(the_env, @'si::*step-level*',
interpreter.d:				 cl_1P(ECL_SYM_VAL(the_env, @'si::*step-level*')));
interpreter.d:			/* The user told us to step over. *step-level* contains
interpreter.d:			ECL_SETQ(the_env, @'si::*step-action*', cl_1P(a));
interpreter.d:		reg0 = the_env->values[0];
interpreter.d:		if (ECL_SYM_VAL(the_env, @'si::*step-action*') == ECL_T) {
interpreter.d:		cl_object a = ECL_SYM_VAL(the_env, @'si::*step-action*');
interpreter.d:		the_env->values[0] = reg0;
interpreter.d:			ECL_SETQ(the_env, @'si::*step-level*',
interpreter.d:				 cl_1M(ECL_SYM_VAL(the_env, @'si::*step-level*')));
interpreter.d:			ECL_SETQ(the_env, @'si::*step-action*', ECL_T);
interpreter.d:			ECL_SETQ(the_env, @'si::*step-action*', cl_1M(a));
interpreter.d:		reg0 = the_env->values[0];
interpreter.d:@(defun si::interpreter-stack ()
iso_latin_names.h:/* -*- mode: c; c-basic-offset: 8 -*- */
iso_latin_names.h:    iso_latin_names.h -- character names in ISO-LATIN-1
iso_latin_names.h:        ecl_def_string_array_elt("HYPHEN-MINUS"),
iso_latin_names.h:        ecl_def_string_array_elt("LESS-THAN_SIGN"),
iso_latin_names.h:        ecl_def_string_array_elt("GREATER-THAN_SIGN"),
list.d:/* -*- mode: c; c-basic-offset: 8 -*- */
list.d:    list.d -- List manipulating routines.
list.d:#include <ecl/ecl-inl.h>
list.d:#define TEST(t,k) ((t)->test_c_function)((t),(k))
list.d:#define KEY(t,x) ((t)->key_c_function)((t),(x))
list.d:        printf(">>>>FUCKFUCK-at-list:%d:%d\n", string1->string.t, string2->string.t);
list.d:        printf(">>>>FUCKFUCK-at-list:%d:%d:%d\n", narg, string1->string.t, string2->string.t);
list.d:        printf("order-at-list:%d:%d\n", a, b);
list.d:	t->env->function = t->test_function;
list.d:        printf("string tag 1st(%d) 2nd(%d)\n", t->item_compared->string.t, x->string.t);
list.d:        test_at_list(t->item_compared, x);
list.d:        test_at_string(t->item_compared, x);
list.d:        test3_at_list(1, t->item_compared, x);
list.d:        printf(">>FUCK-CANCER-FROM\n");
list.d:        test3_at_string(1, t->item_compared, x);
list.d:        printf(">>FUCK-CANCER-TO\n");
list.d:        cl_string_equal(2, t->item_compared, x);
list.d:        printf(">>FUCK-CANCER-TO2\n");
list.d:        printf(">>!!!!FUCK-test_fn(%ld) cl_string_equal(%ld)\n", t->test_fn, &cl_string_equal);
list.d:        ((t_fuckfn)(t->test_fn))(2, t->item_compared, x);
list.d:        printf(">>FUCK-CANCER-TO4\n");
list.d:        // printf(">>FUCK-CANCER-TO3\n");
list.d:        // fuckfn(2, t->item_compared, x);
list.d:        // printf(">>FUCK-CANCER-TO4\n");
list.d:	return ((t_fuckfn)(t->test_fn))(2, t->item_compared, x) != ECL_NIL;
list.d:	t->env->function = t->test_function;
list.d:	return t->test_fn(2, t->item_compared, x) == ECL_NIL;
list.d:	return (t->item_compared == KEY(t,x));
list.d:	return ecl_eql(t->item_compared, KEY(t,x));
list.d:	return ecl_equal(t->item_compared, KEY(t,x));
list.d:	return ecl_equalp(t->item_compared, KEY(t,x));
list.d:	t->env->function = t->key_function;
list.d:	return t->key_fn(1,x);
list.d:	cl_env_ptr env = t->env = ecl_process_env();
list.d:	t->item_compared = item;
list.d:		    FEerror("Both :TEST and :TEST-NOT are specified.", 0);
list.d:		t->test_function = test = si_coerce_to_function(test);
list.d:			t->test_c_function = test_eq;
list.d:			t->test_c_function = test_eql;
list.d:			t->test_c_function = test_equal;
list.d:			t->test_c_function = test_equalp;
list.d:			t->test_c_function = test_compare;
list.d:			t->test_fn = ecl_function_dispatch(env, test);
list.d:			t->test_function = env->function;
list.d:		t->test_c_function = test_compare_not;
list.d:		t->test_fn = ecl_function_dispatch(env, test_not);
list.d:		t->test_function = env->function;
list.d:		t->test_c_function = test_eql;
list.d:		t->key_fn = ecl_function_dispatch(env, key);
list.d:		t->key_function = env->function;
list.d:		t->key_c_function = key_function;
list.d:		t->key_c_function = key_identity;
list.d:	if (narg--) {
list.d:		while (narg--) {
list.d:	if (--narg) {
list.d:		while (--narg) {
list.d:	for (; narg > 1; narg--) {
list.d:		t->item_compared = x;
list.d:	for (; n > 0 && CONSP(x); n--)
list.d:	while (n-- > 0 && !Null(x)) {
list.d:	for (r = l; n && CONSP(r); n--, r = ECL_CONS_CDR(r))
list.d:	/* INV: ecl_to_size() signals a type-error if SIZE is not a integer >=0 */
list.d:	while (i-- > 0)
list.d:                FEwrong_type_only_arg(@[copy-list], x, @[list]);
list.d:                FEwrong_type_only_arg(@[copy-alist], x, @[list]);
list.d:	while (narg--) {
list.d:	for (r = l; n && CONSP(r); n--, r = ECL_CONS_CDR(r))
list.d:	/* INV: ecl_to_size() signals a type-error if NN is not an integer >=0 */
list.d:	for (n++, r = l; n && CONSP(r); n--, r = ECL_CONS_CDR(r))
list.d:	/* INV: ecl_to_size() signas a type-error if NN is not an integer >=0 */
load.d:/* -*- mode: c; c-basic-offset: 8 -*- */
load.d:    load.d -- Binary loader (contains also open_fasl_data).
load.d:#include <ecl/ecl-inl.h>
load.d:	if (block->cblock.handle == NULL) {
load.d:        block->cblock.entry =
load.d:                ecl_library_symbol(block, (char *)init_prefix->base_string.self, 0);
load.d:	if (block->cblock.entry != NULL)
load.d:	prefix = ecl_symbol_value(@'si::*init-function-prefix*');
load.d:                prefix = @si::base-string-concatenate(3,
load.d:	basename = @si::base-string-concatenate(2, prefix, @string-upcase(1, funcall(4, @'nsubstitute', ECL_CODE_CHAR('_'), ECL_CODE_CHAR('-'), basename)));
load.d:	block->cblock.entry = ecl_library_symbol(block, (char*)basename->base_string.self, 0);
load.d:	if (block->cblock.entry == NULL) {
load.d:        block->cblock.data_text = (char*)array->base_string.self;
load.d:        block->cblock.data_text_size = array->base_string.dim;
load.d:	ecl_init_module(block, (void (*)(cl_object))(block->cblock.entry));
load.d:                cl_object pathname = ECL_SYM_VAL(the_env, @'*load-pathname*');
load.d:		ecl_bds_bind(the_env, @'ext::*source-location*', location);
load.d:                        if (the_env->nvalues) {
load.d:	cl_object old_eptbc = env->packages_to_be_created;
load.d:                cl_object progv_list = ECL_SYM_VAL(env, @'si::+ecl-syntax-progv-list+');
load.d:                env->packages_to_be_created_p = ECL_T;
load.d:                env->packages_to_be_created_p = ECL_NIL;
load.d:                x = cl_set_difference(2, env->packages_to_be_created, old_eptbc);
load.d:                old_eptbc = env->packages_to_be_created;
load.d:	      &key (verbose ecl_symbol_value(@'*load-verbose*'))
load.d:		   (print ecl_symbol_value(@'*load-print*'))
load.d:	           (search_list ecl_symbol_value(@'si::*load-search-list*'))
load.d:	pntype   = pathname->pathname.type;
load.d:	hooks = ecl_symbol_value(@'ext::*load-hooks*');
load.d:	if (Null(pathname->pathname.directory) &&
load.d:	    Null(pathname->pathname.host) &&
load.d:	    Null(pathname->pathname.device) &&
load.d:					       @':if-does-not-exist', ECL_NIL,
load.d:                                               @':external-format', external_format,
load.d:					       @':search-list', ECL_NIL);
load.d:			function = cl_cdr(ecl_assoc(pathname->pathname.type, hooks));
load.d:		filename->pathname.type = CAAR(hooks);
load.d:	ecl_bds_bind(the_env, @'*load-pathname*', not_a_filename? ECL_NIL : source);
load.d:	ecl_bds_bind(the_env, @'*load-truename*',
macros.d:/* -*- mode: c; c-basic-offset: 8 -*- */
macros.d:    macros.c -- Macros.
macros.d:/******************************* ------- ******************************/
macros.d: *	env -> ( var-list . fun-list )
macros.d: *	fun-list -> ( { definition | atomic-marker }* )
macros.d: *	definition -> ( macro-name SI::MACRO { extra-data }* )
macros.d: *		    | ( function-name FUNCTION { extra-data }* )
macros.d: *		    | ( a-symbol anything { extra-data }* )
macros.d: *	atomic-marker -> CB | LB
macros.d: * the functions MACROEXPAND-1, MACROEXPAND and MACRO-FUNCTION can find the
macros.d:			if (CADR(record) == @'si::symbol-macro')
macros.d:	return si_get_sysprop(name, @'si::symbol-macro');
macros.d:		cl_object hook = ecl_symbol_value(@'*macroexpand-hook*');
macros.d:	ECL_SET(@'*macroexpand-hook*', @'funcall');
main.d:/* -*- mode: c; c-basic-offset: 8 -*- */
main.d:    main.c --
main.d:#  define MAP_FAILED -1
main.d:#include <ecl/ecl-inl.h>
main.d:	env->c_env = NULL;
main.d:	env->cleanup = 0;
main.d:	env->own_process = ECL_NIL;
main.d:	env->string_pool = ECL_NIL;
main.d:	env->stack = NULL;
main.d:	env->stack_top = NULL;
main.d:	env->stack_limit = NULL;
main.d:	env->stack_size = 0;
main.d:	env->fmt_aux_stream = ecl_make_string_output_stream(64, 1);
main.d:        env->ffi_args_limit = 0;
main.d:        env->ffi_types = 0;
main.d:        env->ffi_values = 0;
main.d:        env->ffi_values_ptrs = 0;
main.d:	env->fficall = ecl_alloc(sizeof(struct ecl_fficall));
main.d:	((struct ecl_fficall*)env->fficall)->registers = 0;
main.d:	env->method_cache = ecl_make_cache(64, 4096);
main.d:	env->slot_cache = ecl_make_cache(3, 4096);
main.d:        env->pending_interrupt = ECL_NIL;
main.d:		env->signal_queue = cl_make_list(1, ecl_make_fixnum(size));
main.d:		env->big_register[i] = x;
main.d:        env->trap_fpe_bits = 0;
main.d:        env->packages_to_be_created = ECL_NIL;
main.d:        env->packages_to_be_created_p = ECL_NIL;
main.d:	env->fault_address = env;
main.d:	 * a lisp environment set up -- the allocator assumes one -- and we
main.d:			MAP_ANON | MAP_PRIVATE, -1, 0);
main.d:                        output->default_sigmask = 0;
main.d:                        output->default_sigmask = ecl_alloc_atomic(bytes);
main.d:                        memcpy(output->default_sigmask,
main.d:                               parent->default_sigmask,
main.d:                        output->default_sigmask = cl_core.default_sigmask;
main.d:	output->disable_interrupts = 1;
main.d:	output->pending_interrupt = ECL_NIL;
main.d:	output->signal_queue_spinlock = ECL_NIL;
main.d:		cl_object l = ecl_symbol_value(@'si::*exit-hooks*');
main.d:			ECL_SET(@'si::*exit-hooks*', l);
main.d:	ecl_set_option(ECL_OPT_BOOTED, -1);
main.d:ecl_def_ct_base_string(str_common_lisp,"COMMON-LISP",11,static,const);
main.d:ecl_def_ct_base_string(str_common_lisp_user,"COMMON-LISP-USER",16,static,const);
main.d:ecl_def_ct_base_string(str_cl_user,"CL-USER",7,static,const);
main.d:ecl_def_ct_single_float(flt_zero_neg,-0.0,static,const);
main.d:ecl_def_ct_double_float(dbl_zero_neg,-0.0,static,const);
main.d:ecl_def_ct_long_float(ldbl_zero_neg,-0.0l,static,const);
main.d:ecl_def_ct_ratio(minus_half,ecl_make_fixnum(-1),ecl_make_fixnum(2),static,const);
main.d:ecl_def_ct_single_float(flt_one_neg,-1,static,const);
main.d:		{874, "WINDOWS-CP874"},
main.d:		{932, "WINDOWS-CP932"},
main.d:		{936, "WINDOWS-CP936"},
main.d:		{949, "WINDOWS-CP949"},
main.d:		{950, "WINDOWS-CP950"},
main.d:		{1200, "WINDOWS-CP1200"},
main.d:		{1201, "WINDOWS-CP1201"},
main.d:		{1250, "WINDOWS-CP1250"},
main.d:		{1251, "WINDOWS-CP1251"},
main.d:		{1252, "WINDOWS-CP1252"},
main.d:		{1253, "WINDOWS-CP1253"},
main.d:		{1254, "WINDOWS-CP1254"},
main.d:		{1255, "WINDOWS-CP1255"},
main.d:		{1256, "WINDOWS-CP1256"},
main.d:		{1257, "WINDOWS-CP1257"},
main.d:		{1258, "WINDOWS-CP1258"},
main.d:		{0,"LATIN-1"}
main.d:	if (stream->stream.mode != ecl_smm_io_wcon)
main.d:	stream->stream.eof_char = 26;
main.d:	ECL_NIL_SYMBOL->symbol.t = t_symbol;
main.d:	ECL_NIL_SYMBOL->symbol.dynamic = 0;
main.d:	ECL_NIL_SYMBOL->symbol.value = ECL_NIL;
main.d:	ECL_NIL_SYMBOL->symbol.name = str_NIL;
main.d:	ECL_NIL_SYMBOL->symbol.gfdef = ECL_NIL;
main.d:	ECL_NIL_SYMBOL->symbol.plist = ECL_NIL;
main.d:	ECL_NIL_SYMBOL->symbol.hpack = ECL_NIL;
main.d:	ECL_NIL_SYMBOL->symbol.stype = ecl_stp_constant;
main.d:	ECL_NIL_SYMBOL->symbol.binding = ECL_MISSING_SPECIAL_BINDING;
main.d:	ECL_T->symbol.t = (short)t_symbol;
main.d:	ECL_T->symbol.dynamic = 0;
main.d:	ECL_T->symbol.value = ECL_T;
main.d:	ECL_T->symbol.name = str_T;
main.d:	ECL_T->symbol.gfdef = ECL_NIL;
main.d:	ECL_T->symbol.plist = ECL_NIL;
main.d:	ECL_T->symbol.hpack = ECL_NIL;
main.d:	ECL_T->symbol.stype = ecl_stp_constant;
main.d:	ECL_T->symbol.binding = ECL_MISSING_SPECIAL_BINDING;
main.d:        env->packages_to_be_created = ECL_NIL;
main.d:	ECL_NIL_SYMBOL->symbol.hpack = cl_core.lisp_package;
main.d:	ECL_T->symbol.hpack = cl_core.lisp_package;
main.d:	 * Initialize the per-thread data.
main.d:	 * frame stack immediately (for instance SI:PATHNAME-TRANSLATIONS).
main.d:	ECL_SET(@'*default-pathname-defaults*', si_getcwd(0));
main.d:	ECL_SET(@'*default-pathname-defaults*',
main.d:	env->bindings_array = si_make_vector(ECL_T, ecl_make_fixnum(1024),
main.d:        si_fill_array_with_elt(env->bindings_array, OBJNULL, ecl_make_fixnum(0), ECL_NIL);
main.d:        env->thread_local_bindings_size = env->bindings_array->vector.dim;
main.d:        env->thread_local_bindings = env->bindings_array->vector.self.t;
main.d:	ECL_SET(@'mp::*current-process*', env->own_process);
main.d:	@si::pathname-translations(2,str_sys,
main.d:	ECL_SET(@'*random-state*', ecl_make_random_state(ECL_T));
main.d:	ECL_SET(@'ffi::c-int-max', ecl_make_integer(INT_MAX));
main.d:	ECL_SET(@'ffi::c-int-min', ecl_make_integer(INT_MIN));
main.d:	ECL_SET(@'ffi::c-long-max', ecl_make_integer(LONG_MAX));
main.d:	ECL_SET(@'ffi::c-long-min', ecl_make_integer(LONG_MIN));
main.d:	ECL_SET(@'ffi::c-uint-max', ecl_make_unsigned_integer(UINT_MAX));
main.d:	ECL_SET(@'ffi::c-ulong-max', ecl_make_unsigned_integer(ULONG_MAX));
main.d:	ECL_SET(@'ffi::c-long-long-max', ecl_make_unsigned_integer(LLONG_MAX));
main.d:	ECL_SET(@'ffi::c-ulong-long-max', ecl_make_unsigned_integer(ULLONG_MAX));
main.d:	ECL_SET(@'*print-case*', @':upcase');
main.d:	ECL_SET(@'mp::+load-compile-lock+',
main.d:		ecl_make_lock(@'mp::+load-compile-lock+', 1));
main.d:                CONS(str_fas, @'si::load-binary'),
main.d:		CONS(str_fasl, @'si::load-binary'),
main.d:		CONS(str_fasb, @'si::load-binary'),
main.d:		CONS(str_FASB, @'si::load-binary'),
main.d:		CONS(str_lsp, @'si::load-source'),
main.d:		CONS(str_lisp, @'si::load-source'),
main.d:		CONS(str_LSP, @'si::load-source'),
main.d:		CONS(str_LISP, @'si::load-source'),
main.d:		CONS(str_fasc, @'si::load-bytecodes'),
main.d:		CONS(str_FASC, @'si::load-bytecodes'),
main.d:		CONS(ECL_NIL, @'si::load-source'));
main.d:	ECL_SET(@'ext::*load-hooks*', aux);
main.d:	ECL_SET(@'si::*class-name-hash-table*',
main.d:	ECL_SET(@'LAMBDA-LIST-KEYWORDS',
main.d:		cl_list(8, @'&optional', @'&rest', @'&key', @'&allow-other-keys',
main.d:	if (cl_fboundp(@'ext::make-encoding') != ECL_NIL) {
main.d:                cl_object this = the_env->own_process;
main.d:		ecl_musleep(1e-3, 1);
main.d:        ECL_SET(@'ext::*program-exit-code*', code);
main.d:        if (the_env->frs_org <= the_env->frs_top)
main.d:                ecl_unwind(the_env, the_env->frs_org);
main.d:@(defun ext::exit (&optional (code ECL_SYM_VAL(ecl_process_env(),@'ext::*program-exit-code*')))
main.d:	value = getenv((char*)var->base_string.self);
main.d:		unsetenv((char*)var->base_string.self);
main.d:		putenv((char*)var->base_string.self);
main.d:		ret_val = setenv((char*)var->base_string.self,
main.d:				 (char*)value->base_string.self, 1);
main.d:		putenv((char*)value->base_string.self);
main.d:	if (ret_val == -1)
mapfun.d:/* -*- mode: c; c-basic-offset: 8 -*- */
mapfun.d:    mapfun.c -- Mapping.
mapfun.d:	narg = cars_frame->frame.size;                                  \
multival.d:/* -*- mode: c; c-basic-offset: 8 -*- */
multival.d:    multival.c -- Multiple Values.
multival.d:	the_env->nvalues = narg;
multival.d:			the_env->values[i] = ecl_va_arg(args);
multival.d:		output = the_env->values[0];
multival.d:	the_env->values[0] = ECL_NIL;
multival.d:			FEerror("Too many values in VALUES-LIST",0);
multival.d:		the_env->values[i++] = ECL_CONS_CAR(list);
multival.d:	the_env->nvalues = i;
multival.d:	return the_env->values[0];
newhash.h:/* -*- mode: c; c-basic-offset: 8 -*- */
newhash.h:		a=a-b;  a=a-c;  a=a^(c>>43);	\
newhash.h:		b=b-c;  b=b-a;  b=b^(a<<9);	\
newhash.h:		c=c-a;  c=c-b;  c=c^(b>>8);	\
newhash.h:		a=a-b;  a=a-c;  a=a^(c>>38);	\
newhash.h:		b=b-c;  b=b-a;  b=b^(a<<23);	\
newhash.h:		c=c-a;  c=c-b;  c=c^(b>>5);	\
newhash.h:		a=a-b;  a=a-c;  a=a^(c>>35);	\
newhash.h:		b=b-c;  b=b-a;  b=b^(a<<49);	\
newhash.h:		c=c-a;  c=c-b;  c=c^(b>>11);	\
newhash.h:		a=a-b;  a=a-c;  a=a^(c>>12);	\
newhash.h:		b=b-c;  b=b-a;  b=b^(a<<18);	\
newhash.h:		c=c-a;  c=c-b;  c=c^(b>>22);	\
newhash.h:	for (len = length; len >= 24; len -= 24) {
newhash.h:	/*------------------------------------- handle the last 11 bytes */
newhash.h:	/*-------------------------------------------- report the result */
newhash.h:		a -= b; a -= c; a ^= (c>>13);	\
newhash.h:		b -= c; b -= a; b ^= (a<<8);	\
newhash.h:		c -= a; c -= b; c ^= (b>>13);	\
newhash.h:		a -= b; a -= c; a ^= (c>>12);	\
newhash.h:		b -= c; b -= a; b ^= (a<<16);	\
newhash.h:		c -= a; c -= b; c ^= (b>>5);	\
newhash.h:		a -= b; a -= c; a ^= (c>>3);	\
newhash.h:		b -= c; b -= a; b ^= (a<<10);	\
newhash.h:		c -= a; c -= b; c ^= (b>>15);	\
newhash.h:	for (len = length; len >= 12; len -= 12) {
newhash.h:	/*------------------------------------- handle the last 11 bytes */
newhash.h:	/*-------------------------------------------- report the result */
newhash.h:	for (i = len; i >= 3; i -= 3) {
newhash.h:	for (i = len; i >= 3; i -= 3) {
num_arith.d:/* -*- mode: c; c-basic-offset: 8 -*- */
num_arith.d:    num_arith.c  -- Arithmetic operations
num_arith.d:	while (--narg)
num_arith.d:	while (narg-- > 1) {
num_co.d:/* -*- mode: c; c-basic-offset: 8 -*- */
num_co.d:    num_co.c -- Operations on floating-point numbers.
num_co.d:	IMPLEMENTATION-DEPENDENT
num_co.d:	that know the representation of floating-point numbers.
num_co.d:/* Coerce X to single-float if one arg,
num_co.d:		x = x->ratio.num;
num_co.d:		x = x->ratio.den;
num_co.d:	ecl_return1(the_env, the_env->values[1]);
num_co.d:	ecl_return1(the_env, the_env->values[1]);
num_co.d:			f = -f;
num_co.d:			d = -d;
num_co.d:			d = -d;
num_co.d:                FEwrong_type_nth_arg(@[decode-float],1,x,@[float]);
num_co.d:		FEwrong_type_nth_arg(@[scale-float],2,y,@[fixnum]);
num_co.d:                FEwrong_type_nth_arg(@[scale-float],1,x,@[float]);
num_co.d:		FEwrong_type_nth_arg(@[float-radix],1,x,@[float]);
num_co.d:                FEwrong_type_nth_arg(@[float-sign],1,x,@[float]);
num_co.d:                if (signbit(f) != negativep) y = ecl_make_single_float(-f);
num_co.d:                if (signbit(f) != negativep) y = ecl_make_double_float(-f);
num_co.d:                if (signbit(f) != negativep) y = ecl_make_long_float(-f);
num_co.d:                FEwrong_type_nth_arg(@[float-sign],2,y,@[float]);
num_co.d:                FEwrong_type_nth_arg(@[float-digits],1,x,@[float]);
num_co.d:				precision = FLT_MANT_DIG - (FLT_MIN_EXP - exp);
num_co.d:				precision = DBL_MANT_DIG - (DBL_MIN_EXP - exp);
num_co.d:				precision = LDBL_MANT_DIG - (LDBL_MIN_EXP - exp);
num_co.d:		FEwrong_type_nth_arg(@[float-precision],1,x,@[float]);
num_co.d:                        s = -1;
num_co.d:                        d = -d;
num_co.d:			e -= LDBL_MANT_DIG;
num_co.d:                        s = -1;
num_co.d:                        d = -d;
num_co.d:			e -= DBL_MANT_DIG;
num_co.d:                        s = -1;
num_co.d:                        d = -d;
num_co.d:			e -= FLT_MANT_DIG;
num_co.d:		FEwrong_type_nth_arg(@[integer-decode-float],1,x,@[float]);
num_co.d:		x = x->complex.real;
num_co.d:		x = x->complex.imag;
num_log.d:/* -*- mode: c; c-basic-offset: 8 -*- */
num_log.d:    num_log.c  -- Logical operations on numbers.
num_log.d:	return(-1);
num_log.d:	if (narg-- == 1) {
num_log.d:		} while (--narg);
num_log.d:	return @logxor(2,x,ecl_make_fixnum(-1));
num_log.d:			count = mpz_popcount(x->big.big_num);
num_log.d:			mpz_com(z->big.big_num, x->big.big_num);
num_log.d:			count = mpz_popcount(z->big.big_num);
num_log.d:		cl_index bits = -w;
num_log.d:			 * to implementation-specific results :-/
num_log.d:				y = (y < 0)? -1 : 0;
num_log.d:		mpz_div_2exp(y->big.big_num, x->big.big_num, bits);
num_log.d:		mpz_mul_2exp(y->big.big_num, x->big.big_num, (unsigned long)w);
num_log.d:		@(return ecl_make_fixnum(-1))
num_log.d:		@(return ecl_make_fixnum(-1))
num_log.d:			i = mpz_tstbit(x->big.big_num, n);
num_log.d:	      sign_x = -1;
num_log.d:	      r = ecl_make_fixnum(-1);
num_log.d:		count = mpz_sizeinbase(x->big.big_num, 2);
num_log.d:                FEwrong_type_only_arg(@[integer-length], x, @[integer]);
num_log.d:		d = x->vector.dim;
num_log.d:		xp = x->vector.self.bit;
num_log.d:		xo = x->vector.offset;
num_log.d:		if (d != y->vector.dim)
num_log.d:		yp = y->vector.self.bit;
num_log.d:		yo = y->vector.offset;
num_log.d:			if (r->vector.dim != d)
num_log.d:			i = (r->vector.self.bit - xp)*8 + (r->vector.offset - xo);
num_log.d:			if ((i > 0 && i < d) || (i < 0 && -i < d)) {
num_log.d:			i = (r->vector.self.bit - yp)*8 + (r->vector.offset - yo);
num_log.d:			if ((i > 0 && i < d) || (i < 0 && -i < d)) {
num_log.d:		if ((cl_elttype)x->array.elttype != ecl_aet_bit)
num_log.d:		d = x->array.dim;
num_log.d:		xp = x->vector.self.bit;
num_log.d:		xo = x->vector.offset;
num_log.d:		if ((cl_elttype)y->array.elttype != ecl_aet_bit)
num_log.d:		if (x->array.rank != y->array.rank)
num_log.d:		yp = y->vector.self.bit;
num_log.d:		yo = y->vector.offset;
num_log.d:		for (i = 0;  i < x->array.rank;  i++)
num_log.d:			if (x->array.dims[i] != y->array.dims[i])
num_log.d:			if ((cl_elttype)r->array.elttype != ecl_aet_bit)
num_log.d:			if (r->array.rank != x->array.rank)
num_log.d:			for (i = 0;  i < x->array.rank;  i++)
num_log.d:				if (r->array.dims[i] != x->array.dims[i])
num_log.d:			i = (r->vector.self.bit - xp)*8 + (r->vector.offset - xo);
num_log.d:			if ((i > 0 && i < d) || (i < 0 && -i < d)) {
num_log.d:			i = (r->vector.self.bit - yp)*8 + (r->vector.offset - yo);
num_log.d:			if ((i > 0 && i < d) || (i < 0 && -i < d)) {
num_log.d:		  r->array.self.t = NULL;
num_log.d:		  r->array.displaced = ECL_NIL;
num_log.d:		  r->array.rank = x->array.rank;
num_log.d:		  r->array.dims = x->array.dims;
num_log.d:		  r->array.elttype = ecl_aet_bit;
num_log.d:		  r->array.dim = x->array.dim;
num_log.d:		  r->array.flags = 0; /* no fill pointer, not adjustable */
num_log.d:	rp = r->vector.self.bit;
num_log.d:	ro = r->vector.offset;
num_log.d:	(place)=((place)&~(-0400>>(nbits)))|((value)&(-0400>>(nbits)))
num_log.d:	(place)=((place)&(-0400>>(8-(nbits))))|((value)&~(-0400>>(8-(nbits))))
num_log.d:	(integer) = ((pointer)[index]<<(offset))|((integer)>>(8-(offset)))
num_log.d:	set_low((pointer)[index], 8-(offset), (value)>>(offset)); \
num_log.d:	set_high((pointer)[(index)+1], offset, (value)<<(8-(offset)))
num_log.d:	rp = r0->vector.self.bit;
num_log.d:	ro = r0->vector.offset;
num_log.d:			set_high(ri, j, r->vector.self.bit[n]);
num_log.d:			ri = r->vector.self.bit[i];
num_log.d:	FEerror("Illegal arguments for bit-array operation.", 0);
num_pred.d:/* -*- mode: c; c-basic-offset: 8 -*- */
num_pred.d:    num_pred.c  -- Predicates on numbers.
num_rand.d:/* -*- mode: c; c-basic-offset: 8 -*- */
num_rand.d:    num_rand.c  -- Random numbers.
num_rand.d:	rs->random.value
num_rand.d:	= rs->random.value
num_rand.d:	+ (rs->random.value<<2)
num_rand.d:	+ (rs->random.value<<17)
num_rand.d:	+ (rs->random.value<<27);
num_rand.d:	rs->random.value = rs->random.value & 0xffffffff;
num_rand.d:	return (double)(rs->random.value>>1) / (4294967296.0/2.0);
num_rand.d: * Mersenne-Twister random number generator
num_rand.d:#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
num_rand.d:	ulong *mt = (ulong*)a->base_string.self;
num_rand.d:	if (fh != -1) {
num_rand.d:			mt[j] = (1812433253UL * (mt[j-1] ^ (mt[j-1] >> 30)) + j);
num_rand.d:				mt[j] ^= mt[j-16];
num_rand.d:	ulong *mt = (ulong*)state->base_string.self;
num_rand.d:		for (kk=0; kk < (MT_N - MT_M); kk++) {
num_rand.d:		for (; kk < (MT_N - 1); kk++) {
num_rand.d:			mt[kk] = mt[kk+(MT_M-MT_N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
num_rand.d:		y = (mt[MT_N-1] & UPPER_MASK) | (mt[0] & LOWER_MASK);
num_rand.d:		mt[MT_N-1] = mt[MT_M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];
num_rand.d:        for (bit_length = mpz_size(buffer->big.big_num); bit_length; ) {
num_rand.d:                ECL_BIGNUM_LIMBS(buffer)[--bit_length] =
num_rand.d:                z = ecl_make_fixnum(generate_int32(rs->random.value) % ecl_fixnum(x));
num_rand.d:		z = random_integer(x, rs->random.value);
num_rand.d:                                         (float)generate_double(rs->random.value));
num_rand.d:                                         generate_double(rs->random.value));
num_rand.d:                                       (long double)generate_double(rs->random.value));
num_rand.d:		z->random.value = init_random_state();
num_rand.d:			rs = ecl_symbol_value(@'*random-state*');
num_rand.d:			FEwrong_type_only_arg(@[make-random-state], rs,
num_rand.d:                                              @[random-state]);
num_rand.d:		z->random.value = cl_copy_seq(rs->random.value);
num_rand.d:@(defun random (x &optional (rs ecl_symbol_value(@'*random-state*')))
number.d:/* -*- mode: c; c-basic-offset: 8 -*- */
number.d:    number.c -- constructing numbers.
number.d:#include <ecl/ecl-inl.h>
number.d:	FEwrong_type_argument(cl_list(2, @'unsigned-byte', ecl_make_fixnum(8)),
number.d:		if (ecl_likely(aux >= -128 && aux <= 127))
number.d:	FEwrong_type_argument(cl_list(2, @'signed-byte', ecl_make_fixnum(8)),
number.d:	const int16_t int16_min = -0x8000;
number.d:	const int32_t int32_min = -0x80000000L;
number.d:		} else if (mpz_fits_ulong_p(x->big.big_num)) {
number.d:			return (ecl_uint64_t)mpz_get_ui(x->big.big_num);
number.d:			mpz_fdiv_q_2exp(copy->big.big_num, x->big.big_num, 32);
number.d:			if (mpz_fits_ulong_p(copy->big.big_num)) {
number.d:				output = (ecl_uint64_t)mpz_get_ui(copy->big.big_num);
number.d:					(ecl_uint64_t)mpz_get_ui(x->big.big_num);
number.d:	} else if (mpz_fits_slong_p(x->big.big_num)) {
number.d:		return (ecl_int64_t)mpz_get_si(x->big.big_num);
number.d:		mpz_fdiv_q_2exp(copy->big.big_num, x->big.big_num, 32);
number.d:		if (mpz_fits_slong_p(copy->big.big_num)) {
number.d:			output = (ecl_int64_t)mpz_get_si(copy->big.big_num);
number.d:			mpz_fdiv_r_2exp(copy->big.big_num, x->big.big_num, 32);
number.d:			return (output << 32) + mpz_get_ui(copy->big.big_num);
number.d:		} else if (mpz_fits_ulong_p(x->big.big_num)) {
number.d:			return (ecl_ulong_long_t)mpz_get_ui(x->big.big_num);
number.d:			int i = ECL_LONG_LONG_BITS - FIXNUM_BITS;
number.d:			mpz_fdiv_q_2exp(copy->bit.big_num, x->big.big_num, i);
number.d:			if (mpz_fits_ulong_p(copy->big.big_num)) {
number.d:				output = mpz_get_ui(copy->big.big_num);
number.d:				for (i -= FIXNUM_BITS; i; i-= FIXNUM_BITS) {
number.d:					output += mpz_get_ui(x->big.big_num);
number.d:	} else if (mpz_fits_slong_p(x->big.big_num)) {
number.d:		return (ecl_long_long_t)mpz_get_si(x->big.big_num);
number.d:		int i = ECL_LONG_LONG_BITS - FIXNUM_BITS;
number.d:		mpz_fdiv_q_2exp(copy->bit.big_num, x->big.big_num, i);
number.d:		if (mpz_fits_ulong_p(copy->big.big_num)) {
number.d:			output = mpz_get_si(copy->big.big_num);
number.d:			for (i -= FIXNUM_BITS; i; i-= FIXNUM_BITS) {
number.d:				output += mpz_get_ui(x->big.big_num);
number.d:				      ecl_negate(ecl_ash(ecl_make_fixnum(1), ECL_LONG_LONG_BITS-1)),
number.d:				      ecl_one_minus(ecl_ash(ecl_make_fixnum(1), ECL_LONG_LONG_BITS-1))),
number.d:	if (den == ecl_make_fixnum(-1))
number.d:	r->ratio.num = num;
number.d:	r->ratio.den = den;
number.d:        int bits = status & env->trap_fpe_bits;
number.d:			condition = @'division-by-zero';
number.d:			condition = @'floating-point-invalid-operation';
number.d:			condition = @'floating-point-overflow';
number.d:			condition = @'floating-point-underflow';
number.d:			condition = @'floating-point-inexact';
number.d:                        condition = @'arithmetic-error';
number.d:	x->longfloat.value = f;
number.d:	c->complex.real = r;
number.d:	c->complex.imag = i;
number.d:                mpz_set(bignum->big.big_num, integer->big.big_num);
number.d:        unsigned long den_twos = mpz_scan1(buffer->big.big_num, 0);
number.d:                mpz_div_2exp(buffer->big.big_num, buffer->big.big_num, den_twos);
number.d:                return -den_twos;
number.d:        cl_fixnum delta = ecl_integer_length(den) - num_size;
number.d:        scale -= delta;
number.d:                        den = ecl_ash(den, -adjust);
number.d:                if ((len - digits) == 1) {
number.d:                                        ecl_make_fixnum(-1) :
number.d:                        *scaleout = scale - (digits + 1);
number.d:#if (FIXNUM_BITS-ECL_TAG_BITS) >= FLT_MANT_DIG
number.d:#if (FIXNUM_BITS-ECL_TAG_BITS) >= DBL_MANT_DIG
number.d:#if (FIXNUM_BITS-ECL_TAG_BITS) >= LDBL_MANT_DIG
number.d:                return (float)ratio_to_double(x->ratio.num, x->ratio.den);
number.d:                return ratio_to_double(x->ratio.num, x->ratio.den);
number.d:                return ratio_to_long_double(x->ratio.num, x->ratio.den);
number.d:			e -= DBL_MANT_DIG;
number.d:			e -= LDBL_MANT_DIG;
number.d:        const int fb = FIXNUM_BITS - 3;
number.d:                               e - LDBL_MANT_DIG);
number.d:                int newe = e - fb;
number.d:                long double d2 = ldexpl(d - d1, newe);
package.d:/* -*- mode: c; c-basic-offset: 8 -*- */
package.d:    package.d -- Packages.
package.d:#include <ecl/ecl-inl.h>
package.d:/******************************* ------- ******************************/
package.d:			       @'package-error',
package.d:			       @'package-error',
package.d:	if (s->symbol.hpack == p)
package.d:		s->symbol.hpack = ECL_NIL;
package.d:	if (s->symbol.hpack == ECL_NIL)
package.d:		s->symbol.hpack = p;
package.d:        p->pack.internal = make_package_hashtable();
package.d:	p->pack.external = make_package_hashtable();
package.d:        p->pack.name = name;
package.d:	p->pack.nicknames = ECL_NIL;
package.d:	p->pack.shadowings = ECL_NIL;
package.d:	p->pack.uses = ECL_NIL;
package.d:	p->pack.usedby = ECL_NIL;
package.d:	p->pack.locked = FALSE;
package.d:        cl_object package = ecl_assoc(name, env->packages_to_be_created);
package.d:                env->packages_to_be_created =
package.d:                        cl_acons(name, package, env->packages_to_be_created);
package.d:                cl_object l = env->packages_to_be_created;
package.d:                                env->packages_to_be_created =
package.d:                                                      env->packages_to_be_created);
package.d:                        x->pack.nicknames = CONS(nick, x->pack.nicknames);
package.d:                        x->pack.uses = CONS(y, x->pack.uses);
package.d:                        y->pack.usedby = CONS(x, y->pack.usedby);
package.d:	if (x->pack.locked) {
package.d:                        x->pack.name = name;
package.d:                        x->pack.nicknames = ECL_CONS_CDR(nicknames);
package.d:		if (ecl_string_eq(name, p->pack.name))
package.d:		if (member_string_eq(name, p->pack.nicknames))
package.d:	    ECL_SYM_VAL(ecl_process_env(), @'si::*relative-package-names*') != ECL_NIL) {
package.d:                } else if (p->pack.locked && !ignore_error) {
package.d:                        s->symbol.hpack = p;
package.d:                                p->pack.external =
package.d:                                        _ecl_sethash(name, p->pack.external, s);
package.d:                                p->pack.internal =
package.d:                                        _ecl_sethash(name, p->pack.internal, s);
package.d:	s = ecl_gethash_safe(name, p->pack.external, OBJNULL);
package.d:	s = ecl_gethash_safe(name, p->pack.internal, OBJNULL);
package.d:	ul = p->pack.uses;
package.d:		s = ecl_gethash_safe(name, ECL_CONS_CAR(ul)->pack.external, OBJNULL);
package.d:                FEwrong_type_nth_arg(@[find-symbol], 1, n, @[string]);
package.d:        cl_object l = p->pack.uses;
package.d:                cl_object y = ecl_gethash_safe(name, other_p->pack.external, OBJNULL);
package.d:	if (p->pack.locked) {
package.d:                cl_object hash = p->pack.internal;
package.d:                        hash = p->pack.external;
package.d:                if (ecl_member_eq(s, p->pack.shadowings)) {
package.d:                        p->pack.shadowings = ecl_remove_eq(s, p->pack.shadowings);
package.d:        cl_object l = p->pack.usedby;
package.d:                    !ecl_member_eq(x, other_p->pack.shadowings)) {
package.d:	if (p->pack.locked)
package.d:                                ecl_remhash(name, p->pack.internal);
package.d:                        p->pack.external = _ecl_sethash(name, p->pack.external, s);
package.d:	if (p->pack.locked)
package.d:	if (Null(p->pack.name)) {
package.d:        while (!Null(l = p->pack.uses)) {
package.d:        while (!Null(l = p->pack.usedby)) {
package.d:                for (hash = p->pack.internal, i = 0; i < hash->hash.size; i++)
package.d:                        if (hash->hash.data[i].key != OBJNULL) {
package.d:                                cl_object s = hash->hash.data[i].value;
package.d:                cl_clrhash(p->pack.internal);
package.d:                for (hash = p->pack.external, i = 0; i < hash->hash.size; i++)
package.d:                        if (hash->hash.data[i].key != OBJNULL) {
package.d:                                cl_object s = hash->hash.data[i].value;
package.d:                cl_clrhash(p->pack.external);
package.d:                p->pack.shadowings = ECL_NIL;
package.d:                p->pack.name = ECL_NIL;
package.d:	if (p->pack.locked) {
package.d:                        ecl_remhash(name, p->pack.external);
package.d:                        p->pack.internal = _ecl_sethash(name, p->pack.internal, s);
package.d:	if (p->pack.locked) {
package.d:                p->pack.internal = _ecl_sethash(name, p->pack.internal, s);
package.d:	if (p->pack.locked)
package.d:		CEpackage_error("Cannot shadowing-import symbol ~S into "
package.d:                                if (!ecl_member_eq(x, p->pack.shadowings))
package.d:                                        p->pack.shadowings
package.d:                                                = CONS(x, p->pack.shadowings);
package.d:                        if(ecl_member_eq(x, p->pack.shadowings))
package.d:                                p->pack.shadowings =
package.d:                                        ecl_remove_eq(x, p->pack.shadowings);
package.d:                                ecl_remhash(name, p->pack.internal);
package.d:                                ecl_remhash(name, p->pack.external);
package.d:                p->pack.shadowings = CONS(s, p->pack.shadowings);
package.d:                p->pack.internal = _ecl_sethash(name, p->pack.internal, s);
package.d:	if (p->pack.locked)
package.d:                        p->pack.internal = _ecl_sethash(s, p->pack.internal, x);
package.d:                        x->symbol.hpack = p;
package.d:                p->pack.shadowings = CONS(x, p->pack.shadowings);
package.d:	if (ecl_member_eq(x, p->pack.uses))
package.d:		FEpackage_error("Cannot apply USE-PACKAGE on keyword package.",
package.d:	if (p->pack.locked)
package.d:                hash_entries = x->pack.external->hash.data;
package.d:                hash_length = x->pack.external->hash.size;
package.d:                                    && ! ecl_member_eq(there, p->pack.shadowings)) {
package.d:                        p->pack.uses = CONS(x, p->pack.uses);
package.d:                        x->pack.usedby = CONS(p, x->pack.usedby);
package.d:	if (p->pack.locked)
package.d:                p->pack.uses = ecl_remove_eq(x, p->pack.uses);
package.d:                x->pack.usedby = ecl_remove_eq(p, x->pack.usedby);
package.d:	@(return p->pack.name)
package.d:	@(return p->pack.nicknames)
package.d:	return cl_copy_list(si_coerce_to_package(p)->pack.uses);
package.d:	return cl_copy_list(si_coerce_to_package(p)->pack.usedby);
package.d:	return cl_copy_list(si_coerce_to_package(p)->pack.shadowings);
package.d:	bool previous = p->pack.locked;
package.d:	p->pack.locked = (t != ECL_NIL);
package.d:                FEwrong_type_nth_arg(@[shadowing-import],1,symbols,
package.d:                FEwrong_type_nth_arg(@[use-package], 1, pack,
package.d:                FEwrong_type_nth_arg(@[unuse-package], 1, pack,
package.d:                FEwrong_type_only_arg(@[si::package-hash-tables], p, @[package]);
package.d:                he = si_copy_hash_table(p->pack.external);
package.d:                hi = si_copy_hash_table(p->pack.internal);
package.d:                u = cl_copy_list(p->pack.uses);
pathname.d:/* -*- mode: c; c-basic-offset: 8 -*- */
pathname.d:    pathname.d -- Pathnames.
pathname.d:#include <ecl/ecl-inl.h>
pathname.d:                if (path->pathname.logical)
pathname.d:	 *    list that was passed to MAKE-PATHNAME.
pathname.d:			item = ecl_nth(i-1, directory);
pathname.d:			if (item == @':absolute' || item == @':wild-inferiors')
pathname.d:                                ptr = ecl_nthcdr(i-2, directory);
pathname.d:                                i--;
pathname.d:			item = ecl_nth(i-1, directory);
pathname.d:			if (item == @':absolute' || item == @':wild-inferiors')
pathname.d:					ECL_RPLACD(ecl_nthcdr(--i, directory),
pathname.d:		} else if (item != @':wild' && item != @':wild-inferiors') {
pathname.d:		p->pathname.logical = ecl_logical_hostname_p(host);
pathname.d:		p->pathname.logical = FALSE;
pathname.d:	    !(!p->pathname.logical && ecl_stringp(device))) {
pathname.d:	ERROR:	FEerror("~s is not a valid pathname-~a component", 2, x, component);
pathname.d:			directory = cl_list(2, @':absolute', @':wild-inferiors');
pathname.d:        p->pathname.host = host;
pathname.d:                if (p->pathname.logical)
pathname.d:                p->pathname.host =
pathname.d:                p->pathname.device =
pathname.d:                p->pathname.directory =
pathname.d:                p->pathname.name =
pathname.d:                p->pathname.type =
pathname.d:                p->pathname.version = version;
pathname.d:	directory = destructively_check_directory(directory, p->pathname.logical, 0);
pathname.d:		cl_error(3, @'file-error', @':pathname', p);
pathname.d:	p->pathname.directory = directory;
pathname.d:	if (pathname->pathname.logical || pathname->pathname.host != ECL_NIL
pathname.d:	    || pathname->pathname.device != ECL_NIL) {
pathname.d:	directory = pathname->pathname.directory;
pathname.d: *	2) :wild, :wild-inferiors, :up
pathname.d:				wild_inferiors = (i > start && ecl_char(s, i-1) == '*');
pathname.d:	switch(i-j) {
pathname.d:			return @':wild-inferiors';
pathname.d: * pathname-name or pathname-type when the same error is detected.
pathname.d:	return !Null(@assoc(4, host, cl_core.pathname_translations, @':test', @'string-equal'));
pathname.d: *	[logical-hostname:][;][logical-directory-component;][pathname-name][.pathname-type]
pathname.d: *	[device:][[//hostname]/][directory-component/]*[pathname-name][.pathname-type]
pathname.d: *	logical-hostname, device, hostname = word
pathname.d: *	logical-directory-component = word | wildcard-word
pathname.d: *	directory-component = word | wildcard-word | '..' | '.'
pathname.d: *	pathname-name, pathname-type = word | wildcard-word | ""
pathname.d:	/* We first try parsing as logical-pathname. In case of
pathname.d:	 * failure, physical-pathname parsing is performed only when
pathname.d:	 *	[logical-hostname:][;][logical-directory-component;][pathname-name][.pathname-type]
pathname.d:	if (*ep == start || ecl_char(s, *ep-1) != '.')
pathname.d:	if (*ep == start || ecl_char(s, *ep-1) != '.')
pathname.d:		version = cl_parse_integer(3, aux, @':junk-allowed', ECL_T);
pathname.d:	 *	[[device:[//hostname]]/][directory-component/]*[pathname-name][.pathname-type]
pathname.d:	if (@string-equal(2, device, @':file') == ECL_T)
pathname.d:			if (is_slash(ecl_char(s,--start)))
pathname.d:	if ((*ep - start) <= 1 || ecl_char(s, *ep-1) != '.') {
pathname.d:	path->pathname.logical = logical;
pathname.d:	/* This routine outputs the value of *default-pathname-defaults*
pathname.d:	 * not enter an infinite loop when using PARSE-NAMESTRING, because
pathname.d:	cl_object path = ecl_symbol_value(@'*default-pathname-defaults*');
pathname.d:		ecl_bds_bind(the_env, @'*default-pathname-defaults*', si_getcwd(0));
pathname.d:                FEwrong_type_key_arg(@[pathname], @[*default-pathname-defaults*],
pathname.d:		switch ((enum ecl_smmode)x->stream.mode) {
pathname.d:                const char *type = "(OR FILE-STREAM STRING PATHNAME)";
pathname.d:	if (!x->pathname.logical) {
pathname.d:		cl_error(9, @'simple-type-error', @':format-control',
pathname.d:			 @':format-arguments', cl_list(1, x),
pathname.d:			 @':expected-type', @'logical-pathname',
pathname.d:/* FIXME! WILD-PATHNAME-P is missing! */
pathname.d:@(defun wild-pathname-p (pathname &optional component)
pathname.d:		if (pathname->pathname.host == @':wild')
pathname.d:		if (pathname->pathname.device == @':wild')
pathname.d:		if (pathname->pathname.version == @':wild')
pathname.d:		cl_object name = pathname->pathname.name;
pathname.d:		cl_object name = pathname->pathname.type;
pathname.d:		cl_object list = pathname->pathname.directory;
pathname.d:			    (name == @':wild' || name == @':wild-inferiors' ||
pathname.d:	if (pathname->pathname.device != ECL_NIL)
pathname.d:			pathname->pathname.device);
pathname.d:	if (pathname->pathname.host != ECL_NIL)
pathname.d:	if (pathname->pathname.directory == ECL_NIL ||
pathname.d:	    ECL_CONS_CAR(pathname->pathname.directory) == @':relative') {
pathname.d:	if (x->pathname.logical)
pathname.d: * a namestring. The output must always be a new simple-string which can
pathname.d:		cl_error(3, @'file-error', @':pathname', pathname_orig);
pathname.d:			6, pathname_orig->pathname.host,
pathname.d:                        pathname_orig->pathname.device,
pathname.d:                        pathname_orig->pathname.directory,
pathname.d:                        pathname_orig->pathname.name,
pathname.d:                        pathname_orig->pathname.type,
pathname.d:                        pathname_orig->pathname.version);
pathname.d:	if (cl_core.path_max != -1 &&
pathname.d:	    ecl_length(namestring) >= cl_core.path_max - 16)
pathname.d:	if (Null(host = path->pathname.host))
pathname.d:		host = defaults->pathname.host;
pathname.d:	if (Null(path->pathname.device)) {
pathname.d:		if (Null(path->pathname.host))
pathname.d:		else if (path->pathname.host == defaults->pathname.host)
pathname.d:			device = defaults->pathname.device;
pathname.d:			device = default_device(path->pathname.host);
pathname.d:		device = path->pathname.device;
pathname.d:	if (Null(path->pathname.directory)) {
pathname.d:        } else if (ECL_CONS_CAR(path->pathname.directory) == @':absolute') {
pathname.d:		directory = path->pathname.directory;
pathname.d:        } else if (!Null(defaults->pathname.directory)) {
pathname.d:                                       CDR(path->pathname.directory));
pathname.d:		directory = path->pathname.directory;
pathname.d:	if (Null(name = path->pathname.name)) {
pathname.d:	if (Null(type = path->pathname.type)) {
pathname.d:	version = path->pathname.version;
pathname.d:	if (Null(path->pathname.name)) {
pathname.d:			version = defaults->pathname.version;
pathname.d:	logical = x->pathname.logical;
pathname.d:	host = x->pathname.host;
pathname.d:		if ((y = x->pathname.device) != @':unspecific' &&
pathname.d:		if ((y = x->pathname.device) != ECL_NIL) {
pathname.d:	l = x->pathname.directory;
pathname.d:		} else if (y == @':wild-inferiors') {
pathname.d:		if ((ecl_stringp(x->pathname.name) &&
pathname.d:		     ecl_member_char(':', x->pathname.name)) ||
pathname.d:		    (ecl_stringp(x->pathname.type) &&
pathname.d:		     ecl_member_char(':', x->pathname.type)))
pathname.d:	y = x->pathname.name;
pathname.d:	} else if (!logical && !Null(x->pathname.type)) {
pathname.d:	y = x->pathname.type;
pathname.d:	y = x->pathname.version;
pathname.d:				while (i--) {
pathname.d:		if (Null(x->pathname.name) && Null(x->pathname.type)) {
pathname.d:			default_host = defaults->pathname.host;
pathname.d:		p = ecl_vector_start_end(@[parse-namestring], thing, start, end);
pathname.d:	if (host != ECL_NIL && !ecl_equal(output->pathname.host, host)) {
pathname.d:		defaults = ecl_make_pathname(defaults->pathname.host,
pathname.d:	if (!hostp) host = defaults->pathname.host;
pathname.d:	if (!devicep) x->pathname.device = defaults->pathname.device;
pathname.d:	if (!directoryp) x->pathname.directory = defaults->pathname.directory;
pathname.d:	if (!namep) x->pathname.name = defaults->pathname.name;
pathname.d:	if (!typep) x->pathname.type = defaults->pathname.type;
pathname.d:	if (!versionp) x->pathname.version = defaults->pathname.version;
pathname.d:	@(return ((ECL_PATHNAMEP(pname) && pname->pathname.logical)?
pathname.d:	@(return translate_component_case(pname->pathname.host,
pathname.d:	@(return translate_component_case(pname->pathname.device,
pathname.d:        @(return translate_list_case(pname->pathname.directory,
pathname.d:	@(return translate_component_case(pname->pathname.name,
pathname.d:        @(return translate_component_case(pname->pathname.type,
pathname.d:	@(return  pname->pathname.version)
pathname.d:						  pname->pathname.name,
pathname.d:						  pname->pathname.type,
pathname.d:						  pname->pathname.version,
pathname.d:						  pname->pathname.directory,
pathname.d:	pname = pname->pathname.host;
pathname.d:#define EN_MATCH(p1,p2,el) (ecl_equalp(p1->pathname.el, p2->pathname.el)? ECL_NIL : p1->pathname.el)
pathname.d:	pathdir = path->pathname.directory;
pathname.d:	defaultdir = defaults->pathname.directory;
pathname.d:	if (fname == ECL_NIL) fname = path->pathname.name;
pathname.d:	newpath->pathname.logical = path->pathname.logical;
pathname.d:/* --------------- PATHNAME MATCHING ------------------ */
pathname.d:                        if (++i >= lp) i--;
pathname.d:		FEerror("~S is not supported as mask for pathname-match-p", 1, mask);
pathname.d:		if (item_mask == @':wild-inferiors') {
pathname.d:	if (path->pathname.logical != mask->pathname.logical)
pathname.d:	if (!path_item_match(path->pathname.host, mask->pathname.host))
pathname.d:	if (!Null(mask->pathname.directory) &&
pathname.d:	    !path_list_match(path->pathname.directory, mask->pathname.directory))
pathname.d:	if (!path_item_match(path->pathname.name, mask->pathname.name))
pathname.d:	if (!path_item_match(path->pathname.type, mask->pathname.type))
pathname.d:	if (Null(mask->pathname.version) ||
pathname.d:	    path_item_match(path->pathname.version, mask->pathname.version))
pathname.d:/* --------------- PATHNAME TRANSLATIONS ------------------ */
pathname.d:		if (x->pathname.logical)
pathname.d:		FEerror("~S is not a valid from-pathname translation", 1, x);
pathname.d:@(defun si::pathname-translations (host &optional (set OBJNULL))
pathname.d:                FEwrong_type_nth_arg(@[si::pathname-translations], 1, host, @[string]);
pathname.d:	pair = @assoc(4, host, cl_core.pathname_translations, @':test', @'string-equal');
pathname.d:                FEwrong_type_nth_arg(@[si::pathname-translations], 2, set, @[list]);
pathname.d:		if (item_mask == @':wild-inferiors') {
pathname.d:	if (pattern == @':wild-inferiors')
pathname.d:		if (mask == @':wild-inferiors') {
pathname.d:@(defun translate-pathname (source from to &key ((:case scase) @':local'))
pathname.d:	if (source->pathname.logical != from->pathname.logical)
pathname.d:	if (cl_string_equal(2, source->pathname.host, from->pathname.host) == ECL_NIL)
pathname.d:	host = to->pathname.host;
pathname.d:	device = to->pathname.device;
pathname.d:	wilds = find_list_wilds(source->pathname.directory,
pathname.d:				from->pathname.directory);
pathname.d:	if (Null(to->pathname.directory)) {
pathname.d:                d = translate_list_case(from->pathname.directory, fromcase, tocase);
pathname.d:                d = copy_list_wildcards(&wilds, to->pathname.directory);
pathname.d:	wilds = find_wilds(ECL_NIL, source->pathname.name, from->pathname.name);
pathname.d:	if (Null(to->pathname.name)) {
pathname.d:                d = translate_component_case(from->pathname.name, fromcase, tocase);
pathname.d:                d = copy_wildcards(&wilds, to->pathname.name);
pathname.d:	wilds = find_wilds(ECL_NIL, source->pathname.type, from->pathname.type);
pathname.d:	if (Null(to->pathname.type)) {
pathname.d:                d = translate_component_case(from->pathname.type, fromcase, tocase);
pathname.d:                d = copy_wildcards(&wilds, to->pathname.type);
pathname.d:	version = to->pathname.version;
pathname.d:	if (from->pathname.version == @':wild') {
pathname.d:		if (to->pathname.version == @':wild') {
pathname.d:			version = source->pathname.version;
pathname.d:@(defun translate-logical-pathname (source &key)
pathname.d:	if (!pathname->pathname.logical) {
pathname.d:	l = @si::pathname-translations(1, pathname->pathname.host);
predicate.d:/* -*- mode: c; c-basic-offset: 8 -*- */
predicate.d:    predicate.c -- Predicates.
predicate.d:                   Null(CAR(x->base_string.displaced))) ? ECL_T : ECL_NIL))
predicate.d:                   Null(CAR(x->vector.displaced))) ? ECL_T : ECL_NIL))
predicate.d:                   Null(CAR(x->vector.displaced)) &&
predicate.d:                   (cl_elttype)x->vector.elttype == ecl_aet_object) ? ECL_T : ECL_NIL))
predicate.d:	    || (t == t_instance && x->instance.isgf)
predicate.d: * EQL-comparison of floats. If we are using signed zeros and NaNs,
predicate.d: * numeric comparison of floating points is not equivalent to bit-wise
predicate.d: *	(= 0 -0.0) => T
predicate.d: *	(EQL 0 -0.0) => NIL
predicate.d:        if (x->d.t != y->d.t)
predicate.d:	switch (x->d.t) {
predicate.d:		return (ecl_eql(x->ratio.num, y->ratio.num) &&
predicate.d:			ecl_eql(x->ratio.den, y->ratio.den));
predicate.d:		return (ecl_eql(x->complex.real, y->complex.real) &&
predicate.d:			ecl_eql(x->complex.imag, y->complex.imag));
predicate.d:		return !memcmp(x->sse.data.b8, y->sse.data.b8, 16);
predicate.d:		return (tx == ty) && ecl_eql(x->ratio.num, y->ratio.num) &&
predicate.d:			ecl_eql(x->ratio.den, y->ratio.den);
predicate.d:		return (tx == ty) && ecl_eql(x->complex.real, y->complex.real) &&
predicate.d:			ecl_eql(x->complex.imag, y->complex.imag);
predicate.d:		if (x->vector.fillp != y->vector.fillp)
predicate.d:		ox = x->vector.offset;
predicate.d:		oy = y->vector.offset;
predicate.d:		for (i = 0;  i < x->vector.fillp;  i++)
predicate.d:			if((x->vector.self.bit[(i+ox)/8] & (0200>>(i+ox)%8))
predicate.d:			 !=(y->vector.self.bit[(i+oy)/8] & (0200>>(i+oy)%8)))
predicate.d:		       ecl_equal(x->pathname.host, y->pathname.host) &&
predicate.d:		       ecl_equal(x->pathname.device, y->pathname.device) &&
predicate.d:		       ecl_equal(x->pathname.directory, y->pathname.directory) &&
predicate.d:		       ecl_equal(x->pathname.name, y->pathname.name) &&
predicate.d:		       ecl_equal(x->pathname.type, y->pathname.type) &&
predicate.d:		       ecl_equal(x->pathname.version, y->pathname.version);
predicate.d:		return (tx == ty) && (x->foreign.data == y->foreign.data);
predicate.d:		j = x->vector.fillp;
predicate.d:		if (j != y->vector.fillp)
predicate.d:		if (ty != t_array || x->array.rank != y->array.rank)
predicate.d:		if (x->array.rank > 1) {
predicate.d:			for (i = 0; i < x->array.rank; i++)
predicate.d:				if (x->array.dims[i] != y->array.dims[i])
predicate.d:		if (x->array.dim != y->array.dim)
predicate.d:		j=x->array.dim;
predicate.d:		for (i = 0;  i < x->instance.length;  i++)
predicate.d:			if (!ecl_equalp(x->instance.slots[i], y->instance.slots[i]))
predicate.d:		if ((tx != ty) || (x->str.name != y->str.name))
predicate.d:		for (i = 0;  i < x->str.length;  i++)
predicate.d:			if (!ecl_equalp(x->str.self[i], y->str.self[i]))
predicate.d:                    x->hash.entries != y->hash.entries ||
predicate.d:		    x->hash.test != y->hash.test)
predicate.d:					cl_object key = env->values[1];
predicate.d:		return (tx == ty) && ecl_equalp(x->random.value, y->random.value);
print.d:/* -*- mode: c; c-basic-offset: 8 -*- */
print.d:    print.d -- Print.
print.d:		return ecl_symbol_value(@'*standard-output*');
print.d:		return ecl_symbol_value(@'*terminal-io*');
print.d:	cl_object object = ecl_symbol_value(@'*print-base*');
print.d:		ECL_SETQ(ecl_process_env(), @'*print-base*', ecl_make_fixnum(10));
print.d:		FEerror("The value of *PRINT-BASE*~%  ~S~%"
print.d:	cl_object object = ecl_symbol_value(@'*print-level*');
print.d:		ERROR:	ECL_SETQ(ecl_process_env(), @'*print-level*', ECL_NIL);
print.d:			FEerror("The value of *PRINT-LEVEL*~%  ~S~%"
print.d:	cl_object object = ecl_symbol_value(@'*print-length*');
print.d:		ERROR:	ECL_SETQ(ecl_process_env(), @'*print-length*', ECL_NIL);
print.d:			FEerror("The value of *PRINT-LENGTH*~%  ~S~%"
print.d:	return ecl_symbol_value(@'*print-radix*') != ECL_NIL;
print.d:	cl_object output = ecl_symbol_value(@'*print-case*');
print.d:		ECL_SETQ(ecl_process_env(), @'*print-case*', @':downcase');
print.d:		FEerror("The value of *PRINT-CASE*~%  ~S~%"
print.d:	return ecl_symbol_value(@'*print-gensym*') != ECL_NIL;
print.d:	return ecl_symbol_value(@'*print-array*') != ECL_NIL;
print.d:	return ecl_symbol_value(@'*print-readably*') != ECL_NIL;
print.d:	return ecl_symbol_value(@'*print-escape*') != ECL_NIL;
print.d:	return ecl_symbol_value(@'*print-circle*') != ECL_NIL;
print.d:		    (array ecl_symbol_value(@'*print-array*'))
print.d:		    (base ecl_symbol_value(@'*print-base*'))
print.d:		    ((:case cas) ecl_symbol_value(@'*print-case*'))
print.d:		    (circle ecl_symbol_value(@'*print-circle*'))
print.d:		    (escape ecl_symbol_value(@'*print-escape*'))
print.d:		    (gensym ecl_symbol_value(@'*print-gensym*'))
print.d:		    (length ecl_symbol_value(@'*print-length*'))
print.d:		    (level ecl_symbol_value(@'*print-level*'))
print.d:		    (lines ecl_symbol_value(@'*print-lines*'))
print.d:		    (miser_width ecl_symbol_value(@'*print-miser-width*'))
print.d:		    (pprint_dispatch ecl_symbol_value(@'*print-pprint-dispatch*'))
print.d:		    (pretty ecl_symbol_value(@'*print-pretty*'))
print.d:		    (radix ecl_symbol_value(@'*print-radix*'))
print.d:		    (readably ecl_symbol_value(@'*print-readably*'))
print.d:		    (right_margin ecl_symbol_value(@'*print-right-margin*')))
print.d:	ecl_bds_bind(the_env, @'*print-array*', array);
print.d:	ecl_bds_bind(the_env, @'*print-base*', base);
print.d:	ecl_bds_bind(the_env, @'*print-case*', cas);
print.d:	ecl_bds_bind(the_env, @'*print-circle*', circle);
print.d:	ecl_bds_bind(the_env, @'*print-escape*', escape);
print.d:	ecl_bds_bind(the_env, @'*print-gensym*', gensym);
print.d:	ecl_bds_bind(the_env, @'*print-level*', level);
print.d:	ecl_bds_bind(the_env, @'*print-length*', length);
print.d:	ecl_bds_bind(the_env, @'*print-lines*', lines);
print.d:	ecl_bds_bind(the_env, @'*print-miser-width*', miser_width);
print.d:	ecl_bds_bind(the_env, @'*print-pprint-dispatch*', pprint_dispatch);
print.d:	ecl_bds_bind(the_env, @'*print-pretty*', pretty);
print.d:	ecl_bds_bind(the_env, @'*print-radix*', radix);
print.d:	ecl_bds_bind(the_env, @'*print-readably*', readably);
print.d:	ecl_bds_bind(the_env, @'*print-right-margin*', right_margin);
print.d:	ecl_bds_bind(the_env, @'*print-escape*', ECL_T);
print.d:	ecl_bds_bind(the_env, @'*print-pretty*', ECL_T);
print.d:@(defun write-char (c &optional strm)
print.d:@(defun write-string (strng &o strm &k (start ecl_make_fixnum(0)) end)
print.d:                FEwrong_type_nth_arg(@[write-string], 1, strng, @[string]);
print.d:		_ecl_funcall5(@'gray::stream-write-string', strm, strng, start, end);
print.d:@(defun write-line (strng &o strm &k (start ecl_make_fixnum(0)) end)
print.d:                FEwrong_type_nth_arg(@[write-line], 1, strng, @[string]);
print.d:		_ecl_funcall5(@'gray::stream-write-string', strm, strng,
print.d:@(defun fresh-line (&optional strm)
print.d:		return _ecl_funcall2(@'gray::stream-fresh-line', strm);
print.d:@(defun finish-output (&o strm)
print.d:		return _ecl_funcall2(@'gray::stream-finish-output', strm);
print.d:@(defun force-output (&o strm)
print.d:@(defun clear-output (&o strm)
print.d:@(defun write-sequence (sequence stream &key (start ecl_make_fixnum(0)) end)
print.d:		return _ecl_funcall5(@'gray::stream-write-sequence',
print.d:	ecl_bds_bind(the_env, @'*print-escape*', ECL_NIL);
print.d:	ecl_bds_bind(the_env, @'*print-readably*', ECL_NIL);
print.d:	ecl_bds_bind(the_env, @'*print-escape*', ECL_T);
print.d:		return _ecl_funcall2(@'gray::stream-terpri', strm);
print.d:		for (i = 0;  i < strng->string.fillp;  i++)
print.d:			ecl_write_char(strng->string.self[i], strm);
print.d:		for (i = 0;  i < strng->base_string.fillp;  i++)
print.d:			ecl_write_char(strng->base_string.self[i], strm);
print.d:                FEwrong_type_nth_arg(@[write-string], 1, strng, @[string]);
print.d:	THE ULTRA-SPECIAL-DINNER-SERVICE OPTIMIZATION
read.d:/* -*- mode: c; c-basic-offset: 4 -*- */
read.d:  read.d -- Read.
read.d:#include <ecl/ecl-inl.h>
read.d:#define read_suppress (ecl_symbol_value(@'*read-suppress*') != ECL_NIL)
read.d:# define TOKEN_STRING_DIM(s) ((s)->string.dim)
read.d:# define TOKEN_STRING_FILLP(s) ((s)->string.fillp)
read.d:# define TOKEN_STRING_CHAR(s,n) ((s)->string.self[n])
read.d:# define TOKEN_STRING_CHAR_SET(s,n,c) (s)->string.self[n]=(c)
read.d:# define TOKEN_STRING_CHAR_CMP(s,n,c) ((s)->string.self[n]==(c))
read.d:# define TOKEN_STRING_DIM(s) ((s)->base_string.dim)
read.d:# define TOKEN_STRING_FILLP(s) ((s)->base_string.fillp)
read.d:# define TOKEN_STRING_CHAR(s,n) ((s)->base_string.self[n])
read.d:# define TOKEN_STRING_CHAR_SET(s,n,c) ((s)->base_string.self[n]=(c))
read.d:# define TOKEN_STRING_CHAR_CMP(s,n,c) ((s)->base_string.self[n]==(c))
read.d:        cl_object pool = env->string_pool;
read.d:                env->string_pool = CDR(pool);
read.d:                cl_object pool = env->string_pool;
read.d:                        env->string_pool = CONS(string, pool);
read.d:        ecl_bds_bind(env, @'si::*sharp-eq-context*', ECL_NIL);
read.d:        ecl_bds_bind(env, @'si::*backq-level*', ecl_make_fixnum(0));
read.d:        if (!Null(ECL_SYM_VAL(env, @'si::*sharp-eq-context*')))
read.d: * that were escaped, as in ({(low-limit . high-limit)}*). The list
read.d:                        high_limit = low_limit = -1;
read.d:                for (; i > high_limit; i--) {
read.d:                for (; i > low_limit; i--) {
read.d:        enum ecl_readtable_case read_case = rtbl->readtable.read_case;
read.d:        cl_fixnum upcase; /* # uppercase characters - # downcase characters */
read.d:                        the_env->nvalues = 0;
read.d:                if (the_env->nvalues == 0) {
read.d:                unlikely_if (the_env->nvalues > 1) {
read.d:                        FEerror("The readmacro ~S returned ~D values.", 2, x, ecl_make_fixnum(the_env->nvalues));
read.d:                        while (colon--) {
read.d:                        /* If the readtable case was :INVERT and all non-escaped characters
read.d:                                        invert_buffer_case(token, escape_list, -1);
read.d:                                } else if (upcase == -count) {
read.d:                                unlikely_if (Null(the_env->packages_to_be_created_p)) {
read.d:                                                        ecl_make_fixnum(length-1)),
read.d:                                upcase--;
read.d:        /* If the readtable case was :INVERT and all non-escaped characters
read.d:                        invert_buffer_case(token, escape_list, -1);
read.d:                } else if (upcase == -count) {
read.d:                the_env->nvalues = 1;
read.d:        the_env->nvalues = 1;
read.d:        ecl_bds_bind(env, @'si::*sharp-eq-context*', ECL_NIL);
read.d:        ecl_bds_bind(env, @'si::*backq-level*', ecl_make_fixnum(0));
read.d:                env->nvalues = 1;
read.d:        } else if (env->nvalues) {
read.d:                if (!Null(ECL_SYM_VAL(env, @'si::*sharp-eq-context*')))
read.d:        cl_fixnum backq_level = ecl_fixnum(ECL_SYM_VAL(env, @'si::*backq-level*'));
read.d:                x = @'si::unquote-splice';
read.d:                x = @'si::unquote-nsplice';
read.d:        ECL_SETQ(env, @'si::*backq-level*', ecl_make_fixnum(backq_level-1));
read.d:        ECL_SETQ(env, @'si::*backq-level*', ecl_make_fixnum(backq_level));
read.d:        cl_fixnum backq_level = ecl_fixnum(ECL_SYM_VAL(the_env, @'si::*backq-level*'));
read.d:        ECL_SETQ(the_env, @'si::*backq-level*', ecl_make_fixnum(backq_level+1));
read.d:        ECL_SETQ(the_env, @'si::*backq-level*', ecl_make_fixnum(backq_level));
read.d:  or FALSE depending on the value of *READ-SUPPRESS*.
read.d:            !Null(ECL_SYM_VAL(the_env, @'si::*sharp-eq-context*')))
read.d:                        x->complex.real = real;
read.d:                        x->complex.imag = imag;
read.d:                        FEreader_error("~S is an illegal CHAR-FONT.", in, 1, d);
read.d:                rv->bclosure.code = ECL_CONS_CAR(x);
read.d:                rv->bclosure.lex = ECL_CONS_CAR(x);
read.d:                rv->bclosure.entry = _ecl_bclosure_dispatch_vararg;
read.d:        rv->bytecodes.name = ECL_CONS_CAR(x);
read.d:        rv->bytecodes.definition = ECL_CONS_CAR(x);
read.d:        rv->bytecodes.code_size = ecl_to_fix(cl_list_length(nth));
read.d:        rv->bytecodes.code = ecl_alloc_atomic(rv->bytecodes.code_size * sizeof(uint16_t));
read.d:                ((cl_opcode*)(rv->bytecodes.code))[i] = ecl_to_fix(ECL_CONS_CAR(nth));
read.d:        rv->bytecodes.data = nth;
read.d:        rv->bytecodes.file = nth;
read.d:        rv->bytecodes.file_position = nth;
read.d:        rv->bytecodes.entry = _ecl_bytecodes_dispatch_vararg;
read.d: *----------------------------------------------------------------------
read.d: *----------------------------------------------------------------------
read.d:        if (ecl_fixnum(ECL_SYM_VAL(the_env, @'si::*backq-level*')) > 0) {
read.d:                        v = _ecl_funcall4(@'make-array', cl_list(1, cl_length(x)),
read.d:                                          @':initial-contents', x);
read.d:                /* Second case: *read-suppress* = t, we ignore the data */
read.d:                v = _ecl_funcall4(@'make-array', cl_list(1, cl_length(x)),
read.d:                                  @':initial-contents', x);
read.d:                        FEreader_error("Cannot fill the bit-vector #*.", in, 0);
read.d:        last = ECL_STACK_REF(env,-1);
read.d:                elt = (i < dimcount) ? env->stack[sp+i] : last;
read.d:                        x->vector.self.bit[i/CHAR_BIT] &= ~(0200 >> i%CHAR_BIT);
read.d:                        x->vector.self.bit[i/CHAR_BIT] |= 0200 >> i%CHAR_BIT;
read.d:        unlikely_if (ecl_symbol_value(@'*read-eval*') == ECL_NIL)
read.d:        cl_object sharp_eq_context = ECL_SYM_VAL(the_env, @'si::*sharp-eq-context*');
read.d:        ECL_SETQ(the_env, @'si::*sharp-eq-context*', CONS(pair, sharp_eq_context));
read.d:        pair = ecl_assq(d, ECL_SYM_VAL(the_env, @'si::*sharp-eq-context*'));
read.d:         * [1] object -> itself
read.d:         * [2] object -> nothing
read.d:         * [3] (# . object) -> object
read.d:                        if (x->vector.elttype == ecl_aet_object) {
read.d:                                for (i = 0;  i < x->vector.fillp;  i++)
read.d:                                        x->vector.self.t[i] =
read.d:                                                do_patch_sharp(x->vector.self.t[i], table);
read.d:                        if (x->vector.elttype == ecl_aet_object) {
read.d:                                cl_index i, j = x->array.dim;
read.d:                                        x->array.self.t[i] =
read.d:                                                do_patch_sharp(x->array.self.t[i], table);
read.d:                        cl_object r = do_patch_sharp(x->complex.real, table);
read.d:                        cl_object i = do_patch_sharp(x->complex.imag, table);
read.d:                        if (r != x->complex.real || i != x->complex.imag) {
read.d:                                x->complex = c->complex;
read.d:                        x->bclosure.lex = do_patch_sharp(x->bclosure.lex, table);
read.d:                        x = x->bclosure.code = do_patch_sharp(x->bclosure.code, table);
read.d:                        x->bytecodes.name = do_patch_sharp(x->bytecodes.name, table);
read.d:                        x->bytecodes.definition = do_patch_sharp(x->bytecodes.definition, table);
read.d:                        x->bytecodes.data = do_patch_sharp(x->bytecodes.data, table);
read.d:                        if (x->vector.elttype == ecl_aet_object) {
read.d:                                for (i = 0;  i < x->vector.fillp;  i++)
read.d:                                        x->vector.self.t[i] =
read.d:                                                do_patch_sharp(x->vector.self.t[i], table);
read.d:                        if (x->vector.elttype == ecl_aet_object) {
read.d:                                cl_index i, j = x->array.dim;
read.d:                                        x->array.self.t[i] =
read.d:                                                do_patch_sharp(x->array.self.t[i], table);
read.d:                        cl_object r = do_patch_sharp(x->complex.real, table);
read.d:                        cl_object i = do_patch_sharp(x->complex.imag, table);
read.d:                        if (r != x->complex.real || i != x->complex.imag) {
read.d:                                x->complex = c->complex;
read.d:                        x->bclosure.lex = do_patch_sharp(x->bclosure.lex, table);
read.d:                        x = x->bclosure.code = do_patch_sharp(x->bclosure.code, table);
read.d:                        x->bytecodes.name = do_patch_sharp(x->bytecodes.name, table);
read.d:                        x->bytecodes.definition = do_patch_sharp(x->bytecodes.definition, table);
read.d:                        x->bytecodes.data = do_patch_sharp(x->bytecodes.data, table);
read.d:        pairs = ECL_SYM_VAL(the_env, @'si::*sharp-eq-context*');
read.d:                                        --level;
read.d:  #$ fixnum returns a random-state with the fixnum
read.d:        rs->random.value = c;
read.d:        assert_type_readtable(@[copy-readtable], 1, from);
read.d:        output->readtable.locked = 0;
read.d:        output->readtable.table = to_rtab = (struct ecl_readtable_entry *)
read.d:        from_rtab = from->readtable.table;
read.d:        output->readtable.read_case = from->readtable.read_case;
read.d:        if (!Null(from->readtable.hash)) {
read.d:                output->readtable.hash = si_copy_hash_table(from->readtable.hash);
read.d:                output->readtable.hash = ECL_NIL;
read.d:                assert_type_readtable(@[copy-readtable], 2, to);
read.d:                to->readtable = output->readtable;
read.d:        /* INV: *READ-BASE* always has a value */
read.d:        cl_object x = ECL_SYM_VAL(the_env, @'*read-base*');
read.d:                        ECL_SETQ(the_env, @'*read-base*', ecl_make_fixnum(10));
read.d:                        FEerror("The value of *READ-BASE*~&  ~S~%"
read.d:        /* INV: *READ-DEFAULT-FLOAT-FORMAT* is always bound to something */
read.d:        x = ECL_SYM_VAL(the_env, @'*read-default-float-format*');
read.d:        if (x == @'single-float' || x == @'short-float')
read.d:        if (x == @'double-float')
read.d:        if (x == @'long-float') {
read.d:        ECL_SETQ(the_env, @'*read-default-float-format*', @'single-float');
read.d:        FEerror("The value of *READ-DEFAULT-FLOAT-FORMAT*~& ~S~%"
read.d:                "is not one of (SINGLE-FLOAT SHORT-FLOAT DOUBLE-FLOAT LONG-FLOAT)",
read.d:                return ECL_SYM_VAL(the_env, @'*standard-input*');
read.d:                return ECL_SYM_VAL(the_env, @'*terminal-io*');
read.d:          nlogd(">>read non-recursive. ansi_stream_p(%d)", ECL_ANSI_STREAM_P(strm));
read.d:          nlogd(">>read non-recursive. to");
read.d:          nlogd(">>>>>>>>>read-char from");
read.d:          nlogd(">>>>>>>>>read-char to(%d)", c);
read.d:          ecl_bds_bind(the_env, @'si::*sharp-eq-context*', ECL_NIL);
read.d:          ecl_bds_bind(the_env, @'si::*backq-level*', ecl_make_fixnum(0));
read.d:          if (!Null(ECL_SYM_VAL(the_env, @'si::*sharp-eq-context*')))
read.d:          value0 = _ecl_funcall2(@'gray::stream-read-line', strm);
read.d:              TOKEN_STRING_CHAR_CMP(token,TOKEN_STRING_FILLP(token)-1,'\r'))
read.d:                  TOKEN_STRING_FILLP(token)--;
read.d:@(defun read-char (&optional (strm ECL_NIL) (eof_errorp ECL_T) eof_value recursivep)
read.d:@(defun peek-char (&optional peek_type (strm ECL_NIL) (eof_errorp ECL_T) eof_value recursivep)
read.d:                  _ecl_funcall2(@'gray::stream-read-char-no-hang', strm);
read.d:  return funcall(5, @'gray::stream-read-sequence', stream, sequence, start, end);
read.d:        assert_type_readtable(@[readtable-case], 1, r);
read.d:        switch (r->readtable.read_case) {
read.d:        assert_type_readtable(@[readtable-case], 1, r);
read.d:        if (r->readtable.locked) {
read.d:                r->readtable.read_case = ecl_case_upcase;
read.d:                r->readtable.read_case = ecl_case_downcase;
read.d:                r->readtable.read_case = ecl_case_preserve;
read.d:                r->readtable.read_case = ecl_case_invert;
read.d:                FEwrong_type_nth_arg(@[si::readtable-case-set], 2,
read.d:                cl_object hash = readtable->readtable.hash;
read.d:                        m = readtable->readtable.table[c].dispatch;
read.d:                        cat = readtable->readtable.table[c].syntax_type;
read.d:        if (readtable->readtable.locked) {
read.d:                cl_object hash = readtable->readtable.hash;
read.d:                        readtable->readtable.hash = hash;
read.d:                        readtable->readtable.table[c].dispatch = macro_or_table;
read.d:                        readtable->readtable.table[c].syntax_type = cat;
read.d:  if (tordtbl->readtable.locked) {
read.d:  assert_type_readtable(@[readtable-case], 1, tordtbl);
read.d:  assert_type_readtable(@[readtable-case], 2, fromrdtbl);
read.d:  assert_type_readtable(@[make-dispatch-macro-character], 3, readtable);
read.d:  assert_type_readtable(@[set-dispatch-macro-character], 4, readtable);
read.d:  unlikely_if (readtable->readtable.locked) {
read.d:  assert_type_readtable(@[get-dispatch-macro-character], 3, readtable);
read.d:@(defun ext::readtable-lock (r &optional yesno)
read.d:  assert_type_readtable(@[ext::readtable-lock], 1, r);
read.d:  output = (r->readtable.locked)? ECL_T : ECL_NIL;
read.d:          r->readtable.locked = !Null(yesno);
read.d:        r->readtable.locked = 0;
read.d:        r->readtable.read_case = ecl_case_upcase;
read.d:        r->readtable.table = rtab
read.d:        r->readtable.hash = ECL_NIL;
read.d:                                        @'si::sharp-a-reader', r);
read.d:                                        @'si::sharp-s-reader', r);
read.d:        cl_set_dispatch_macro_character(4, ECL_CODE_CHAR('#'), ECL_CODE_CHAR('-'),
read.d:        r->readtable.locked = 1;
read.d:        ECL_SET(@'*read-default-float-format*', @'single-float');
read.d:                              @'*print-pprint-dispatch*', /* See end of pprint.lsp */
read.d:                              @'*print-array*',
read.d:                              @'*print-base*',
read.d:                              @'*print-case*',
read.d:                              @'*print-circle*',
read.d:                              @'*print-escape*',
read.d:                              @'*print-gensym*',
read.d:                              @'*print-length*',
read.d:                              @'*print-level*',
read.d:                              @'*print-lines*',
read.d:                              @'*print-miser-width*',
read.d:                              @'*print-pretty*',
read.d:                              @'*print-radix*',
read.d:                              @'*print-readably*',
read.d:                              @'*print-right-margin*',
read.d:                              @'*read-base*',
read.d:                              @'*read-default-float-format*',
read.d:                              @'*read-eval*',
read.d:                              @'*read-suppress*',
read.d:                              @'si::*print-package*',
read.d:                              @'si::*print-structure*',
read.d:                              @'si::*sharp-eq-context*',
read.d:                              @'si::*circle-counter*');
read.d:                              /**pprint-dispatch-table**/ ECL_NIL,
read.d:                              /**print-array**/ ECL_T,
read.d:                              /**print-base**/ ecl_make_fixnum(10),
read.d:                              /**print-case**/ @':downcase',
read.d:                              /**print-circle**/ ECL_T,
read.d:                              /**print-escape**/ ECL_T,
read.d:                              /**print-gensym**/ ECL_T,
read.d:                              /**print-length**/ ECL_NIL,
read.d:                              /**print-level**/ ECL_NIL,
read.d:                              /**print-lines**/ ECL_NIL,
read.d:                              /**print-miser-width**/ ECL_NIL,
read.d:                              /**print-pretty**/ ECL_NIL,
read.d:                              /**print-radix**/ ECL_NIL,
read.d:                              /**print-readably**/ ECL_T,
read.d:                              /**print-right-margin**/ ECL_NIL,
read.d:                              /**read-base**/ ecl_make_fixnum(10),
read.d:                              /**read-default-float-format**/ @'single-float',
read.d:                              /**read-eval**/ ECL_T,
read.d:                              /**read-suppress**/ ECL_NIL,
read.d:                              /*si::*print-package**/ cl_core.lisp_package,
read.d:                              /*si::*print-structure**/ ECL_T,
read.d:                              /*si::*sharp-eq-context**/ ECL_NIL,
read.d:                              /*si::*cicle-counter**/ ECL_NIL);
read.d:                ECL_SET(@'si::+ecl-syntax-progv-list+', CONS(var,val));
read.d:                              @'*print-pprint-dispatch*', /* See end of pprint.lsp */
read.d:                              @'*print-array*',
read.d:                              @'*print-base*',
read.d:                              @'*print-case*',
read.d:                              @'*print-circle*',
read.d:                              @'*print-escape*',
read.d:                              @'*print-gensym*',
read.d:                              @'*print-length*',
read.d:                              @'*print-level*',
read.d:                              @'*print-lines*',
read.d:                              @'*print-miser-width*',
read.d:                              @'*print-pretty*',
read.d:                              @'*print-radix*',
read.d:                              @'*print-readably*',
read.d:                              @'*print-right-margin*',
read.d:                              @'*read-base*',
read.d:                              @'*read-default-float-format*',
read.d:                              @'*read-eval*',
read.d:                              @'*read-suppress*',
read.d:                              @'si::*sharp-eq-context*',
read.d:                              @'si::*circle-counter*');
read.d:                              /**pprint-dispatch-table**/ ECL_NIL,
read.d:                              /**print-array**/ ECL_T,
read.d:                              /**print-base**/ ecl_make_fixnum(10),
read.d:                              /**print-case**/ @':upcase',
read.d:                              /**print-circle**/ ECL_NIL,
read.d:                              /**print-escape**/ ECL_T,
read.d:                              /**print-gensym**/ ECL_T,
read.d:                              /**print-length**/ ECL_NIL,
read.d:                              /**print-level**/ ECL_NIL,
read.d:                              /**print-lines**/ ECL_NIL,
read.d:                              /**print-miser-width**/ ECL_NIL,
read.d:                              /**print-pretty**/ ECL_NIL,
read.d:                              /**print-radix**/ ECL_NIL,
read.d:                              /**print-readably**/ ECL_T,
read.d:                              /**print-right-margin**/ ECL_NIL,
read.d:                              /**read-base**/ ecl_make_fixnum(10),
read.d:                              /**read-default-float-format**/ @'single-float',
read.d:                              /**read-eval**/ ECL_T,
read.d:                              /**read-suppress**/ ECL_NIL,
read.d:                              /*si::*sharp-eq-context**/ ECL_NIL,
read.d:                              /*si::*cicle-counter**/ ECL_NIL);
read.d:                ECL_SET(@'si::+io-syntax-progv-list+', CONS(var,val));
read.d: *----------------------------------------------------------------------
read.d: * ecl_init_module --
read.d: *----------------------------------------------------------------------
read.d:        volatile cl_object old_eptbc = env->packages_to_be_created;
read.d:        block->cblock.entry = entry_point;
read.d:                env->packages_to_be_created_p = ECL_T;
read.d:                perm_len = block->cblock.data_size;
read.d:                temp_len = block->cblock.temp_data_size;
read.d:                if (block->cblock.data_text == 0 || block->cblock.data_text_size == 0) {
read.d:                                /* Code from COMPILE uses data in *compiler-constants* */
read.d:                                cl_object v = ECL_SYM_VAL(env,@'si::*compiler-constants*');
read.d:                                             v->vector.dim != len ||
read.d:                                             v->vector.elttype != ecl_aet_object)
read.d:                                                "si::*compiler-constants*", 0);
read.d:                                VV = block->cblock.data = v->vector.self.t;
read.d:                                VVtemp = block->cblock.temp_data = 0;
read.d:                VV = block->cblock.data = perm_len? (cl_object *)ecl_alloc(perm_len * sizeof(cl_object)) : NULL;
read.d:                VV = block->cblock.data;
read.d:                VVtemp = block->cblock.temp_data = temp_len? (cl_object *)ecl_alloc(temp_len * sizeof(cl_object)) : NULL;
read.d:                        cl_object v = ecl_deserialize(block->cblock.data_text);
read.d:                        unlikely_if (v->vector.dim < len)
read.d:                        memcpy(VV, v->vector.self.t, len * sizeof(cl_object));
read.d:                in = ecl_make_simple_base_string((char *)block->cblock.data_text,
read.d:                                                 block->cblock.data_text_size);
read.d:                in = si_make_sequence_input_stream(3, in, @':external-format',
read.d:                                                   @':utf-8');
read.d:                in=ecl_make_string_input_stream(in, 0, block->cblock.data_text_size);
read.d:                progv_list = ECL_SYM_VAL(env, @'si::+ecl-syntax-progv-list+');
read.d:                                VVtemp[i-perm_len] = x;
read.d:                if (!Null(ECL_SYM_VAL(env, @'si::*sharp-eq-context*'))) {
read.d:                        while (i--) {
read.d:                                        VVtemp[i-perm_len] = patch_sharp(VVtemp[i-perm_len]);
read.d:                env->packages_to_be_created_p = ECL_NIL;
read.d:                for (i = 0; i < block->cblock.cfuns_size; i++) {
read.d:                        const struct ecl_cfun *prototype = block->cblock.cfuns+i;
read.d:                        cl_index fname_location = ecl_fixnum(prototype->block);
read.d:                        cl_index location = ecl_fixnum(prototype->name);
read.d:                        cl_object position = prototype->file_position;
read.d:                        int narg = prototype->narg;
read.d:                                ecl_make_cfun_va((cl_objectfn)prototype->entry,
read.d:                                ecl_make_cfun((cl_objectfn_fixed)prototype->entry,
read.d:                        if (position != ecl_make_fixnum(-1)) {
read.d:                                                                  block->cblock.source,
read.d:                /* Execute top-level code */
read.d:                x = cl_set_difference(2, env->packages_to_be_created, old_eptbc);
read.d:                old_eptbc = env->packages_to_be_created;
read.d:                                2, x, block->cblock.name);
read.d:                        block->cblock.temp_data = NULL;
read.d:                        block->cblock.temp_data_size = 0;
read.d:                env->packages_to_be_created = old_eptbc;
read.d:                env->packages_to_be_created_p = ECL_NIL;
reference.d:/* -*- mode: c; c-basic-offset: 8 -*- */
reference.d:    reference.c -- Reference in Constants and Variables.
reference.d:#include <ecl/ecl-inl.h>
reference.d:	Symbol-function returns
reference.d:                function-closure		for function
reference.d:		(macro . function-closure)	for macros
reference.d:		@(return (((fname->symbol.stype & ecl_stp_special_form)
reference.d:		unlikely_if (fun->symbol.stype & (ecl_stp_macro | ecl_stp_special_form))
reference.d:		} else if (CAR(fun) == @'ext::lambda-block') {
reference.d:	      || (t == t_instance && fun->instance.isgf)
reference.d:			FEwrong_type_only_arg(@[symbol-value], sym, @[symbol]);
sequence.d:/* -*- mode: c; c-basic-offset: 8 -*- */
sequence.d:    sequence.d -- Sequence routines.
sequence.d:#include <ecl/ecl-inl.h>
sequence.d:                FEwrong_type_key_arg(fun, @[:start], start, @[unsigned-byte]);
sequence.d:                                             ecl_read_from_cstring("(OR NULL UNSIGNED-BYTE)"));
sequence.d:		for (i = index, l = seq;  i > 0;  --i) {
sequence.d:                if (index >= seq->vector.fillp) goto E;
sequence.d:		for (i = index, l = seq;  i > 0;  --i) {
sequence.d:                if (index >= seq->vector.fillp) goto E;
sequence.d:			while (!Null(sequence) && (limit--)) {
sequence.d:		if (start > sequence->vector.fillp) {
sequence.d:			size = sequence->vector.fillp - start;
sequence.d:	sequence = ecl_subseq(sequence, p.start, p.end - p.start);
sequence.d:		return(x->vector.fillp);
sequence.d:		output = ecl_alloc_simple_vector(seq->vector.fillp, ecl_array_elttype(seq));
sequence.d:		ecl_copy_subarray(output, 0, seq, 0, seq->vector.fillp);
sequence.d:		ecl_reverse_subarray(output, 0, seq->vector.fillp);
sequence.d:		ecl_reverse_subarray(seq, 0, seq->vector.fillp);
serialize.d:/* -*- mode: c; c-basic-offset: 8 -*- */
serialize.d:    serialize.d -- Serialize a bunch of lisp data.
serialize.d:        ((int + sizeof(cl_fixnum) - 1) & ~(sizeof(cl_fixnum) - 1))
serialize.d:        cl_index fillp = pool->data->vector.fillp;
serialize.d:        if (next_fillp >= pool->data->vector.dim) {
serialize.d:                pool->data = _ecl_funcall3(@'adjust-array', pool->data,
serialize.d:        pool->data->vector.fillp = next_fillp;
serialize.d:        index = ecl_gethash_safe(what, pool->hash, OBJNULL);
serialize.d:                index = ecl_make_fixnum(pool->hash->hash.entries);
serialize.d:                ecl_sethash(what, pool->hash, index);
serialize.d:                ECL_RPLACD(pool->last, cons);
serialize.d:                pool->last = cons;
serialize.d:        memcpy(pool->data->vector.self.b8 + index, data, size);
serialize.d:        for (; dim; dim--, index += sizeof(cl_object)) {
serialize.d:                cl_object *p = (cl_object *)(pool->data->vector.self.b8 + index);
serialize.d:        cl_object disp = v->vector.displaced;
serialize.d:                v->vector.displaced = ECL_NIL;
serialize.d:                cl_index index = v->vector.self.b8 - to->vector.self.b8;
serialize.d:                v->vector.displaced = enqueue(pool, to);
serialize.d:                v->vector.self.b8 = (uint8_t*)index;
serialize.d:        if (!Null(v->vector.displaced)) {
serialize.d:        } else if (v->vector.elttype == ecl_aet_object) {
serialize.d:                serialize_object_ptr(pool, v->vector.self.t, v->vector.dim);
serialize.d:                serialize_bits(pool, v->vector.self.b8,
serialize.d:                               v->vector.dim * ecl_aet_size[v->vector.elttype]);
serialize.d:        serialize_bits(pool, a->array.dims, sizeof(cl_index) * a->array.rank);
serialize.d:                        (large_cons_ptr)(pool->data->vector.self.b8 + index);
serialize.d:                cons->t = t_list;
serialize.d:                cons->car = enqueue(pool, ECL_CONS_CAR(what));
serialize.d:                cons->cdr = enqueue(pool, ECL_CONS_CDR(what));
serialize.d:        bytes = object_size[what->d.t];
serialize.d:        buffer = (cl_object)(pool->data->vector.self.b8 + index);
serialize.d:        switch (buffer->d.t) {
serialize.d:                buffer->cons.car = enqueue(pool, buffer->cons.car);
serialize.d:                buffer->cons.cdr = enqueue(pool, buffer->cons.car);
serialize.d:                cl_index dim = ((size < 0) ? (-size) : size);
serialize.d:                buffer->ratio.den = enqueue(pool, buffer->ratio.den);
serialize.d:                buffer->ratio.num = enqueue(pool, buffer->ratio.num);
serialize.d:                buffer->complex.real = enqueue(pool, buffer->complex.real);
serialize.d:                buffer->complex.imag = enqueue(pool, buffer->complex.imag);
serialize.d:                cl_index bytes = ROUND_TO_WORD(buffer->array.rank *
serialize.d:                serialize_bits(pool, buffer->array.dims, bytes);
serialize.d:                p->name = enqueue(pool, what->pack.name);
serialize.d:                p->name = enqueue(pool, what->symbol.name);
serialize.d:                p->pack = enqueue(pool, what->symbol.hpack);
serialize.d:                buffer->pathname.host =
serialize.d:                        enqueue(pool, buffer->pathname.host);
serialize.d:                buffer->pathname.device =
serialize.d:                        enqueue(pool, buffer->pathname.device);
serialize.d:                buffer->pathname.directory =
serialize.d:                        enqueue(pool, buffer->pathname.directory);
serialize.d:                buffer->pathname.name = enqueue(pool, buffer->pathname.name);
serialize.d:                buffer->pathname.type = enqueue(pool, buffer->pathname.type);
serialize.d:                buffer->pathname.version =
serialize.d:                        enqueue(pool, buffer->pathname.version);
serialize.d:        pool->data = si_make_vector(@'ext::byte8',
serialize.d:        pool->hash = cl__make_hash_table(@'eql', ecl_make_fixnum(256),
serialize.d:        ecl_sethash(root, pool->hash, ecl_make_fixnum(0));
serialize.d:        pool->queue = ecl_list1(root);
serialize.d:        pool->last = pool->queue;
serialize.d:        pool->data->vector.self.index[0] = pool->data->vector.fillp;
serialize.d:        pool->data->vector.self.index[1] = pool->hash->hash.entries;
serialize.d:        return pool->data;
serialize.d:        while (!Null(pool->queue)) {
serialize.d:                cl_object what = ECL_CONS_CAR(pool->queue);
serialize.d:                pool->queue = ECL_CONS_CDR(pool->queue);
serialize.d:        if (v->vector.displaced == ECL_NIL) {
serialize.d:                cl_type t = v->vector.elttype;
serialize.d:                cl_index size = v->vector.dim * ecl_aet_size[t];
serialize.d:                        v->vector.self.t = reconstruct_object_ptr(data, bytes);
serialize.d:                        v->vector.self.t = reconstruct_bits(data, size);
serialize.d:        cl_index bytes = ROUND_TO_WORD(a->array.rank * sizeof(cl_index));
serialize.d:        a->array.dims = reconstruct_bits(data, bytes);
serialize.d:        cl_type t = ((cl_object)data)->d.t;
serialize.d:        switch (o->d.t) {
serialize.d:                *output = ecl_cons(c->car, c->cdr);
serialize.d:        if (!ECL_IMMEDIATE(v->vector.displaced)) {
serialize.d:                cl_object disp = get_object(v->vector.displaced, o_list);
serialize.d:                        cl_index offset = (cl_index)v->vector.self.b8;
serialize.d:                        v->vector.displaced = ECL_NIL;
serialize.d:        if (v->vector.elttype == ecl_aet_object) {
serialize.d:                cl_object *p = v->vector.self.t;
serialize.d:                for (i = v->vector.dim; i; i--, p++) {
serialize.d:        switch (o->d.t) {
serialize.d:                o->ratio.den = get_object(o->ratio.den, o_list);
serialize.d:                o->ratio.num = get_object(o->ratio.num, o_list);
serialize.d:                o->complex.real = get_object(o->complex.real, o_list);
serialize.d:                o->complex.imag = get_object(o->complex.imag, o_list);
serialize.d:                o->pathname.host = get_object(o->pathname.host, o_list);
serialize.d:                o->pathname.device =
serialize.d:                        get_object(o->pathname.device, o_list);
serialize.d:                o->pathname.directory =
serialize.d:                        get_object(o->pathname.directory, o_list);
serialize.d:                o->pathname.name = get_object(o->pathname.name, o_list);
serialize.d:                o->pathname.type = get_object(o->pathname.type, o_list);
serialize.d:                o->pathname.version =
serialize.d:                        get_object(o->pathname.version, o_list);
serialize.d:                if (!ECL_IMMEDIATE(package) && package->d.t == t_package) {
serialize.d:                        cl_object name = get_object(package->pack.name,
serialize.d:                if (!ECL_IMMEDIATE(symbol) && symbol->d.t == t_symbol) {
serialize.d:                        cl_object name = get_object(s->name, output);
serialize.d:                        cl_object pack = get_object(s->pack, output);
serialize.d:        @(return ecl_deserialize(data->vector.self.b8))
sse2.d:/* -*- mode: c; c-basic-offset: 8 -*- */
sse2.d:    sse2.c --  SSE2 vector type support
sse2.d:                FEwrong_type_nth_arg(@[ext::sse-pack-as-elt-type], 1, x, @[ext::sse-pack]);
sse2.d:	if (x->sse.elttype != rtype) {
sse2.d:		new->sse.elttype = rtype;
sse2.d:		new->sse.data.vi = x->sse.data.vi;
sse2.d:                FEwrong_type_nth_arg(@[ext::sse-pack-element-type], 1, x, @[ext::sse-pack]);
sse2.d:	@(return ecl_elttype_to_symbol(x->sse.elttype) ecl_make_fixnum(x->sse.elttype));
sse2.d:                FEwrong_type_nth_arg(@[ext::sse-pack-to-vector], 1, x, @[ext::sse-pack]);
sse2.d:	etype = x->sse.elttype;
sse2.d:	memcpy(vec->vector.self.b8, x->sse.data.b8, 16);
sse2.d:                FEwrong_type_nth_arg(@[ext::vector-to-sse-pack], 1, x, @[array]);
sse2.d:	verify_sse_elttype(x->vector.elttype);
sse2.d:	if (ecl_unlikely(x->vector.dim * ecl_aet_size[x->vector.elttype] != 16))
sse2.d:		FEerror("Wrong vector size in VECTOR-TO-SSE-PACK: ~S",1,ecl_make_fixnum(x->vector.dim));
sse2.d:	ssev->sse.elttype = x->vector.elttype;
sse2.d:	memcpy(ssev->sse.data.b8, x->vector.self.b8, 16);
sse2.d:   The unboxing primitives accept any kind of sse-pack on purpose. */
sse2.d:	obj->sse.elttype = ecl_aet_b8;
sse2.d:	obj->sse.data.vi = value;
sse2.d:			return x->sse.data.vi;
sse2.d:		x = ecl_type_error(@'coerce', "variable", x, @'ext::sse-pack');
sse2.d:	obj->sse.elttype = ecl_aet_sf;
sse2.d:	obj->sse.data.vf = value;
sse2.d:			return x->sse.data.vf;
sse2.d:		x = ecl_type_error(@'coerce', "variable", x, @'ext::sse-pack');
sse2.d:	obj->sse.elttype = ecl_aet_df;
sse2.d:	obj->sse.data.vd = value;
sse2.d:			return x->sse.data.vd;
sse2.d:		x = ecl_type_error(@'coerce', "variable", x, @'ext::sse-pack');
stacks.d:/* -*- mode: c; c-basic-offset: 8 -*- */
stacks.d:    stacks.c -- Binding/History/Frame stacks.
stacks.d:	if (&foo > env->cs_org - new_size + 16) {
stacks.d:		env->cs_limit = env->cs_org - new_size + 2*safety_area;
stacks.d:		if (env->cs_limit < env->cs_barrier)
stacks.d:			env->cs_barrier = env->cs_limit;
stacks.d:	if (&foo < env->cs_org + new_size - 16) {
stacks.d:		env->cs_limit = env->cs_org + new_size - 2*safety_area;
stacks.d:		if (env->cs_limit > env->cs_barrier)
stacks.d:			env->cs_barrier = env->cs_limit;
stacks.d:		ecl_internal_error("can't reset env->cs_limit.");
stacks.d:	env->cs_size = new_size;
stacks.d:	cl_index size = env->cs_size;
stacks.d:	if (env->cs_limit > env->cs_org - size)
stacks.d:		env->cs_limit -= safety_area;
stacks.d:	if (env->cs_limit < env->cs_org + size)
stacks.d:		env->cs_limit += safety_area;
stacks.d:		  @'ext::stack-overflow', @':size', ecl_make_fixnum(size),
stacks.d:		  @':type', @'ext::c-stack');
stacks.d:	env->cs_org = (char*)(&env);
stacks.d:	env->cs_barrier = env->cs_org;
stacks.d:			env->cs_barrier = env->cs_org - rl.rlim_cur - 1024;
stacks.d:			env->cs_barrier = env->cs_org + rl.rlim_cur + 1024;
stacks.d:	while (n--) ecl_bds_unwind1(env);
stacks.d:	ecl_bds_ptr old_org = env->bds_org;
stacks.d:	cl_index limit = env->bds_top - old_org;
stacks.d:		env->bds_top = org + limit;
stacks.d:		env->bds_org = org;
stacks.d:		env->bds_limit = org + (size - 2*margin);
stacks.d:		env->bds_size = size;
stacks.d:	cl_index size = env->bds_size;
stacks.d:	ecl_bds_ptr org = env->bds_org;
stacks.d:	if (env->bds_limit >= last) {
stacks.d:	env->bds_limit += margin;
stacks.d:		  @'ext::stack-overflow', @':size', ecl_make_fixnum(size),
stacks.d:		  @':type', @'ext::binding-stack');
stacks.d:        return env->bds_top;
stacks.d:	ecl_bds_ptr new_bds_top = new_bds_top_index + env->bds_org;
stacks.d:	ecl_bds_ptr bds = env->bds_top;
stacks.d:	for (;  bds > new_bds_top;  bds--)
stacks.d:		bds->symbol->symbol.value = bds->value;
stacks.d:	env->bds_top = new_bds_top;
stacks.d:        cl_index n = env->bds_top - env->bds_org;
stacks.d:		ecl_bds_ptr p = env->bds_org + ecl_fixnum(x);
stacks.d:		if (env->bds_org <= p && p <= env->bds_top)
stacks.d:	@(return ecl_make_fixnum(env->bds_top - env->bds_org))
stacks.d:	@(return get_bds_ptr(arg)->symbol)
stacks.d:        cl_object v = get_bds_ptr(arg)->value;
stacks.d:        cl_index new_index = symbol->symbol.binding;
stacks.d:		symbol->symbol.binding = new_index;
stacks.d:		symbol->symbol.dynamic |= 1;
stacks.d:        ecl_copy_subarray(new_vector, 0, vector, 0, vector->vector.dim);
stacks.d:        cl_index index = s->symbol.binding;
stacks.d:        if (index >= env->thread_local_bindings_size) {
stacks.d:                cl_object vector = env->bindings_array;
stacks.d:                env->bindings_array = vector = ecl_extend_bindings_array(vector);
stacks.d:                env->thread_local_bindings_size = vector->vector.dim;
stacks.d:                env->thread_local_bindings = vector->vector.self.t;
stacks.d:        cl_index index = s->symbol.binding;
stacks.d:        if (index >= env->thread_local_bindings_size) {
stacks.d:        location = env->thread_local_bindings + index;
stacks.d:        slot = ++env->bds_top;
stacks.d:        if (slot >= env->bds_limit) slot = ecl_bds_overflow();
stacks.d:        slot->symbol = s;
stacks.d:        slot->value = *location;
stacks.d:	(++(env->bds_top))->symbol = s;
stacks.d:	env->bds_top->value = s->symbol.value; \
stacks.d:	s->symbol.value = v;
stacks.d:        cl_index index = s->symbol.binding;
stacks.d:        if (index >= env->thread_local_bindings_size) {
stacks.d:        location = env->thread_local_bindings + index;
stacks.d:        slot = ++env->bds_top;
stacks.d:        if (slot >= env->bds_limit) slot = ecl_bds_overflow();
stacks.d:        slot->symbol = s;
stacks.d:        slot->value = *location;
stacks.d:	if (!(*location)) *location = s->symbol.value;
stacks.d:	(++(env->bds_top))->symbol = s;
stacks.d:	env->bds_top->value = s->symbol.value;
stacks.d:	ecl_bds_ptr slot = env->bds_top--;
stacks.d:	cl_object s = slot->symbol;
stacks.d:        cl_object *location = env->thread_local_bindings + s->symbol.binding;
stacks.d:        *location = slot->value;
stacks.d:        s->symbol.value = slot->value;
stacks.d:        cl_index index = s->symbol.binding;
stacks.d:        if (index < env->thread_local_bindings_size) {
stacks.d:                cl_object x = env->thread_local_bindings[index];
stacks.d:        return s->symbol.value;
stacks.d:        cl_index index = s->symbol.binding;
stacks.d:        if (index < env->thread_local_bindings_size) {
stacks.d:                cl_object *location = env->thread_local_bindings + index;
stacks.d:	return (s->symbol.value = value);
stacks.d:		x = x->bclosure.code;
stacks.d:		y = x->bytecodes.name;
stacks.d:		return(x->cfun.name);
stacks.d:	ecl_ihs_ptr p = env->ihs_top;
stacks.d:	if (n > p->index)
stacks.d:	while (n < p->index)
stacks.d:		p = p->next;
stacks.d:	@(return ecl_make_fixnum(env->ihs_top->index))
stacks.d:	@(return ecl_make_fixnum(get_ihs_ptr(ecl_to_size(arg))->bds))
stacks.d:	@(return get_ihs_ptr(ecl_to_size(arg))->function)
stacks.d:	@(return get_ihs_ptr(ecl_to_size(arg))->lex_env)
stacks.d:	ecl_frame_ptr old_org = env->frs_org;
stacks.d:	cl_index limit = env->frs_top - old_org;
stacks.d:		env->frs_top = org + limit;
stacks.d:		env->frs_org = org;
stacks.d:		env->frs_limit = org + (size - 2*margin);
stacks.d:		env->frs_size = size;
stacks.d:	cl_index size = env->frs_size;
stacks.d:	ecl_frame_ptr org = env->frs_org;
stacks.d:	if (env->frs_limit >= last) {
stacks.d:	env->frs_limit += margin;
stacks.d:		  @'ext::stack-overflow', @':size', ecl_make_fixnum(size),
stacks.d:		  @':type', @'ext::frame-stack');
stacks.d:	ecl_frame_ptr output = ++env->frs_top;
stacks.d:	if (output >= env->frs_limit) {
stacks.d:		output = env->frs_top;
stacks.d:	output->frs_bds_top_index = env->bds_top - env->bds_org;
stacks.d:	output->frs_val = val;
stacks.d:	output->frs_ihs = env->ihs_top;
stacks.d:	output->frs_sp = ECL_STACK_INDEX(env);
stacks.d:	env->nlj_fr = fr;
stacks.d:	while (env->frs_top != fr && env->frs_top->frs_val != ECL_PROTECT_TAG)
stacks.d:		--env->frs_top;
stacks.d:	env->ihs_top = env->frs_top->frs_ihs;
stacks.d:	ecl_bds_unwind(env, env->frs_top->frs_bds_top_index);
stacks.d:	ECL_STACK_SET_INDEX(env, env->frs_top->frs_sp);
stacks.d:	ecl_longjmp(env->frs_top->frs_jmpbuf, 1);
stacks.d:	for (top = env->frs_top;  top >= env->frs_org;  top--)
stacks.d:		if (top->frs_val == frame_id)
stacks.d:		ecl_frame_ptr p = env->frs_org + ecl_fixnum(x);
stacks.d:		if (env->frs_org <= p && p <= env->frs_top)
stacks.d:	@(return ecl_make_fixnum(env->frs_top - env->frs_org))
stacks.d:	@(return ecl_make_fixnum(get_frame_ptr(arg)->frs_bds_top_index))
stacks.d:	@(return get_frame_ptr(arg)->frs_val)
stacks.d:	@(return ecl_make_fixnum(get_frame_ptr(arg)->frs_ihs->index))
stacks.d:	     x <= env->frs_top && x->frs_ihs->index < y;
stacks.d:	@(return ((x > env->frs_top) ? ECL_NIL : ecl_make_fixnum(x - env->frs_org)))
stacks.d:	if (type == @'ext::frame-stack') {
stacks.d:	} else if (type == @'ext::binding-stack') {
stacks.d:	} else if (type == @'ext::c-stack') {
stacks.d:	} else if (type == @'ext::lisp-stack') {
stacks.d:	if (type == @'ext::frame-stack') {
stacks.d:		output = env->frs_size;
stacks.d:	} else if (type == @'ext::binding-stack') {
stacks.d:		output = env->bds_size;
stacks.d:	} else if (type == @'ext::c-stack') {
stacks.d:		output = env->cs_size;
stacks.d:	} else if (type == @'ext::lisp-stack') {
stacks.d:		output = env->stack_size;
stacks.d:	env->frs_size = size;
stacks.d:	env->frs_org = (ecl_frame_ptr)ecl_alloc_atomic(size * sizeof(*env->frs_org));
stacks.d:	env->frs_top = env->frs_org-1;
stacks.d:	env->frs_limit = &env->frs_org[size - 2*margin];
stacks.d:	env->bds_size = size;
stacks.d:	env->bds_org = (ecl_bds_ptr)ecl_alloc_atomic(size * sizeof(*env->bds_org));
stacks.d:	env->bds_top = env->bds_org-1;
stacks.d:	env->bds_limit = &env->bds_org[size - 2*margin];
stacks.d:	env->ihs_top = &ihs_org;
string.d:/* -*- mode: c; c-basic-offset: 8 -*- */
string.d:    string.d -- String routines.
string.d:#include <ecl/ecl-inl.h>
string.d:		x->base_string.self[i] = code;
string.d:		x->string.self[i] = code;
string.d:	if (element_type == @'base-char' || element_type == @'standard-char') {
string.d:	} else if (_ecl_funcall3(@'subtypep', element_type, @'base-char') == ECL_T) {
string.d:	output->base_string.self       = (ecl_base_char *)ecl_alloc_atomic(l+1);
string.d:        output->base_string.self[l]    = 0;
string.d:	output->base_string.flags      = ECL_FLAG_HAS_FILL_POINTER | ECL_FLAG_ADJUSTABLE;
string.d:        output->base_string.elttype    = ecl_aet_bc;
string.d:	output->base_string.displaced  = ECL_NIL;
string.d:	output->base_string.dim        = l;
string.d:	output->base_string.fillp      = 0;
string.d:	output->string.self       = (ecl_character *)ecl_alloc_atomic(bytes);
string.d:	output->string.flags      = ECL_FLAG_HAS_FILL_POINTER | ECL_FLAG_ADJUSTABLE;
string.d:        output->string.elttype    = ecl_aet_ch;
string.d:	output->string.displaced  = ECL_NIL;
string.d:	output->string.dim        = l;
string.d:        output->string.fillp      = 0;
string.d:	Make_simple_base_string(s) makes a simple-base string from C string s.
string.d:        x->base_string.elttype = ecl_aet_bc;
string.d:        x->base_string.flags = 0; /* no fill pointer, no adjustable */
string.d:	x->base_string.displaced = ECL_NIL;
string.d:	x->base_string.dim = (x->base_string.fillp = l);
string.d:	x->base_string.self = (ecl_base_char *)s;
string.d:	memcpy(x->base_string.self, s, l);
string.d:		for (i = 0; i < s->string.fillp; i++) {
string.d:			if (!ECL_BASE_CHAR_CODE_P(s->string.self[i]))
string.d:		FEwrong_type_nth_arg(@[si::copy-to-simple-base-string],1,s,@[string]);
string.d:		x = x->symbol.name;
string.d:		cl_index index, length = x->string.fillp;
string.d:			ecl_character c = x->string.self[index];
string.d:				FEerror("Cannot coerce string ~A to a base-string", 1, x);
string.d:			y->base_string.self[index] = c;
string.d:		cl_index length = x->base_string.fillp;
string.d:		memcpy(y->base_string.self, x->base_string.self, length);
string.d:			x = ECL_NIL_SYMBOL->symbol.name;
string.d:                FEwrong_type_nth_arg(@[si::copy-to-simple-base-string],1,x,@[string]);
string.d:		x = x->symbol.name;
string.d:			y->base_string.self[0] = c;
string.d:			y->string.self[0] = c;
string.d:		y->base_string.self[0] = c;
string.d:			x = ECL_NIL_SYMBOL->symbol.name;
string.d:		x = x->symbol.name;
string.d:		y->string.self[0] = ECL_CHAR_CODE(x);
string.d:		cl_index index, len = x->base_string.dim;
string.d:		y = ecl_alloc_simple_extended_string(x->base_string.fillp);
string.d:			y->string.self[index] = x->base_string.self[index];
string.d:		y->string.fillp = x->base_string.fillp;
string.d:			x = ECL_NIL_SYMBOL->symbol.name;
string.d:                FEwrong_type_nth_arg(@[si::coerce-to-extended-string],1,x,@[string]);
string.d:		if (index >= object->string.dim)
string.d:		return object->string.self[index];
string.d:		if (index >= object->base_string.dim)
string.d:		return object->base_string.self[index];
string.d:		if (index >= object->string.dim)
string.d:		return object->string.self[index] = value;
string.d:		if (index >= object->base_string.dim)
string.d:		return object->base_string.self[index] = value;
string.d:                FEwrong_type_nth_arg(@[si::char-set],1,object,@[string]);
string.d:			return -1;
string.d:		return -1;
string.d:			return -1;
string.d:		return -1;
string.d:	if (e1 - s1 != e2 - s2)
string.d:	if (string1->string.t == t_string) {
string.d:		if (string2->string.t == t_string) {
string.d:				if (string1->string.self[s1++] != string2->string.self[s2++])
string.d:				if (string1->string.self[s1++] != string2->base_string.self[s2++])
string.d:		if (string2->string.t == t_string) {
string.d:				if (string1->base_string.self[s1++] != string2->string.self[s2++])
string.d:				if (string1->base_string.self[s1++] != string2->base_string.self[s2++])
string.d:		if (string1->base_string.self[s1++] != string2->base_string.self[s2++])
string.d:	i = x->base_string.fillp;
string.d:	j = y->base_string.fillp;
string.d:			return memcmp(x->string.self, y->string.self, i * sizeof *x->string.self) == 0;
string.d:				if (x->string.self[index] != y->base_string.self[index])
string.d:			return memcmp(x->base_string.self, y->base_string.self, i) == 0;
string.d:	return memcmp(x->base_string.self, y->base_string.self, i) == 0;
string.d:        printf(">>>>FUCKFUCK:%d:%d\n", string1->string.t, string2->string.t);
string.d:        printf(">>>>FUCKFUCK:%d:%d:%d\n", narg, string1->string.t, string2->string.t);
string.d:        printf("order-at-string:%d:%d\n", a, b);
string.d:  printf("FUCK-string-equal:%d, %d\n", string1->string.t, string2->string.t);
string.d:	string2 = cl_string(string2); // this is fuckin string2->string.t == \xf4 (must be 10)
string.d:	if (e1 - s1 != e2 - s2)
string.d:	output = compare_base(string1->base_string.self + s1, e1 - s1,
string.d:			      string2->base_string.self + s2, e2 - s2,
string.d:		output = compare_base(string1->base_string.self + s1, e1 - s1,
string.d:				      string2->base_string.self + s2, e2 - s2,
string.d:	return string_compare(narg, -1, -1, 1, args);
string.d:	return string_compare(narg, -1, 0, 1, args);
string.d:	return string_compare(narg, -1, +1, 1, args);
string.d:@(defun string-lessp (&rest args)
string.d:	return string_compare(narg, -1, -1, 0, args);
string.d:@(defun string-greaterp (&rest args)
string.d:@(defun string-not-greaterp (&rest args)
string.d:	return string_compare(narg, -1, 0, 0, args);
string.d:@(defun string-not-lessp (&rest args)
string.d:@(defun string-not-equal (&rest args)
string.d:	return string_compare(narg, -1, +1, 0, args);
string.d:		for (i = 0, f = char_bag->vector.fillp;  i < f;  i++) {
string.d:			cl_object other = char_bag->vector.self.t[i];
string.d:		for (i = 0, f = char_bag->string.fillp;  i < f;  i++) {
string.d:			if (c == char_bag->string.self[i])
string.d:		for (i = 0, f = char_bag->base_string.fillp;  i < f;  i++) {
string.d:			if (c == char_bag->base_string.self[i])
string.d:		for (; j > i; j--) {
string.d:			cl_index c = ecl_char(strng, j-1);
string.d:			strng->string.self[i] = (*casefun)(strng->string.self[i], &b);
string.d:		strng->base_string.self[i] = (*casefun)(strng->base_string.self[i], &b);
string.d:@(defun string-upcase (&rest args)
string.d:	return string_case(narg, @[string-upcase], char_upcase, args);
string.d:@(defun string-downcase (&rest args)
string.d:	return string_case(narg, @[string-downcase], char_downcase, args);
string.d:@(defun string-capitalize (&rest args)
string.d:	return string_case(narg, @[string-capitalize], char_capitalize, args);
string.d:			strng->string.self[i] = (*casefun)(strng->string.self[i], &b);
string.d:		strng->base_string.self[i] = (*casefun)(strng->base_string.self[i], &b);
string.d:@(defun nstring-upcase (&rest args)
string.d:	return nstring_case(narg, @'nstring-upcase', char_upcase, args);
string.d:@(defun nstring-downcase (&rest args)
string.d:	return nstring_case(narg, @'nstring-downcase', char_downcase, args);
string.d:@(defun nstring-capitalize (&rest args)
string.d:	return nstring_case(narg, @'nstring-capitalize', char_capitalize, args);
string.d:@(defun si::base-string-concatenate (&rest args)
string.d:		if (s->base_string.fillp) {
string.d:			l += s->base_string.fillp;
string.d:		size_t bytes = s->base_string.fillp;
string.d:		l -= bytes;
string.d:		memcpy(output->base_string.self + l, s->base_string.self, bytes);
structure.d:/* -*- mode: c; c-basic-offset: 8 -*- */
structure.d:    structure.c -- Structure interface.
structure.d:#include <ecl/ecl-inl.h>
structure.d:/******************************* ------- ******************************/
structure.d:		x = si_get_sysprop(x, @'si::structure-include');
structure.d:@(defun si::make-structure (type &rest args)
structure.d:	ECL_STRUCT_LENGTH(x) = --narg;
structure.d:        x->instance.sig = ECL_UNBOUND;
structure.d:		FEwrong_type_only_arg(@[copy-structure], x, @[structure]);
structure.d:        y->instance.sig = x->instance.sig;
structure.d:                FEwrong_type_only_arg(@[copy-structure], s, @[structure]);
structure.d:/* Kept only for compatibility. One should use class-of or type-of. */
structure.d:                FEwrong_type_only_arg(@[si::structure-name], s, @[structure]);
structure.d:                FEwrong_type_nth_arg(@[si::structure-ref], 1, x, type);
structure.d:                FEwrong_type_nth_arg(@[si::structure-ref], 1, x, type);
structure.d:                FEwrong_type_nth_arg(@[si::structure-set], 1, x, type);
structure.d:                FEwrong_type_nth_arg(@[si::structure-set], 1, x, type);
structure.d:	if (ECL_INSTANCEP(s) && structure_subtypep(ECL_CLASS_OF(s), @'structure-object'))
symbol.d:/* -*- mode: c; c-basic-offset: 8 -*- */
symbol.d:    symbol.d -- Symbols.
symbol.d:#include <ecl/ecl-inl.h>
symbol.d:/******************************* ------- ******************************/
symbol.d:/* FIXME! CURRENTLY SYMBOLS ARE RESTRICTED TO HAVE NON-UNICODE NAMES */
symbol.d:                return ECL_NIL_SYMBOL->symbol.hpack;
symbol.d:                return s->symbol.hpack;
symbol.d:        FEwrong_type_nth_arg(@[symbol-package], 1, s, @[symbol]);
symbol.d:                return ECL_NIL_SYMBOL->symbol.stype;
symbol.d:                return s->symbol.stype;
symbol.d:        FEwrong_type_nth_arg(@[symbol-name], 1, s, @[symbol]);
symbol.d:                ECL_NIL_SYMBOL->symbol.stype = type;
symbol.d:                s->symbol.stype = type;
symbol.d:        FEwrong_type_nth_arg(@[symbol-name], 1, s, @[symbol]);
symbol.d:                return ECL_NIL_SYMBOL->symbol.name;
symbol.d:                return s->symbol.name;
symbol.d:        FEwrong_type_nth_arg(@[symbol-name], 1, s, @[symbol]);
symbol.d:                return &ECL_NIL_SYMBOL->symbol.plist;
symbol.d:                return &s->symbol.plist;
symbol.d:        FEwrong_type_nth_arg(@[symbol-plist], 1, s, @[symbol]);
symbol.d:		FEwrong_type_nth_arg(@[make-symbol],1,str,@[string]);
symbol.d:	x->symbol.name = str;
symbol.d:	x->symbol.dynamic = 0;
symbol.d:	x->symbol.binding = ECL_MISSING_SPECIAL_BINDING;
symbol.d:	x->symbol.plist = ECL_NIL;
symbol.d:	x->symbol.hpack = ECL_NIL;
symbol.d:	x->symbol.stype = ecl_stp_ordinary;
symbol.d:	cl_error(9, @'simple-type-error', @':format-control',
symbol.d:		 @':format-arguments', cl_list(1, x),
symbol.d:		 @':expected-type', @'si::property-list',
symbol.d:	(SI:PUT-F plist value indicator)
symbol.d:	return (ecl_t_of(s) == t_symbol) && (s->symbol.hpack == cl_core.keyword_package);
symbol.d:		x->symbol.dynamic = 0;
symbol.d:		x->symbol.stype = sym->symbol.stype;
symbol.d:		x->symbol.value = sym->symbol.value;
symbol.d:		x->symbol.gfdef = sym->symbol.gfdef;
symbol.d:		x->symbol.plist = cl_copy_list(sym->symbol.plist);
symbol.d:		x->symbol.binding = ECL_MISSING_SPECIAL_BINDING;
symbol.d:		counter = ECL_SYM_VAL(the_env, @'*gensym-counter*');
symbol.d:	ecl_bds_bind(the_env, @'*print-escape*', ECL_NIL);
symbol.d:	ecl_bds_bind(the_env, @'*print-readably*', ECL_NIL);
symbol.d:	ecl_bds_bind(the_env, @'*print-base*', ecl_make_fixnum(10));
symbol.d:	ecl_bds_bind(the_env, @'*print-radix*', ECL_NIL);
symbol.d:		ECL_SETQ(the_env, @'*gensym-counter*',ecl_one_plus(counter));
symbol.d:	ecl_bds_bind(the_env, @'*print-escape*', ECL_NIL);
symbol.d:	ecl_bds_bind(the_env, @'*print-readably*', ECL_NIL);
symbol.d:	ecl_bds_bind(the_env, @'*print-base*', ecl_make_fixnum(10));
symbol.d:	ecl_bds_bind(the_env, @'*print-radix*', ECL_NIL);
symbol.d:	(SI:REM-F plist indicator) returns two values:
symbol.d:@(defun si::put-properties (sym &rest ind_values)
symbol.d:	while (--narg >= 2) {
symbol.d:		narg--;
symbol.d:@si::*make-special(cl_object sym)
symbol.d:	cl_remprop(sym, @'si::symbol-macro');
symbol.d:@si::*make-constant(cl_object sym, cl_object val)
symbols_list.h:/* -*- mode: c; c-basic-offset: 8 -*- */
symbols_list.h: * not be able to cross-compile.
symbols_list.h:{"NIL", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"T", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "UNBOUND", SI_ORDINARY, NULL, -1, ECL_UNBOUND},
symbols_list.h:{SYS_ "PROTECT-TAG", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "*RESTART-CLUSTERS*", SI_SPECIAL, NULL, -1, Cnil},
symbols_list.h:{SYS_ "*HANDLER-CLUSTERS*", SI_SPECIAL, NULL, -1, Cnil},
symbols_list.h:{"&ALLOW-OTHER-KEYS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"&AUX", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"&BODY", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"&ENVIRONMENT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"&KEY", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"&OPTIONAL", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"&REST", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"&WHOLE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"+", CL_SPECIAL, cl_P, -1, ECL_NIL},
symbols_list.h:{"++", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"+++", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"-", CL_SPECIAL, cl_M, -1, ECL_NIL},
symbols_list.h:{"*", CL_SPECIAL, cl_X, -1, ECL_NIL},
symbols_list.h:{"**", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"***", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"/", CL_SPECIAL, cl_N, -1, ECL_NIL},
symbols_list.h:{"//", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"///", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"/=", CL_ORDINARY, cl_NE, -1, OBJNULL},
symbols_list.h:{"*BREAK-ON-SIGNALS*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*COMPILE-FILE-PATHNAME*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*COMPILE-FILE-TRUENAME*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*COMPILE-PRINT*", CL_SPECIAL, NULL, -1, ECL_T},
symbols_list.h:{"*COMPILE-VERBOSE*", CL_SPECIAL, NULL, -1, ECL_T},
symbols_list.h:{"*DEBUG-IO*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*DEBUGGER-HOOK*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*DEFAULT-PATHNAME-DEFAULTS*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*ERROR-OUTPUT*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*FEATURES*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*GENSYM-COUNTER*", CL_SPECIAL, NULL, -1, ecl_make_fixnum(0)},
symbols_list.h:{"*LOAD-PATHNAME*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*LOAD-PRINT*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*LOAD-TRUENAME*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*LOAD-VERBOSE*", CL_SPECIAL, NULL, -1, ECL_T},
symbols_list.h:{"*MACROEXPAND-HOOK*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*MODULES*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "*MODULE-PROVIDER-FUNCTIONS*", EXT_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*PACKAGE*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*PRINT-ARRAY*", CL_SPECIAL, NULL, -1, ECL_T},
symbols_list.h:{"*PRINT-BASE*", CL_SPECIAL, NULL, -1, ecl_make_fixnum(10)},
symbols_list.h:{"*PRINT-CASE*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*PRINT-CIRCLE*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*PRINT-ESCAPE*", CL_SPECIAL, NULL, -1, ECL_T},
symbols_list.h:{"*PRINT-GENSYM*", CL_SPECIAL, NULL, -1, ECL_T},
symbols_list.h:{"*PRINT-LENGTH*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*PRINT-LEVEL*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*PRINT-LINES*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*PRINT-MISER-WIDTH*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*PRINT-PPRINT-DISPATCH*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*PRINT-PRETTY*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*PRINT-PRETTY*", CL_SPECIAL, NULL, -1, ECL_T},
symbols_list.h:{"*PRINT-RADIX*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*PRINT-READABLY*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*PRINT-RIGHT-MARGIN*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*QUERY-IO*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*RANDOM-STATE*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*READ-BASE*", CL_SPECIAL, NULL, -1, ecl_make_fixnum(10)},
symbols_list.h:{"*READ-DEFAULT-FLOAT-FORMAT*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*READ-EVAL*", CL_SPECIAL, NULL, -1, ECL_T},
symbols_list.h:{"*READ-SUPPRESS*", CL_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{"*READTABLE*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*STANDARD-INPUT*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*STANDARD-OUTPUT*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*TERMINAL-IO*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"*TRACE-OUTPUT*", CL_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{"1-", CL_ORDINARY, cl_1M, 1, OBJNULL},
symbols_list.h:{"<", CL_ORDINARY, cl_L, -1, OBJNULL},
symbols_list.h:{"<=", CL_ORDINARY, cl_LE, -1, OBJNULL},
symbols_list.h:{"=", CL_ORDINARY, cl_E, -1, OBJNULL},
symbols_list.h:{">", CL_ORDINARY, cl_G, -1, OBJNULL},
symbols_list.h:{">=", CL_ORDINARY, cl_GE, -1, OBJNULL},
symbols_list.h:{"ABORT", CL_ORDINARY, ECL_NAME(cl_abort), -1, OBJNULL},
symbols_list.h:{"ADJOIN", CL_ORDINARY, cl_adjoin, -1, OBJNULL},
symbols_list.h:{"ADJUST-ARRAY", CL_ORDINARY, ECL_NAME(cl_adjust_array), -1, OBJNULL},
symbols_list.h:{"ADJUSTABLE-ARRAY-P", CL_ORDINARY, cl_adjustable_array_p, 1, OBJNULL},
symbols_list.h:{"ALPHA-CHAR-P", CL_ORDINARY, cl_alpha_char_p, 1, OBJNULL},
symbols_list.h:{"AND", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"APPEND", CL_ORDINARY, cl_append, -1, OBJNULL},
symbols_list.h:{"APPLY", CL_ORDINARY, cl_apply, -1, OBJNULL},
symbols_list.h:{"APROPOS", CL_ORDINARY, ECL_NAME(cl_apropos), -1, OBJNULL},
symbols_list.h:{"APROPOS-LIST", CL_ORDINARY, ECL_NAME(cl_apropos_list), -1, OBJNULL},
symbols_list.h:{"AREF", CL_ORDINARY, cl_aref, -1, OBJNULL},
symbols_list.h:{"ARITHMETIC-ERROR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ARITHMETIC-ERROR-OPERANDS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ARITHMETIC-ERROR-OPERATION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ARRAY", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ARRAY-DIMENSION", CL_ORDINARY, cl_array_dimension, 2, OBJNULL},
symbols_list.h:{"ARRAY-DIMENSION-LIMIT", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_ARRAY_DIMENSION_LIMIT)},
symbols_list.h:{"ARRAY-DIMENSIONS", CL_ORDINARY, ECL_NAME(cl_array_dimensions), 1, OBJNULL},
symbols_list.h:{"ARRAY-DISPLACEMENT", CL_ORDINARY, cl_array_displacement, 1, OBJNULL},
symbols_list.h:{"ARRAY-ELEMENT-TYPE", CL_ORDINARY, cl_array_element_type, 1, OBJNULL},
symbols_list.h:{"ARRAY-HAS-FILL-POINTER-P", CL_ORDINARY, cl_array_has_fill_pointer_p, 1, OBJNULL},
symbols_list.h:{"ARRAY-IN-BOUNDS-P", CL_ORDINARY, ECL_NAME(cl_array_in_bounds_p), -1, OBJNULL},
symbols_list.h:{"ARRAY-RANK", CL_ORDINARY, cl_array_rank, 1, OBJNULL},
symbols_list.h:{"ARRAY-RANK-LIMIT", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_ARRAY_RANK_LIMIT)},
symbols_list.h:{"ARRAY-ROW-MAJOR-INDEX", CL_ORDINARY, ECL_NAME(cl_array_row_major_index), -1, OBJNULL},
symbols_list.h:{"ARRAY-TOTAL-SIZE", CL_ORDINARY, cl_array_total_size, 1, OBJNULL},
symbols_list.h:{"ARRAY-TOTAL-SIZE-LIMIT", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_ARRAY_TOTAL_LIMIT)},
symbols_list.h:{"ASSERT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ASSOC", CL_ORDINARY, cl_assoc, -1, OBJNULL},
symbols_list.h:{"ASSOC-IF", CL_ORDINARY, ECL_NAME(cl_assoc_if), -1, OBJNULL},
symbols_list.h:{"ASSOC-IF-NOT", CL_ORDINARY, ECL_NAME(cl_assoc_if_not), -1, OBJNULL},
symbols_list.h:{"ATAN", CL_ORDINARY, cl_atan, -1, OBJNULL},
symbols_list.h:{"BASE-CHAR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"BASE-STRING", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"BIGNUM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"BIT", CL_ORDINARY, ECL_NAME(cl_bit), -1, OBJNULL},
symbols_list.h:{"BIT-AND", CL_ORDINARY, ECL_NAME(cl_bit_and), -1, OBJNULL},
symbols_list.h:{"BIT-ANDC1", CL_ORDINARY, ECL_NAME(cl_bit_andc1), -1, OBJNULL},
symbols_list.h:{"BIT-ANDC2", CL_ORDINARY, ECL_NAME(cl_bit_andc2), -1, OBJNULL},
symbols_list.h:{"BIT-EQV", CL_ORDINARY, ECL_NAME(cl_bit_eqv), -1, OBJNULL},
symbols_list.h:{"BIT-IOR", CL_ORDINARY, ECL_NAME(cl_bit_ior), -1, OBJNULL},
symbols_list.h:{"BIT-NAND", CL_ORDINARY, ECL_NAME(cl_bit_nand), -1, OBJNULL},
symbols_list.h:{"BIT-NOR", CL_ORDINARY, ECL_NAME(cl_bit_nor), -1, OBJNULL},
symbols_list.h:{"BIT-NOT", CL_ORDINARY, ECL_NAME(cl_bit_not), -1, OBJNULL},
symbols_list.h:{"BIT-ORC1", CL_ORDINARY, ECL_NAME(cl_bit_orc1), -1, OBJNULL},
symbols_list.h:{"BIT-ORC2", CL_ORDINARY, ECL_NAME(cl_bit_orc2), -1, OBJNULL},
symbols_list.h:{"BIT-VECTOR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"BIT-VECTOR-P", CL_ORDINARY, cl_bit_vector_p, 1, OBJNULL},
symbols_list.h:{"BIT-XOR", CL_ORDINARY, ECL_NAME(cl_bit_xor), -1, OBJNULL},
symbols_list.h:{"BLOCK", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"BOOLE-1", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOL1)},
symbols_list.h:{"BOOLE-2", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOL2)},
symbols_list.h:{"BOOLE-AND", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLAND)},
symbols_list.h:{"BOOLE-ANDC1", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLANDC1)},
symbols_list.h:{"BOOLE-ANDC2", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLANDC2)},
symbols_list.h:{"BOOLE-C1", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLC1)},
symbols_list.h:{"BOOLE-C2", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLC2)},
symbols_list.h:{"BOOLE-CLR", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLCLR)},
symbols_list.h:{"BOOLE-EQV", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLEQV)},
symbols_list.h:{"BOOLE-IOR", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLIOR)},
symbols_list.h:{"BOOLE-NAND", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLNAND)},
symbols_list.h:{"BOOLE-NOR", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLNOR)},
symbols_list.h:{"BOOLE-ORC1", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLORC1)},
symbols_list.h:{"BOOLE-ORC2", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLORC2)},
symbols_list.h:{"BOOLE-SET", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLSET)},
symbols_list.h:{"BOOLE-XOR", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_BOOLXOR)},
symbols_list.h:{"BOOLEAN", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"BOTH-CASE-P", CL_ORDINARY, cl_both_case_p, 1, OBJNULL},
symbols_list.h:{"BREAK", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"BROADCAST-STREAM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"BROADCAST-STREAM-STREAMS", CL_ORDINARY, cl_broadcast_stream_streams, 1, OBJNULL},
symbols_list.h:{"BUTLAST", CL_ORDINARY, cl_butlast, -1, OBJNULL},
symbols_list.h:{"BYTE-POSITION", CL_ORDINARY, ECL_NAME(cl_byte_position), 1, OBJNULL},
symbols_list.h:{"BYTE-SIZE", CL_ORDINARY, ECL_NAME(cl_byte_size), 1, OBJNULL},
symbols_list.h:{"CALL-ARGUMENTS-LIMIT", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_CALL_ARGUMENTS_LIMIT)},
symbols_list.h:{"CASE", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"CATCH", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"CCASE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"CEILING", CL_ORDINARY, cl_ceiling, -1, OBJNULL},
symbols_list.h:{"CELL-ERROR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"CELL-ERROR-NAME", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"CERROR", CL_ORDINARY, cl_cerror, -1, OBJNULL},
symbols_list.h:{"CHAR-CODE", CL_ORDINARY, cl_char_code, 1, OBJNULL},
symbols_list.h:{"CHAR-CODE-LIMIT", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_CHAR_CODE_LIMIT)},
symbols_list.h:{"CHAR-DOWNCASE", CL_ORDINARY, cl_char_downcase, 1, OBJNULL},
symbols_list.h:{"CHAR-EQUAL", CL_ORDINARY, cl_char_equal, -1, OBJNULL},
symbols_list.h:{"CHAR-GREATERP", CL_ORDINARY, cl_char_greaterp, -1, OBJNULL},
symbols_list.h:{"CHAR-INT", CL_ORDINARY, cl_char_int, 1, OBJNULL},
symbols_list.h:{"CHAR-LESSP", CL_ORDINARY, cl_char_lessp, -1, OBJNULL},
symbols_list.h:{"CHAR-NAME", CL_ORDINARY, cl_char_name, 1, OBJNULL},
symbols_list.h:{"CHAR-NOT-EQUAL", CL_ORDINARY, cl_char_not_equal, -1, OBJNULL},
symbols_list.h:{"CHAR-NOT-GREATERP", CL_ORDINARY, cl_char_not_greaterp, -1, OBJNULL},
symbols_list.h:{"CHAR-NOT-LESSP", CL_ORDINARY, cl_char_not_lessp, -1, OBJNULL},
symbols_list.h:{"CHAR-UPCASE", CL_ORDINARY, cl_char_upcase, 1, OBJNULL},
symbols_list.h:{"CHAR/=", CL_ORDINARY, cl_charNE, -1, OBJNULL},
symbols_list.h:{"CHAR<", CL_ORDINARY, cl_charL, -1, OBJNULL},
symbols_list.h:{"CHAR<=", CL_ORDINARY, cl_charLE, -1, OBJNULL},
symbols_list.h:{"CHAR=", CL_ORDINARY, cl_charE, -1, OBJNULL},
symbols_list.h:{"CHAR>", CL_ORDINARY, cl_charG, -1, OBJNULL},
symbols_list.h:{"CHAR>=", CL_ORDINARY, cl_charGE, -1, OBJNULL},
symbols_list.h:{"CHECK-TYPE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"CLEAR-INPUT", CL_ORDINARY, cl_clear_input, -1, OBJNULL},
symbols_list.h:{"CLEAR-OUTPUT", CL_ORDINARY, cl_clear_output, -1, OBJNULL},
symbols_list.h:{"CLOSE", CL_ORDINARY, cl_close, -1, OBJNULL},
symbols_list.h:{"CODE-CHAR", CL_ORDINARY, cl_code_char, 1, OBJNULL},
symbols_list.h:{"COMPILATION-SPEED", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"COMPILE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"COMPILE-FILE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"COMPILE-FILE-PATHNAME", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"COMPILED-FUNCTION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"COMPILED-FUNCTION-P", CL_ORDINARY, cl_compiled_function_p, 1, OBJNULL},
symbols_list.h:{"COMPILER-MACRO", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"COMPILER-MACRO-FUNCTION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"COMPLEMENT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"COMPLEX", CL_ORDINARY, cl_complex, -1, OBJNULL},
symbols_list.h:{"COMPUTE-RESTARTS", CL_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{"CONCATENATE", CL_ORDINARY, ECL_NAME(cl_concatenate), -1, OBJNULL},
symbols_list.h:{"CONCATENATED-STREAM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"CONCATENATED-STREAM-STREAMS", CL_ORDINARY, cl_concatenated_stream_streams, 1, OBJNULL},
symbols_list.h:{"COND", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"CONDITION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"CONTINUE", CL_ORDINARY, ECL_NAME(cl_continue), -1, OBJNULL},
symbols_list.h:{"CONSTANTP", CL_ORDINARY, cl_constantp, -1, OBJNULL},
symbols_list.h:{"CONTROL-ERROR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"COPY-ALIST", CL_ORDINARY, cl_copy_alist, 1, OBJNULL},
symbols_list.h:{"COPY-LIST", CL_ORDINARY, cl_copy_list, 1, OBJNULL},
symbols_list.h:{"COPY-PPRINT-DISPATCH", CL_ORDINARY, ECL_NAME_PPRINT(cl_copy_pprint_dispatch), -1, OBJNULL},
symbols_list.h:{"COPY-READTABLE", CL_ORDINARY, cl_copy_readtable, -1, OBJNULL},
symbols_list.h:{"COPY-SEQ", CL_ORDINARY, cl_copy_seq, 1, OBJNULL},
symbols_list.h:{"COPY-STRUCTURE", CL_ORDINARY, cl_copy_structure, 1, OBJNULL},
symbols_list.h:{"COPY-SYMBOL", CL_ORDINARY, cl_copy_symbol, -1, OBJNULL},
symbols_list.h:{"COPY-TREE", CL_ORDINARY, cl_copy_tree, 1, OBJNULL},
symbols_list.h:{"COUNT", CL_ORDINARY, ECL_NAME(cl_count), -1, OBJNULL},
symbols_list.h:{"COUNT-IF", CL_ORDINARY, ECL_NAME(cl_count_if), -1, OBJNULL},
symbols_list.h:{"COUNT-IF-NOT", CL_ORDINARY, ECL_NAME(cl_count_if_not), -1, OBJNULL},
symbols_list.h:{"CTYPECASE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEBUG", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DECF", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DECLAIM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DECLARATION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DECLARE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DECODE-FLOAT", CL_ORDINARY, cl_decode_float, 1, OBJNULL},
symbols_list.h:{"DECODE-UNIVERSAL-TIME", CL_ORDINARY, ECL_NAME(cl_decode_universal_time), -1, OBJNULL},
symbols_list.h:{"DEFCONSTANT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFINE-CONDITION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFINE-COMPILER-MACRO", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFINE-MODIFY-MACRO", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFINE-SETF-EXPANDER", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFINE-SYMBOL-MACRO", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFMACRO", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFPACKAGE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFPARAMETER", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFSETF", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFSTRUCT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFTYPE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFUN", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFVAR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DELETE", CL_ORDINARY, ECL_NAME(cl_delete), -1, OBJNULL},
symbols_list.h:{"DELETE-DUPLICATES", CL_ORDINARY, ECL_NAME(cl_delete_duplicates), -1, OBJNULL},
symbols_list.h:{"DELETE-FILE", CL_ORDINARY, cl_delete_file, 1, OBJNULL},
symbols_list.h:{"DELETE-IF", CL_ORDINARY, ECL_NAME(cl_delete_if), -1, OBJNULL},
symbols_list.h:{"DELETE-IF-NOT", CL_ORDINARY, ECL_NAME(cl_delete_if_not), -1, OBJNULL},
symbols_list.h:{"DELETE-PACKAGE", CL_ORDINARY, cl_delete_package, 1, OBJNULL},
symbols_list.h:{"DEPOSIT-FIELD", CL_ORDINARY, ECL_NAME(cl_deposit_field), 3, OBJNULL},
symbols_list.h:{"DESCRIBE", CL_ORDINARY, ECL_NAME(cl_describe), -1, OBJNULL},
symbols_list.h:{"DESTRUCTURING-BIND", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DIGIT-CHAR", CL_ORDINARY, cl_digit_char, -1, OBJNULL},
symbols_list.h:{"DIGIT-CHAR-P", CL_ORDINARY, cl_digit_char_p, -1, OBJNULL},
symbols_list.h:{"DIRECTORY", CL_ORDINARY, cl_directory, -1, OBJNULL},
symbols_list.h:{"DIRECTORY-NAMESTRING", CL_ORDINARY, cl_directory_namestring, 1, OBJNULL},
symbols_list.h:{"DISASSEMBLE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DIVISION-BY-ZERO", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DO", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"DO*", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"DO-ALL-SYMBOLS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DO-EXTERNAL-SYMBOLS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DO-SYMBOLS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DOCUMENTATION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DOLIST", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"DOTIMES", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"DOUBLE-FLOAT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DOUBLE-FLOAT-EPSILON", CL_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{"DOUBLE-FLOAT-NEGATIVE-EPSILON", CL_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{"DRIBBLE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DYNAMIC-EXTENT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ECASE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ECHO-STREAM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ECHO-STREAM-INPUT-STREAM", CL_ORDINARY, cl_echo_stream_input_stream, 1, OBJNULL},
symbols_list.h:{"ECHO-STREAM-OUTPUT-STREAM", CL_ORDINARY, cl_echo_stream_output_stream, 1, OBJNULL},
symbols_list.h:{"ED", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ENCODE-UNIVERSAL-TIME", CL_ORDINARY, ECL_NAME(cl_encode_universal_time), -1, OBJNULL},
symbols_list.h:{"END-OF-FILE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ENOUGH-NAMESTRING", CL_ORDINARY, cl_enough_namestring, -1, OBJNULL},
symbols_list.h:{"ENSURE-DIRECTORIES-EXIST", CL_ORDINARY, ECL_NAME(cl_ensure_directories_exist), -1, OBJNULL},
symbols_list.h:{"ERROR", CL_ORDINARY, cl_error, -1, OBJNULL},
symbols_list.h:{"ETYPECASE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"EVAL-WHEN", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"EVERY", CL_ORDINARY, ECL_NAME(cl_every), -1, OBJNULL},
symbols_list.h:{"EXPORT", CL_ORDINARY, cl_export, -1, OBJNULL},
symbols_list.h:{"EXTENDED-CHAR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FCEILING", CL_ORDINARY, ECL_NAME(cl_fceiling), -1, OBJNULL},
symbols_list.h:{"FFLOOR", CL_ORDINARY, ECL_NAME(cl_ffloor), -1, OBJNULL},
symbols_list.h:{"FILE-AUTHOR", CL_ORDINARY, cl_file_author, 1, OBJNULL},
symbols_list.h:{"FILE-ERROR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FILE-ERROR-PATHNAME", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FILE-LENGTH", CL_ORDINARY, cl_file_length, 1, OBJNULL},
symbols_list.h:{"FILE-NAMESTRING", CL_ORDINARY, cl_file_namestring, 1, OBJNULL},
symbols_list.h:{"FILE-POSITION", CL_ORDINARY, cl_file_position, -1, OBJNULL},
symbols_list.h:{"FILE-STREAM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FILE-STRING-LENGTH", CL_ORDINARY, cl_file_string_length, 2, OBJNULL},
symbols_list.h:{"FILE-WRITE-DATE", CL_ORDINARY, cl_file_write_date, 1, OBJNULL},
symbols_list.h:{"FILL", CL_ORDINARY, ECL_NAME(cl_fill), -1, OBJNULL},
symbols_list.h:{"FILL-POINTER", CL_ORDINARY, cl_fill_pointer, 1, OBJNULL},
symbols_list.h:{"FIND", CL_ORDINARY, ECL_NAME(cl_find), -1, OBJNULL},
symbols_list.h:{"FIND-ALL-SYMBOLS", CL_ORDINARY, ECL_NAME(cl_find_all_symbols), 1, OBJNULL},
symbols_list.h:{"FIND-IF", CL_ORDINARY, ECL_NAME(cl_find_if), -1, OBJNULL},
symbols_list.h:{"FIND-IF-NOT", CL_ORDINARY, ECL_NAME(cl_find_if_not), -1, OBJNULL},
symbols_list.h:{"FIND-PACKAGE", CL_ORDINARY, cl_find_package, 1, OBJNULL},
symbols_list.h:{"FIND-RESTART", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FIND-SYMBOL", CL_ORDINARY, cl_find_symbol, -1, OBJNULL},
symbols_list.h:{"FINISH-OUTPUT", CL_ORDINARY, cl_finish_output, -1, OBJNULL},
symbols_list.h:{"FIXNUM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FLET", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"FLOAT", CL_ORDINARY, cl_float, -1, OBJNULL},
symbols_list.h:{"FLOAT-DIGITS", CL_ORDINARY, cl_float_digits, 1, OBJNULL},
symbols_list.h:{"FLOAT-PRECISION", CL_ORDINARY, cl_float_precision, 1, OBJNULL},
symbols_list.h:{"FLOAT-RADIX", CL_ORDINARY, cl_float_radix, 1, OBJNULL},
symbols_list.h:{"FLOAT-SIGN", CL_ORDINARY, cl_float_sign, -1, OBJNULL},
symbols_list.h:{"FLOATING-POINT-INEXACT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FLOATING-POINT-INVALID-OPERATION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FLOATING-POINT-OVERFLOW", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FLOATING-POINT-UNDERFLOW", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FLOOR", CL_ORDINARY, cl_floor, -1, OBJNULL},
symbols_list.h:{"FORCE-OUTPUT", CL_ORDINARY, cl_force_output, -1, OBJNULL},
symbols_list.h:{"FORMAT", CL_ORDINARY, cl_format, -1, OBJNULL},
symbols_list.h:{"FORMATTER", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FRESH-LINE", CL_ORDINARY, cl_fresh_line, -1, OBJNULL},
symbols_list.h:{"FROUND", CL_ORDINARY, ECL_NAME(cl_fround), -1, OBJNULL},
symbols_list.h:{"FTRUNCATE", CL_ORDINARY, ECL_NAME(cl_ftruncate), -1, OBJNULL},
symbols_list.h:{"FTYPE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FUNCALL", CL_ORDINARY, cl_funcall, -1, OBJNULL},
symbols_list.h:{"FUNCTION-LAMBDA-EXPRESSION", CL_ORDINARY, cl_function_lambda_expression, 1, OBJNULL},
symbols_list.h:{"FUNCTION", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"FUNCTION-KEYWORDS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"GCD", CL_ORDINARY, cl_gcd, -1, OBJNULL},
symbols_list.h:{"GENSYM", CL_ORDINARY, cl_gensym, -1, OBJNULL},
symbols_list.h:{"GENTEMP", CL_ORDINARY, cl_gentemp, -1, OBJNULL},
symbols_list.h:{"GET", CL_ORDINARY, cl_get, -1, OBJNULL},
symbols_list.h:{"GET-DECODED-TIME", CL_ORDINARY, ECL_NAME(cl_get_decoded_time), 0, OBJNULL},
symbols_list.h:{"GET-DISPATCH-MACRO-CHARACTER", CL_ORDINARY, cl_get_dispatch_macro_character, -1, OBJNULL},
symbols_list.h:{"GET-INTERNAL-REAL-TIME", CL_ORDINARY, cl_get_internal_real_time, 0, OBJNULL},
symbols_list.h:{"GET-INTERNAL-RUN-TIME", CL_ORDINARY, cl_get_internal_run_time, 0, OBJNULL},
symbols_list.h:{"GET-MACRO-CHARACTER", CL_ORDINARY, cl_get_macro_character, -1, OBJNULL},
symbols_list.h:{"GET-OUTPUT-STREAM-STRING", CL_ORDINARY, cl_get_output_stream_string, 1, OBJNULL},
symbols_list.h:{"GET-PROPERTIES", CL_ORDINARY, cl_get_properties, 2, OBJNULL},
symbols_list.h:{"GET-SETF-EXPANSION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"GET-UNIVERSAL-TIME", CL_ORDINARY, cl_get_universal_time, 0, OBJNULL},
symbols_list.h:{"GETF", CL_ORDINARY, cl_getf, -1, OBJNULL},
symbols_list.h:{"GETHASH", CL_ORDINARY, cl_gethash, -1, OBJNULL},
symbols_list.h:{"GO", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"GRAPHIC-CHAR-P", CL_ORDINARY, cl_graphic_char_p, 1, OBJNULL},
symbols_list.h:{"HANDLER-CASE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"HANDLER-BIND", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"HASH-TABLE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"HASH-TABLE-COUNT", CL_ORDINARY, cl_hash_table_count, 1, OBJNULL},
symbols_list.h:{"HASH-TABLE-P", CL_ORDINARY, cl_hash_table_p, 1, OBJNULL},
symbols_list.h:{"HASH-TABLE-REHASH-SIZE", CL_ORDINARY, cl_hash_table_rehash_size, 1, OBJNULL},
symbols_list.h:{"HASH-TABLE-REHASH-THRESHOLD", CL_ORDINARY, cl_hash_table_rehash_threshold, 1, OBJNULL},
symbols_list.h:{"HASH-TABLE-SIZE", CL_ORDINARY, cl_hash_table_size, 1, OBJNULL},
symbols_list.h:{"HASH-TABLE-TEST", CL_ORDINARY, cl_hash_table_test, 1, OBJNULL},
symbols_list.h:{"HOST-NAMESTRING", CL_ORDINARY, cl_host_namestring, 1, OBJNULL},
symbols_list.h:{"IGNORABLE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"IGNORE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"IGNORE-ERRORS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"IMPORT", CL_ORDINARY, cl_import, -1, OBJNULL},
symbols_list.h:{"IN-PACKAGE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"INCF", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"INLINE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"INPUT-STREAM-P", CL_ORDINARY, cl_input_stream_p, 1, OBJNULL},
symbols_list.h:{"INTEGER", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"INTEGER-DECODE-FLOAT", CL_ORDINARY, cl_integer_decode_float, 1, OBJNULL},
symbols_list.h:{"INTEGER-LENGTH", CL_ORDINARY, cl_integer_length, 1, OBJNULL},
symbols_list.h:{"INTERACTIVE-STREAM-P", CL_ORDINARY, cl_interactive_stream_p, 1, OBJNULL},
symbols_list.h:{"INTERN", CL_ORDINARY, cl_intern, -1, OBJNULL},
symbols_list.h:{"INTERNAL-TIME-UNITS-PER-SECOND", CL_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{"INTERSECTION", CL_ORDINARY, ECL_NAME(cl_intersection), -1, OBJNULL},
symbols_list.h:{"INVOKE-DEBUGGER", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"INVOKE-RESTART", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"INVOKE-RESTART-INTERACTIVELY", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"KEYWORD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"LABELS", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"LAMBDA", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"LAMBDA-LIST-KEYWORDS", CL_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{"LAMBDA-PARAMETERS-LIMIT", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_LAMBDA_PARAMETERS_LIMIT)},
symbols_list.h:{"LAST", CL_ORDINARY, cl_last, -1, OBJNULL},
symbols_list.h:{"LCM", CL_ORDINARY, cl_lcm, -1, OBJNULL},
symbols_list.h:{"LDB-TEST", CL_ORDINARY, ECL_NAME(cl_ldb_test), 2, OBJNULL},
symbols_list.h:{"LEAST-NEGATIVE-DOUBLE-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_NEGATIVE_DOUBLE_FLOAT},
symbols_list.h:{"LEAST-NEGATIVE-LONG-FLOAT", CL_CONSTANT, NULL, -1,  ECL_LEAST_NEGATIVE_LONG_FLOAT},
symbols_list.h:{"LEAST-NEGATIVE-NORMALIZED-DOUBLE-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_NEGATIVE_DOUBLE_FLOAT},
symbols_list.h:{"LEAST-NEGATIVE-NORMALIZED-LONG-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_NEGATIVE_LONG_FLOAT},
symbols_list.h:{"LEAST-NEGATIVE-NORMALIZED-SHORT-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_NEGATIVE_SHORT_FLOAT},
symbols_list.h:{"LEAST-NEGATIVE-NORMALIZED-SINGLE-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_NEGATIVE_SINGLE_FLOAT},
symbols_list.h:{"LEAST-NEGATIVE-SHORT-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_NEGATIVE_SHORT_FLOAT},
symbols_list.h:{"LEAST-NEGATIVE-SINGLE-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_NEGATIVE_SINGLE_FLOAT},
symbols_list.h:{"LEAST-POSITIVE-DOUBLE-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_POSITIVE_DOUBLE_FLOAT},
symbols_list.h:{"LEAST-POSITIVE-LONG-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_POSITIVE_LONG_FLOAT},
symbols_list.h:{"LEAST-POSITIVE-NORMALIZED-DOUBLE-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_POSITIVE_DOUBLE_FLOAT},
symbols_list.h:{"LEAST-POSITIVE-NORMALIZED-LONG-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_POSITIVE_LONG_FLOAT},
symbols_list.h:{"LEAST-POSITIVE-NORMALIZED-SHORT-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_POSITIVE_SHORT_FLOAT},
symbols_list.h:{"LEAST-POSITIVE-NORMALIZED-SINGLE-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_POSITIVE_SINGLE_FLOAT},
symbols_list.h:{"LEAST-POSITIVE-SHORT-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_POSITIVE_SHORT_FLOAT},
symbols_list.h:{"LEAST-POSITIVE-SINGLE-FLOAT", CL_CONSTANT, NULL, -1, ECL_LEAST_POSITIVE_SINGLE_FLOAT},
symbols_list.h:{"LET", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"LET*", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"LISP-IMPLEMENTATION-TYPE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"LISP-IMPLEMENTATION-VERSION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"LIST", CL_ORDINARY, cl_list, -1, OBJNULL},
symbols_list.h:{"LIST*", CL_ORDINARY, cl_listX, -1, OBJNULL},
symbols_list.h:{"LIST-ALL-PACKAGES", CL_ORDINARY, cl_list_all_packages, 0, OBJNULL},
symbols_list.h:{"LIST-LENGTH", CL_ORDINARY, cl_list_length, 1, OBJNULL},
symbols_list.h:{"LISTEN", CL_ORDINARY, cl_listen, -1, OBJNULL},
symbols_list.h:{"LOAD", CL_ORDINARY, cl_load, -1, OBJNULL},
symbols_list.h:{"LOAD-LOGICAL-PATHNAME-TRANSLATIONS", CL_ORDINARY, ECL_NAME(cl_load_logical_pathname_translations), 1, OBJNULL},
symbols_list.h:{"LOAD-TIME-VALUE", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"LOCALLY", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"LOG", CL_ORDINARY, cl_log, -1, OBJNULL},
symbols_list.h:{"LOGAND", CL_ORDINARY, cl_logand, -1, OBJNULL},
symbols_list.h:{"LOGEQV", CL_ORDINARY, cl_logeqv, -1, OBJNULL},
symbols_list.h:{"LOGICAL-PATHNAME", CL_ORDINARY, cl_logical_pathname, 1, OBJNULL},
symbols_list.h:{"LOGICAL-PATHNAME-TRANSLATIONS", CL_ORDINARY, ECL_NAME(cl_logical_pathname_translations), 1, OBJNULL},
symbols_list.h:{"LOGIOR", CL_ORDINARY, cl_logior, -1, OBJNULL},
symbols_list.h:{"LOGXOR", CL_ORDINARY, cl_logxor, -1, OBJNULL},
symbols_list.h:{"LONG-FLOAT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"LONG-FLOAT-EPSILON", CL_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{"LONG-FLOAT-NEGATIVE-EPSILON", CL_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{"LONG-SITE-NAME", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"LOOP", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"LOOP-FINISH", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"LOWER-CASE-P", CL_ORDINARY, cl_lower_case_p, 1, OBJNULL},
symbols_list.h:{"MACHINE-INSTANCE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"MACHINE-TYPE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"MACHINE-VERSION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"MACRO-FUNCTION", CL_ORDINARY, cl_macro_function, -1, OBJNULL},
symbols_list.h:{"MACROEXPAND", CL_ORDINARY, cl_macroexpand, -1, OBJNULL},
symbols_list.h:{"MACROEXPAND-1", CL_ORDINARY, cl_macroexpand_1, -1, OBJNULL},
symbols_list.h:{"MACROLET", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"MAKE-ARRAY", CL_ORDINARY, ECL_NAME(cl_make_array), -1, OBJNULL},
symbols_list.h:{"MAKE-BROADCAST-STREAM", CL_ORDINARY, cl_make_broadcast_stream, -1, OBJNULL},
symbols_list.h:{"MAKE-CONDITION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"MAKE-CONCATENATED-STREAM", CL_ORDINARY, cl_make_concatenated_stream, -1, OBJNULL},
symbols_list.h:{"MAKE-DISPATCH-MACRO-CHARACTER", CL_ORDINARY, cl_make_dispatch_macro_character, -1, OBJNULL},
symbols_list.h:{"MAKE-ECHO-STREAM", CL_ORDINARY, cl_make_echo_stream, 2, OBJNULL},
symbols_list.h:{"MAKE-HASH-TABLE", CL_ORDINARY, cl_make_hash_table, -1, OBJNULL},
symbols_list.h:{"MAKE-LIST", CL_ORDINARY, cl_make_list, -1, OBJNULL},
symbols_list.h:{"MAKE-PACKAGE", CL_ORDINARY, cl_make_package, -1, OBJNULL},
symbols_list.h:{"MAKE-PATHNAME", CL_ORDINARY, cl_make_pathname, -1, OBJNULL},
symbols_list.h:{"MAKE-RANDOM-STATE", CL_ORDINARY, cl_make_random_state, -1, OBJNULL},
symbols_list.h:{"MAKE-SEQUENCE", CL_ORDINARY, ECL_NAME(cl_make_sequence), -1, OBJNULL},
symbols_list.h:{"MAKE-STRING", CL_ORDINARY, cl_make_string, -1, OBJNULL},
symbols_list.h:{"MAKE-STRING-INPUT-STREAM", CL_ORDINARY, cl_make_string_input_stream, -1, OBJNULL},
symbols_list.h:{"MAKE-STRING-OUTPUT-STREAM", CL_ORDINARY, cl_make_string_output_stream, -1, OBJNULL},
symbols_list.h:{"MAKE-SYMBOL", CL_ORDINARY, cl_make_symbol, 1, OBJNULL},
symbols_list.h:{"MAKE-SYNONYM-STREAM", CL_ORDINARY, cl_make_synonym_stream, 1, OBJNULL},
symbols_list.h:{"MAKE-TWO-WAY-STREAM", CL_ORDINARY, cl_make_two_way_stream, 2, OBJNULL},
symbols_list.h:{"MAP", CL_ORDINARY, ECL_NAME(cl_map), -1, OBJNULL},
symbols_list.h:{"MAP-INTO", CL_ORDINARY, ECL_NAME(cl_map_into), -1, OBJNULL},
symbols_list.h:{"MAPC", CL_ORDINARY, cl_mapc, -1, OBJNULL},
symbols_list.h:{"MAPCAN", CL_ORDINARY, cl_mapcan, -1, OBJNULL},
symbols_list.h:{"MAPCAR", CL_ORDINARY, cl_mapcar, -1, OBJNULL},
symbols_list.h:{"MAPCON", CL_ORDINARY, cl_mapcon, -1, OBJNULL},
symbols_list.h:{"MAPL", CL_ORDINARY, cl_mapl, -1, OBJNULL},
symbols_list.h:{"MAPLIST", CL_ORDINARY, cl_maplist, -1, OBJNULL},
symbols_list.h:{"MASK-FIELD", CL_ORDINARY, ECL_NAME(cl_mask_field), 2, OBJNULL},
symbols_list.h:{"MAX", CL_ORDINARY, cl_max, -1, OBJNULL},
symbols_list.h:{"MEMBER", CL_ORDINARY, cl_member, -1, OBJNULL},
symbols_list.h:{"MEMBER-IF", CL_ORDINARY, ECL_NAME(cl_member_if), -1, OBJNULL},
symbols_list.h:{"MEMBER-IF-NOT", CL_ORDINARY, ECL_NAME(cl_member_if_not), -1, OBJNULL},
symbols_list.h:{"MERGE", CL_ORDINARY, ECL_NAME(cl_merge), -1, OBJNULL},
symbols_list.h:{"MERGE-PATHNAMES", CL_ORDINARY, cl_merge_pathnames, -1, OBJNULL},
symbols_list.h:{"MIN", CL_ORDINARY, cl_min, -1, OBJNULL},
symbols_list.h:{"MISMATCH", CL_ORDINARY, ECL_NAME(cl_mismatch), -1, OBJNULL},
symbols_list.h:{"MOST-NEGATIVE-DOUBLE-FLOAT", CL_CONSTANT, NULL, -1, ECL_MOST_NEGATIVE_DOUBLE_FLOAT},
symbols_list.h:{"MOST-NEGATIVE-FIXNUM", CL_CONSTANT, NULL, -1, ecl_make_fixnum(MOST_NEGATIVE_FIXNUM)},
symbols_list.h:{"MOST-NEGATIVE-LONG-FLOAT", CL_CONSTANT, NULL, -1, ECL_MOST_NEGATIVE_LONG_FLOAT},
symbols_list.h:{"MOST-NEGATIVE-SHORT-FLOAT", CL_CONSTANT, NULL, -1, ECL_MOST_NEGATIVE_SHORT_FLOAT},
symbols_list.h:{"MOST-NEGATIVE-SINGLE-FLOAT", CL_CONSTANT, NULL, -1, ECL_MOST_NEGATIVE_SINGLE_FLOAT},
symbols_list.h:{"MOST-POSITIVE-DOUBLE-FLOAT", CL_CONSTANT, NULL, -1, ECL_MOST_POSITIVE_DOUBLE_FLOAT},
symbols_list.h:{"MOST-POSITIVE-FIXNUM", CL_CONSTANT, NULL, -1, ecl_make_fixnum(MOST_POSITIVE_FIXNUM)},
symbols_list.h:{"MOST-POSITIVE-LONG-FLOAT", CL_CONSTANT, NULL, -1, ECL_MOST_POSITIVE_LONG_FLOAT},
symbols_list.h:{"MOST-POSITIVE-SHORT-FLOAT", CL_CONSTANT, NULL, -1, ECL_MOST_POSITIVE_SHORT_FLOAT},
symbols_list.h:{"MOST-POSITIVE-SINGLE-FLOAT", CL_CONSTANT, NULL, -1, ECL_MOST_POSITIVE_SINGLE_FLOAT},
symbols_list.h:{"MUFFLE-WARNING", CL_ORDINARY, ECL_NAME(cl_muffle_warning), -1, OBJNULL},
symbols_list.h:{"MULTIPLE-VALUE-BIND", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"MULTIPLE-VALUE-CALL", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"MULTIPLE-VALUE-LIST", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"MULTIPLE-VALUE-PROG1", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"MULTIPLE-VALUE-SETQ", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"MULTIPLE-VALUES-LIMIT", CL_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_MULTIPLE_VALUES_LIMIT)},
symbols_list.h:{"NAME-CHAR", CL_ORDINARY, cl_name_char, 1, OBJNULL},
symbols_list.h:{"NBUTLAST", CL_ORDINARY, cl_nbutlast, -1, OBJNULL},
symbols_list.h:{"NCONC", CL_ORDINARY, cl_nconc, -1, OBJNULL},
symbols_list.h:{"NINTERSECTION", CL_ORDINARY, ECL_NAME(cl_nintersection), -1, OBJNULL},
symbols_list.h:{"NOTANY", CL_ORDINARY, ECL_NAME(cl_notany), -1, OBJNULL},
symbols_list.h:{"NOTEVERY", CL_ORDINARY, ECL_NAME(cl_notevery), -1, OBJNULL},
symbols_list.h:{"NOTINLINE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"NSET-DIFFERENCE", CL_ORDINARY, ECL_NAME(cl_nset_difference), -1, OBJNULL},
symbols_list.h:{"NSET-EXCLUSIVE-OR", CL_ORDINARY, ECL_NAME(cl_nset_exclusive_or), -1, OBJNULL},
symbols_list.h:{"NSTRING-CAPITALIZE", CL_ORDINARY, cl_nstring_capitalize, -1, OBJNULL},
symbols_list.h:{"NSTRING-DOWNCASE", CL_ORDINARY, cl_nstring_downcase, -1, OBJNULL},
symbols_list.h:{"NSTRING-UPCASE", CL_ORDINARY, cl_nstring_upcase, -1, OBJNULL},
symbols_list.h:{"NSUBLIS", CL_ORDINARY, cl_nsublis, -1, OBJNULL},
symbols_list.h:{"NSUBST", CL_ORDINARY, cl_nsubst, -1, OBJNULL},
symbols_list.h:{"NSUBST-IF", CL_ORDINARY, ECL_NAME(cl_nsubst_if), -1, OBJNULL},
symbols_list.h:{"NSUBST-IF-NOT", CL_ORDINARY, ECL_NAME(cl_nsubst_if_not), -1, OBJNULL},
symbols_list.h:{"NSUBSTITUTE", CL_ORDINARY, ECL_NAME(cl_nsubstitute), -1, OBJNULL},
symbols_list.h:{"NSUBSTITUTE-IF", CL_ORDINARY, ECL_NAME(cl_nsubstitute_if), -1, OBJNULL},
symbols_list.h:{"NSUBSTITUTE-IF-NOT", CL_ORDINARY, ECL_NAME(cl_nsubstitute_if_not), -1, OBJNULL},
symbols_list.h:{"NTH-VALUE", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"NUMBER", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"NUNION", CL_ORDINARY, ECL_NAME(cl_nunion), -1, OBJNULL},
symbols_list.h:{"OPEN", CL_ORDINARY, cl_open, -1, OBJNULL},
symbols_list.h:{"OPEN-STREAM-P", CL_ORDINARY, cl_open_stream_p, 1, OBJNULL},
symbols_list.h:{"OPTIMIZE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"OR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"OTHERWISE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"OUTPUT-STREAM-P", CL_ORDINARY, cl_output_stream_p, 1, OBJNULL},
symbols_list.h:{"PACKAGE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PACKAGE-ERROR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PACKAGE-ERROR-PACKAGE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PACKAGE-NAME", CL_ORDINARY, cl_package_name, 1, OBJNULL},
symbols_list.h:{"PACKAGE-NICKNAMES", CL_ORDINARY, cl_package_nicknames, 1, OBJNULL},
symbols_list.h:{"PACKAGE-SHADOWING-SYMBOLS", CL_ORDINARY, cl_package_shadowing_symbols, 1, OBJNULL},
symbols_list.h:{"PACKAGE-USE-LIST", CL_ORDINARY, cl_package_use_list, 1, OBJNULL},
symbols_list.h:{"PACKAGE-USED-BY-LIST", CL_ORDINARY, cl_package_used_by_list, 1, OBJNULL},
symbols_list.h:{"PAIRLIS", CL_ORDINARY, cl_pairlis, -1, OBJNULL},
symbols_list.h:{"PARSE-ERROR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PARSE-INTEGER", CL_ORDINARY, cl_parse_integer, -1, OBJNULL},
symbols_list.h:{"PARSE-NAMESTRING", CL_ORDINARY, cl_parse_namestring, -1, OBJNULL},
symbols_list.h:{"PATHNAME-DEVICE", CL_ORDINARY, cl_pathname_device, -1, OBJNULL},
symbols_list.h:{"PATHNAME-DIRECTORY", CL_ORDINARY, cl_pathname_directory, -1, OBJNULL},
symbols_list.h:{"PATHNAME-HOST", CL_ORDINARY, cl_pathname_host, -1, OBJNULL},
symbols_list.h:{"PATHNAME-MATCH-P", CL_ORDINARY, cl_pathname_match_p, 2, OBJNULL},
symbols_list.h:{"PATHNAME-NAME", CL_ORDINARY, cl_pathname_name, -1, OBJNULL},
symbols_list.h:{"PATHNAME-TYPE", CL_ORDINARY, cl_pathname_type, -1, OBJNULL},
symbols_list.h:{"PATHNAME-VERSION", CL_ORDINARY, cl_pathname_version, 1, OBJNULL},
symbols_list.h:{"PEEK-CHAR", CL_ORDINARY, cl_peek_char, -1, OBJNULL},
symbols_list.h:{"PI", CL_CONSTANT, NULL, -1, ECL_PI},
symbols_list.h:{"POP", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"POSITION", CL_ORDINARY, ECL_NAME(cl_position), -1, OBJNULL},
symbols_list.h:{"POSITION-IF", CL_ORDINARY, ECL_NAME(cl_position_if), -1, OBJNULL},
symbols_list.h:{"POSITION-IF-NOT", CL_ORDINARY, ECL_NAME(cl_position_if_not), -1, OBJNULL},
symbols_list.h:{"PPRINT", CL_ORDINARY, cl_pprint, -1, OBJNULL},
symbols_list.h:{"PPRINT-DISPATCH", CL_ORDINARY, ECL_NAME_PPRINT(cl_pprint_dispatch), -1, OBJNULL},
symbols_list.h:{"PPRINT-EXIT-IF-LIST-EXHAUSTED", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PPRINT-FILL", CL_ORDINARY, ECL_NAME_PPRINT(cl_pprint_fill), -1, OBJNULL},
symbols_list.h:{"PPRINT-INDENT", CL_ORDINARY, ECL_NAME_PPRINT(cl_pprint_indent), -1, OBJNULL},
symbols_list.h:{"PPRINT-LINEAR", CL_ORDINARY, ECL_NAME_PPRINT(cl_pprint_linear), -1, OBJNULL},
symbols_list.h:{"PPRINT-LOGICAL-BLOCK", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PPRINT-NEWLINE", CL_ORDINARY, ECL_NAME_PPRINT(cl_pprint_newline), -1, OBJNULL},
symbols_list.h:{"PPRINT-POP", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PPRINT-TAB", CL_ORDINARY, ECL_NAME_PPRINT(cl_pprint_tab), -1, OBJNULL},
symbols_list.h:{"PPRINT-TABULAR", CL_ORDINARY, ECL_NAME_PPRINT(cl_pprint_tabular), -1, OBJNULL},
symbols_list.h:{"PRIN1", CL_ORDINARY, cl_prin1, -1, OBJNULL},
symbols_list.h:{"PRIN1-TO-STRING", CL_ORDINARY, ECL_NAME(cl_prin1_to_string), 1, OBJNULL},
symbols_list.h:{"PRINC", CL_ORDINARY, cl_princ, -1, OBJNULL},
symbols_list.h:{"PRINC-TO-STRING", CL_ORDINARY, ECL_NAME(cl_princ_to_string), 1, OBJNULL},
symbols_list.h:{"PRINT", CL_ORDINARY, cl_print, -1, OBJNULL},
symbols_list.h:{"PRINT-NOT-READABLE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PRINT-NOT-READABLE-OBJECT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PROBE-FILE", CL_ORDINARY, cl_probe_file, 1, OBJNULL},
symbols_list.h:{"PROCLAIM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PROG", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"PROG*", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"PROG1", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"PROG2", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"PROGN", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"PROGRAM-ERROR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PROGV", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"PSETF", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PSETQ", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"PUSH", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PUSHNEW", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"QUOTE", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"RANDOM", CL_ORDINARY, cl_random, -1, OBJNULL},
symbols_list.h:{"RANDOM-STATE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"RANDOM-STATE-P", CL_ORDINARY, cl_random_state_p, 1, OBJNULL},
symbols_list.h:{"RASSOC", CL_ORDINARY, cl_rassoc, -1, OBJNULL},
symbols_list.h:{"RASSOC-IF", CL_ORDINARY, ECL_NAME(cl_rassoc_if), -1, OBJNULL},
symbols_list.h:{"RASSOC-IF-NOT", CL_ORDINARY, ECL_NAME(cl_rassoc_if_not), -1, OBJNULL},
symbols_list.h:{"RATIO", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"READ", CL_ORDINARY, cl_read, -1, OBJNULL},
symbols_list.h:{"READ-BYTE", CL_ORDINARY, cl_read_byte, -1, OBJNULL},
symbols_list.h:{"READ-CHAR", CL_ORDINARY, cl_read_char, -1, OBJNULL},
symbols_list.h:{"READ-CHAR-NO-HANG", CL_ORDINARY, cl_read_char_no_hang, -1, OBJNULL},
symbols_list.h:{"READ-DELIMITED-LIST", CL_ORDINARY, cl_read_delimited_list, -1, OBJNULL},
symbols_list.h:{"READ-FROM-STRING", CL_ORDINARY, ECL_NAME(cl_read_from_string), -1, OBJNULL},
symbols_list.h:{"READ-LINE", CL_ORDINARY, cl_read_line, -1, OBJNULL},
symbols_list.h:{"READ-PRESERVING-WHITESPACE", CL_ORDINARY, cl_read_preserving_whitespace, -1, OBJNULL},
symbols_list.h:{"READ-SEQUENCE", CL_ORDINARY, cl_read_sequence, -1, OBJNULL},
symbols_list.h:{"READER-ERROR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"READTABLE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"READTABLE-CASE", CL_ORDINARY, cl_readtable_case, 1, OBJNULL},
symbols_list.h:{"REAL", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"REDUCE", CL_ORDINARY, ECL_NAME(cl_reduce), -1, OBJNULL},
symbols_list.h:{"REMF", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"REMOVE", CL_ORDINARY, ECL_NAME(cl_remove), -1, OBJNULL},
symbols_list.h:{"REMOVE-DUPLICATES", CL_ORDINARY, ECL_NAME(cl_remove_duplicates), -1, OBJNULL},
symbols_list.h:{"REMOVE-IF", CL_ORDINARY, ECL_NAME(cl_remove_if), -1, OBJNULL},
symbols_list.h:{"REMOVE-IF-NOT", CL_ORDINARY, ECL_NAME(cl_remove_if_not), -1, OBJNULL},
symbols_list.h:{"RENAME-FILE", CL_ORDINARY, cl_rename_file, -1, OBJNULL},
symbols_list.h:{"RENAME-PACKAGE", CL_ORDINARY, cl_rename_package, -1, OBJNULL},
symbols_list.h:{"REPLACE", CL_ORDINARY, ECL_NAME(cl_replace), -1, OBJNULL},
symbols_list.h:{"REQUIRE", CL_ORDINARY, ECL_NAME(cl_require), -1, OBJNULL},
symbols_list.h:{"RESTART-BIND", CL_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{"RESTART-CASE", CL_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{"RESTART-NAME", CL_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{"RETURN", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"RETURN-FROM", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"ROOM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ROTATEF", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ROUND", CL_ORDINARY, cl_round, -1, OBJNULL},
symbols_list.h:{"ROW-MAJOR-AREF", CL_ORDINARY, cl_row_major_aref, 2, OBJNULL},
symbols_list.h:{"SAFETY", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SATISFIES", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SBIT", CL_ORDINARY, ECL_NAME(cl_sbit), -1, OBJNULL},
symbols_list.h:{"SCALE-FLOAT", CL_ORDINARY, cl_scale_float, 2, OBJNULL},
symbols_list.h:{"SEARCH", CL_ORDINARY, ECL_NAME(cl_search), -1, OBJNULL},
symbols_list.h:{"SEQUENCE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SERIOUS-CONDITION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SET-DIFFERENCE", CL_ORDINARY, ECL_NAME(cl_set_difference), -1, OBJNULL},
symbols_list.h:{"SET-DISPATCH-MACRO-CHARACTER", CL_ORDINARY, cl_set_dispatch_macro_character, -1, OBJNULL},
symbols_list.h:{"SET-EXCLUSIVE-OR", CL_ORDINARY, ECL_NAME(cl_set_exclusive_or), -1, OBJNULL},
symbols_list.h:{"SET-MACRO-CHARACTER", CL_ORDINARY, cl_set_macro_character, -1, OBJNULL},
symbols_list.h:{"SET-PPRINT-DISPATCH", CL_ORDINARY, ECL_NAME_PPRINT(cl_set_pprint_dispatch), -1, OBJNULL},
symbols_list.h:{"SET-SYNTAX-FROM-CHAR", CL_ORDINARY, cl_set_syntax_from_char, -1, OBJNULL},
symbols_list.h:{"SETF", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SETQ", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"SHADOW", CL_ORDINARY, cl_shadow, -1, OBJNULL},
symbols_list.h:{"SHADOWING-IMPORT", CL_ORDINARY, cl_shadowing_import, -1, OBJNULL},
symbols_list.h:{"SHIFTF", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SHORT-FLOAT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SHORT-FLOAT-EPSILON", CL_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{"SHORT-FLOAT-NEGATIVE-EPSILON", CL_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{"SHORT-SITE-NAME", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIGNAL", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIGNED-BYTE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIMPLE-ARRAY", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIMPLE-BASE-STRING", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIMPLE-BIT-VECTOR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIMPLE-BIT-VECTOR-P", CL_ORDINARY, cl_simple_bit_vector_p, 1, OBJNULL},
symbols_list.h:{"SIMPLE-CONDITION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIMPLE-CONDITION-FORMAT-CONTROL", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIMPLE-CONDITION-FORMAT-ARGUMENTS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIMPLE-ERROR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIMPLE-STRING", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIMPLE-STRING-P", CL_ORDINARY, cl_simple_string_p, 1, OBJNULL},
symbols_list.h:{"SIMPLE-TYPE-ERROR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIMPLE-VECTOR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SIMPLE-VECTOR-P", CL_ORDINARY, cl_simple_vector_p, 1, OBJNULL},
symbols_list.h:{"SIMPLE-WARNING", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SINGLE-FLOAT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SINGLE-FLOAT-EPSILON", CL_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{"SINGLE-FLOAT-NEGATIVE-EPSILON", CL_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{"SOFTWARE-TYPE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SOFTWARE-VERSION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SOME", CL_ORDINARY, ECL_NAME(cl_some), -1, OBJNULL},
symbols_list.h:{"SORT", CL_ORDINARY, ECL_NAME(cl_sort), -1, OBJNULL},
symbols_list.h:{"SPACE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SPECIAL", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SPECIAL-OPERATOR-P", CL_ORDINARY, cl_special_operator_p, 1, OBJNULL},
symbols_list.h:{"SPEED", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STABLE-SORT", CL_ORDINARY, ECL_NAME(cl_stable_sort), -1, OBJNULL},
symbols_list.h:{"STANDARD-CHAR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STANDARD-CHAR-P", CL_ORDINARY, cl_standard_char_p, 1, OBJNULL},
symbols_list.h:{"STEP", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STORAGE-CONDITION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STORE-VALUE", CL_ORDINARY, ECL_NAME(cl_store_value), -1, OBJNULL},
symbols_list.h:{"STREAM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STREAM-ELEMENT-TYPE", CL_ORDINARY, cl_stream_element_type, 1, OBJNULL},
symbols_list.h:{"STREAM-ERROR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STREAM-ERROR-STREAM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STREAM-EXTERNAL-FORMAT", CL_ORDINARY, cl_stream_external_format, 1, OBJNULL},
symbols_list.h:{"STRING-DOWNCASE", CL_ORDINARY, cl_string_downcase, -1, OBJNULL},
symbols_list.h:{"STRING-CAPITALIZE", CL_ORDINARY, cl_string_capitalize, -1, OBJNULL},
symbols_list.h:{"STRING-EQUAL", CL_ORDINARY, cl_string_equal, -1, OBJNULL},
symbols_list.h:{"STRING-GREATERP", CL_ORDINARY, cl_string_greaterp, -1, OBJNULL},
symbols_list.h:{"STRING-LEFT-TRIM", CL_ORDINARY, cl_string_left_trim, 2, OBJNULL},
symbols_list.h:{"STRING-LESSP", CL_ORDINARY, cl_string_lessp, -1, OBJNULL},
symbols_list.h:{"STRING-NOT-EQUAL", CL_ORDINARY, cl_string_not_equal, -1, OBJNULL},
symbols_list.h:{"STRING-NOT-GREATERP", CL_ORDINARY, cl_string_not_greaterp, -1, OBJNULL},
symbols_list.h:{"STRING-NOT-LESSP", CL_ORDINARY, cl_string_not_lessp, -1, OBJNULL},
symbols_list.h:{"STRING-RIGHT-TRIM", CL_ORDINARY, cl_string_right_trim, 2, OBJNULL},
symbols_list.h:{"STRING-STREAM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STRING-TRIM", CL_ORDINARY, cl_string_trim, 2, OBJNULL},
symbols_list.h:{"STRING-UPCASE", CL_ORDINARY, cl_string_upcase, -1, OBJNULL},
symbols_list.h:{"STRING/=", CL_ORDINARY, cl_stringNE, -1, OBJNULL},
symbols_list.h:{"STRING<", CL_ORDINARY, cl_stringL, -1, OBJNULL},
symbols_list.h:{"STRING<=", CL_ORDINARY, cl_stringLE, -1, OBJNULL},
symbols_list.h:{"STRING=", CL_ORDINARY, cl_stringE, -1, OBJNULL},
symbols_list.h:{"STRING>", CL_ORDINARY, cl_stringG, -1, OBJNULL},
symbols_list.h:{"STRING>=", CL_ORDINARY, cl_stringGE, -1, OBJNULL},
symbols_list.h:{"STRUCTURE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STYLE-WARNING", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SUBLIS", CL_ORDINARY, cl_sublis, -1, OBJNULL},
symbols_list.h:{"SUBSEQ", CL_ORDINARY, cl_subseq, -1, OBJNULL},
symbols_list.h:{"SUBSETP", CL_ORDINARY, ECL_NAME(cl_subsetp), -1, OBJNULL},
symbols_list.h:{"SUBST", CL_ORDINARY, cl_subst, -1, OBJNULL},
symbols_list.h:{"SUBST-IF", CL_ORDINARY, ECL_NAME(cl_subst_if), -1, OBJNULL},
symbols_list.h:{"SUBST-IF-NOT", CL_ORDINARY, ECL_NAME(cl_subst_if_not), -1, OBJNULL},
symbols_list.h:{"SUBSTITUTE", CL_ORDINARY, ECL_NAME(cl_substitute), -1, OBJNULL},
symbols_list.h:{"SUBSTITUTE-IF", CL_ORDINARY, ECL_NAME(cl_substitute_if), -1, OBJNULL},
symbols_list.h:{"SUBSTITUTE-IF-NOT", CL_ORDINARY, ECL_NAME(cl_substitute_if_not), -1, OBJNULL},
symbols_list.h:{"SUBTYPEP", CL_ORDINARY, ECL_NAME(cl_subtypep), -1, OBJNULL},
symbols_list.h:{"SYMBOL", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SYMBOL-FUNCTION", CL_ORDINARY, cl_symbol_function, 1, OBJNULL},
symbols_list.h:{"SYMBOL-MACROLET", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"SYMBOL-NAME", CL_ORDINARY, cl_symbol_name, 1, OBJNULL},
symbols_list.h:{"SYMBOL-PACKAGE", CL_ORDINARY, cl_symbol_package, 1, OBJNULL},
symbols_list.h:{"SYMBOL-PLIST", CL_ORDINARY, cl_symbol_plist, 1, OBJNULL},
symbols_list.h:{"SYMBOL-VALUE", CL_ORDINARY, cl_symbol_value, 1, OBJNULL},
symbols_list.h:{"SYNONYM-STREAM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SYNONYM-STREAM-SYMBOL", CL_ORDINARY, cl_synonym_stream_symbol, 1, OBJNULL},
symbols_list.h:{"TAGBODY", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"TERPRI", CL_ORDINARY, cl_terpri, -1, OBJNULL},
symbols_list.h:{"THE", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"THROW", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"TIME", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"TRACE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"TRANSLATE-LOGICAL-PATHNAME", CL_ORDINARY, cl_translate_logical_pathname, -1, OBJNULL},
symbols_list.h:{"TRANSLATE-PATHNAME", CL_ORDINARY, cl_translate_pathname, -1, OBJNULL},
symbols_list.h:{"TREE-EQUAL", CL_ORDINARY, cl_tree_equal, -1, OBJNULL},
symbols_list.h:{"TRUNCATE", CL_ORDINARY, cl_truncate, -1, OBJNULL},
symbols_list.h:{"TWO-WAY-STREAM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"TWO-WAY-STREAM-INPUT-STREAM", CL_ORDINARY, cl_two_way_stream_input_stream, 1, OBJNULL},
symbols_list.h:{"TWO-WAY-STREAM-OUTPUT-STREAM", CL_ORDINARY, cl_two_way_stream_output_stream, 1, OBJNULL},
symbols_list.h:{"TYPE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"TYPE-ERROR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"TYPE-ERROR-DATUM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"TYPE-ERROR-EXPECTED-TYPE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"TYPE-OF", CL_ORDINARY, cl_type_of, 1, OBJNULL},
symbols_list.h:{"TYPECASE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"TYPEP", CL_ORDINARY, ECL_NAME(cl_typep), -1, OBJNULL},
symbols_list.h:{"UNBOUND-SLOT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"UNBOUND-SLOT-INSTANCE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"UNBOUND-VARIABLE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"UNDEFINED-FUNCTION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"UNEXPORT", CL_ORDINARY, cl_unexport, -1, OBJNULL},
symbols_list.h:{"UNINTERN", CL_ORDINARY, cl_unintern, -1, OBJNULL},
symbols_list.h:{"UNION", CL_ORDINARY, ECL_NAME(cl_union), -1, OBJNULL},
symbols_list.h:{"UNLESS", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"UNREAD-CHAR", CL_ORDINARY, cl_unread_char, -1, OBJNULL},
symbols_list.h:{"UNSIGNED-BYTE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"UNTRACE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"UNUSE-PACKAGE", CL_ORDINARY, cl_unuse_package, -1, OBJNULL},
symbols_list.h:{"UNWIND-PROTECT", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"UPGRADED-ARRAY-ELEMENT-TYPE", CL_ORDINARY, ECL_NAME(cl_upgraded_array_element_type), -1, OBJNULL},
symbols_list.h:{"UPGRADED-COMPLEX-PART-TYPE", CL_ORDINARY, ECL_NAME(cl_upgraded_complex_part_type), -1, OBJNULL},
symbols_list.h:{"UPPER-CASE-P", CL_ORDINARY, cl_upper_case_p, 1, OBJNULL},
symbols_list.h:{"USE-PACKAGE", CL_ORDINARY, cl_use_package, -1, OBJNULL},
symbols_list.h:{"USE-VALUE", CL_ORDINARY, ECL_NAME(cl_use_value), -1, OBJNULL},
symbols_list.h:{"USER-HOMEDIR-PATHNAME", CL_ORDINARY, cl_user_homedir_pathname, -1, OBJNULL},
symbols_list.h:{"VALUES", CL_ORDINARY, cl_values, -1, OBJNULL},
symbols_list.h:{"VALUES-LIST", CL_ORDINARY, cl_values_list, 1, OBJNULL},
symbols_list.h:{"VARIABLE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"VECTOR", CL_ORDINARY, ECL_NAME(cl_vector), -1, OBJNULL},
symbols_list.h:{"VECTOR-POP", CL_ORDINARY, ECL_NAME(cl_vector_pop), 1, OBJNULL},
symbols_list.h:{"VECTOR-PUSH", CL_ORDINARY, cl_vector_push, 2, OBJNULL},
symbols_list.h:{"VECTOR-PUSH-EXTEND", CL_ORDINARY, cl_vector_push_extend, -1, OBJNULL},
symbols_list.h:{"WARN", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WARNING", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WHEN", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"WILD-PATHNAME-P", CL_ORDINARY, cl_wild_pathname_p, -1, OBJNULL},
symbols_list.h:{"WITH-COMPILATION-UNIT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WITH-CONDITION-RESTARTS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WITH-HASH-TABLE-ITERATOR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WITH-INPUT-FROM-STRING", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WITH-OPEN-FILE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WITH-OPEN-STREAM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WITH-OUTPUT-TO-STRING", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WITH-PACKAGE-ITERATOR", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WITH-SIMPLE-RESTART", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WITH-STANDARD-IO-SYNTAX", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WRITE", CL_ORDINARY, cl_write, -1, OBJNULL},
symbols_list.h:{"WRITE-BYTE", CL_ORDINARY, cl_write_byte, 2, OBJNULL},
symbols_list.h:{"WRITE-CHAR", CL_ORDINARY, cl_write_char, -1, OBJNULL},
symbols_list.h:{"WRITE-LINE", CL_ORDINARY, cl_write_line, -1, OBJNULL},
symbols_list.h:{"WRITE-SEQUENCE", CL_ORDINARY, cl_write_sequence, -1, OBJNULL},
symbols_list.h:{"WRITE-STRING", CL_ORDINARY, cl_write_string, -1, OBJNULL},
symbols_list.h:{"WRITE-TO-STRING", CL_ORDINARY, ECL_NAME(cl_write_to_string), -1, OBJNULL},
symbols_list.h:{"Y-OR-N-P", CL_ORDINARY, ECL_NAME(cl_y_or_n_p), -1, OBJNULL},
symbols_list.h:{"YES-OR-NO-P", CL_ORDINARY, ECL_NAME(cl_yes_or_no_p), -1, OBJNULL},
symbols_list.h:{"ALLOCATE-INSTANCE", CL_ORDINARY, NULL, 2, OBJNULL},
symbols_list.h:{"ADD-METHOD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"BUILT-IN-CLASS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"CALL-METHOD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"CALL-NEXT-METHOD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"CHANGE-CLASS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"CLASS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"CLASS-NAME", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"CLASS-OF", CL_ORDINARY, cl_class_of, 1, OBJNULL},
symbols_list.h:{"COMPUTE-APPLICABLE-METHODS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFCLASS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFGENERIC", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFINE-METHOD-COMBINATION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DEFMETHOD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"DESCRIBE-OBJECT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"ENSURE-GENERIC-FUNCTION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"FIND-CLASS", CL_ORDINARY, cl_find_class, -1, OBJNULL},
symbols_list.h:{"FIND-METHOD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"GENERIC-FUNCTION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"IF", CL_FORM, NULL, -1, OBJNULL},
symbols_list.h:{"INITIALIZE-INSTANCE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"INVALID-METHOD-ERROR", CL_ORDINARY, ECL_NAME(cl_invalid_method_error), -1, OBJNULL},
symbols_list.h:{"MAKE-INSTANCE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"MAKE-INSTANCES-OBSOLETE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"MAKE-LOAD-FORM", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"MAKE-LOAD-FORM-SAVING-SLOTS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"MAKE-METHOD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"METHOD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"METHOD-COMBINATION-ERROR", CL_ORDINARY, ECL_NAME(cl_method_combination_error), -1, OBJNULL},
symbols_list.h:{"METHOD-COMBINATION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"METHOD-QUALIFIERS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"NEXT-METHOD-P", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"NO-APPLICABLE-METHOD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"NO-NEXT-METHOD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PRINT-OBJECT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"PRINT-UNREADABLE-OBJECT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"REINITIALIZE-INSTANCE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"REMOVE-METHOD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SHARED-INITIALIZE", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SLOT-BOUNDP", CL_ORDINARY, ECL_NAME(cl_slot_boundp), 2, OBJNULL},
symbols_list.h:{"SLOT-EXISTS-P", CL_ORDINARY, ECL_NAME(cl_slot_exists_p), 2, OBJNULL},
symbols_list.h:{"SLOT-MAKUNBOUND", CL_ORDINARY, ECL_NAME(cl_slot_makunbound), 2, OBJNULL},
symbols_list.h:{"SLOT-MISSING", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SLOT-UNBOUND", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"SLOT-VALUE", CL_ORDINARY, cl_slot_value, 2, OBJNULL},
symbols_list.h:{"STANDARD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STANDARD-CLASS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STANDARD-GENERIC-FUNCTION", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STANDARD-METHOD", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STANDARD-OBJECT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STRUCTURE-CLASS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"STRUCTURE-OBJECT", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"UPDATE-INSTANCE-FOR-DIFFERENT-CLASS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"UPDATE-INSTANCE-FOR-REDEFINED-CLASS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WITH-ACCESSORS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{"WITH-SLOTS", CL_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "ACCESSOR", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "ARGUMENT-PRECEDENCE-ORDER", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "ALLOCATION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DECLARE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DEFAULT-INITARGS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DESCRIPTION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DIRECT-DEFAULT-INITARGS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DIRECT-SLOTS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DIRECT-SUPERCLASSES", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "GENERIC-FUNCTION-CLASS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "IDENTITY-WITH-ONE-ARGUMENT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INITARG", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INITARGS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INITFORM", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INITFUNCTION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LAMBDA-LIST", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LOCATION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "METACLASS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "METHOD", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "METHOD-CLASS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "METHOD-COMBINATION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "OPERATOR", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "ORDER", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "READER", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "READERS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "REQUIRED", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "WRITER", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "WRITERS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "#!", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "*BACKQ-LEVEL*", SI_SPECIAL, NULL, -1, ecl_make_fixnum(0)},
symbols_list.h:{SYS_ "*CBLOCK*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "*CIRCLE-COUNTER*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "*CIRCLE-STACK*", SI_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "*CLASS-NAME-HASH-TABLE*", SI_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "*COMPILER-CONSTANTS*", SI_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "*GC-MESSAGE*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "*GC-VERBOSE*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "*IGNORE-EOF-ON-TERMINAL-IO*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "*INDENT-FORMATTED-OUTPUT*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "*INIT-FUNCTION-PREFIX*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "*INTERRUPTS-ENABLED*", EXT_SPECIAL, NULL, 1, ECL_T},
symbols_list.h:{SYS_ "*KEEP-DEFINITIONS*", SI_SPECIAL, NULL, -1, ECL_T},
symbols_list.h:{EXT_ "*LOAD-HOOKS*", EXT_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "*LOAD-SEARCH-LIST*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "*MAKE-CONSTANT", SI_ORDINARY, si_Xmake_constant, 2, OBJNULL},
symbols_list.h:{SYS_ "*MAKE-SPECIAL", SI_ORDINARY, si_Xmake_special, 1, OBJNULL},
symbols_list.h:{SYS_ "*PRINT-PACKAGE*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "*PRINT-STRUCTURE*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "*SHARP-EQ-CONTEXT*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "*STEP-LEVEL*", SI_SPECIAL, OBJNULL, -1, ecl_make_fixnum(0)},
symbols_list.h:{SYS_ "*STEP-ACTION*", SI_SPECIAL, OBJNULL, -1, ECL_NIL},
symbols_list.h:{SYS_ ".", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "UNQUOTE", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "UNQUOTE-NSPLICE", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "UNQUOTE-SPLICE", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "ALLOCATE-RAW-INSTANCE", SI_ORDINARY, si_allocate_raw_instance, 3, OBJNULL},
symbols_list.h:{SYS_ "ASET", SI_ORDINARY, si_aset, -1, OBJNULL},
symbols_list.h:{SYS_ "BASE-CHAR-P", SI_ORDINARY, si_base_char_p, 1, OBJNULL},
symbols_list.h:{SYS_ "BASE-STRING-P", SI_ORDINARY, si_base_string_p, 1, OBJNULL},
symbols_list.h:{SYS_ "BC-DISASSEMBLE", SI_ORDINARY, si_bc_disassemble, 1, OBJNULL},
symbols_list.h:{SYS_ "BC-SPLIT", SI_ORDINARY, si_bc_split, 1, OBJNULL},
symbols_list.h:{SYS_ "BC-JOIN", SI_ORDINARY, si_bc_join, 4, OBJNULL},
symbols_list.h:{SYS_ "BDS-TOP", SI_ORDINARY, si_bds_top, 0, OBJNULL},
symbols_list.h:{SYS_ "BDS-VAL", SI_ORDINARY, si_bds_val, 1, OBJNULL},
symbols_list.h:{SYS_ "BDS-VAR", SI_ORDINARY, si_bds_var, 1, OBJNULL},
symbols_list.h:{SYS_ "BIT-ARRAY-OP", SI_ORDINARY, si_bit_array_op, 4, OBJNULL},
symbols_list.h:{SYS_ "C-ARGUMENTS-LIMIT", SI_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_C_ARGUMENTS_LIMIT)},
symbols_list.h:{SYS_ "CHAR-SET", SI_ORDINARY, si_char_set, 3, OBJNULL},
symbols_list.h:{EXT_ "CHDIR", EXT_ORDINARY, si_chdir, -1, OBJNULL},
symbols_list.h:{SYS_ "CLEAR-COMPILER-PROPERTIES", SI_ORDINARY, cl_identity, 1, OBJNULL},
symbols_list.h:{SYS_ "COERCE-TO-BASE-STRING", SI_ORDINARY, si_coerce_to_base_string, 1, OBJNULL},
symbols_list.h:{SYS_ "COERCE-TO-EXTENDED-STRING", SI_ORDINARY, si_coerce_to_extended_string, 1, OBJNULL},
symbols_list.h:{SYS_ "COERCE-TO-FILENAME", SI_ORDINARY, si_coerce_to_filename, 1, OBJNULL},
symbols_list.h:{SYS_ "COERCE-TO-FUNCTION", SI_ORDINARY, si_coerce_to_function, 1, OBJNULL},
symbols_list.h:{SYS_ "COERCE-TO-PACKAGE", SI_ORDINARY, si_coerce_to_package, 1, OBJNULL},
symbols_list.h:{SYS_ "COPY-TO-SIMPLE-BASE-STRING", SI_ORDINARY, si_copy_to_simple_base_string, 1, OBJNULL},
symbols_list.h:{SYS_ "COMPILED-FUNCTION-BLOCK", SI_ORDINARY, si_compiled_function_block, 1, OBJNULL},
symbols_list.h:{EXT_ "COMPILED-FUNCTION-NAME", EXT_ORDINARY, si_compiled_function_name, 1, OBJNULL},
symbols_list.h:{SYS_ "COPY-STREAM", SI_ORDINARY, si_copy_stream, 1, OBJNULL},
symbols_list.h:{SYS_ "DO-READ-SEQUENCE", SI_ORDINARY, si_do_read_sequence, 4, OBJNULL},
symbols_list.h:{SYS_ "DO-WRITE-SEQUENCE", SI_ORDINARY, si_do_write_sequence, 4, OBJNULL},
symbols_list.h:{SYS_ "ELT-SET", SI_ORDINARY, si_elt_set, 3, OBJNULL},
symbols_list.h:{SYS_ "EVAL-WITH-ENV", SI_ORDINARY, si_eval_with_env, -1, OBJNULL},
symbols_list.h:{SYS_ "EXPAND-DEFMACRO", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "FILE-COLUMN", SI_ORDINARY, si_file_column, 1, OBJNULL},
symbols_list.h:{EXT_ "FILE-KIND", EXT_ORDINARY, si_file_kind, 2, OBJNULL},
symbols_list.h:{SYS_ "FILL-POINTER-SET", SI_ORDINARY, si_fill_pointer_set, 2, OBJNULL},
symbols_list.h:{EXT_ "FILE-STREAM-FD", EXT_ORDINARY, si_file_stream_fd, 1, OBJNULL},
symbols_list.h:{SYS_ "FORMAT-ERROR", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "FORMATTER-AUX", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "FORMATTER-AUX", SI_ORDINARY, si_formatter_aux, -1, OBJNULL},
symbols_list.h:{SYS_ "FRS-BDS", SI_ORDINARY, si_frs_bds, 1, OBJNULL},
symbols_list.h:{SYS_ "FRS-IHS", SI_ORDINARY, si_frs_ihs, 1, OBJNULL},
symbols_list.h:{SYS_ "FRS-TAG", SI_ORDINARY, si_frs_tag, 1, OBJNULL},
symbols_list.h:{SYS_ "FRS-TOP", SI_ORDINARY, si_frs_top, 0, OBJNULL},
symbols_list.h:{SYS_ "FSET", SI_ORDINARY, si_fset, -1, OBJNULL},
symbols_list.h:{SYS_ "FUNCTION-BLOCK-NAME", SI_ORDINARY, si_function_block_name, 1, OBJNULL},
symbols_list.h:{SYS_ "GET-LIBRARY-PATHNAME", SI_ORDINARY, si_get_library_pathname, 0, OBJNULL},
symbols_list.h:{SYS_ "GET-SYSPROP", SI_ORDINARY, si_get_sysprop, 2, OBJNULL},
symbols_list.h:{EXT_ "GETCWD", EXT_ORDINARY, si_getcwd, -1, OBJNULL},
symbols_list.h:{SYS_ "HASH-SET", SI_ORDINARY, si_hash_set, 3, OBJNULL},
symbols_list.h:{SYS_ "HASH-TABLE-ITERATOR", SI_ORDINARY, si_hash_table_iterator, 1, OBJNULL},
symbols_list.h:{SYS_ "IHS-BDS", SI_ORDINARY, si_ihs_bds, 1, OBJNULL},
symbols_list.h:{SYS_ "IHS-ENV", SI_ORDINARY, si_ihs_env, 1, OBJNULL},
symbols_list.h:{SYS_ "IHS-FUN", SI_ORDINARY, si_ihs_fun, 1, OBJNULL},
symbols_list.h:{SYS_ "IHS-NEXT", SI_ORDINARY, si_ihs_next, 1, OBJNULL},
symbols_list.h:{SYS_ "IHS-PREV", SI_ORDINARY, si_ihs_prev, 1, OBJNULL},
symbols_list.h:{SYS_ "IHS-TOP", SI_ORDINARY, si_ihs_top, 0, OBJNULL},
symbols_list.h:{SYS_ "INTERPRETER-STACK", SI_ORDINARY, si_interpreter_stack, -1, OBJNULL},
symbols_list.h:{SYS_ "LINK-FROM", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "LINK-TO", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "LOAD-SOURCE", SI_ORDINARY, si_load_source, 4, OBJNULL},
symbols_list.h:{SYS_ "LOGICAL-PATHNAME-P", SI_ORDINARY, si_logical_pathname_p, 1, OBJNULL},
symbols_list.h:{SYS_ "MACRO", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "MAKE-LAMBDA", SI_ORDINARY, si_make_lambda, 2, OBJNULL},
symbols_list.h:{SYS_ "MAKE-PURE-ARRAY", SI_ORDINARY, si_make_pure_array, 6, OBJNULL},
symbols_list.h:{SYS_ "MAKE-STRING-OUTPUT-STREAM-FROM-STRING", SI_ORDINARY, si_make_string_output_stream_from_string, 1, OBJNULL},
symbols_list.h:{SYS_ "MAKE-STRUCTURE", SI_ORDINARY, si_make_structure, -1, OBJNULL},
symbols_list.h:{SYS_ "MAKE-VECTOR", SI_ORDINARY, si_make_vector, 6, OBJNULL},
symbols_list.h:{SYS_ "MANGLE-NAME", SI_ORDINARY, si_mangle_name, -1, OBJNULL},
symbols_list.h:{EXT_ "MAKE-PIPE", EXT_ORDINARY, si_make_pipe, 0, OBJNULL},
symbols_list.h:{EXT_ "PACKAGE-LOCK", EXT_ORDINARY, si_package_lock, 2, OBJNULL},
symbols_list.h:{SYS_ "PACKAGE-HASH-TABLES", SI_ORDINARY, si_package_hash_tables, 1, OBJNULL},
symbols_list.h:{SYS_ "PATHNAME-TRANSLATIONS", SI_ORDINARY, si_pathname_translations, -1, OBJNULL},
symbols_list.h:{SYS_ "PRETTY-PRINT-FORMAT", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "PROCESS-DECLARATIONS", SI_ORDINARY, si_process_declarations, -1, OBJNULL},
symbols_list.h:{SYS_ "PROCESS-LAMBDA", SI_ORDINARY, si_process_lambda, 1, OBJNULL},
symbols_list.h:{SYS_ "PROCESS-LAMBDA-LIST", SI_ORDINARY, si_process_lambda_list, 2, OBJNULL},
symbols_list.h:{SYS_ "PUT-F", SI_ORDINARY, si_put_f, 3, OBJNULL},
symbols_list.h:{SYS_ "PUT-PROPERTIES", SI_ORDINARY, si_put_properties, -1, OBJNULL},
symbols_list.h:{SYS_ "PUT-SYSPROP", SI_ORDINARY, si_put_sysprop, 3, OBJNULL},
symbols_list.h:{SYS_ "READTABLE-CASE-SET", SI_ORDINARY, si_readtable_case_set, 2, OBJNULL},
symbols_list.h:{SYS_ "REM-F", SI_ORDINARY, si_rem_f, 2, OBJNULL},
symbols_list.h:{SYS_ "REM-SYSPROP", SI_ORDINARY, si_rem_sysprop, 2, OBJNULL},
symbols_list.h:{SYS_ "REPLACE-ARRAY", SI_ORDINARY, si_replace_array, 2, OBJNULL},
symbols_list.h:{SYS_ "ROW-MAJOR-ASET", SI_ORDINARY, si_row_major_aset, 3, OBJNULL},
symbols_list.h:{EXT_ "RUN-PROGRAM", EXT_ORDINARY, si_run_program, -1, OBJNULL},
symbols_list.h:{SYS_ "WAIT-FOR-ALL-PROCESSES", SI_ORDINARY, si_wait_for_all_processes, -1, OBJNULL},
symbols_list.h:{EXT_ "SAFE-EVAL", EXT_ORDINARY, ECL_NAME(si_safe_eval), -1, OBJNULL},
symbols_list.h:{SYS_ "SCH-FRS-BASE", SI_ORDINARY, si_sch_frs_base, 2, OBJNULL},
symbols_list.h:{SYS_ "SCHAR-SET", SI_ORDINARY, si_char_set, 3, OBJNULL},
symbols_list.h:{SYS_ "SHARP-A-READER", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "SHARP-S-READER", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "SELECT-PACKAGE", SI_ORDINARY, si_select_package, 1, OBJNULL},
symbols_list.h:{SYS_ "SET-SYMBOL-PLIST", SI_ORDINARY, si_set_symbol_plist, 2, OBJNULL},
symbols_list.h:{EXT_ "SETENV", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "SETF-METHOD", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "SETF-NAMEP", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "SIMPLE-PROGRAM-ERROR", SI_ORDINARY,  ECL_NAME(si_simple_program_error), -1, OBJNULL},
symbols_list.h:{SYS_ "SIGNAL-SIMPLE-ERROR", SI_ORDINARY, si_signal_simple_error, -1, OBJNULL},
symbols_list.h:{SYS_ "SIGNAL-TYPE-ERROR", SI_ORDINARY, si_signal_type_error, 2, OBJNULL},
symbols_list.h:{SYS_ "STANDARD-READTABLE", SI_ORDINARY, si_standard_readtable, 0, OBJNULL},
symbols_list.h:{SYS_ "STEPPER", SI_ORDINARY, OBJNULL, -1, OBJNULL},
symbols_list.h:{SYS_ "BASE-STRING-CONCATENATE", SI_ORDINARY, si_base_string_concatenate, -1, OBJNULL},
symbols_list.h:{SYS_ "STRING-TO-OBJECT", SI_ORDINARY, ECL_NAME(si_string_to_object), -1, OBJNULL},
symbols_list.h:{SYS_ "STRUCTURE-NAME", SI_ORDINARY, si_structure_name, 1, OBJNULL},
symbols_list.h:{SYS_ "STRUCTURE-PRINT-FUNCTION", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "STRUCTURE-REF", SI_ORDINARY, si_structure_ref, 3, OBJNULL},
symbols_list.h:{SYS_ "STRUCTURE-SET", SI_ORDINARY, si_structure_set, 4, OBJNULL},
symbols_list.h:{SYS_ "STRUCTURE-SLOT-DESCRIPTIONS", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "STRUCTURE-SUBTYPE-P", SI_ORDINARY, si_structure_subtype_p, 2, OBJNULL},
symbols_list.h:{SYS_ "SYMBOL-MACRO", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "TERMINAL-INTERRUPT", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "TOP-LEVEL", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "UNIVERSAL-ERROR-HANDLER", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "VALID-FUNCTION-NAME-P", SI_ORDINARY, si_valid_function_name_p, 1, OBJNULL},
symbols_list.h:{SYS_ "WRITE-OBJECT", SI_SPECIAL, si_write_object, 2, OBJNULL},
symbols_list.h:{SYS_ "WRITE-UGLY-OBJECT", SI_SPECIAL, si_write_ugly_object, 2, OBJNULL},
symbols_list.h:{SYS_ "STRUCTURE-INCLUDE", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "COPY-INSTANCE", SI_ORDINARY, si_copy_instance, 1, OBJNULL},
symbols_list.h:{SYS_ "GENERIC-FUNCTION-P", SI_ORDINARY, si_generic_function_p, 1, OBJNULL},
symbols_list.h:{SYS_ "INSTANCE-REF", SI_ORDINARY, si_instance_ref, 2, OBJNULL},
symbols_list.h:{SYS_ "INSTANCE-SET", SI_ORDINARY, si_instance_set, 3, OBJNULL},
symbols_list.h:{SYS_ "INSTANCE-SIG", SI_ORDINARY, si_instance_sig, 1, OBJNULL},
symbols_list.h:{SYS_ "INSTANCE-SIG-SET", SI_ORDINARY, si_instance_sig_set, 1, OBJNULL},
symbols_list.h:{SYS_ "INSTANCE-CLASS", SI_ORDINARY, si_instance_class, 1, OBJNULL},
symbols_list.h:{SYS_ "INSTANCE-CLASS-SET", SI_ORDINARY, si_instance_class_set, 2, OBJNULL},
symbols_list.h:{SYS_ "SL-BOUNDP", SI_ORDINARY, si_sl_boundp, 1, OBJNULL},
symbols_list.h:{SYS_ "SL-MAKUNBOUND", SI_ORDINARY, si_sl_makunbound, 2, OBJNULL},
symbols_list.h:{SYS_ "SUBCLASSP", SI_ORDINARY, ECL_NAME(si_subclassp), -1, OBJNULL},
symbols_list.h:{SYS_ "OF-CLASS-P", SI_ORDINARY, ECL_NAME(si_of_class_p), -1, OBJNULL},
symbols_list.h:{EXT_ "*SOURCE-LOCATION*", EXT_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "*REGISTER-WITH-PDE-HOOK*", EXT_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "REGISTER-WITH-PDE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "PROFILE", SI_ORDINARY, IF_PROFILE(si_profile), -1, OBJNULL},
symbols_list.h:{SYS_ "CLEAR-PROFILE", SI_ORDINARY, IF_PROFILE(si_clear_profile), -1, OBJNULL},
symbols_list.h:{SYS_ "DISPLAY-PROFILE", SI_ORDINARY, IF_PROFILE(si_display_profile), -1, OBJNULL},
symbols_list.h:{SYS_ "*PROFILE-ARRAY*", SI_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "OPEN-CLIENT-STREAM", SI_ORDINARY, IF_TCP(si_open_client_stream), 2, OBJNULL},
symbols_list.h:{SYS_ "OPEN-SERVER-STREAM", SI_ORDINARY, IF_TCP(si_open_server_stream), 1, OBJNULL},
symbols_list.h:{SYS_ "OPEN-UNIX-SOCKET-STREAM", SI_ORDINARY, IF_TCP(si_open_unix_socket_stream), 1, OBJNULL},
symbols_list.h:{SYS_ "LOOKUP-HOST-ENTRY", SI_ORDINARY, IF_TCP(si_lookup_host_entry), 1, OBJNULL},
symbols_list.h:{EXT_ "CATCH-SIGNAL", EXT_ORDINARY, si_catch_signal, -1, OBJNULL},
symbols_list.h:{EXT_ "GET-SIGNAL-HANDLER", EXT_ORDINARY, si_get_signal_handler, 1, OBJNULL},
symbols_list.h:{EXT_ "SET-SIGNAL-HANDLER", EXT_ORDINARY, si_set_signal_handler, 2, OBJNULL},
symbols_list.h:{KEY_ "ADJUSTABLE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "ABORT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "ABSOLUTE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "ALLOW-OTHER-KEYS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "APPEND", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "ARRAY", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "BACK", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "BASE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "BLOCK", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CAPITALIZE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CATCH", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CASE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CIRCLE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "COMPILE-TOPLEVEL", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "COMMON",KEYWORD,NULL,-1,OBJNULL},
symbols_list.h:{KEY_ "CONC-NAME", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CONSTRUCTOR", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CONTROL-STRING", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "COPIER", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CREATE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DATUM", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DEFAULT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DEFAULTS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DEVICE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DIRECTION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DIRECTORY", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DISPLACED-INDEX-OFFSET", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DISPLACED-TO", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DOCUMENTATION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DOWNCASE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "ELEMENT-TYPE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "END", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "END1", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "END2", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "EOF", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "ERROR", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "ESCAPE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "EXECUTE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "EXPECTED-TYPE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "EXPORT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "EXPORT-FROM", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "EXTERNAL", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "EXTERNAL-FORMAT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "FILE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "FILL-POINTER", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "FORMAT-ARGUMENTS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "FORMAT-CONTROL", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "FUNCTION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "GENSYM", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "HOST", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "IF-DOES-NOT-EXIST", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "IF-EXISTS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "IF-OUTPUT-EXISTS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "IGNORE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "IMPORT-FROM", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INCLUDE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INHERITED", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INITIAL-ELEMENT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INITIAL-CONTENTS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INITIAL-OFFSET", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INPUT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INTERACTIVE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INSTANCE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INTERN", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INTERNAL", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INVERT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "IO", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "JUNK-ALLOWED", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "KEY", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LENGTH", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LEVEL", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LINES", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LINK", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LIST-ALL", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LOCAL",KEYWORD,NULL,-1,OBJNULL},
symbols_list.h:{KEY_ "LOCKABLE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LOAD-TOPLEVEL", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "MASK", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "MISER-WIDTH", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "NAME", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "NAMED", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "NEW-VERSION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "NEWEST", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "NICKNAMES", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "OBJECT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "OFFSET", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "OPERATION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "OPERANDS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "OUTPUT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "OVERWRITE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "PACKAGE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "PATHNAME", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "PPRINT-DISPATCH", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "PREDICATE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "PRESERVE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "PRETTY", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "PRINT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "PRINT-FUNCTION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "PRINT-OBJECT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "PROBE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "PROCESS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "RADIX", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "READABLY", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "REHASH-SIZE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "REHASH-THRESHOLD", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "RELATIVE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "RENAME", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "RENAME-AND-DELETE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "REPORT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "RIGHT-MARGIN", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "SET-DEFAULT-PATHNAME", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "SEARCH-LIST", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "SHADOW", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "SHADOWING-IMPORT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "SIZE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "SPECIAL", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "START", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "START1", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "START2", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "STREAM", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "SUPERSEDE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "TAG", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "TEST", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "TEST-NOT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "TYPE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UNSPECIFIC", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UNMASK", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UP", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UPCASE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "USE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CSTREAM", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "VERBOSE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "VERSION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "WILD", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "WILD-INFERIORS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "WAIT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "BYTE8", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "BYTE16", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "BYTE32", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "BYTE64", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "COMPILER-LET", EXT_FORM, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "INTEGER8", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "INTEGER16", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "INTEGER32", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "INTEGER64", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "LAMBDA-BLOCK", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "QUIT", EXT_ORDINARY, si_quit, -1, OBJNULL},
symbols_list.h:{EXT_ "GET-METHOD", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "INSTANCE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "ALLOCATE-FOREIGN-DATA", SI_ORDINARY, si_allocate_foreign_data, 2, OBJNULL},
symbols_list.h:{SYS_ "FIND-FOREIGN-SYMBOL", SI_ORDINARY, si_find_foreign_symbol, 4, OBJNULL},
symbols_list.h:{SYS_ "FOREIGN-DATA", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "FOREIGN-DATA-ADDRESS", SI_ORDINARY, si_foreign_data_address, 1, OBJNULL},
symbols_list.h:{SYS_ "FOREIGN-DATA-EQUAL", SI_ORDINARY, si_foreign_data_equal, 2, OBJNULL},
symbols_list.h:{SYS_ "FOREIGN-DATA-P", SI_ORDINARY, si_foreign_data_p, 1, OBJNULL},
symbols_list.h:{SYS_ "FOREIGN-DATA-POINTER", SI_ORDINARY, si_foreign_data_pointer, 4, OBJNULL},
symbols_list.h:{SYS_ "FOREIGN-DATA-RECAST", SI_ORDINARY, si_foreign_data_recast, 3, OBJNULL},
symbols_list.h:{SYS_ "FOREIGN-DATA-REF", SI_ORDINARY, si_foreign_data_ref, 4, OBJNULL},
symbols_list.h:{SYS_ "FOREIGN-DATA-REF-ELT", SI_ORDINARY, si_foreign_data_ref_elt, 3, OBJNULL},
symbols_list.h:{SYS_ "FOREIGN-DATA-SET", SI_ORDINARY, si_foreign_data_set, 3, OBJNULL},
symbols_list.h:{SYS_ "FOREIGN-DATA-SET-ELT", SI_ORDINARY, si_foreign_data_set_elt, 4, OBJNULL},
symbols_list.h:{SYS_ "FOREIGN-DATA-TAG", SI_ORDINARY, si_foreign_data_tag, 1, OBJNULL},
symbols_list.h:{SYS_ "FOREIGN-ELT-TYPE-P", SI_ORDINARY, si_foreign_elt_type_p, 1, OBJNULL},
symbols_list.h:{SYS_ "FREE-FOREIGN-DATA", SI_ORDINARY, si_free_foreign_data, 1, OBJNULL},
symbols_list.h:{SYS_ "MAKE-FOREIGN-DATA-FROM-ARRAY", SI_ORDINARY, si_make_foreign_data_from_array, 1, OBJNULL},
symbols_list.h:{SYS_ "LOAD-FOREIGN-MODULE", SI_ORDINARY, si_load_foreign_module, 1, OBJNULL},
symbols_list.h:{SYS_ "NULL-POINTER-P", SI_ORDINARY, si_null_pointer_p, 1, OBJNULL},
symbols_list.h:{SYS_ "SIZE-OF-FOREIGN-ELT-TYPE", SI_ORDINARY, si_size_of_foreign_elt_type, 1, OBJNULL},
symbols_list.h:{SYS_ "ALIGNMENT-OF-FOREIGN-ELT-TYPE", SI_ORDINARY, si_alignment_of_foreign_elt_type, 1, OBJNULL},
symbols_list.h:{KEY_ "BYTE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CHAR", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CSTRING", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "DOUBLE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "FIXNUM", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "FLOAT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INT8-T", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INT16-T", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INT32-T", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "INT64-T", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LONG", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LONG-LONG", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "POINTER-SELF", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "POINTER-VOID", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "SHORT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "STRUCT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UNION", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "VOID", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UINT8-T", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UINT16-T", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UINT32-T", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UINT64-T", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UNSIGNED-BYTE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UNSIGNED-CHAR", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UNSIGNED-INT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UNSIGNED-LONG", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UNSIGNED-LONG-LONG", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UNSIGNED-SHORT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "GC", EXT_ORDINARY, si_gc, -1, OBJNULL},
symbols_list.h:{SYS_ "GC-DUMP", SI_ORDINARY, si_gc_dump, 0, OBJNULL},
symbols_list.h:{SYS_ "GC-STATS", SI_ORDINARY, si_gc_stats, 1, OBJNULL},
symbols_list.h:{SYS_ "ALLOCATE", SI_ORDINARY, si_allocate, -1, OBJNULL},
symbols_list.h:{SYS_ "ALLOCATED-PAGES", SI_ORDINARY, si_allocated_pages, -1, OBJNULL},
symbols_list.h:{SYS_ "MAXIMUM-ALLOCATABLE-PAGES", SI_ORDINARY, si_maximum_allocatable_pages, -1, OBJNULL},
symbols_list.h:{SYS_ "ALLOCATE-CONTIGUOUS-PAGES", SI_ORDINARY, si_allocate_contiguous_pages, -1, OBJNULL},
symbols_list.h:{SYS_ "ALLOCATED-CONTIGUOUS-PAGES", SI_ORDINARY, si_allocated_contiguous_pages, -1, OBJNULL},
symbols_list.h:{SYS_ "MAXIMUM-CONTIGUOUS-PAGES", SI_ORDINARY, si_maximum_contiguous_pages, -1, OBJNULL},
symbols_list.h:{SYS_ "GC-TIME", SI_ORDINARY, si_gc_time, -1, OBJNULL},
symbols_list.h:{SYS_ "GET-HOLE-SIZE", SI_ORDINARY, si_get_hole_size, -1, OBJNULL},
symbols_list.h:{SYS_ "SET-HOLE-SIZE", SI_ORDINARY, si_set_hole_size, -1, OBJNULL},
symbols_list.h:{SYS_ "IGNORE-MAXIMUM-PAGES", SI_ORDINARY, si_ignore_maximum_pages, -1, OBJNULL},
symbols_list.h:{SYS_ "ROOM-REPORT", SI_ORDINARY, si_room_report, -1, OBJNULL},
symbols_list.h:{SYS_ "RESET-GC-COUNT", SI_ORDINARY, si_reset_gc_count, -1, OBJNULL},
symbols_list.h:{MP_ "PROCESS", MP_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "LOCK", MP_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "CONDITION-VARIABLE", MP_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "*CURRENT-PROCESS*", MP_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "ALL-PROCESSES", MP_ORDINARY, IF_MP(mp_all_processes), 0, OBJNULL},
symbols_list.h:{MP_ "EXIT-PROCESS", MP_ORDINARY, IF_MP(mp_exit_process), 0, OBJNULL},
symbols_list.h:{MP_ "MAKE-PROCESS", MP_ORDINARY, IF_MP(mp_make_process), -1, OBJNULL},
symbols_list.h:{MP_ "PROCESS-ACTIVE-P", MP_ORDINARY, IF_MP(mp_process_active_p), 1, OBJNULL},
symbols_list.h:{MP_ "PROCESS-ENABLE", MP_ORDINARY, IF_MP(mp_process_enable), 1, OBJNULL},
symbols_list.h:{MP_ "PROCESS-YIELD", MP_ORDINARY, IF_MP(mp_process_yield), 0, OBJNULL},
symbols_list.h:{MP_ "PROCESS-KILL", MP_ORDINARY, IF_MP(mp_process_kill), 1, OBJNULL},
symbols_list.h:{MP_ "PROCESS-NAME", MP_ORDINARY, IF_MP(mp_process_name), 1, OBJNULL},
symbols_list.h:{MP_ "PROCESS-PRESET", MP_ORDINARY, IF_MP(mp_process_preset), -1, OBJNULL},
symbols_list.h:{MP_ "PROCESS-RUN-FUNCTION", MP_ORDINARY, IF_MP(mp_process_run_function), -1, OBJNULL},
symbols_list.h:{MP_ "PROCESS-WHOSTATE", MP_ORDINARY, IF_MP(mp_process_whostate), 1, OBJNULL},
symbols_list.h:{MP_ "PROCESS-JOIN", MP_ORDINARY, IF_MP(mp_process_join), 1, OBJNULL},
symbols_list.h:{MP_ "MAKE-LOCK", MP_ORDINARY, IF_MP(mp_make_lock), -1, OBJNULL},
symbols_list.h:{KEY_ "RECURSIVE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "RECURSIVE-LOCK-P", MP_ORDINARY, IF_MP(mp_recursive_lock_p), 1, OBJNULL},
symbols_list.h:{MP_ "LOCK-NAME", MP_ORDINARY, IF_MP(mp_lock_name), 1, OBJNULL},
symbols_list.h:{MP_ "LOCK-OWNER", MP_ORDINARY, IF_MP(mp_lock_owner), 1, OBJNULL},
symbols_list.h:{MP_ "LOCK-COUNT", MP_ORDINARY, IF_MP(mp_lock_count), 1, OBJNULL},
symbols_list.h:{MP_ "GET-LOCK", MP_ORDINARY, IF_MP(mp_get_lock), -1, OBJNULL},
symbols_list.h:{MP_ "GIVEUP-LOCK", MP_ORDINARY, IF_MP(mp_giveup_lock), 1, OBJNULL},
symbols_list.h:{MP_ "MAKE-CONDITION-VARIABLE", MP_ORDINARY, IF_MP(mp_make_condition_variable), 0, OBJNULL},
symbols_list.h:{MP_ "CONDITION-VARIABLE-WAIT", MP_ORDINARY, IF_MP(mp_condition_variable_wait), 2, OBJNULL},
symbols_list.h:{MP_ "CONDITION-VARIABLE-TIMEDWAIT", MP_ORDINARY, IF_MP(mp_condition_variable_timedwait), 3, OBJNULL},
symbols_list.h:{MP_ "CONDITION-VARIABLE-SIGNAL", MP_ORDINARY, IF_MP(mp_condition_variable_signal), 1, OBJNULL},
symbols_list.h:{MP_ "CONDITION-VARIABLE-BROADCAST", MP_ORDINARY, IF_MP(mp_condition_variable_broadcast), 1, OBJNULL},
symbols_list.h:{KEY_ "INITIAL-BINDINGS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "INTERRUPT-PROCESS", MP_ORDINARY, IF_MP(mp_interrupt_process), 2, OBJNULL},
symbols_list.h:{MP_ "+LOAD-COMPILE-LOCK+", MP_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "WITH-LOCK", MP_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "BLOCK-SIGNALS", MP_ORDINARY, IF_MP(mp_block_signals), 0, OBJNULL},
symbols_list.h:{MP_ "RESTORE-SIGNALS", MP_ORDINARY, IF_MP(mp_restore_signals), 1, OBJNULL},
symbols_list.h:{MP_ "PROCESS-SUSPEND", MP_ORDINARY, IF_MP(mp_process_suspend), 1, OBJNULL},
symbols_list.h:{MP_ "PROCESS-RESUME", MP_ORDINARY, IF_MP(mp_process_resume), 1, OBJNULL},
symbols_list.h:{MP_ "SUSPEND-LOOP", MP_ORDINARY, IF_MP(mp_suspend_loop), 0, OBJNULL},
symbols_list.h:{MP_ "BREAK-SUSPEND-LOOP", MP_ORDINARY, IF_MP(mp_break_suspend_loop), 0, OBJNULL},
symbols_list.h:{MP_ "MAKE-RWLOCK", MP_ORDINARY, IF_MP(mp_make_rwlock), -1, OBJNULL},
symbols_list.h:{MP_ "RWLOCK", MP_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "RWLOCK-NAME", MP_ORDINARY, IF_MP(mp_rwlock_name), 1, OBJNULL},
symbols_list.h:{MP_ "GET-RWLOCK-READ", MP_ORDINARY, IF_MP(mp_get_rwlock_read), -1, OBJNULL},
symbols_list.h:{MP_ "GET-RWLOCK-WRITE", MP_ORDINARY, IF_MP(mp_get_rwlock_write), -1, OBJNULL},
symbols_list.h:{MP_ "GIVEUP-RWLOCK-READ", MP_ORDINARY, IF_MP(mp_giveup_rwlock_read), 1, OBJNULL},
symbols_list.h:{MP_ "GIVEUP-RWLOCK-WRITE", MP_ORDINARY, IF_MP(mp_giveup_rwlock_write), 1, OBJNULL},
symbols_list.h:{MP_ "GLOBAL-LOCK", MP_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "ERROR-LOCK", MP_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "SEMAPHORE", MP_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "MAKE-SEMAPHORE", MP_ORDINARY, IF_MP(mp_make_semaphore), -1, OBJNULL},
symbols_list.h:{MP_ "SIGNAL-SEMAPHORE", MP_ORDINARY, IF_MP(mp_signal_semaphore), -1, OBJNULL},
symbols_list.h:{MP_ "WAIT-ON-SEMAPHORE", MP_ORDINARY, IF_MP(mp_wait_on_semaphore), 1, OBJNULL},
symbols_list.h:{MP_ "SEMAPHORE-COUNT", MP_ORDINARY, IF_MP(mp_semaphore_count), 1, OBJNULL},
symbols_list.h:{MP_ "SEMAPHORE-NAME", MP_ORDINARY, IF_MP(mp_semaphore_name), 1, OBJNULL},
symbols_list.h:{MP_ "SEMAPHORE-WAIT-COUNT", MP_ORDINARY, IF_MP(mp_semaphore_wait_count), 1, OBJNULL},
symbols_list.h:{KEY_ "COUNT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "BARRIER", MP_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "MAKE-BARRIER", MP_ORDINARY, IF_MP(mp_make_barrier), -1, OBJNULL},
symbols_list.h:{MP_ "BARRIER-UNBLOCK", MP_ORDINARY, IF_MP(mp_barrier_unblock), -1, OBJNULL},
symbols_list.h:{MP_ "BARRIER-WAIT", MP_ORDINARY, IF_MP(mp_barrier_wait), -1, OBJNULL},
symbols_list.h:{MP_ "BARRIER-COUNT", MP_ORDINARY, IF_MP(mp_barrier_count), 1, OBJNULL},
symbols_list.h:{MP_ "BARRIER-NAME", MP_ORDINARY, IF_MP(mp_barrier_name), 1, OBJNULL},
symbols_list.h:{MP_ "BARRIER-ARRIVERS-COUNT", MP_ORDINARY, IF_MP(mp_barrier_arrivers_count), 1, OBJNULL},
symbols_list.h:{KEY_ "DISABLE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "RESET-COUNT", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "KILL-WAITING", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UNBLOCKED", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "MAILBOX", MP_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{MP_ "MAKE-MAILBOX", MP_ORDINARY, IF_MP(mp_make_mailbox), -1, OBJNULL},
symbols_list.h:{MP_ "MAILBOX-NAME", MP_ORDINARY, IF_MP(mp_mailbox_name), 1, OBJNULL},
symbols_list.h:{MP_ "MAILBOX-COUNT", MP_ORDINARY, IF_MP(mp_mailbox_count), 1, OBJNULL},
symbols_list.h:{MP_ "MAILBOX-EMPTY-P", MP_ORDINARY, IF_MP(mp_mailbox_empty_p), 1, OBJNULL},
symbols_list.h:{MP_ "MAILBOX-READ", MP_ORDINARY, IF_MP(mp_mailbox_read), 1, OBJNULL},
symbols_list.h:{MP_ "MAILBOX-SEND", MP_ORDINARY, IF_MP(mp_mailbox_send), 2, OBJNULL},
symbols_list.h:{SYS_ "WHILE", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "UNTIL", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "QUASIQUOTE", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "*EXIT-HOOKS*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{CLOS_ ".COMBINED-METHOD-ARGS.", CLOS_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{CLOS_ "+BUILTIN-CLASSES+", CLOS_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{CLOS_ "*NEXT-METHODS*", CLOS_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{CLOS_ "*OPTIMIZE-SLOT-ACCESS*", CLOS_SPECIAL, NULL, -1, ECL_T},
symbols_list.h:{CLOS_ "+THE-T-CLASS+", CLOS_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{CLOS_ "+THE-CLASS+", CLOS_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{CLOS_ "+THE-STD-CLASS+", CLOS_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{CLOS_ "+THE-STANDARD-CLASS+", CLOS_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{CLOS_ "+THE-FUNCALLABLE-STANDARD-CLASS+", CLOS_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{CLOS_ "ACCESSOR-METHOD-SLOT-DEFINITION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "ADD-DEPENDENT", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "ADD-DIRECT-METHOD", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "ADD-DIRECT-SUBCLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "CLASS-DEFAULT-INITARGS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "CLASS-DIRECT-DEFAULT-INITARGS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "CLASS-DIRECT-SLOTS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "CLASS-DIRECT-SUBCLASSES", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "CLASS-DIRECT-SUPERCLASSES", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "CLASS-FINALIZED-P", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "CLASS-PRECEDENCE-LIST", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "CLASS-PROTOTYPE", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "CLASS-SLOTS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "COMPUTE-APPLICABLE-METHODS-USING-CLASSES", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "COMPUTE-CLASS-PRECEDENCE-LIST", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "COMPUTE-DEFAULT-INITARGS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "COMPUTE-DISCRIMINATING-FUNCTION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "COMPUTE-EFFECTIVE-METHOD", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "COMPUTE-EFFECTIVE-SLOT-DEFINITION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "COMPUTE-SLOTS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "DIRECT-SLOT-DEFINITION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "DIRECT-SLOT-DEFINITION-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "EFFECTIVE-SLOT-DEFINITION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "EFFECTIVE-SLOT-DEFINITION-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "ENSURE-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "ENSURE-CLASS-USING-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "ENSURE-GENERIC-FUNCTION-USING-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "EQL-SPECIALIZER", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "EQL-SPECIALIZER-OBJECT", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "EXTRACT-LAMBDA-LIST", CLOS_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{CLOS_ "EXTRACT-SPECIALIZER-NAMES", CLOS_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{CLOS_ "FINALIZE-INHERITANCE", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "FIND-METHOD-COMBINATION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "FORWARD-REFERENCED-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "FUNCALLABLE-STANDARD-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "FUNCALLABLE-STANDARD-INSTANCE-ACCESS", CLOS_ORDINARY, si_instance_ref, 2, OBJNULL},
symbols_list.h:{CLOS_ "FUNCALLABLE-STANDARD-OBJECT", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "GENERIC-FUNCTION-DECLARATIONS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "GENERIC-FUNCTION-LAMBDA-LIST", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "GENERIC-FUNCTION-METHOD-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "GENERIC-FUNCTION-METHOD-COMBINATION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "GENERIC-FUNCTION-METHODS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "GENERIC-FUNCTION-NAME", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "INTERN-EQL-SPECIALIZER", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "LOCATION-TABLE", CLOS_ORDINARY | PRIVATE, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "MAKE-METHOD-LAMBDA", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "MAP-DEPENDENTS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "METAOBJECT", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "METHOD-FUNCTION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "METHOD-GENERIC-FUNCTION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "METHOD-LAMBDA-LIST", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "METHOD-SPECIALIZERS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "NAME", CLOS_ORDINARY | PRIVATE, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "READER-METHOD-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "REMOVE-DEPENDENT", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "REMOVE-DIRECT-METHOD", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "REMOVE-DIRECT-SUBCLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SET-FUNCALLABLE-INSTANCE-FUNCTION", CLOS_ORDINARY, clos_set_funcallable_instance_function, 2, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-BOUNDP-USING-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-DEFINITION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-DEFINITION-ALLOCATION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-DEFINITION-INITARGS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-DEFINITION-INITFORM", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-DEFINITION-INITFUNCTION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-DEFINITION-LOCATION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-DEFINITION-NAME", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-DEFINITION-READERS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-DEFINITION-TYPE", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-DEFINITION-WRITERS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-MAKUNBOUND-USING-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-VALUE-USING-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-VALUE-SET", CLOS_ORDINARY, clos_slot_value_set, 3, OBJNULL},
symbols_list.h:{CLOS_ "SLOT-TABLE", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SPECIALIZER", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SPECIALIZER-DIRECT-GENERIC-FUNCTIONS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SPECIALIZER-DIRECT-METHODS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "STANDARD-ACCESSOR-METHOD", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "STANDARD-DIRECT-SLOT-DEFINITION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "STANDARD-EFFECTIVE-SLOT-DEFINITION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "STANDARD-INSTANCE-ACCESS", CLOS_ORDINARY, si_instance_ref, 2, OBJNULL},
symbols_list.h:{CLOS_ "STANDARD-READER-METHOD", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "STANDARD-SLOT-DEFINITION", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "STANDARD-WRITER-METHOD", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "STANDARD-OPTIMIZED-READER-METHOD", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "STANDARD-OPTIMIZED-WRITER-METHOD", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "STD-COMPUTE-APPLICABLE-METHODS", CLOS_ORDINARY, ECL_NAME(clos_std_compute_applicable_methods), 2, OBJNULL},
symbols_list.h:{CLOS_ "STD-COMPUTE-APPLICABLE-METHODS-USING-CLASSES", CLOS_ORDINARY, NULL, 2, OBJNULL},
symbols_list.h:{CLOS_ "STD-COMPUTE-EFFECTIVE-METHOD", CLOS_ORDINARY, ECL_NAME(clos_std_compute_effective_method), 3, OBJNULL},
symbols_list.h:{CLOS_ "COMPUTE-EFFECTIVE-METHOD-FUNCTION", CLOS_ORDINARY, ECL_NAME(clos_compute_effective_method_function), 3, OBJNULL},
symbols_list.h:{CLOS_ "UPDATE-DEPENDENT", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "UPDATE-INSTANCE", CLOS_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{CLOS_ "VALIDATE-SUPERCLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "WRITER-METHOD-CLASS", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "CLEAR-GFUN-HASH", SI_ORDINARY, si_clear_gfun_hash, 1, OBJNULL},
symbols_list.h:{CLOS_ "NEED-TO-MAKE-LOAD-FORM-P", CLOS_ORDINARY, ECL_NAME(clos_need_to_make_load_form_p), 2, OBJNULL},
symbols_list.h:{CLOS_ "LOAD-DEFCLASS", CLOS_ORDINARY, ECL_NAME(clos_load_defclass), 4, OBJNULL},
symbols_list.h:{CLOS_ "DOCSTRING", CLOS_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{CLOS_ "SAFE-INSTANCE-REF", CLOS_ORDINARY, clos_safe_instance_ref, 2, OBJNULL},
symbols_list.h:{SYS_ "CL-FIXNUM-BITS", SI_CONSTANT, NULL, -1, ecl_make_fixnum(FIXNUM_BITS)},
symbols_list.h:{EXT_ "CL-FIXNUM", EXT_ORDINARY, NULL, -1, NULL},
symbols_list.h:{EXT_ "CL-INDEX", EXT_ORDINARY, NULL, -1, NULL},
symbols_list.h:{SYS_ "DO-DEFTYPE", SI_ORDINARY, ECL_NAME(si_do_deftype), -1, OBJNULL},
symbols_list.h:{SYS_ "CREATE-TYPE-NAME", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "*ALIEN-DECLARATIONS*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "LOAD-BINARY", SI_ORDINARY, si_load_binary, 4, OBJNULL},
symbols_list.h:{SYS_ "LOAD-BINARY", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "*CODE-WALKER*", SI_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "CALL-CFUN", SI_ORDINARY, IF_DFFI(si_call_cfun), -1, OBJNULL},
symbols_list.h:{KEY_ "CALLBACK", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "MAKE-DYNAMIC-CALLBACK", SI_ORDINARY, IF_DFFI(si_make_dynamic_callback), -1, OBJNULL},
symbols_list.h:{SYS_ "FREE-FFI-CLOSURE", SI_ORDINARY, IF_LIBFFI(si_free_ffi_closure), 1, OBJNULL},
symbols_list.h:{KEY_ "CDECL", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "STDCALL", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "TRAP-FPE", SI_ORDINARY, si_trap_fpe, 2, OBJNULL},
symbols_list.h:{EXT_ "*ACTION-ON-UNDEFINED-VARIABLE*", EXT_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "SET-BUFFERING-MODE", SI_ORDINARY, si_set_buffering_mode, 2, OBJNULL},
symbols_list.h:{KEY_ "NONE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LINE-BUFFERED", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "FULLY-BUFFERED", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LINE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "FULL", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "CMP-ENV-REGISTER-MACROLET", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "GET-FINALIZER", EXT_ORDINARY, si_get_finalizer, 1, OBJNULL},
symbols_list.h:{EXT_ "SET-FINALIZER", EXT_ORDINARY, si_set_finalizer, 2, OBJNULL},
symbols_list.h:{SYS_ "*RELATIVE-PACKAGE-NAMES*", SI_SPECIAL, NULL, -1, RELATIVE_PACKAGES_P},
symbols_list.h:{KEY_ "RELATIVE-PACKAGE-NAMES", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "FIND-RELATIVE-PACKAGE", SI_ORDINARY, IF_RELPACK(si_find_relative_package), -1, OBJNULL},
symbols_list.h:{SYS_ "PACKAGE-PARENT", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "PACKAGE-CHILDREN", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "WRONG-TYPE-ARGUMENT", SI_ORDINARY, si_wrong_type_argument, -1, OBJNULL},
symbols_list.h:{SYS_ "*CURRENT-FORM*", SI_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "CODE-BLOCK", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "FRAME", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "APPLY-FROM-STACK-FRAME", SI_ORDINARY, si_apply_from_stack_frame, 2, OBJNULL},
symbols_list.h:{GRAY_ "CLOSE", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAMP", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "INPUT-STREAM-P", GRAY_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{GRAY_ "OUTPUT-STREAM-P", GRAY_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{GRAY_ "OPEN-STREAM-P", GRAY_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-ADVANCE-TO-COLUMN", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-CLEAR-INPUT", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-CLEAR-OUTPUT", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-ELEMENT-TYPE", GRAY_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-FILE-DESCRIPTOR", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-FILE-POSITION", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-FINISH-OUTPUT", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-FORCE-OUTPUT", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-FRESH-LINE", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-INTERACTIVE-P", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-LINE-COLUMN", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-LISTEN", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-PEEK-CHAR", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-READ-BYTE", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-READ-CHAR", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-READ-CHAR-NO-HANG", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-READ-LINE", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-READ-SEQUENCE", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-START-LINE-P", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-TERPRI", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-UNREAD-CHAR", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-WRITE-BYTE", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-WRITE-CHAR", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-WRITE-SEQUENCE", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "STREAM-WRITE-STRING", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "FUNDAMENTAL-STREAM", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "FUNDAMENTAL-INPUT-STREAM", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "FUNDAMENTAL-OUTPUT-STREAM", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "FUNDAMENTAL-CHARACTER-STREAM", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "FUNDAMENTAL-BINARY-STREAM", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "FUNDAMENTAL-CHARACTER-INPUT-STREAM", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "FUNDAMENTAL-CHARACTER-OUTPUT-STREAM", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "FUNDAMENTAL-BINARY-INPUT-STREAM", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{GRAY_ "FUNDAMENTAL-BINARY-OUTPUT-STREAM", GRAY_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "BC-FILE", EXT_ORDINARY, si_compiled_function_file, 1, ECL_NIL},
symbols_list.h:{EXT_ "COMPILED-FUNCTION-FILE", EXT_ORDINARY, si_compiled_function_file, 1, ECL_NIL},
symbols_list.h:{SYS_ "PROPERTY-LIST", SI_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{SYS_ "HASH-EQL", SI_ORDINARY, si_hash_eql, -1, OBJNULL},
symbols_list.h:{SYS_ "HASH-EQUAL", SI_ORDINARY, si_hash_equal, -1, OBJNULL},
symbols_list.h:{SYS_ "HASH-EQUALP", SI_ORDINARY, si_hash_equalp, -1, OBJNULL},
symbols_list.h:{EXT_ "INTERACTIVE-INTERRUPT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "STORAGE-EXHAUSTED", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "STACK-OVERFLOW", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "STACK-OVERFLOW-SIZE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "STACK-OVERFLOW-TYPE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "BINDING-STACK", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "FRAME-STACK", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "LISP-STACK", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "C-STACK", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "HEAP-SIZE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "ILLEGAL-INSTRUCTION", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "SET-LIMIT", EXT_ORDINARY, si_set_limit, 2, OBJNULL},
symbols_list.h:{EXT_ "GET-LIMIT", EXT_ORDINARY, si_get_limit, 1, OBJNULL},
symbols_list.h:{EXT_ "SEGMENTATION-VIOLATION", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "EXTENDED-STRING", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "CHECK-PENDING-INTERRUPTS", SI_ORDINARY, si_check_pending_interrupts, 0, OBJNULL},
symbols_list.h:{KEY_ "LATIN-1", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "ISO-8859-1", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UTF-8", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UCS-2", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UCS-4", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "CONSTANTLY-T", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "CONSTANTLY-NIL", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "MAYBE-QUOTE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "MAYBE-UNQUOTE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CR", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LF", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CRLF", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UCS-2BE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UCS-4BE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UCS-2LE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UCS-4LE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "LOAD-ENCODING", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "MAKE-ENCODING", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "ALL-ENCODINGS", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "US-ASCII", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "LITTLE-ENDIAN", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "BIG-ENDIAN", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "+UNICODE-DATABASE+", SI_CONSTANT, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "COPY-FILE", EXT_ORDINARY, si_copy_file, 2, OBJNULL},
symbols_list.h:{EXT_ "FILL-ARRAY-WITH-ELT", EXT_ORDINARY, si_fill_array_with_elt, 4, OBJNULL},
symbols_list.h:{EXT_ "+ECL-VERSION-NUMBER+", EXT_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_VERSION_NUMBER)},
symbols_list.h:{EXT_ "*BYTECODES-COMPILER*", EXT_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "SHORT-FLOAT-POSITIVE-INFINITY", EXT_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "SINGLE-FLOAT-POSITIVE-INFINITY", EXT_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "DOUBLE-FLOAT-POSITIVE-INFINITY", EXT_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "LONG-FLOAT-POSITIVE-INFINITY", EXT_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "SHORT-FLOAT-NEGATIVE-INFINITY", EXT_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "SINGLE-FLOAT-NEGATIVE-INFINITY", EXT_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "DOUBLE-FLOAT-NEGATIVE-INFINITY", EXT_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "LONG-FLOAT-NEGATIVE-INFINITY", EXT_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "FLOAT-NAN-P", EXT_ORDINARY, si_float_nan_p, 1, OBJNULL},
symbols_list.h:{EXT_ "FLOAT-INFINITY-P", EXT_ORDINARY, si_float_infinity_p, 1, OBJNULL},
symbols_list.h:{SYS_ "READ-OBJECT-OR-IGNORE", EXT_ORDINARY, si_read_object_or_ignore, 2, OBJNULL},
symbols_list.h:{EXT_ "FLOAT-NAN-STRING", EXT_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{EXT_ "FLOAT-INFINITY-STRING", EXT_ORDINARY, NULL, 1, OBJNULL},
symbols_list.h:{EXT_ "READTABLE-LOCK", EXT_ORDINARY, si_readtable_lock, -1, OBJNULL},
symbols_list.h:{SYS_ "+IO-SYNTAX-PROGV-LIST+", SI_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "+ECL-SYNTAX-PROGV-LIST+", SI_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "WITH-ECL-IO-SYNTAX", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "STREAM-EXTERNAL-FORMAT-SET", SI_ORDINARY, si_stream_external_format_set, 2, OBJNULL},
symbols_list.h:{KEY_ "SYSV", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "UNIX64", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "WIN64", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "WEAK-POINTER", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "MAKE-WEAK-POINTER", EXT_ORDINARY, si_make_weak_pointer, 1, OBJNULL},
symbols_list.h:{EXT_ "WEAK-POINTER-VALUE", EXT_ORDINARY, si_weak_pointer_value, 1, OBJNULL},
symbols_list.h:{SYS_ "*ALLOW-WITH-INTERRUPTS*", SI_SPECIAL, NULL, -1, ECL_T},
symbols_list.h:{EXT_ "WITH-UNIQUE-NAMES", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "HANDLE-SIGNAL", SI_ORDINARY, si_handle_signal, 2, OBJNULL},
symbols_list.h:{EXT_ "WITH-INTERRUPTS", MP_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "WITHOUT-INTERRUPTS", MP_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "WITH-LOCAL-INTERRUPTS", MP_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "ALLOW-WITH-INTERRUPTS", MP_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "*QUIT-TAG*", SI_SPECIAL, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "ARRAY-RAW-DATA", EXT_ORDINARY, si_array_raw_data, 1, OBJNULL},
symbols_list.h:{EXT_ "*PROGRAM-EXIT-CODE*", EXT_SPECIAL, NULL, -1, ecl_make_fixnum(0)},
symbols_list.h:{EXT_ "EXIT", EXT_ORDINARY, si_exit, -1, OBJNULL},
symbols_list.h:{KEY_ "ENVIRON", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "MAKE-EXTERNAL-PROCESS", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "EXTERNAL-PROCESS", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "EXTERNAL-PROCESS-PID", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "EXTERNAL-PROCESS-INPUT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "EXTERNAL-PROCESS-OUTPUT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "EXTERNAL-PROCESS-STATUS", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "RUNNING", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "EXITED", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "SIGNALED", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "STOPPED", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "EXTERNAL-PROCESS-WAIT", EXT_ORDINARY, si_external_process_wait, -1, OBJNULL},
symbols_list.h:{SYS_ "CLOSE-WINDOWS-HANDLE", SI_ORDINARY, si_close_windows_handle, 1, OBJNULL},
symbols_list.h:{SYS_ "CLOSE-WINDOWS-HANDLE", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "*INVOKE-DEBUGGER-HOOK*", EXT_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "*DOCUMENTATION-POOL*", EXT_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "ANNOTATE", EXT_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "GET-ANNOTATION", EXT_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "REMOVE-ANNOTATION", EXT_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "FUNCTION-LAMBDA-LIST", EXT_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "DEFAULT-ANNOTATION-LOGIC", EXT_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "OPTIONAL-ANNOTATION", EXT_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "LOCATION", EXT_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "LISP-IMPLEMENTATION-VCS-ID", EXT_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "SIGNAL-SERVICING", SI_ORDINARY, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "*DEFAULT-EXTERNAL-FORMAT*", EXT_SPECIAL, NULL, -1, ECL_T},
symbols_list.h:{KEY_ "PASS-THROUGH", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "WITH-BACKEND", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "ARRAY-INDEX", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "ANSI-STREAM", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "COMPLEX-ARRAY", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "SEQUENCE-START-END", SI_ORDINARY, si_sequence_start_end, 4, OBJNULL},
symbols_list.h:{SYS_ "SEQUENCE-COUNT", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "SHRINK-VECTOR", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "COPY-SUBARRAY", SI_ORDINARY, si_copy_subarray, 5, OBJNULL},
symbols_list.h:{SYS_ "CONS-CAR", SI_ORDINARY, cl_car, 1, OBJNULL},
symbols_list.h:{SYS_ "CONS-CDR", SI_ORDINARY, cl_cdr, 1, OBJNULL},
symbols_list.h:{EXT_ "COMPILER-TYPECASE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "ASSERT-FAILURE", SI_ORDINARY, ECL_NAME(si_assert_failure), -1, OBJNULL},
symbols_list.h:{SYS_ "CCASE-ERROR", SI_ORDINARY, ECL_NAME(si_ccase_error), 3, OBJNULL},
symbols_list.h:{SYS_ "ECASE-ERROR", SI_ORDINARY, ECL_NAME(si_ecase_error), 2, OBJNULL},
symbols_list.h:{SYS_ "ETYPECASE-ERROR", SI_ORDINARY, ECL_NAME(si_etypecase_error), 2, OBJNULL},
symbols_list.h:{SYS_ "CTYPECASE-ERROR", SI_ORDINARY, ECL_NAME(si_ctypecase_error), 3, OBJNULL},
symbols_list.h:{SYS_ "DO-CHECK-TYPE", SI_ORDINARY, ECL_NAME(si_do_check_type), 4, OBJNULL},
symbols_list.h:{EXT_ "ARRAY-ELEMENT-TYPE-BYTE-SIZE", EXT_ORDINARY, si_array_element_type_byte_size, 1, OBJNULL},
symbols_list.h:{EXT_ "SSE-PACK", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "SSE-PACK-P", EXT_ORDINARY, IF_SSE2(si_sse_pack_p), 1, OBJNULL},
symbols_list.h:{EXT_ "SSE-PACK-AS-ELT-TYPE", EXT_ORDINARY, IF_SSE2(si_sse_pack_as_elt_type), 2, OBJNULL},
symbols_list.h:{EXT_ "VECTOR-TO-SSE-PACK", EXT_ORDINARY, IF_SSE2(si_vector_to_sse_pack), 1, OBJNULL},
symbols_list.h:{EXT_ "SSE-PACK-TO-VECTOR", EXT_ORDINARY, IF_SSE2(si_sse_pack_to_vector), 2, OBJNULL},
symbols_list.h:{EXT_ "INT-SSE-PACK", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "FLOAT-SSE-PACK", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "DOUBLE-SSE-PACK", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "SSE-PACK-ELEMENT-TYPE", EXT_ORDINARY, IF_SSE2(si_sse_pack_element_type), 1, OBJNULL},
symbols_list.h:{EXT_ "*SSE-PACK-PRINT-MODE*", EXT_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "UNIX-SIGNAL-RECEIVED", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "UNIX-SIGNAL-RECEIVED-CODE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "CODE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "ASSUME-RIGHT-TYPE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "FLOAT-TO-DIGITS", SI_ORDINARY, si_float_to_digits, 4, OBJNULL},
symbols_list.h:{SYS_ "FLOAT-TO-STRING-FREE", SI_ORDINARY, si_float_to_string_free, 4, OBJNULL},
symbols_list.h:{SYS_ "INTEGER-TO-STRING", SI_ORDINARY, si_integer_to_string, 5, OBJNULL},
symbols_list.h:{SYS_ "PRINT-UNREADABLE-OBJECT-FUNCTION", SI_ORDINARY, si_print_unreadable_object_function, 5, OBJNULL},
symbols_list.h:{EXT_ "DUMP-C-BACKTRACE", EXT_ORDINARY, si_dump_c_backtrace, 1, OBJNULL},
symbols_list.h:{EXT_ "+PROCESS-STANDARD-INPUT+", EXT_CONSTANT, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "+PROCESS-STANDARD-OUTPUT+", EXT_CONSTANT, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "+PROCESS-ERROR-OUTPUT+", EXT_CONSTANT, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "*HELP-MESSAGE*", EXT_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "*LISP-INIT-FILE-LIST*", EXT_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "+DEFAULT-COMMAND-ARG-RULES+", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "COMMAND-ARGS", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "*COMMAND-ARGS*", EXT_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{EXT_ "PROCESS-COMMAND-ARGS", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "*UNPROCESSED-ECL-COMMAND-ARGS*", EXT_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{KEY_ "OCTETS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "CHARACTER-CODING-ERROR", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "CHARACTER-CODING-ERROR-EXTERNAL-FORMAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "CHARACTER-ENCODING-ERROR", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "CHARACTER-ENCODING-ERROR-CODE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "CHARACTER-DECODING-ERROR", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "CHARACTER-DECODING-ERROR-OCTETS", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "STREAM-DECODING-ERROR", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "STREAM-ENCODING-ERROR", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "DECODING-ERROR", EXT_ORDINARY, NULL, 3, OBJNULL},
symbols_list.h:{EXT_ "ENCODING-ERROR", EXT_ORDINARY, NULL, 3, OBJNULL},
symbols_list.h:{SYS_ "PROPER-LIST-P", SI_ORDINARY, si_proper_list_p, 1, OBJNULL},
symbols_list.h:{SYS_ "TRACED-OLD-DEFINITION", SI_ORDINARY, ECL_NAME(si_traced_old_definition), 1, OBJNULL},
symbols_list.h:{SYS_ "*TRACE-LIST*", SI_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{SYS_ "FUNCTION-BOUNDARY", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "*INSPECTOR-HOOK*", EXT_SPECIAL, NULL, -1, ECL_NIL},
symbols_list.h:{KEY_ "RESOLVE-SYMLINKS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "LOAD-BYTECODES", SI_ORDINARY, si_load_bytecodes, 4, OBJNULL},
symbols_list.h:{KEY_ "SHARED", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "PRIVATE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "MMAP", EXT_ORDINARY, si_mmap, -1, OBJNULL},
symbols_list.h:{EXT_ "MMAP-ARRAY", EXT_ORDINARY, si_mmap_array, 1, OBJNULL},
symbols_list.h:{SYS_ "GET-CDATA", SI_ORDINARY, si_get_cdata, 1, OBJNULL},
symbols_list.h:{SYS_ "ADD-CDATA", SI_ORDINARY, si_add_cdata, 2, OBJNULL},
symbols_list.h: * CDR-5 http://cdr.eurolisp.org/document/5/extra-num-types.html
symbols_list.h:{EXT_ "NEGATIVE-FIXNUM", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-FIXNUM", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-FIXNUM", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-FIXNUM", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-FIXNUM-P", EXT_ORDINARY, ECL_NAME(si_negative_fixnum_p), 1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-FIXNUM-P", EXT_ORDINARY, ECL_NAME(si_positive_fixnum_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-FIXNUM-P", EXT_ORDINARY, ECL_NAME(si_non_negative_fixnum_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-FIXNUM-P", EXT_ORDINARY, ECL_NAME(si_non_positive_fixnum_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-INTEGER", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-INTEGER", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-INTEGER", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-INTEGER", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-INTEGER-P", EXT_ORDINARY, ECL_NAME(si_negative_integer_p), 1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-INTEGER-P", EXT_ORDINARY, ECL_NAME(si_positive_integer_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-INTEGER-P", EXT_ORDINARY, ECL_NAME(si_non_negative_integer_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-INTEGER-P", EXT_ORDINARY, ECL_NAME(si_non_positive_integer_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-RATIONAL", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-RATIONAL", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-RATIONAL", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-RATIONAL", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-RATIONAL-P", EXT_ORDINARY, ECL_NAME(si_negative_rational_p), 1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-RATIONAL-P", EXT_ORDINARY, ECL_NAME(si_positive_rational_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-RATIONAL-P", EXT_ORDINARY, ECL_NAME(si_non_negative_rational_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-RATIONAL-P", EXT_ORDINARY, ECL_NAME(si_non_positive_rational_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-RATIO", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-RATIO", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-RATIO", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-RATIO", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-RATIO-P", EXT_ORDINARY, ECL_NAME(si_negative_ratio_p), 1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-RATIO-P", EXT_ORDINARY, ECL_NAME(si_positive_ratio_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-RATIO-P", EXT_ORDINARY, ECL_NAME(si_non_negative_ratio_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-RATIO-P", EXT_ORDINARY, ECL_NAME(si_non_positive_ratio_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-REAL", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-REAL", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-REAL", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-REAL", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-REAL-P", EXT_ORDINARY, ECL_NAME(si_negative_real_p), 1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-REAL-P", EXT_ORDINARY, ECL_NAME(si_positive_real_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-REAL-P", EXT_ORDINARY, ECL_NAME(si_non_negative_real_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-REAL-P", EXT_ORDINARY, ECL_NAME(si_non_positive_real_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_negative_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_positive_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_non_negative_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_non_positive_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-SHORT-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-SHORT-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-SHORT-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-SHORT-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-SHORT-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_negative_short_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-SHORT-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_positive_short_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-SHORT-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_non_negative_short_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-SHORT-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_non_positive_short_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-SINGLE-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-SINGLE-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-SINGLE-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-SINGLE-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-SINGLE-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_negative_single_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-SINGLE-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_positive_single_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-SINGLE-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_non_negative_single_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-SINGLE-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_non_positive_single_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-DOUBLE-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-DOUBLE-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-DOUBLE-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-DOUBLE-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-DOUBLE-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_negative_double_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-DOUBLE-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_positive_double_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-DOUBLE-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_non_negative_double_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-DOUBLE-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_non_positive_double_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-LONG-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-LONG-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-LONG-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-LONG-FLOAT", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "NEGATIVE-LONG-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_negative_long_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "POSITIVE-LONG-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_positive_long_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-NEGATIVE-LONG-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_non_negative_long_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "NON-POSITIVE-LONG-FLOAT-P", EXT_ORDINARY, ECL_NAME(si_non_positive_long_float_p), 1, OBJNULL},
symbols_list.h:{EXT_ "ARRAY-INDEX-P", EXT_ORDINARY, ECL_NAME(si_array_index_p), 1, OBJNULL},
symbols_list.h:{EXT_ "SEQUENCE-STREAM", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "MAKE-SEQUENCE-INPUT-STREAM", EXT_ORDINARY, si_make_sequence_input_stream, -1, OBJNULL},
symbols_list.h:{EXT_ "MAKE-SEQUENCE-OUTPUT-STREAM", EXT_ORDINARY, si_make_sequence_output_stream, -1, OBJNULL},
symbols_list.h:{SYS_ "MISSING-KEYWORD", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "HASH-TABLE-CONTENT", EXT_ORDINARY, si_hash_table_content, 1, OBJNULL},
symbols_list.h:{EXT_ "HASH-TABLE-FILL", EXT_ORDINARY, si_hash_table_fill, 2, OBJNULL},
symbols_list.h:{SYS_ "REPORT-FUNCTION", SI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "DO-DEFSETF", SI_ORDINARY, ECL_NAME(si_do_defsetf), 2, OBJNULL},
symbols_list.h:{SYS_ "DO-DEFINE-SETF-METHOD", SI_ORDINARY, ECL_NAME(si_do_define_setf_method), 2, OBJNULL},
symbols_list.h:{SYS_ "SETF-DEFINITION", SI_ORDINARY, ECL_NAME(si_setf_definition), 2, OBJNULL},
symbols_list.h:{EXT_ "ASSUME-NO-ERRORS", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "ASSUME-TYPES-DONT-CHANGE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "CHECK-ARGUMENTS-TYPE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "INLINE-ACCESSORS", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "INLINE-TYPE-CHECKS", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "EVALUATE-FORMS", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "TYPE-ASSERTIONS", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "CHECK-STACK-OVERFLOW", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "ARRAY-BOUNDS-CHECK", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "VALUE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "KEY-AND-VALUE", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{KEY_ "WEAKNESS", KEYWORD, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "HASH-TABLE-WEAKNESS", EXT_ORDINARY, si_hash_table_weakness, 1, OBJNULL},
symbols_list.h:{EXT_ "TRULY-THE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "CHECKED-VALUE", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "INSTALL-BYTECODES-COMPILER", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{EXT_ "INSTALL-C-COMPILER", EXT_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "C-CHAR-BIT", FFI_CONSTANT, NULL, -1, ecl_make_fixnum(CHAR_BIT)},
symbols_list.h:{FFI_ "C-CHAR-MAX", FFI_CONSTANT, NULL, -1, ecl_make_fixnum(CHAR_MAX)},
symbols_list.h:{FFI_ "C-CHAR-MIN", FFI_CONSTANT, NULL, -1, ecl_make_fixnum(CHAR_MIN)},
symbols_list.h:{FFI_ "C-INT-MAX", FFI_CONSTANT, NULL, -1, OBJNULL}, /* See main.d */
symbols_list.h:{FFI_ "C-INT-MIN", FFI_CONSTANT, NULL, -1, OBJNULL}, /* See main.d */
symbols_list.h:{FFI_ "C-SHORT-MAX", FFI_CONSTANT, NULL, -1, ecl_make_fixnum(SHRT_MAX)},
symbols_list.h:{FFI_ "C-SHORT-MIN", FFI_CONSTANT, NULL, -1, ecl_make_fixnum(SHRT_MIN)},
symbols_list.h:{FFI_ "C-LONG-MAX", FFI_CONSTANT, NULL, -1, OBJNULL}, /* See main.d */
symbols_list.h:{FFI_ "C-LONG-MIN", FFI_CONSTANT, NULL, -1, OBJNULL}, /* See main.d */
symbols_list.h:{FFI_ "C-LONG-LONG-MAX",FFI_CONSTANT,NULL,-1,OBJNULL}, /* See main.d */
symbols_list.h:{FFI_ "C-UCHAR-MAX", FFI_CONSTANT, NULL, -1, ecl_make_fixnum(UCHAR_MAX)},
symbols_list.h:{FFI_ "C-UINT-MAX", FFI_CONSTANT, NULL, -1, OBJNULL}, /* See main.d */
symbols_list.h:{FFI_ "C-USHORT-MAX", FFI_CONSTANT, NULL, -1, ecl_make_fixnum(USHRT_MAX)},
symbols_list.h:{FFI_ "C-ULONG-MAX", FFI_CONSTANT, NULL, -1, OBJNULL}, /* See main.d */
symbols_list.h:{FFI_ "C-ULONG-LONG-MAX",FFI_CONSTANT,NULL,-1,OBJNULL}, /* See main.d */
symbols_list.h:{FFI_ "C-LONG-LONG-BIT", FFI_CONSTANT, NULL, -1, ecl_make_fixnum(ECL_LONG_LONG_BITS)},
symbols_list.h:{FFI_ "C-LONG-LONG-BIT", FFI_CONSTANT, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "*USE-DFFI*", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "+NULL-CSTRING-POINTER+", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "ALLOCATE-FOREIGN-OBJECT", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "ALLOCATE-FOREIGN-STRING", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "C-INLINE", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "CALLBACK", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "CHAR*", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "CHAR-ARRAY-TO-POINTER", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "CLINES", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "CONVERT-FROM-CSTRING", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "CONVERT-FROM-FOREIGN-STRING", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "CONVERT-TO-CSTRING", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "CONVERT-TO-FOREIGN-STRING", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEF-ARRAY", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEF-ARRAY-POINTER", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEF-CONSTANT", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEF-ENUM", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEF-FOREIGN-TYPE", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEF-FOREIGN-VAR", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEF-FUNCTION", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEF-STRUCT", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEF-TYPE", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEF-UNION", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEFCALLBACK", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEFCBODY", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEFENTRY", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEFINLINE", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEFLA", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEREF-ARRAY", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DEREF-POINTER", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "DOUBLE", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "ENSURE-CHAR-CHARACTER", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "ENSURE-CHAR-INTEGER", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "ENSURE-CHAR-STORABLE", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "FIND-FOREIGN-LIBRARY", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "FOREIGN-STRING-LENGTH", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "FREE-CSTRING", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "FREE-FOREIGN-OBJECT", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "GET-SLOT-POINTER", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "GET-SLOT-VALUE", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "INT", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "LOAD-FOREIGN-LIBRARY", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "MAKE-NULL-POINTER", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "MAKE-POINTER", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "NULL-CHAR-P", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "OBJECT", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "POINTER-ADDRESS", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "SIZE-OF-FOREIGN-TYPE", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "VOID", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "WITH-CAST-POINTER", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "WITH-CSTRING", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "WITH-CSTRINGS", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "WITH-FOREIGN-OBJECT", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "WITH-FOREIGN-OBJECTS", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "WITH-FOREIGN-STRING", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{FFI_ "WITH-FOREIGN-STRINGS", FFI_ORDINARY, NULL, -1, OBJNULL},
symbols_list.h:{SYS_ "BIND-SIMPLE-RESTARTS", SI_ORDINARY, ECL_NAME(si_bind_simple_restarts), 2, OBJNULL},
symbols_list.h:{SYS_ "BIND-SIMPLE-HANDLERS", SI_ORDINARY, ECL_NAME(si_bind_simple_handlers), 2, OBJNULL},
symbols_list.h:{NULL, CL_ORDINARY, NULL, -1, OBJNULL}};
symbols_list2.h:/* -*- mode: c; c-basic-offset: 8 -*- */
symbols_list2.h: * not be able to cross-compile.
symbols_list2.h:{SYS_ "PROTECT-TAG",NULL},
symbols_list2.h:{SYS_ "*RESTART-CLUSTERS*",NULL},
symbols_list2.h:{SYS_ "*HANDLER-CLUSTERS*",NULL},
symbols_list2.h:{"&ALLOW-OTHER-KEYS",NULL},
symbols_list2.h:{"-","cl_M"},
symbols_list2.h:{"*BREAK-ON-SIGNALS*",NULL},
symbols_list2.h:{"*COMPILE-FILE-PATHNAME*",NULL},
symbols_list2.h:{"*COMPILE-FILE-TRUENAME*",NULL},
symbols_list2.h:{"*COMPILE-PRINT*",NULL},
symbols_list2.h:{"*COMPILE-VERBOSE*",NULL},
symbols_list2.h:{"*DEBUG-IO*",NULL},
symbols_list2.h:{"*DEBUGGER-HOOK*",NULL},
symbols_list2.h:{"*DEFAULT-PATHNAME-DEFAULTS*",NULL},
symbols_list2.h:{"*ERROR-OUTPUT*",NULL},
symbols_list2.h:{"*GENSYM-COUNTER*",NULL},
symbols_list2.h:{"*LOAD-PATHNAME*",NULL},
symbols_list2.h:{"*LOAD-PRINT*",NULL},
symbols_list2.h:{"*LOAD-TRUENAME*",NULL},
symbols_list2.h:{"*LOAD-VERBOSE*",NULL},
symbols_list2.h:{"*MACROEXPAND-HOOK*",NULL},
symbols_list2.h:{EXT_ "*MODULE-PROVIDER-FUNCTIONS*",NULL},
symbols_list2.h:{"*PRINT-ARRAY*",NULL},
symbols_list2.h:{"*PRINT-BASE*",NULL},
symbols_list2.h:{"*PRINT-CASE*",NULL},
symbols_list2.h:{"*PRINT-CIRCLE*",NULL},
symbols_list2.h:{"*PRINT-ESCAPE*",NULL},
symbols_list2.h:{"*PRINT-GENSYM*",NULL},
symbols_list2.h:{"*PRINT-LENGTH*",NULL},
symbols_list2.h:{"*PRINT-LEVEL*",NULL},
symbols_list2.h:{"*PRINT-LINES*",NULL},
symbols_list2.h:{"*PRINT-MISER-WIDTH*",NULL},
symbols_list2.h:{"*PRINT-PPRINT-DISPATCH*",NULL},
symbols_list2.h:{"*PRINT-PRETTY*",NULL},
symbols_list2.h:{"*PRINT-PRETTY*",NULL},
symbols_list2.h:{"*PRINT-RADIX*",NULL},
symbols_list2.h:{"*PRINT-READABLY*",NULL},
symbols_list2.h:{"*PRINT-RIGHT-MARGIN*",NULL},
symbols_list2.h:{"*QUERY-IO*",NULL},
symbols_list2.h:{"*RANDOM-STATE*",NULL},
symbols_list2.h:{"*READ-BASE*",NULL},
symbols_list2.h:{"*READ-DEFAULT-FLOAT-FORMAT*",NULL},
symbols_list2.h:{"*READ-EVAL*",NULL},
symbols_list2.h:{"*READ-SUPPRESS*",NULL},
symbols_list2.h:{"*STANDARD-INPUT*",NULL},
symbols_list2.h:{"*STANDARD-OUTPUT*",NULL},
symbols_list2.h:{"*TERMINAL-IO*",NULL},
symbols_list2.h:{"*TRACE-OUTPUT*",NULL},
symbols_list2.h:{"1-","cl_1M"},
symbols_list2.h:{"ADJUST-ARRAY","ECL_NAME(cl_adjust_array)"},
symbols_list2.h:{"ADJUSTABLE-ARRAY-P","cl_adjustable_array_p"},
symbols_list2.h:{"ALPHA-CHAR-P","cl_alpha_char_p"},
symbols_list2.h:{"APROPOS-LIST","ECL_NAME(cl_apropos_list)"},
symbols_list2.h:{"ARITHMETIC-ERROR",NULL},
symbols_list2.h:{"ARITHMETIC-ERROR-OPERANDS",NULL},
symbols_list2.h:{"ARITHMETIC-ERROR-OPERATION",NULL},
symbols_list2.h:{"ARRAY-DIMENSION","cl_array_dimension"},
symbols_list2.h:{"ARRAY-DIMENSION-LIMIT",NULL},
symbols_list2.h:{"ARRAY-DIMENSIONS","ECL_NAME(cl_array_dimensions)"},
symbols_list2.h:{"ARRAY-DISPLACEMENT","cl_array_displacement"},
symbols_list2.h:{"ARRAY-ELEMENT-TYPE","cl_array_element_type"},
symbols_list2.h:{"ARRAY-HAS-FILL-POINTER-P","cl_array_has_fill_pointer_p"},
symbols_list2.h:{"ARRAY-IN-BOUNDS-P","ECL_NAME(cl_array_in_bounds_p)"},
symbols_list2.h:{"ARRAY-RANK","cl_array_rank"},
symbols_list2.h:{"ARRAY-RANK-LIMIT",NULL},
symbols_list2.h:{"ARRAY-ROW-MAJOR-INDEX","ECL_NAME(cl_array_row_major_index)"},
symbols_list2.h:{"ARRAY-TOTAL-SIZE","cl_array_total_size"},
symbols_list2.h:{"ARRAY-TOTAL-SIZE-LIMIT",NULL},
symbols_list2.h:{"ASSOC-IF","ECL_NAME(cl_assoc_if)"},
symbols_list2.h:{"ASSOC-IF-NOT","ECL_NAME(cl_assoc_if_not)"},
symbols_list2.h:{"BASE-CHAR",NULL},
symbols_list2.h:{"BASE-STRING",NULL},
symbols_list2.h:{"BIT-AND","ECL_NAME(cl_bit_and)"},
symbols_list2.h:{"BIT-ANDC1","ECL_NAME(cl_bit_andc1)"},
symbols_list2.h:{"BIT-ANDC2","ECL_NAME(cl_bit_andc2)"},
symbols_list2.h:{"BIT-EQV","ECL_NAME(cl_bit_eqv)"},
symbols_list2.h:{"BIT-IOR","ECL_NAME(cl_bit_ior)"},
symbols_list2.h:{"BIT-NAND","ECL_NAME(cl_bit_nand)"},
symbols_list2.h:{"BIT-NOR","ECL_NAME(cl_bit_nor)"},
symbols_list2.h:{"BIT-NOT","ECL_NAME(cl_bit_not)"},
symbols_list2.h:{"BIT-ORC1","ECL_NAME(cl_bit_orc1)"},
symbols_list2.h:{"BIT-ORC2","ECL_NAME(cl_bit_orc2)"},
symbols_list2.h:{"BIT-VECTOR",NULL},
symbols_list2.h:{"BIT-VECTOR-P","cl_bit_vector_p"},
symbols_list2.h:{"BIT-XOR","ECL_NAME(cl_bit_xor)"},
symbols_list2.h:{"BOOLE-1",NULL},
symbols_list2.h:{"BOOLE-2",NULL},
symbols_list2.h:{"BOOLE-AND",NULL},
symbols_list2.h:{"BOOLE-ANDC1",NULL},
symbols_list2.h:{"BOOLE-ANDC2",NULL},
symbols_list2.h:{"BOOLE-C1",NULL},
symbols_list2.h:{"BOOLE-C2",NULL},
symbols_list2.h:{"BOOLE-CLR",NULL},
symbols_list2.h:{"BOOLE-EQV",NULL},
symbols_list2.h:{"BOOLE-IOR",NULL},
symbols_list2.h:{"BOOLE-NAND",NULL},
symbols_list2.h:{"BOOLE-NOR",NULL},
symbols_list2.h:{"BOOLE-ORC1",NULL},
symbols_list2.h:{"BOOLE-ORC2",NULL},
symbols_list2.h:{"BOOLE-SET",NULL},
symbols_list2.h:{"BOOLE-XOR",NULL},
symbols_list2.h:{"BOTH-CASE-P","cl_both_case_p"},
symbols_list2.h:{"BROADCAST-STREAM",NULL},
symbols_list2.h:{"BROADCAST-STREAM-STREAMS","cl_broadcast_stream_streams"},
symbols_list2.h:{"BYTE-POSITION","ECL_NAME(cl_byte_position)"},
symbols_list2.h:{"BYTE-SIZE","ECL_NAME(cl_byte_size)"},
symbols_list2.h:{"CALL-ARGUMENTS-LIMIT",NULL},
symbols_list2.h:{"CELL-ERROR",NULL},
symbols_list2.h:{"CELL-ERROR-NAME",NULL},
symbols_list2.h:{"CHAR-CODE","cl_char_code"},
symbols_list2.h:{"CHAR-CODE-LIMIT",NULL},
symbols_list2.h:{"CHAR-DOWNCASE","cl_char_downcase"},
symbols_list2.h:{"CHAR-EQUAL","cl_char_equal"},
symbols_list2.h:{"CHAR-GREATERP","cl_char_greaterp"},
symbols_list2.h:{"CHAR-INT","cl_char_int"},
symbols_list2.h:{"CHAR-LESSP","cl_char_lessp"},
symbols_list2.h:{"CHAR-NAME","cl_char_name"},
symbols_list2.h:{"CHAR-NOT-EQUAL","cl_char_not_equal"},
symbols_list2.h:{"CHAR-NOT-GREATERP","cl_char_not_greaterp"},
symbols_list2.h:{"CHAR-NOT-LESSP","cl_char_not_lessp"},
symbols_list2.h:{"CHAR-UPCASE","cl_char_upcase"},
symbols_list2.h:{"CHECK-TYPE",NULL},
symbols_list2.h:{"CLEAR-INPUT","cl_clear_input"},
symbols_list2.h:{"CLEAR-OUTPUT","cl_clear_output"},
symbols_list2.h:{"CODE-CHAR","cl_code_char"},
symbols_list2.h:{"COMPILATION-SPEED",NULL},
symbols_list2.h:{"COMPILE-FILE",NULL},
symbols_list2.h:{"COMPILE-FILE-PATHNAME",NULL},
symbols_list2.h:{"COMPILED-FUNCTION",NULL},
symbols_list2.h:{"COMPILED-FUNCTION-P","cl_compiled_function_p"},
symbols_list2.h:{"COMPILER-MACRO",NULL},
symbols_list2.h:{"COMPILER-MACRO-FUNCTION",NULL},
symbols_list2.h:{"COMPUTE-RESTARTS",NULL},
symbols_list2.h:{"CONCATENATED-STREAM",NULL},
symbols_list2.h:{"CONCATENATED-STREAM-STREAMS","cl_concatenated_stream_streams"},
symbols_list2.h:{"CONTROL-ERROR",NULL},
symbols_list2.h:{"COPY-ALIST","cl_copy_alist"},
symbols_list2.h:{"COPY-LIST","cl_copy_list"},
symbols_list2.h:{"COPY-PPRINT-DISPATCH","ECL_NAME_PPRINT(cl_copy_pprint_dispatch)"},
symbols_list2.h:{"COPY-READTABLE","cl_copy_readtable"},
symbols_list2.h:{"COPY-SEQ","cl_copy_seq"},
symbols_list2.h:{"COPY-STRUCTURE","cl_copy_structure"},
symbols_list2.h:{"COPY-SYMBOL","cl_copy_symbol"},
symbols_list2.h:{"COPY-TREE","cl_copy_tree"},
symbols_list2.h:{"COUNT-IF","ECL_NAME(cl_count_if)"},
symbols_list2.h:{"COUNT-IF-NOT","ECL_NAME(cl_count_if_not)"},
symbols_list2.h:{"DECODE-FLOAT","cl_decode_float"},
symbols_list2.h:{"DECODE-UNIVERSAL-TIME","ECL_NAME(cl_decode_universal_time)"},
symbols_list2.h:{"DEFINE-CONDITION",NULL},
symbols_list2.h:{"DEFINE-COMPILER-MACRO",NULL},
symbols_list2.h:{"DEFINE-MODIFY-MACRO",NULL},
symbols_list2.h:{"DEFINE-SETF-EXPANDER",NULL},
symbols_list2.h:{"DEFINE-SYMBOL-MACRO",NULL},
symbols_list2.h:{"DELETE-DUPLICATES","ECL_NAME(cl_delete_duplicates)"},
symbols_list2.h:{"DELETE-FILE","cl_delete_file"},
symbols_list2.h:{"DELETE-IF","ECL_NAME(cl_delete_if)"},
symbols_list2.h:{"DELETE-IF-NOT","ECL_NAME(cl_delete_if_not)"},
symbols_list2.h:{"DELETE-PACKAGE","cl_delete_package"},
symbols_list2.h:{"DEPOSIT-FIELD","ECL_NAME(cl_deposit_field)"},
symbols_list2.h:{"DESTRUCTURING-BIND",NULL},
symbols_list2.h:{"DIGIT-CHAR","cl_digit_char"},
symbols_list2.h:{"DIGIT-CHAR-P","cl_digit_char_p"},
symbols_list2.h:{"DIRECTORY-NAMESTRING","cl_directory_namestring"},
symbols_list2.h:{"DIVISION-BY-ZERO",NULL},
symbols_list2.h:{"DO-ALL-SYMBOLS",NULL},
symbols_list2.h:{"DO-EXTERNAL-SYMBOLS",NULL},
symbols_list2.h:{"DO-SYMBOLS",NULL},
symbols_list2.h:{"DOUBLE-FLOAT",NULL},
symbols_list2.h:{"DOUBLE-FLOAT-EPSILON",NULL},
symbols_list2.h:{"DOUBLE-FLOAT-NEGATIVE-EPSILON",NULL},
symbols_list2.h:{"DYNAMIC-EXTENT",NULL},
symbols_list2.h:{"ECHO-STREAM",NULL},
symbols_list2.h:{"ECHO-STREAM-INPUT-STREAM","cl_echo_stream_input_stream"},
symbols_list2.h:{"ECHO-STREAM-OUTPUT-STREAM","cl_echo_stream_output_stream"},
symbols_list2.h:{"ENCODE-UNIVERSAL-TIME","ECL_NAME(cl_encode_universal_time)"},
symbols_list2.h:{"END-OF-FILE",NULL},
symbols_list2.h:{"ENOUGH-NAMESTRING","cl_enough_namestring"},
symbols_list2.h:{"ENSURE-DIRECTORIES-EXIST","ECL_NAME(cl_ensure_directories_exist)"},
symbols_list2.h:{"EVAL-WHEN",NULL},
symbols_list2.h:{"EXTENDED-CHAR",NULL},
symbols_list2.h:{"FILE-AUTHOR","cl_file_author"},
symbols_list2.h:{"FILE-ERROR",NULL},
symbols_list2.h:{"FILE-ERROR-PATHNAME",NULL},
symbols_list2.h:{"FILE-LENGTH","cl_file_length"},
symbols_list2.h:{"FILE-NAMESTRING","cl_file_namestring"},
symbols_list2.h:{"FILE-POSITION","cl_file_position"},
symbols_list2.h:{"FILE-STREAM",NULL},
symbols_list2.h:{"FILE-STRING-LENGTH","cl_file_string_length"},
symbols_list2.h:{"FILE-WRITE-DATE","cl_file_write_date"},
symbols_list2.h:{"FILL-POINTER","cl_fill_pointer"},
symbols_list2.h:{"FIND-ALL-SYMBOLS","ECL_NAME(cl_find_all_symbols)"},
symbols_list2.h:{"FIND-IF","ECL_NAME(cl_find_if)"},
symbols_list2.h:{"FIND-IF-NOT","ECL_NAME(cl_find_if_not)"},
symbols_list2.h:{"FIND-PACKAGE","cl_find_package"},
symbols_list2.h:{"FIND-RESTART",NULL},
symbols_list2.h:{"FIND-SYMBOL","cl_find_symbol"},
symbols_list2.h:{"FINISH-OUTPUT","cl_finish_output"},
symbols_list2.h:{"FLOAT-DIGITS","cl_float_digits"},
symbols_list2.h:{"FLOAT-PRECISION","cl_float_precision"},
symbols_list2.h:{"FLOAT-RADIX","cl_float_radix"},
symbols_list2.h:{"FLOAT-SIGN","cl_float_sign"},
symbols_list2.h:{"FLOATING-POINT-INEXACT",NULL},
symbols_list2.h:{"FLOATING-POINT-INVALID-OPERATION",NULL},
symbols_list2.h:{"FLOATING-POINT-OVERFLOW",NULL},
symbols_list2.h:{"FLOATING-POINT-UNDERFLOW",NULL},
symbols_list2.h:{"FORCE-OUTPUT","cl_force_output"},
symbols_list2.h:{"FRESH-LINE","cl_fresh_line"},
symbols_list2.h:{"FUNCTION-LAMBDA-EXPRESSION","cl_function_lambda_expression"},
symbols_list2.h:{"FUNCTION-KEYWORDS",NULL},
symbols_list2.h:{"GET-DECODED-TIME","ECL_NAME(cl_get_decoded_time)"},
symbols_list2.h:{"GET-DISPATCH-MACRO-CHARACTER","cl_get_dispatch_macro_character"},
symbols_list2.h:{"GET-INTERNAL-REAL-TIME","cl_get_internal_real_time"},
symbols_list2.h:{"GET-INTERNAL-RUN-TIME","cl_get_internal_run_time"},
symbols_list2.h:{"GET-MACRO-CHARACTER","cl_get_macro_character"},
symbols_list2.h:{"GET-OUTPUT-STREAM-STRING","cl_get_output_stream_string"},
symbols_list2.h:{"GET-PROPERTIES","cl_get_properties"},
symbols_list2.h:{"GET-SETF-EXPANSION",NULL},
symbols_list2.h:{"GET-UNIVERSAL-TIME","cl_get_universal_time"},
symbols_list2.h:{"GRAPHIC-CHAR-P","cl_graphic_char_p"},
symbols_list2.h:{"HANDLER-CASE",NULL},
symbols_list2.h:{"HANDLER-BIND",NULL},
symbols_list2.h:{"HASH-TABLE",NULL},
symbols_list2.h:{"HASH-TABLE-COUNT","cl_hash_table_count"},
symbols_list2.h:{"HASH-TABLE-P","cl_hash_table_p"},
symbols_list2.h:{"HASH-TABLE-REHASH-SIZE","cl_hash_table_rehash_size"},
symbols_list2.h:{"HASH-TABLE-REHASH-THRESHOLD","cl_hash_table_rehash_threshold"},
symbols_list2.h:{"HASH-TABLE-SIZE","cl_hash_table_size"},
symbols_list2.h:{"HASH-TABLE-TEST","cl_hash_table_test"},
symbols_list2.h:{"HOST-NAMESTRING","cl_host_namestring"},
symbols_list2.h:{"IGNORE-ERRORS",NULL},
symbols_list2.h:{"IN-PACKAGE",NULL},
symbols_list2.h:{"INPUT-STREAM-P","cl_input_stream_p"},
symbols_list2.h:{"INTEGER-DECODE-FLOAT","cl_integer_decode_float"},
symbols_list2.h:{"INTEGER-LENGTH","cl_integer_length"},
symbols_list2.h:{"INTERACTIVE-STREAM-P","cl_interactive_stream_p"},
symbols_list2.h:{"INTERNAL-TIME-UNITS-PER-SECOND",NULL},
symbols_list2.h:{"INVOKE-DEBUGGER",NULL},
symbols_list2.h:{"INVOKE-RESTART",NULL},
symbols_list2.h:{"INVOKE-RESTART-INTERACTIVELY",NULL},
symbols_list2.h:{"LAMBDA-LIST-KEYWORDS",NULL},
symbols_list2.h:{"LAMBDA-PARAMETERS-LIMIT",NULL},
symbols_list2.h:{"LDB-TEST","ECL_NAME(cl_ldb_test)"},
symbols_list2.h:{"LEAST-NEGATIVE-DOUBLE-FLOAT",NULL},
symbols_list2.h:{"LEAST-NEGATIVE-LONG-FLOAT",NULL},
symbols_list2.h:{"LEAST-NEGATIVE-NORMALIZED-DOUBLE-FLOAT",NULL},
symbols_list2.h:{"LEAST-NEGATIVE-NORMALIZED-LONG-FLOAT",NULL},
symbols_list2.h:{"LEAST-NEGATIVE-NORMALIZED-SHORT-FLOAT",NULL},
symbols_list2.h:{"LEAST-NEGATIVE-NORMALIZED-SINGLE-FLOAT",NULL},
symbols_list2.h:{"LEAST-NEGATIVE-SHORT-FLOAT",NULL},
symbols_list2.h:{"LEAST-NEGATIVE-SINGLE-FLOAT",NULL},
symbols_list2.h:{"LEAST-POSITIVE-DOUBLE-FLOAT",NULL},
symbols_list2.h:{"LEAST-POSITIVE-LONG-FLOAT",NULL},
symbols_list2.h:{"LEAST-POSITIVE-NORMALIZED-DOUBLE-FLOAT",NULL},
symbols_list2.h:{"LEAST-POSITIVE-NORMALIZED-LONG-FLOAT",NULL},
symbols_list2.h:{"LEAST-POSITIVE-NORMALIZED-SHORT-FLOAT",NULL},
symbols_list2.h:{"LEAST-POSITIVE-NORMALIZED-SINGLE-FLOAT",NULL},
symbols_list2.h:{"LEAST-POSITIVE-SHORT-FLOAT",NULL},
symbols_list2.h:{"LEAST-POSITIVE-SINGLE-FLOAT",NULL},
symbols_list2.h:{"LISP-IMPLEMENTATION-TYPE",NULL},
symbols_list2.h:{"LISP-IMPLEMENTATION-VERSION",NULL},
symbols_list2.h:{"LIST-ALL-PACKAGES","cl_list_all_packages"},
symbols_list2.h:{"LIST-LENGTH","cl_list_length"},
symbols_list2.h:{"LOAD-LOGICAL-PATHNAME-TRANSLATIONS","ECL_NAME(cl_load_logical_pathname_translations)"},
symbols_list2.h:{"LOAD-TIME-VALUE",NULL},
symbols_list2.h:{"LOGICAL-PATHNAME","cl_logical_pathname"},
symbols_list2.h:{"LOGICAL-PATHNAME-TRANSLATIONS","ECL_NAME(cl_logical_pathname_translations)"},
symbols_list2.h:{"LONG-FLOAT",NULL},
symbols_list2.h:{"LONG-FLOAT-EPSILON",NULL},
symbols_list2.h:{"LONG-FLOAT-NEGATIVE-EPSILON",NULL},
symbols_list2.h:{"LONG-SITE-NAME",NULL},
symbols_list2.h:{"LOOP-FINISH",NULL},
symbols_list2.h:{"LOWER-CASE-P","cl_lower_case_p"},
symbols_list2.h:{"MACHINE-INSTANCE",NULL},
symbols_list2.h:{"MACHINE-TYPE",NULL},
symbols_list2.h:{"MACHINE-VERSION",NULL},
symbols_list2.h:{"MACRO-FUNCTION","cl_macro_function"},
symbols_list2.h:{"MACROEXPAND-1","cl_macroexpand_1"},
symbols_list2.h:{"MAKE-ARRAY","ECL_NAME(cl_make_array)"},
symbols_list2.h:{"MAKE-BROADCAST-STREAM","cl_make_broadcast_stream"},
symbols_list2.h:{"MAKE-CONDITION",NULL},
symbols_list2.h:{"MAKE-CONCATENATED-STREAM","cl_make_concatenated_stream"},
symbols_list2.h:{"MAKE-DISPATCH-MACRO-CHARACTER","cl_make_dispatch_macro_character"},
symbols_list2.h:{"MAKE-ECHO-STREAM","cl_make_echo_stream"},
symbols_list2.h:{"MAKE-HASH-TABLE","cl_make_hash_table"},
symbols_list2.h:{"MAKE-LIST","cl_make_list"},
symbols_list2.h:{"MAKE-PACKAGE","cl_make_package"},
symbols_list2.h:{"MAKE-PATHNAME","cl_make_pathname"},
symbols_list2.h:{"MAKE-RANDOM-STATE","cl_make_random_state"},
symbols_list2.h:{"MAKE-SEQUENCE","ECL_NAME(cl_make_sequence)"},
symbols_list2.h:{"MAKE-STRING","cl_make_string"},
symbols_list2.h:{"MAKE-STRING-INPUT-STREAM","cl_make_string_input_stream"},
symbols_list2.h:{"MAKE-STRING-OUTPUT-STREAM","cl_make_string_output_stream"},
symbols_list2.h:{"MAKE-SYMBOL","cl_make_symbol"},
symbols_list2.h:{"MAKE-SYNONYM-STREAM","cl_make_synonym_stream"},
symbols_list2.h:{"MAKE-TWO-WAY-STREAM","cl_make_two_way_stream"},
symbols_list2.h:{"MAP-INTO","ECL_NAME(cl_map_into)"},
symbols_list2.h:{"MASK-FIELD","ECL_NAME(cl_mask_field)"},
symbols_list2.h:{"MEMBER-IF","ECL_NAME(cl_member_if)"},
symbols_list2.h:{"MEMBER-IF-NOT","ECL_NAME(cl_member_if_not)"},
symbols_list2.h:{"MERGE-PATHNAMES","cl_merge_pathnames"},
symbols_list2.h:{"MOST-NEGATIVE-DOUBLE-FLOAT",NULL},
symbols_list2.h:{"MOST-NEGATIVE-FIXNUM",NULL},
symbols_list2.h:{"MOST-NEGATIVE-LONG-FLOAT",NULL},
symbols_list2.h:{"MOST-NEGATIVE-SHORT-FLOAT",NULL},
symbols_list2.h:{"MOST-NEGATIVE-SINGLE-FLOAT",NULL},
symbols_list2.h:{"MOST-POSITIVE-DOUBLE-FLOAT",NULL},
symbols_list2.h:{"MOST-POSITIVE-FIXNUM",NULL},
symbols_list2.h:{"MOST-POSITIVE-LONG-FLOAT",NULL},
symbols_list2.h:{"MOST-POSITIVE-SHORT-FLOAT",NULL},
symbols_list2.h:{"MOST-POSITIVE-SINGLE-FLOAT",NULL},
symbols_list2.h:{"MUFFLE-WARNING","ECL_NAME(cl_muffle_warning)"},
symbols_list2.h:{"MULTIPLE-VALUE-BIND",NULL},
symbols_list2.h:{"MULTIPLE-VALUE-CALL",NULL},
symbols_list2.h:{"MULTIPLE-VALUE-LIST",NULL},
symbols_list2.h:{"MULTIPLE-VALUE-PROG1",NULL},
symbols_list2.h:{"MULTIPLE-VALUE-SETQ",NULL},
symbols_list2.h:{"MULTIPLE-VALUES-LIMIT",NULL},
symbols_list2.h:{"NAME-CHAR","cl_name_char"},
symbols_list2.h:{"NSET-DIFFERENCE","ECL_NAME(cl_nset_difference)"},
symbols_list2.h:{"NSET-EXCLUSIVE-OR","ECL_NAME(cl_nset_exclusive_or)"},
symbols_list2.h:{"NSTRING-CAPITALIZE","cl_nstring_capitalize"},
symbols_list2.h:{"NSTRING-DOWNCASE","cl_nstring_downcase"},
symbols_list2.h:{"NSTRING-UPCASE","cl_nstring_upcase"},
symbols_list2.h:{"NSUBST-IF","ECL_NAME(cl_nsubst_if)"},
symbols_list2.h:{"NSUBST-IF-NOT","ECL_NAME(cl_nsubst_if_not)"},
symbols_list2.h:{"NSUBSTITUTE-IF","ECL_NAME(cl_nsubstitute_if)"},
symbols_list2.h:{"NSUBSTITUTE-IF-NOT","ECL_NAME(cl_nsubstitute_if_not)"},
symbols_list2.h:{"NTH-VALUE",NULL},
symbols_list2.h:{"OPEN-STREAM-P","cl_open_stream_p"},
symbols_list2.h:{"OUTPUT-STREAM-P","cl_output_stream_p"},
symbols_list2.h:{"PACKAGE-ERROR",NULL},
symbols_list2.h:{"PACKAGE-ERROR-PACKAGE",NULL},
symbols_list2.h:{"PACKAGE-NAME","cl_package_name"},
symbols_list2.h:{"PACKAGE-NICKNAMES","cl_package_nicknames"},
symbols_list2.h:{"PACKAGE-SHADOWING-SYMBOLS","cl_package_shadowing_symbols"},
symbols_list2.h:{"PACKAGE-USE-LIST","cl_package_use_list"},
symbols_list2.h:{"PACKAGE-USED-BY-LIST","cl_package_used_by_list"},
symbols_list2.h:{"PARSE-ERROR",NULL},
symbols_list2.h:{"PARSE-INTEGER","cl_parse_integer"},
symbols_list2.h:{"PARSE-NAMESTRING","cl_parse_namestring"},
symbols_list2.h:{"PATHNAME-DEVICE","cl_pathname_device"},
symbols_list2.h:{"PATHNAME-DIRECTORY","cl_pathname_directory"},
symbols_list2.h:{"PATHNAME-HOST","cl_pathname_host"},
symbols_list2.h:{"PATHNAME-MATCH-P","cl_pathname_match_p"},
symbols_list2.h:{"PATHNAME-NAME","cl_pathname_name"},
symbols_list2.h:{"PATHNAME-TYPE","cl_pathname_type"},
symbols_list2.h:{"PATHNAME-VERSION","cl_pathname_version"},
symbols_list2.h:{"PEEK-CHAR","cl_peek_char"},
symbols_list2.h:{"POSITION-IF","ECL_NAME(cl_position_if)"},
symbols_list2.h:{"POSITION-IF-NOT","ECL_NAME(cl_position_if_not)"},
symbols_list2.h:{"PPRINT-DISPATCH","ECL_NAME_PPRINT(cl_pprint_dispatch)"},
symbols_list2.h:{"PPRINT-EXIT-IF-LIST-EXHAUSTED",NULL},
symbols_list2.h:{"PPRINT-FILL","ECL_NAME_PPRINT(cl_pprint_fill)"},
symbols_list2.h:{"PPRINT-INDENT","ECL_NAME_PPRINT(cl_pprint_indent)"},
symbols_list2.h:{"PPRINT-LINEAR","ECL_NAME_PPRINT(cl_pprint_linear)"},
symbols_list2.h:{"PPRINT-LOGICAL-BLOCK",NULL},
symbols_list2.h:{"PPRINT-NEWLINE","ECL_NAME_PPRINT(cl_pprint_newline)"},
symbols_list2.h:{"PPRINT-POP",NULL},
symbols_list2.h:{"PPRINT-TAB","ECL_NAME_PPRINT(cl_pprint_tab)"},
symbols_list2.h:{"PPRINT-TABULAR","ECL_NAME_PPRINT(cl_pprint_tabular)"},
symbols_list2.h:{"PRIN1-TO-STRING","ECL_NAME(cl_prin1_to_string)"},
symbols_list2.h:{"PRINC-TO-STRING","ECL_NAME(cl_princ_to_string)"},
symbols_list2.h:{"PRINT-NOT-READABLE",NULL},
symbols_list2.h:{"PRINT-NOT-READABLE-OBJECT",NULL},
symbols_list2.h:{"PROBE-FILE","cl_probe_file"},
symbols_list2.h:{"PROGRAM-ERROR",NULL},
symbols_list2.h:{"RANDOM-STATE",NULL},
symbols_list2.h:{"RANDOM-STATE-P","cl_random_state_p"},
symbols_list2.h:{"RASSOC-IF","ECL_NAME(cl_rassoc_if)"},
symbols_list2.h:{"RASSOC-IF-NOT","ECL_NAME(cl_rassoc_if_not)"},
symbols_list2.h:{"READ-BYTE","cl_read_byte"},
symbols_list2.h:{"READ-CHAR","cl_read_char"},
symbols_list2.h:{"READ-CHAR-NO-HANG","cl_read_char_no_hang"},
symbols_list2.h:{"READ-DELIMITED-LIST","cl_read_delimited_list"},
symbols_list2.h:{"READ-FROM-STRING","ECL_NAME(cl_read_from_string)"},
symbols_list2.h:{"READ-LINE","cl_read_line"},
symbols_list2.h:{"READ-PRESERVING-WHITESPACE","cl_read_preserving_whitespace"},
symbols_list2.h:{"READ-SEQUENCE","cl_read_sequence"},
symbols_list2.h:{"READER-ERROR",NULL},
symbols_list2.h:{"READTABLE-CASE","cl_readtable_case"},
symbols_list2.h:{"REMOVE-DUPLICATES","ECL_NAME(cl_remove_duplicates)"},
symbols_list2.h:{"REMOVE-IF","ECL_NAME(cl_remove_if)"},
symbols_list2.h:{"REMOVE-IF-NOT","ECL_NAME(cl_remove_if_not)"},
symbols_list2.h:{"RENAME-FILE","cl_rename_file"},
symbols_list2.h:{"RENAME-PACKAGE","cl_rename_package"},
symbols_list2.h:{"RESTART-BIND",NULL},
symbols_list2.h:{"RESTART-CASE",NULL},
symbols_list2.h:{"RESTART-NAME",NULL},
symbols_list2.h:{"RETURN-FROM",NULL},
symbols_list2.h:{"ROW-MAJOR-AREF","cl_row_major_aref"},
symbols_list2.h:{"SCALE-FLOAT","cl_scale_float"},
symbols_list2.h:{"SERIOUS-CONDITION",NULL},
symbols_list2.h:{"SET-DIFFERENCE","ECL_NAME(cl_set_difference)"},
symbols_list2.h:{"SET-DISPATCH-MACRO-CHARACTER","cl_set_dispatch_macro_character"},
symbols_list2.h:{"SET-EXCLUSIVE-OR","ECL_NAME(cl_set_exclusive_or)"},
symbols_list2.h:{"SET-MACRO-CHARACTER","cl_set_macro_character"},
symbols_list2.h:{"SET-PPRINT-DISPATCH","ECL_NAME_PPRINT(cl_set_pprint_dispatch)"},
symbols_list2.h:{"SET-SYNTAX-FROM-CHAR","cl_set_syntax_from_char"},
symbols_list2.h:{"SHADOWING-IMPORT","cl_shadowing_import"},
symbols_list2.h:{"SHORT-FLOAT",NULL},
symbols_list2.h:{"SHORT-FLOAT-EPSILON",NULL},
symbols_list2.h:{"SHORT-FLOAT-NEGATIVE-EPSILON",NULL},
symbols_list2.h:{"SHORT-SITE-NAME",NULL},
symbols_list2.h:{"SIGNED-BYTE",NULL},
symbols_list2.h:{"SIMPLE-ARRAY",NULL},
symbols_list2.h:{"SIMPLE-BASE-STRING",NULL},
symbols_list2.h:{"SIMPLE-BIT-VECTOR",NULL},
symbols_list2.h:{"SIMPLE-BIT-VECTOR-P","cl_simple_bit_vector_p"},
symbols_list2.h:{"SIMPLE-CONDITION",NULL},
symbols_list2.h:{"SIMPLE-CONDITION-FORMAT-CONTROL",NULL},
symbols_list2.h:{"SIMPLE-CONDITION-FORMAT-ARGUMENTS",NULL},
symbols_list2.h:{"SIMPLE-ERROR",NULL},
symbols_list2.h:{"SIMPLE-STRING",NULL},
symbols_list2.h:{"SIMPLE-STRING-P","cl_simple_string_p"},
symbols_list2.h:{"SIMPLE-TYPE-ERROR",NULL},
symbols_list2.h:{"SIMPLE-VECTOR",NULL},
symbols_list2.h:{"SIMPLE-VECTOR-P","cl_simple_vector_p"},
symbols_list2.h:{"SIMPLE-WARNING",NULL},
symbols_list2.h:{"SINGLE-FLOAT",NULL},
symbols_list2.h:{"SINGLE-FLOAT-EPSILON",NULL},
symbols_list2.h:{"SINGLE-FLOAT-NEGATIVE-EPSILON",NULL},
symbols_list2.h:{"SOFTWARE-TYPE",NULL},
symbols_list2.h:{"SOFTWARE-VERSION",NULL},
symbols_list2.h:{"SPECIAL-OPERATOR-P","cl_special_operator_p"},
symbols_list2.h:{"STABLE-SORT","ECL_NAME(cl_stable_sort)"},
symbols_list2.h:{"STANDARD-CHAR",NULL},
symbols_list2.h:{"STANDARD-CHAR-P","cl_standard_char_p"},
symbols_list2.h:{"STORAGE-CONDITION",NULL},
symbols_list2.h:{"STORE-VALUE","ECL_NAME(cl_store_value)"},
symbols_list2.h:{"STREAM-ELEMENT-TYPE","cl_stream_element_type"},
symbols_list2.h:{"STREAM-ERROR",NULL},
symbols_list2.h:{"STREAM-ERROR-STREAM",NULL},
symbols_list2.h:{"STREAM-EXTERNAL-FORMAT","cl_stream_external_format"},
symbols_list2.h:{"STRING-DOWNCASE","cl_string_downcase"},
symbols_list2.h:{"STRING-CAPITALIZE","cl_string_capitalize"},
symbols_list2.h:{"STRING-EQUAL","cl_string_equal"},
symbols_list2.h:{"STRING-GREATERP","cl_string_greaterp"},
symbols_list2.h:{"STRING-LEFT-TRIM","cl_string_left_trim"},
symbols_list2.h:{"STRING-LESSP","cl_string_lessp"},
symbols_list2.h:{"STRING-NOT-EQUAL","cl_string_not_equal"},
symbols_list2.h:{"STRING-NOT-GREATERP","cl_string_not_greaterp"},
symbols_list2.h:{"STRING-NOT-LESSP","cl_string_not_lessp"},
symbols_list2.h:{"STRING-RIGHT-TRIM","cl_string_right_trim"},
symbols_list2.h:{"STRING-STREAM",NULL},
symbols_list2.h:{"STRING-TRIM","cl_string_trim"},
symbols_list2.h:{"STRING-UPCASE","cl_string_upcase"},
symbols_list2.h:{"STYLE-WARNING",NULL},
symbols_list2.h:{"SUBST-IF","ECL_NAME(cl_subst_if)"},
symbols_list2.h:{"SUBST-IF-NOT","ECL_NAME(cl_subst_if_not)"},
symbols_list2.h:{"SUBSTITUTE-IF","ECL_NAME(cl_substitute_if)"},
symbols_list2.h:{"SUBSTITUTE-IF-NOT","ECL_NAME(cl_substitute_if_not)"},
symbols_list2.h:{"SYMBOL-FUNCTION","cl_symbol_function"},
symbols_list2.h:{"SYMBOL-MACROLET",NULL},
symbols_list2.h:{"SYMBOL-NAME","cl_symbol_name"},
symbols_list2.h:{"SYMBOL-PACKAGE","cl_symbol_package"},
symbols_list2.h:{"SYMBOL-PLIST","cl_symbol_plist"},
symbols_list2.h:{"SYMBOL-VALUE","cl_symbol_value"},
symbols_list2.h:{"SYNONYM-STREAM",NULL},
symbols_list2.h:{"SYNONYM-STREAM-SYMBOL","cl_synonym_stream_symbol"},
symbols_list2.h:{"TRANSLATE-LOGICAL-PATHNAME","cl_translate_logical_pathname"},
symbols_list2.h:{"TRANSLATE-PATHNAME","cl_translate_pathname"},
symbols_list2.h:{"TREE-EQUAL","cl_tree_equal"},
symbols_list2.h:{"TWO-WAY-STREAM",NULL},
symbols_list2.h:{"TWO-WAY-STREAM-INPUT-STREAM","cl_two_way_stream_input_stream"},
symbols_list2.h:{"TWO-WAY-STREAM-OUTPUT-STREAM","cl_two_way_stream_output_stream"},
symbols_list2.h:{"TYPE-ERROR",NULL},
symbols_list2.h:{"TYPE-ERROR-DATUM",NULL},
symbols_list2.h:{"TYPE-ERROR-EXPECTED-TYPE",NULL},
symbols_list2.h:{"TYPE-OF","cl_type_of"},
symbols_list2.h:{"UNBOUND-SLOT",NULL},
symbols_list2.h:{"UNBOUND-SLOT-INSTANCE",NULL},
symbols_list2.h:{"UNBOUND-VARIABLE",NULL},
symbols_list2.h:{"UNDEFINED-FUNCTION",NULL},
symbols_list2.h:{"UNREAD-CHAR","cl_unread_char"},
symbols_list2.h:{"UNSIGNED-BYTE",NULL},
symbols_list2.h:{"UNUSE-PACKAGE","cl_unuse_package"},
symbols_list2.h:{"UNWIND-PROTECT",NULL},
symbols_list2.h:{"UPGRADED-ARRAY-ELEMENT-TYPE","ECL_NAME(cl_upgraded_array_element_type)"},
symbols_list2.h:{"UPGRADED-COMPLEX-PART-TYPE","ECL_NAME(cl_upgraded_complex_part_type)"},
symbols_list2.h:{"UPPER-CASE-P","cl_upper_case_p"},
symbols_list2.h:{"USE-PACKAGE","cl_use_package"},
symbols_list2.h:{"USE-VALUE","ECL_NAME(cl_use_value)"},
symbols_list2.h:{"USER-HOMEDIR-PATHNAME","cl_user_homedir_pathname"},
symbols_list2.h:{"VALUES-LIST","cl_values_list"},
symbols_list2.h:{"VECTOR-POP","ECL_NAME(cl_vector_pop)"},
symbols_list2.h:{"VECTOR-PUSH","cl_vector_push"},
symbols_list2.h:{"VECTOR-PUSH-EXTEND","cl_vector_push_extend"},
symbols_list2.h:{"WILD-PATHNAME-P","cl_wild_pathname_p"},
symbols_list2.h:{"WITH-COMPILATION-UNIT",NULL},
symbols_list2.h:{"WITH-CONDITION-RESTARTS",NULL},
symbols_list2.h:{"WITH-HASH-TABLE-ITERATOR",NULL},
symbols_list2.h:{"WITH-INPUT-FROM-STRING",NULL},
symbols_list2.h:{"WITH-OPEN-FILE",NULL},
symbols_list2.h:{"WITH-OPEN-STREAM",NULL},
symbols_list2.h:{"WITH-OUTPUT-TO-STRING",NULL},
symbols_list2.h:{"WITH-PACKAGE-ITERATOR",NULL},
symbols_list2.h:{"WITH-SIMPLE-RESTART",NULL},
symbols_list2.h:{"WITH-STANDARD-IO-SYNTAX",NULL},
symbols_list2.h:{"WRITE-BYTE","cl_write_byte"},
symbols_list2.h:{"WRITE-CHAR","cl_write_char"},
symbols_list2.h:{"WRITE-LINE","cl_write_line"},
symbols_list2.h:{"WRITE-SEQUENCE","cl_write_sequence"},
symbols_list2.h:{"WRITE-STRING","cl_write_string"},
symbols_list2.h:{"WRITE-TO-STRING","ECL_NAME(cl_write_to_string)"},
symbols_list2.h:{"Y-OR-N-P","ECL_NAME(cl_y_or_n_p)"},
symbols_list2.h:{"YES-OR-NO-P","ECL_NAME(cl_yes_or_no_p)"},
symbols_list2.h:{"ALLOCATE-INSTANCE",NULL},
symbols_list2.h:{"ADD-METHOD",NULL},
symbols_list2.h:{"BUILT-IN-CLASS",NULL},
symbols_list2.h:{"CALL-METHOD",NULL},
symbols_list2.h:{"CALL-NEXT-METHOD",NULL},
symbols_list2.h:{"CHANGE-CLASS",NULL},
symbols_list2.h:{"CLASS-NAME",NULL},
symbols_list2.h:{"CLASS-OF","cl_class_of"},
symbols_list2.h:{"COMPUTE-APPLICABLE-METHODS",NULL},
symbols_list2.h:{"DEFINE-METHOD-COMBINATION",NULL},
symbols_list2.h:{"DESCRIBE-OBJECT",NULL},
symbols_list2.h:{"ENSURE-GENERIC-FUNCTION",NULL},
symbols_list2.h:{"FIND-CLASS","cl_find_class"},
symbols_list2.h:{"FIND-METHOD",NULL},
symbols_list2.h:{"GENERIC-FUNCTION",NULL},
symbols_list2.h:{"INITIALIZE-INSTANCE",NULL},
symbols_list2.h:{"INVALID-METHOD-ERROR","ECL_NAME(cl_invalid_method_error)"},
symbols_list2.h:{"MAKE-INSTANCE",NULL},
symbols_list2.h:{"MAKE-INSTANCES-OBSOLETE",NULL},
symbols_list2.h:{"MAKE-LOAD-FORM",NULL},
symbols_list2.h:{"MAKE-LOAD-FORM-SAVING-SLOTS",NULL},
symbols_list2.h:{"MAKE-METHOD",NULL},
symbols_list2.h:{"METHOD-COMBINATION-ERROR","ECL_NAME(cl_method_combination_error)"},
symbols_list2.h:{"METHOD-COMBINATION",NULL},
symbols_list2.h:{"METHOD-QUALIFIERS",NULL},
symbols_list2.h:{"NEXT-METHOD-P",NULL},
symbols_list2.h:{"NO-APPLICABLE-METHOD",NULL},
symbols_list2.h:{"NO-NEXT-METHOD",NULL},
symbols_list2.h:{"PRINT-OBJECT",NULL},
symbols_list2.h:{"PRINT-UNREADABLE-OBJECT",NULL},
symbols_list2.h:{"REINITIALIZE-INSTANCE",NULL},
symbols_list2.h:{"REMOVE-METHOD",NULL},
symbols_list2.h:{"SHARED-INITIALIZE",NULL},
symbols_list2.h:{"SLOT-BOUNDP","ECL_NAME(cl_slot_boundp)"},
symbols_list2.h:{"SLOT-EXISTS-P","ECL_NAME(cl_slot_exists_p)"},
symbols_list2.h:{"SLOT-MAKUNBOUND","ECL_NAME(cl_slot_makunbound)"},
symbols_list2.h:{"SLOT-MISSING",NULL},
symbols_list2.h:{"SLOT-UNBOUND",NULL},
symbols_list2.h:{"SLOT-VALUE","cl_slot_value"},
symbols_list2.h:{"STANDARD-CLASS",NULL},
symbols_list2.h:{"STANDARD-GENERIC-FUNCTION",NULL},
symbols_list2.h:{"STANDARD-METHOD",NULL},
symbols_list2.h:{"STANDARD-OBJECT",NULL},
symbols_list2.h:{"STRUCTURE-CLASS",NULL},
symbols_list2.h:{"STRUCTURE-OBJECT",NULL},
symbols_list2.h:{"UPDATE-INSTANCE-FOR-DIFFERENT-CLASS",NULL},
symbols_list2.h:{"UPDATE-INSTANCE-FOR-REDEFINED-CLASS",NULL},
symbols_list2.h:{"WITH-ACCESSORS",NULL},
symbols_list2.h:{"WITH-SLOTS",NULL},
symbols_list2.h:{KEY_ "ARGUMENT-PRECEDENCE-ORDER",NULL},
symbols_list2.h:{KEY_ "DEFAULT-INITARGS",NULL},
symbols_list2.h:{KEY_ "DIRECT-DEFAULT-INITARGS",NULL},
symbols_list2.h:{KEY_ "DIRECT-SLOTS",NULL},
symbols_list2.h:{KEY_ "DIRECT-SUPERCLASSES",NULL},
symbols_list2.h:{KEY_ "GENERIC-FUNCTION-CLASS",NULL},
symbols_list2.h:{KEY_ "IDENTITY-WITH-ONE-ARGUMENT",NULL},
symbols_list2.h:{KEY_ "LAMBDA-LIST",NULL},
symbols_list2.h:{KEY_ "METHOD-CLASS",NULL},
symbols_list2.h:{KEY_ "METHOD-COMBINATION",NULL},
symbols_list2.h:{SYS_ "*BACKQ-LEVEL*",NULL},
symbols_list2.h:{SYS_ "*CIRCLE-COUNTER*",NULL},
symbols_list2.h:{SYS_ "*CIRCLE-STACK*",NULL},
symbols_list2.h:{SYS_ "*CLASS-NAME-HASH-TABLE*",NULL},
symbols_list2.h:{SYS_ "*COMPILER-CONSTANTS*",NULL},
symbols_list2.h:{SYS_ "*GC-MESSAGE*",NULL},
symbols_list2.h:{SYS_ "*GC-VERBOSE*",NULL},
symbols_list2.h:{SYS_ "*IGNORE-EOF-ON-TERMINAL-IO*",NULL},
symbols_list2.h:{SYS_ "*INDENT-FORMATTED-OUTPUT*",NULL},
symbols_list2.h:{SYS_ "*INIT-FUNCTION-PREFIX*",NULL},
symbols_list2.h:{EXT_ "*INTERRUPTS-ENABLED*",NULL},
symbols_list2.h:{SYS_ "*KEEP-DEFINITIONS*",NULL},
symbols_list2.h:{EXT_ "*LOAD-HOOKS*",NULL},
symbols_list2.h:{SYS_ "*LOAD-SEARCH-LIST*",NULL},
symbols_list2.h:{SYS_ "*MAKE-CONSTANT","si_Xmake_constant"},
symbols_list2.h:{SYS_ "*MAKE-SPECIAL","si_Xmake_special"},
symbols_list2.h:{SYS_ "*PRINT-PACKAGE*",NULL},
symbols_list2.h:{SYS_ "*PRINT-STRUCTURE*",NULL},
symbols_list2.h:{SYS_ "*SHARP-EQ-CONTEXT*",NULL},
symbols_list2.h:{SYS_ "*STEP-LEVEL*","OBJNULL"},
symbols_list2.h:{SYS_ "*STEP-ACTION*","OBJNULL"},
symbols_list2.h:{SYS_ "UNQUOTE-NSPLICE",NULL},
symbols_list2.h:{SYS_ "UNQUOTE-SPLICE",NULL},
symbols_list2.h:{SYS_ "ALLOCATE-RAW-INSTANCE","si_allocate_raw_instance"},
symbols_list2.h:{SYS_ "BASE-CHAR-P","si_base_char_p"},
symbols_list2.h:{SYS_ "BASE-STRING-P","si_base_string_p"},
symbols_list2.h:{SYS_ "BC-DISASSEMBLE","si_bc_disassemble"},
symbols_list2.h:{SYS_ "BC-SPLIT","si_bc_split"},
symbols_list2.h:{SYS_ "BC-JOIN","si_bc_join"},
symbols_list2.h:{SYS_ "BDS-TOP","si_bds_top"},
symbols_list2.h:{SYS_ "BDS-VAL","si_bds_val"},
symbols_list2.h:{SYS_ "BDS-VAR","si_bds_var"},
symbols_list2.h:{SYS_ "BIT-ARRAY-OP","si_bit_array_op"},
symbols_list2.h:{SYS_ "C-ARGUMENTS-LIMIT",NULL},
symbols_list2.h:{SYS_ "CHAR-SET","si_char_set"},
symbols_list2.h:{SYS_ "CLEAR-COMPILER-PROPERTIES","cl_identity"},
symbols_list2.h:{SYS_ "COERCE-TO-BASE-STRING","si_coerce_to_base_string"},
symbols_list2.h:{SYS_ "COERCE-TO-EXTENDED-STRING","si_coerce_to_extended_string"},
symbols_list2.h:{SYS_ "COERCE-TO-FILENAME","si_coerce_to_filename"},
symbols_list2.h:{SYS_ "COERCE-TO-FUNCTION","si_coerce_to_function"},
symbols_list2.h:{SYS_ "COERCE-TO-PACKAGE","si_coerce_to_package"},
symbols_list2.h:{SYS_ "COPY-TO-SIMPLE-BASE-STRING","si_copy_to_simple_base_string"},
symbols_list2.h:{SYS_ "COMPILED-FUNCTION-BLOCK","si_compiled_function_block"},
symbols_list2.h:{EXT_ "COMPILED-FUNCTION-NAME","si_compiled_function_name"},
symbols_list2.h:{SYS_ "COPY-STREAM","si_copy_stream"},
symbols_list2.h:{SYS_ "DO-READ-SEQUENCE","si_do_read_sequence"},
symbols_list2.h:{SYS_ "DO-WRITE-SEQUENCE","si_do_write_sequence"},
symbols_list2.h:{SYS_ "ELT-SET","si_elt_set"},
symbols_list2.h:{SYS_ "EVAL-WITH-ENV","si_eval_with_env"},
symbols_list2.h:{SYS_ "EXPAND-DEFMACRO",NULL},
symbols_list2.h:{SYS_ "FILE-COLUMN","si_file_column"},
symbols_list2.h:{EXT_ "FILE-KIND","si_file_kind"},
symbols_list2.h:{SYS_ "FILL-POINTER-SET","si_fill_pointer_set"},
symbols_list2.h:{EXT_ "FILE-STREAM-FD","si_file_stream_fd"},
symbols_list2.h:{SYS_ "FORMAT-ERROR",NULL},
symbols_list2.h:{SYS_ "FORMATTER-AUX",NULL},
symbols_list2.h:{SYS_ "FORMATTER-AUX","si_formatter_aux"},
symbols_list2.h:{SYS_ "FRS-BDS","si_frs_bds"},
symbols_list2.h:{SYS_ "FRS-IHS","si_frs_ihs"},
symbols_list2.h:{SYS_ "FRS-TAG","si_frs_tag"},
symbols_list2.h:{SYS_ "FRS-TOP","si_frs_top"},
symbols_list2.h:{SYS_ "FUNCTION-BLOCK-NAME","si_function_block_name"},
symbols_list2.h:{SYS_ "GET-LIBRARY-PATHNAME","si_get_library_pathname"},
symbols_list2.h:{SYS_ "GET-SYSPROP","si_get_sysprop"},
symbols_list2.h:{SYS_ "HASH-SET","si_hash_set"},
symbols_list2.h:{SYS_ "HASH-TABLE-ITERATOR","si_hash_table_iterator"},
symbols_list2.h:{SYS_ "IHS-BDS","si_ihs_bds"},
symbols_list2.h:{SYS_ "IHS-ENV","si_ihs_env"},
symbols_list2.h:{SYS_ "IHS-FUN","si_ihs_fun"},
symbols_list2.h:{SYS_ "IHS-NEXT","si_ihs_next"},
symbols_list2.h:{SYS_ "IHS-PREV","si_ihs_prev"},
symbols_list2.h:{SYS_ "IHS-TOP","si_ihs_top"},
symbols_list2.h:{SYS_ "INTERPRETER-STACK","si_interpreter_stack"},
symbols_list2.h:{SYS_ "LINK-FROM",NULL},
symbols_list2.h:{SYS_ "LINK-TO",NULL},
symbols_list2.h:{SYS_ "LOAD-SOURCE","si_load_source"},
symbols_list2.h:{SYS_ "LOGICAL-PATHNAME-P","si_logical_pathname_p"},
symbols_list2.h:{SYS_ "MAKE-LAMBDA","si_make_lambda"},
symbols_list2.h:{SYS_ "MAKE-PURE-ARRAY","si_make_pure_array"},
symbols_list2.h:{SYS_ "MAKE-STRING-OUTPUT-STREAM-FROM-STRING","si_make_string_output_stream_from_string"},
symbols_list2.h:{SYS_ "MAKE-STRUCTURE","si_make_structure"},
symbols_list2.h:{SYS_ "MAKE-VECTOR","si_make_vector"},
symbols_list2.h:{SYS_ "MANGLE-NAME","si_mangle_name"},
symbols_list2.h:{EXT_ "MAKE-PIPE","si_make_pipe"},
symbols_list2.h:{EXT_ "PACKAGE-LOCK","si_package_lock"},
symbols_list2.h:{SYS_ "PACKAGE-HASH-TABLES","si_package_hash_tables"},
symbols_list2.h:{SYS_ "PATHNAME-TRANSLATIONS","si_pathname_translations"},
symbols_list2.h:{SYS_ "PRETTY-PRINT-FORMAT",NULL},
symbols_list2.h:{SYS_ "PROCESS-DECLARATIONS","si_process_declarations"},
symbols_list2.h:{SYS_ "PROCESS-LAMBDA","si_process_lambda"},
symbols_list2.h:{SYS_ "PROCESS-LAMBDA-LIST","si_process_lambda_list"},
symbols_list2.h:{SYS_ "PUT-F","si_put_f"},
symbols_list2.h:{SYS_ "PUT-PROPERTIES","si_put_properties"},
symbols_list2.h:{SYS_ "PUT-SYSPROP","si_put_sysprop"},
symbols_list2.h:{SYS_ "READTABLE-CASE-SET","si_readtable_case_set"},
symbols_list2.h:{SYS_ "REM-F","si_rem_f"},
symbols_list2.h:{SYS_ "REM-SYSPROP","si_rem_sysprop"},
symbols_list2.h:{SYS_ "REPLACE-ARRAY","si_replace_array"},
symbols_list2.h:{SYS_ "ROW-MAJOR-ASET","si_row_major_aset"},
symbols_list2.h:{EXT_ "RUN-PROGRAM","si_run_program"},
symbols_list2.h:{SYS_ "WAIT-FOR-ALL-PROCESSES","si_wait_for_all_processes"},
symbols_list2.h:{EXT_ "SAFE-EVAL","ECL_NAME(si_safe_eval)"},
symbols_list2.h:{SYS_ "SCH-FRS-BASE","si_sch_frs_base"},
symbols_list2.h:{SYS_ "SCHAR-SET","si_char_set"},
symbols_list2.h:{SYS_ "SHARP-A-READER",NULL},
symbols_list2.h:{SYS_ "SHARP-S-READER",NULL},
symbols_list2.h:{SYS_ "SELECT-PACKAGE","si_select_package"},
symbols_list2.h:{SYS_ "SET-SYMBOL-PLIST","si_set_symbol_plist"},
symbols_list2.h:{SYS_ "SETF-METHOD",NULL},
symbols_list2.h:{SYS_ "SETF-NAMEP",NULL},
symbols_list2.h:{SYS_ "SIMPLE-PROGRAM-ERROR","ECL_NAME(si_simple_program_error)"},
symbols_list2.h:{SYS_ "SIGNAL-SIMPLE-ERROR","si_signal_simple_error"},
symbols_list2.h:{SYS_ "SIGNAL-TYPE-ERROR","si_signal_type_error"},
symbols_list2.h:{SYS_ "STANDARD-READTABLE","si_standard_readtable"},
symbols_list2.h:{SYS_ "BASE-STRING-CONCATENATE","si_base_string_concatenate"},
symbols_list2.h:{SYS_ "STRING-TO-OBJECT","ECL_NAME(si_string_to_object)"},
symbols_list2.h:{SYS_ "STRUCTURE-NAME","si_structure_name"},
symbols_list2.h:{SYS_ "STRUCTURE-PRINT-FUNCTION",NULL},
symbols_list2.h:{SYS_ "STRUCTURE-REF","si_structure_ref"},
symbols_list2.h:{SYS_ "STRUCTURE-SET","si_structure_set"},
symbols_list2.h:{SYS_ "STRUCTURE-SLOT-DESCRIPTIONS",NULL},
symbols_list2.h:{SYS_ "STRUCTURE-SUBTYPE-P","si_structure_subtype_p"},
symbols_list2.h:{SYS_ "SYMBOL-MACRO",NULL},
symbols_list2.h:{SYS_ "TERMINAL-INTERRUPT",NULL},
symbols_list2.h:{SYS_ "TOP-LEVEL",NULL},
symbols_list2.h:{SYS_ "UNIVERSAL-ERROR-HANDLER",NULL},
symbols_list2.h:{SYS_ "VALID-FUNCTION-NAME-P","si_valid_function_name_p"},
symbols_list2.h:{SYS_ "WRITE-OBJECT","si_write_object"},
symbols_list2.h:{SYS_ "WRITE-UGLY-OBJECT","si_write_ugly_object"},
symbols_list2.h:{SYS_ "STRUCTURE-INCLUDE",NULL},
symbols_list2.h:{SYS_ "COPY-INSTANCE","si_copy_instance"},
symbols_list2.h:{SYS_ "GENERIC-FUNCTION-P","si_generic_function_p"},
symbols_list2.h:{SYS_ "INSTANCE-REF","si_instance_ref"},
symbols_list2.h:{SYS_ "INSTANCE-SET","si_instance_set"},
symbols_list2.h:{SYS_ "INSTANCE-SIG","si_instance_sig"},
symbols_list2.h:{SYS_ "INSTANCE-SIG-SET","si_instance_sig_set"},
symbols_list2.h:{SYS_ "INSTANCE-CLASS","si_instance_class"},
symbols_list2.h:{SYS_ "INSTANCE-CLASS-SET","si_instance_class_set"},
symbols_list2.h:{SYS_ "SL-BOUNDP","si_sl_boundp"},
symbols_list2.h:{SYS_ "SL-MAKUNBOUND","si_sl_makunbound"},
symbols_list2.h:{SYS_ "OF-CLASS-P","ECL_NAME(si_of_class_p)"},
symbols_list2.h:{EXT_ "*SOURCE-LOCATION*",NULL},
symbols_list2.h:{EXT_ "*REGISTER-WITH-PDE-HOOK*",NULL},
symbols_list2.h:{EXT_ "REGISTER-WITH-PDE",NULL},
symbols_list2.h:{SYS_ "CLEAR-PROFILE",IF_PROFILE("si_clear_profile")},
symbols_list2.h:{SYS_ "DISPLAY-PROFILE",IF_PROFILE("si_display_profile")},
symbols_list2.h:{SYS_ "*PROFILE-ARRAY*",NULL},
symbols_list2.h:{SYS_ "OPEN-CLIENT-STREAM",IF_TCP("si_open_client_stream")},
symbols_list2.h:{SYS_ "OPEN-SERVER-STREAM",IF_TCP("si_open_server_stream")},
symbols_list2.h:{SYS_ "OPEN-UNIX-SOCKET-STREAM",IF_TCP("si_open_unix_socket_stream")},
symbols_list2.h:{SYS_ "LOOKUP-HOST-ENTRY",IF_TCP("si_lookup_host_entry")},
symbols_list2.h:{EXT_ "CATCH-SIGNAL","si_catch_signal"},
symbols_list2.h:{EXT_ "GET-SIGNAL-HANDLER","si_get_signal_handler"},
symbols_list2.h:{EXT_ "SET-SIGNAL-HANDLER","si_set_signal_handler"},
symbols_list2.h:{KEY_ "ALLOW-OTHER-KEYS",NULL},
symbols_list2.h:{KEY_ "COMPILE-TOPLEVEL",NULL},
symbols_list2.h:{KEY_ "CONC-NAME",NULL},
symbols_list2.h:{KEY_ "CONTROL-STRING",NULL},
symbols_list2.h:{KEY_ "DISPLACED-INDEX-OFFSET",NULL},
symbols_list2.h:{KEY_ "DISPLACED-TO",NULL},
symbols_list2.h:{KEY_ "ELEMENT-TYPE",NULL},
symbols_list2.h:{KEY_ "EXPECTED-TYPE",NULL},
symbols_list2.h:{KEY_ "EXPORT-FROM",NULL},
symbols_list2.h:{KEY_ "EXTERNAL-FORMAT",NULL},
symbols_list2.h:{KEY_ "FILL-POINTER",NULL},
symbols_list2.h:{KEY_ "FORMAT-ARGUMENTS",NULL},
symbols_list2.h:{KEY_ "FORMAT-CONTROL",NULL},
symbols_list2.h:{KEY_ "IF-DOES-NOT-EXIST",NULL},
symbols_list2.h:{KEY_ "IF-EXISTS",NULL},
symbols_list2.h:{KEY_ "IF-OUTPUT-EXISTS",NULL},
symbols_list2.h:{KEY_ "IMPORT-FROM",NULL},
symbols_list2.h:{KEY_ "INITIAL-ELEMENT",NULL},
symbols_list2.h:{KEY_ "INITIAL-CONTENTS",NULL},
symbols_list2.h:{KEY_ "INITIAL-OFFSET",NULL},
symbols_list2.h:{KEY_ "JUNK-ALLOWED",NULL},
symbols_list2.h:{KEY_ "LIST-ALL",NULL},
symbols_list2.h:{KEY_ "LOAD-TOPLEVEL",NULL},
symbols_list2.h:{KEY_ "MISER-WIDTH",NULL},
symbols_list2.h:{KEY_ "NEW-VERSION",NULL},
symbols_list2.h:{KEY_ "PPRINT-DISPATCH",NULL},
symbols_list2.h:{KEY_ "PRINT-FUNCTION",NULL},
symbols_list2.h:{KEY_ "PRINT-OBJECT",NULL},
symbols_list2.h:{KEY_ "REHASH-SIZE",NULL},
symbols_list2.h:{KEY_ "REHASH-THRESHOLD",NULL},
symbols_list2.h:{KEY_ "RENAME-AND-DELETE",NULL},
symbols_list2.h:{KEY_ "RIGHT-MARGIN",NULL},
symbols_list2.h:{KEY_ "SET-DEFAULT-PATHNAME",NULL},
symbols_list2.h:{KEY_ "SEARCH-LIST",NULL},
symbols_list2.h:{KEY_ "SHADOWING-IMPORT",NULL},
symbols_list2.h:{KEY_ "TEST-NOT",NULL},
symbols_list2.h:{KEY_ "WILD-INFERIORS",NULL},
symbols_list2.h:{EXT_ "COMPILER-LET",NULL},
symbols_list2.h:{EXT_ "LAMBDA-BLOCK",NULL},
symbols_list2.h:{EXT_ "GET-METHOD",NULL},
symbols_list2.h:{SYS_ "ALLOCATE-FOREIGN-DATA","si_allocate_foreign_data"},
symbols_list2.h:{SYS_ "FIND-FOREIGN-SYMBOL","si_find_foreign_symbol"},
symbols_list2.h:{SYS_ "FOREIGN-DATA",NULL},
symbols_list2.h:{SYS_ "FOREIGN-DATA-ADDRESS","si_foreign_data_address"},
symbols_list2.h:{SYS_ "FOREIGN-DATA-EQUAL","si_foreign_data_equal"},
symbols_list2.h:{SYS_ "FOREIGN-DATA-P","si_foreign_data_p"},
symbols_list2.h:{SYS_ "FOREIGN-DATA-POINTER","si_foreign_data_pointer"},
symbols_list2.h:{SYS_ "FOREIGN-DATA-RECAST","si_foreign_data_recast"},
symbols_list2.h:{SYS_ "FOREIGN-DATA-REF","si_foreign_data_ref"},
symbols_list2.h:{SYS_ "FOREIGN-DATA-REF-ELT","si_foreign_data_ref_elt"},
symbols_list2.h:{SYS_ "FOREIGN-DATA-SET","si_foreign_data_set"},
symbols_list2.h:{SYS_ "FOREIGN-DATA-SET-ELT","si_foreign_data_set_elt"},
symbols_list2.h:{SYS_ "FOREIGN-DATA-TAG","si_foreign_data_tag"},
symbols_list2.h:{SYS_ "FOREIGN-ELT-TYPE-P","si_foreign_elt_type_p"},
symbols_list2.h:{SYS_ "FREE-FOREIGN-DATA","si_free_foreign_data"},
symbols_list2.h:{SYS_ "MAKE-FOREIGN-DATA-FROM-ARRAY","si_make_foreign_data_from_array"},
symbols_list2.h:{SYS_ "LOAD-FOREIGN-MODULE","si_load_foreign_module"},
symbols_list2.h:{SYS_ "NULL-POINTER-P","si_null_pointer_p"},
symbols_list2.h:{SYS_ "SIZE-OF-FOREIGN-ELT-TYPE","si_size_of_foreign_elt_type"},
symbols_list2.h:{SYS_ "ALIGNMENT-OF-FOREIGN-ELT-TYPE","si_alignment_of_foreign_elt_type"},
symbols_list2.h:{KEY_ "INT8-T",NULL},
symbols_list2.h:{KEY_ "INT16-T",NULL},
symbols_list2.h:{KEY_ "INT32-T",NULL},
symbols_list2.h:{KEY_ "INT64-T",NULL},
symbols_list2.h:{KEY_ "LONG-LONG",NULL},
symbols_list2.h:{KEY_ "POINTER-SELF",NULL},
symbols_list2.h:{KEY_ "POINTER-VOID",NULL},
symbols_list2.h:{KEY_ "UINT8-T",NULL},
symbols_list2.h:{KEY_ "UINT16-T",NULL},
symbols_list2.h:{KEY_ "UINT32-T",NULL},
symbols_list2.h:{KEY_ "UINT64-T",NULL},
symbols_list2.h:{KEY_ "UNSIGNED-BYTE",NULL},
symbols_list2.h:{KEY_ "UNSIGNED-CHAR",NULL},
symbols_list2.h:{KEY_ "UNSIGNED-INT",NULL},
symbols_list2.h:{KEY_ "UNSIGNED-LONG",NULL},
symbols_list2.h:{KEY_ "UNSIGNED-LONG-LONG",NULL},
symbols_list2.h:{KEY_ "UNSIGNED-SHORT",NULL},
symbols_list2.h:{SYS_ "GC-DUMP","si_gc_dump"},
symbols_list2.h:{SYS_ "GC-STATS","si_gc_stats"},
symbols_list2.h:{SYS_ "ALLOCATED-PAGES","si_allocated_pages"},
symbols_list2.h:{SYS_ "MAXIMUM-ALLOCATABLE-PAGES","si_maximum_allocatable_pages"},
symbols_list2.h:{SYS_ "ALLOCATE-CONTIGUOUS-PAGES","si_allocate_contiguous_pages"},
symbols_list2.h:{SYS_ "ALLOCATED-CONTIGUOUS-PAGES","si_allocated_contiguous_pages"},
symbols_list2.h:{SYS_ "MAXIMUM-CONTIGUOUS-PAGES","si_maximum_contiguous_pages"},
symbols_list2.h:{SYS_ "GC-TIME","si_gc_time"},
symbols_list2.h:{SYS_ "GET-HOLE-SIZE","si_get_hole_size"},
symbols_list2.h:{SYS_ "SET-HOLE-SIZE","si_set_hole_size"},
symbols_list2.h:{SYS_ "IGNORE-MAXIMUM-PAGES","si_ignore_maximum_pages"},
symbols_list2.h:{SYS_ "ROOM-REPORT","si_room_report"},
symbols_list2.h:{SYS_ "RESET-GC-COUNT","si_reset_gc_count"},
symbols_list2.h:{MP_ "CONDITION-VARIABLE",NULL},
symbols_list2.h:{MP_ "*CURRENT-PROCESS*",NULL},
symbols_list2.h:{MP_ "ALL-PROCESSES",IF_MP("mp_all_processes")},
symbols_list2.h:{MP_ "EXIT-PROCESS",IF_MP("mp_exit_process")},
symbols_list2.h:{MP_ "MAKE-PROCESS",IF_MP("mp_make_process")},
symbols_list2.h:{MP_ "PROCESS-ACTIVE-P",IF_MP("mp_process_active_p")},
symbols_list2.h:{MP_ "PROCESS-ENABLE",IF_MP("mp_process_enable")},
symbols_list2.h:{MP_ "PROCESS-YIELD",IF_MP("mp_process_yield")},
symbols_list2.h:{MP_ "PROCESS-KILL",IF_MP("mp_process_kill")},
symbols_list2.h:{MP_ "PROCESS-NAME",IF_MP("mp_process_name")},
symbols_list2.h:{MP_ "PROCESS-PRESET",IF_MP("mp_process_preset")},
symbols_list2.h:{MP_ "PROCESS-RUN-FUNCTION",IF_MP("mp_process_run_function")},
symbols_list2.h:{MP_ "PROCESS-WHOSTATE",IF_MP("mp_process_whostate")},
symbols_list2.h:{MP_ "PROCESS-JOIN",IF_MP("mp_process_join")},
symbols_list2.h:{MP_ "MAKE-LOCK",IF_MP("mp_make_lock")},
symbols_list2.h:{MP_ "RECURSIVE-LOCK-P",IF_MP("mp_recursive_lock_p")},
symbols_list2.h:{MP_ "LOCK-NAME",IF_MP("mp_lock_name")},
symbols_list2.h:{MP_ "LOCK-OWNER",IF_MP("mp_lock_owner")},
symbols_list2.h:{MP_ "LOCK-COUNT",IF_MP("mp_lock_count")},
symbols_list2.h:{MP_ "GET-LOCK",IF_MP("mp_get_lock")},
symbols_list2.h:{MP_ "GIVEUP-LOCK",IF_MP("mp_giveup_lock")},
symbols_list2.h:{MP_ "MAKE-CONDITION-VARIABLE",IF_MP("mp_make_condition_variable")},
symbols_list2.h:{MP_ "CONDITION-VARIABLE-WAIT",IF_MP("mp_condition_variable_wait")},
symbols_list2.h:{MP_ "CONDITION-VARIABLE-TIMEDWAIT",IF_MP("mp_condition_variable_timedwait")},
symbols_list2.h:{MP_ "CONDITION-VARIABLE-SIGNAL",IF_MP("mp_condition_variable_signal")},
symbols_list2.h:{MP_ "CONDITION-VARIABLE-BROADCAST",IF_MP("mp_condition_variable_broadcast")},
symbols_list2.h:{KEY_ "INITIAL-BINDINGS",NULL},
symbols_list2.h:{MP_ "INTERRUPT-PROCESS",IF_MP("mp_interrupt_process")},
symbols_list2.h:{MP_ "+LOAD-COMPILE-LOCK+",NULL},
symbols_list2.h:{MP_ "WITH-LOCK",NULL},
symbols_list2.h:{MP_ "BLOCK-SIGNALS",IF_MP("mp_block_signals")},
symbols_list2.h:{MP_ "RESTORE-SIGNALS",IF_MP("mp_restore_signals")},
symbols_list2.h:{MP_ "PROCESS-SUSPEND",IF_MP("mp_process_suspend")},
symbols_list2.h:{MP_ "PROCESS-RESUME",IF_MP("mp_process_resume")},
symbols_list2.h:{MP_ "SUSPEND-LOOP",IF_MP("mp_suspend_loop")},
symbols_list2.h:{MP_ "BREAK-SUSPEND-LOOP",IF_MP("mp_break_suspend_loop")},
symbols_list2.h:{MP_ "MAKE-RWLOCK",IF_MP("mp_make_rwlock")},
symbols_list2.h:{MP_ "RWLOCK-NAME",IF_MP("mp_rwlock_name")},
symbols_list2.h:{MP_ "GET-RWLOCK-READ",IF_MP("mp_get_rwlock_read")},
symbols_list2.h:{MP_ "GET-RWLOCK-WRITE",IF_MP("mp_get_rwlock_write")},
symbols_list2.h:{MP_ "GIVEUP-RWLOCK-READ",IF_MP("mp_giveup_rwlock_read")},
symbols_list2.h:{MP_ "GIVEUP-RWLOCK-WRITE",IF_MP("mp_giveup_rwlock_write")},
symbols_list2.h:{MP_ "GLOBAL-LOCK",NULL},
symbols_list2.h:{MP_ "ERROR-LOCK",NULL},
symbols_list2.h:{MP_ "MAKE-SEMAPHORE",IF_MP("mp_make_semaphore")},
symbols_list2.h:{MP_ "SIGNAL-SEMAPHORE",IF_MP("mp_signal_semaphore")},
symbols_list2.h:{MP_ "WAIT-ON-SEMAPHORE",IF_MP("mp_wait_on_semaphore")},
symbols_list2.h:{MP_ "SEMAPHORE-COUNT",IF_MP("mp_semaphore_count")},
symbols_list2.h:{MP_ "SEMAPHORE-NAME",IF_MP("mp_semaphore_name")},
symbols_list2.h:{MP_ "SEMAPHORE-WAIT-COUNT",IF_MP("mp_semaphore_wait_count")},
symbols_list2.h:{MP_ "MAKE-BARRIER",IF_MP("mp_make_barrier")},
symbols_list2.h:{MP_ "BARRIER-UNBLOCK",IF_MP("mp_barrier_unblock")},
symbols_list2.h:{MP_ "BARRIER-WAIT",IF_MP("mp_barrier_wait")},
symbols_list2.h:{MP_ "BARRIER-COUNT",IF_MP("mp_barrier_count")},
symbols_list2.h:{MP_ "BARRIER-NAME",IF_MP("mp_barrier_name")},
symbols_list2.h:{MP_ "BARRIER-ARRIVERS-COUNT",IF_MP("mp_barrier_arrivers_count")},
symbols_list2.h:{KEY_ "RESET-COUNT",NULL},
symbols_list2.h:{KEY_ "KILL-WAITING",NULL},
symbols_list2.h:{MP_ "MAKE-MAILBOX",IF_MP("mp_make_mailbox")},
symbols_list2.h:{MP_ "MAILBOX-NAME",IF_MP("mp_mailbox_name")},
symbols_list2.h:{MP_ "MAILBOX-COUNT",IF_MP("mp_mailbox_count")},
symbols_list2.h:{MP_ "MAILBOX-EMPTY-P",IF_MP("mp_mailbox_empty_p")},
symbols_list2.h:{MP_ "MAILBOX-READ",IF_MP("mp_mailbox_read")},
symbols_list2.h:{MP_ "MAILBOX-SEND",IF_MP("mp_mailbox_send")},
symbols_list2.h:{SYS_ "*EXIT-HOOKS*",NULL},
symbols_list2.h:{CLOS_ ".COMBINED-METHOD-ARGS.",NULL},
symbols_list2.h:{CLOS_ "+BUILTIN-CLASSES+",NULL},
symbols_list2.h:{CLOS_ "*NEXT-METHODS*",NULL},
symbols_list2.h:{CLOS_ "*OPTIMIZE-SLOT-ACCESS*",NULL},
symbols_list2.h:{CLOS_ "+THE-T-CLASS+",NULL},
symbols_list2.h:{CLOS_ "+THE-CLASS+",NULL},
symbols_list2.h:{CLOS_ "+THE-STD-CLASS+",NULL},
symbols_list2.h:{CLOS_ "+THE-STANDARD-CLASS+",NULL},
symbols_list2.h:{CLOS_ "+THE-FUNCALLABLE-STANDARD-CLASS+",NULL},
symbols_list2.h:{CLOS_ "ACCESSOR-METHOD-SLOT-DEFINITION",NULL},
symbols_list2.h:{CLOS_ "ADD-DEPENDENT",NULL},
symbols_list2.h:{CLOS_ "ADD-DIRECT-METHOD",NULL},
symbols_list2.h:{CLOS_ "ADD-DIRECT-SUBCLASS",NULL},
symbols_list2.h:{CLOS_ "CLASS-DEFAULT-INITARGS",NULL},
symbols_list2.h:{CLOS_ "CLASS-DIRECT-DEFAULT-INITARGS",NULL},
symbols_list2.h:{CLOS_ "CLASS-DIRECT-SLOTS",NULL},
symbols_list2.h:{CLOS_ "CLASS-DIRECT-SUBCLASSES",NULL},
symbols_list2.h:{CLOS_ "CLASS-DIRECT-SUPERCLASSES",NULL},
symbols_list2.h:{CLOS_ "CLASS-FINALIZED-P",NULL},
symbols_list2.h:{CLOS_ "CLASS-PRECEDENCE-LIST",NULL},
symbols_list2.h:{CLOS_ "CLASS-PROTOTYPE",NULL},
symbols_list2.h:{CLOS_ "CLASS-SLOTS",NULL},
symbols_list2.h:{CLOS_ "COMPUTE-APPLICABLE-METHODS-USING-CLASSES",NULL},
symbols_list2.h:{CLOS_ "COMPUTE-CLASS-PRECEDENCE-LIST",NULL},
symbols_list2.h:{CLOS_ "COMPUTE-DEFAULT-INITARGS",NULL},
symbols_list2.h:{CLOS_ "COMPUTE-DISCRIMINATING-FUNCTION",NULL},
symbols_list2.h:{CLOS_ "COMPUTE-EFFECTIVE-METHOD",NULL},
symbols_list2.h:{CLOS_ "COMPUTE-EFFECTIVE-SLOT-DEFINITION",NULL},
symbols_list2.h:{CLOS_ "COMPUTE-SLOTS",NULL},
symbols_list2.h:{CLOS_ "DIRECT-SLOT-DEFINITION",NULL},
symbols_list2.h:{CLOS_ "DIRECT-SLOT-DEFINITION-CLASS",NULL},
symbols_list2.h:{CLOS_ "EFFECTIVE-SLOT-DEFINITION",NULL},
symbols_list2.h:{CLOS_ "EFFECTIVE-SLOT-DEFINITION-CLASS",NULL},
symbols_list2.h:{CLOS_ "ENSURE-CLASS",NULL},
symbols_list2.h:{CLOS_ "ENSURE-CLASS-USING-CLASS",NULL},
symbols_list2.h:{CLOS_ "ENSURE-GENERIC-FUNCTION-USING-CLASS",NULL},
symbols_list2.h:{CLOS_ "EQL-SPECIALIZER",NULL},
symbols_list2.h:{CLOS_ "EQL-SPECIALIZER-OBJECT",NULL},
symbols_list2.h:{CLOS_ "EXTRACT-LAMBDA-LIST",NULL},
symbols_list2.h:{CLOS_ "EXTRACT-SPECIALIZER-NAMES",NULL},
symbols_list2.h:{CLOS_ "FINALIZE-INHERITANCE",NULL},
symbols_list2.h:{CLOS_ "FIND-METHOD-COMBINATION",NULL},
symbols_list2.h:{CLOS_ "FORWARD-REFERENCED-CLASS",NULL},
symbols_list2.h:{CLOS_ "FUNCALLABLE-STANDARD-CLASS",NULL},
symbols_list2.h:{CLOS_ "FUNCALLABLE-STANDARD-INSTANCE-ACCESS","si_instance_ref"},
symbols_list2.h:{CLOS_ "FUNCALLABLE-STANDARD-OBJECT",NULL},
symbols_list2.h:{CLOS_ "GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER",NULL},
symbols_list2.h:{CLOS_ "GENERIC-FUNCTION-DECLARATIONS",NULL},
symbols_list2.h:{CLOS_ "GENERIC-FUNCTION-LAMBDA-LIST",NULL},
symbols_list2.h:{CLOS_ "GENERIC-FUNCTION-METHOD-CLASS",NULL},
symbols_list2.h:{CLOS_ "GENERIC-FUNCTION-METHOD-COMBINATION",NULL},
symbols_list2.h:{CLOS_ "GENERIC-FUNCTION-METHODS",NULL},
symbols_list2.h:{CLOS_ "GENERIC-FUNCTION-NAME",NULL},
symbols_list2.h:{CLOS_ "INTERN-EQL-SPECIALIZER",NULL},
symbols_list2.h:{CLOS_ "LOCATION-TABLE",NULL},
symbols_list2.h:{CLOS_ "MAKE-METHOD-LAMBDA",NULL},
symbols_list2.h:{CLOS_ "MAP-DEPENDENTS",NULL},
symbols_list2.h:{CLOS_ "METHOD-FUNCTION",NULL},
symbols_list2.h:{CLOS_ "METHOD-GENERIC-FUNCTION",NULL},
symbols_list2.h:{CLOS_ "METHOD-LAMBDA-LIST",NULL},
symbols_list2.h:{CLOS_ "METHOD-SPECIALIZERS",NULL},
symbols_list2.h:{CLOS_ "READER-METHOD-CLASS",NULL},
symbols_list2.h:{CLOS_ "REMOVE-DEPENDENT",NULL},
symbols_list2.h:{CLOS_ "REMOVE-DIRECT-METHOD",NULL},
symbols_list2.h:{CLOS_ "REMOVE-DIRECT-SUBCLASS",NULL},
symbols_list2.h:{CLOS_ "SET-FUNCALLABLE-INSTANCE-FUNCTION","clos_set_funcallable_instance_function"},
symbols_list2.h:{CLOS_ "SLOT-BOUNDP-USING-CLASS",NULL},
symbols_list2.h:{CLOS_ "SLOT-DEFINITION",NULL},
symbols_list2.h:{CLOS_ "SLOT-DEFINITION-ALLOCATION",NULL},
symbols_list2.h:{CLOS_ "SLOT-DEFINITION-INITARGS",NULL},
symbols_list2.h:{CLOS_ "SLOT-DEFINITION-INITFORM",NULL},
symbols_list2.h:{CLOS_ "SLOT-DEFINITION-INITFUNCTION",NULL},
symbols_list2.h:{CLOS_ "SLOT-DEFINITION-LOCATION",NULL},
symbols_list2.h:{CLOS_ "SLOT-DEFINITION-NAME",NULL},
symbols_list2.h:{CLOS_ "SLOT-DEFINITION-READERS",NULL},
symbols_list2.h:{CLOS_ "SLOT-DEFINITION-TYPE",NULL},
symbols_list2.h:{CLOS_ "SLOT-DEFINITION-WRITERS",NULL},
symbols_list2.h:{CLOS_ "SLOT-MAKUNBOUND-USING-CLASS",NULL},
symbols_list2.h:{CLOS_ "SLOT-VALUE-USING-CLASS",NULL},
symbols_list2.h:{CLOS_ "SLOT-VALUE-SET","clos_slot_value_set"},
symbols_list2.h:{CLOS_ "SLOT-TABLE",NULL},
symbols_list2.h:{CLOS_ "SPECIALIZER-DIRECT-GENERIC-FUNCTIONS",NULL},
symbols_list2.h:{CLOS_ "SPECIALIZER-DIRECT-METHODS",NULL},
symbols_list2.h:{CLOS_ "STANDARD-ACCESSOR-METHOD",NULL},
symbols_list2.h:{CLOS_ "STANDARD-DIRECT-SLOT-DEFINITION",NULL},
symbols_list2.h:{CLOS_ "STANDARD-EFFECTIVE-SLOT-DEFINITION",NULL},
symbols_list2.h:{CLOS_ "STANDARD-INSTANCE-ACCESS","si_instance_ref"},
symbols_list2.h:{CLOS_ "STANDARD-READER-METHOD",NULL},
symbols_list2.h:{CLOS_ "STANDARD-SLOT-DEFINITION",NULL},
symbols_list2.h:{CLOS_ "STANDARD-WRITER-METHOD",NULL},
symbols_list2.h:{CLOS_ "STANDARD-OPTIMIZED-READER-METHOD",NULL},
symbols_list2.h:{CLOS_ "STANDARD-OPTIMIZED-WRITER-METHOD",NULL},
symbols_list2.h:{CLOS_ "STD-COMPUTE-APPLICABLE-METHODS","ECL_NAME(clos_std_compute_applicable_methods)"},
symbols_list2.h:{CLOS_ "STD-COMPUTE-APPLICABLE-METHODS-USING-CLASSES",NULL},
symbols_list2.h:{CLOS_ "STD-COMPUTE-EFFECTIVE-METHOD","ECL_NAME(clos_std_compute_effective_method)"},
symbols_list2.h:{CLOS_ "COMPUTE-EFFECTIVE-METHOD-FUNCTION","ECL_NAME(clos_compute_effective_method_function)"},
symbols_list2.h:{CLOS_ "UPDATE-DEPENDENT",NULL},
symbols_list2.h:{CLOS_ "UPDATE-INSTANCE",NULL},
symbols_list2.h:{CLOS_ "VALIDATE-SUPERCLASS",NULL},
symbols_list2.h:{CLOS_ "WRITER-METHOD-CLASS",NULL},
symbols_list2.h:{SYS_ "CLEAR-GFUN-HASH","si_clear_gfun_hash"},
symbols_list2.h:{CLOS_ "NEED-TO-MAKE-LOAD-FORM-P","ECL_NAME(clos_need_to_make_load_form_p)"},
symbols_list2.h:{CLOS_ "LOAD-DEFCLASS","ECL_NAME(clos_load_defclass)"},
symbols_list2.h:{CLOS_ "SAFE-INSTANCE-REF","clos_safe_instance_ref"},
symbols_list2.h:{SYS_ "CL-FIXNUM-BITS",NULL},
symbols_list2.h:{EXT_ "CL-FIXNUM",NULL},
symbols_list2.h:{EXT_ "CL-INDEX",NULL},
symbols_list2.h:{SYS_ "DO-DEFTYPE","ECL_NAME(si_do_deftype)"},
symbols_list2.h:{SYS_ "CREATE-TYPE-NAME",NULL},
symbols_list2.h:{SYS_ "*ALIEN-DECLARATIONS*",NULL},
symbols_list2.h:{SYS_ "LOAD-BINARY","si_load_binary"},
symbols_list2.h:{SYS_ "LOAD-BINARY",NULL},
symbols_list2.h:{SYS_ "*CODE-WALKER*",NULL},
symbols_list2.h:{SYS_ "CALL-CFUN",IF_DFFI("si_call_cfun")},
symbols_list2.h:{SYS_ "MAKE-DYNAMIC-CALLBACK",IF_DFFI("si_make_dynamic_callback")},
symbols_list2.h:{SYS_ "FREE-FFI-CLOSURE",IF_LIBFFI("si_free_ffi_closure")},
symbols_list2.h:{SYS_ "TRAP-FPE","si_trap_fpe"},
symbols_list2.h:{EXT_ "*ACTION-ON-UNDEFINED-VARIABLE*",NULL},
symbols_list2.h:{SYS_ "SET-BUFFERING-MODE","si_set_buffering_mode"},
symbols_list2.h:{KEY_ "LINE-BUFFERED",NULL},
symbols_list2.h:{KEY_ "FULLY-BUFFERED",NULL},
symbols_list2.h:{SYS_ "CMP-ENV-REGISTER-MACROLET",NULL},
symbols_list2.h:{EXT_ "GET-FINALIZER","si_get_finalizer"},
symbols_list2.h:{EXT_ "SET-FINALIZER","si_set_finalizer"},
symbols_list2.h:{SYS_ "*RELATIVE-PACKAGE-NAMES*",NULL},
symbols_list2.h:{KEY_ "RELATIVE-PACKAGE-NAMES",NULL},
symbols_list2.h:{SYS_ "FIND-RELATIVE-PACKAGE",IF_RELPACK("si_find_relative_package")},
symbols_list2.h:{SYS_ "PACKAGE-PARENT",NULL},
symbols_list2.h:{SYS_ "PACKAGE-CHILDREN",NULL},
symbols_list2.h:{SYS_ "WRONG-TYPE-ARGUMENT","si_wrong_type_argument"},
symbols_list2.h:{SYS_ "*CURRENT-FORM*",NULL},
symbols_list2.h:{SYS_ "CODE-BLOCK",NULL},
symbols_list2.h:{SYS_ "APPLY-FROM-STACK-FRAME","si_apply_from_stack_frame"},
symbols_list2.h:{GRAY_ "INPUT-STREAM-P",NULL},
symbols_list2.h:{GRAY_ "OUTPUT-STREAM-P",NULL},
symbols_list2.h:{GRAY_ "OPEN-STREAM-P",NULL},
symbols_list2.h:{GRAY_ "STREAM-ADVANCE-TO-COLUMN",NULL},
symbols_list2.h:{GRAY_ "STREAM-CLEAR-INPUT",NULL},
symbols_list2.h:{GRAY_ "STREAM-CLEAR-OUTPUT",NULL},
symbols_list2.h:{GRAY_ "STREAM-ELEMENT-TYPE",NULL},
symbols_list2.h:{GRAY_ "STREAM-FILE-DESCRIPTOR",NULL},
symbols_list2.h:{GRAY_ "STREAM-FILE-POSITION",NULL},
symbols_list2.h:{GRAY_ "STREAM-FINISH-OUTPUT",NULL},
symbols_list2.h:{GRAY_ "STREAM-FORCE-OUTPUT",NULL},
symbols_list2.h:{GRAY_ "STREAM-FRESH-LINE",NULL},
symbols_list2.h:{GRAY_ "STREAM-INTERACTIVE-P",NULL},
symbols_list2.h:{GRAY_ "STREAM-LINE-COLUMN",NULL},
symbols_list2.h:{GRAY_ "STREAM-LISTEN",NULL},
symbols_list2.h:{GRAY_ "STREAM-PEEK-CHAR",NULL},
symbols_list2.h:{GRAY_ "STREAM-READ-BYTE",NULL},
symbols_list2.h:{GRAY_ "STREAM-READ-CHAR",NULL},
symbols_list2.h:{GRAY_ "STREAM-READ-CHAR-NO-HANG",NULL},
symbols_list2.h:{GRAY_ "STREAM-READ-LINE",NULL},
symbols_list2.h:{GRAY_ "STREAM-READ-SEQUENCE",NULL},
symbols_list2.h:{GRAY_ "STREAM-START-LINE-P",NULL},
symbols_list2.h:{GRAY_ "STREAM-TERPRI",NULL},
symbols_list2.h:{GRAY_ "STREAM-UNREAD-CHAR",NULL},
symbols_list2.h:{GRAY_ "STREAM-WRITE-BYTE",NULL},
symbols_list2.h:{GRAY_ "STREAM-WRITE-CHAR",NULL},
symbols_list2.h:{GRAY_ "STREAM-WRITE-SEQUENCE",NULL},
symbols_list2.h:{GRAY_ "STREAM-WRITE-STRING",NULL},
symbols_list2.h:{GRAY_ "FUNDAMENTAL-STREAM",NULL},
symbols_list2.h:{GRAY_ "FUNDAMENTAL-INPUT-STREAM",NULL},
symbols_list2.h:{GRAY_ "FUNDAMENTAL-OUTPUT-STREAM",NULL},
symbols_list2.h:{GRAY_ "FUNDAMENTAL-CHARACTER-STREAM",NULL},
symbols_list2.h:{GRAY_ "FUNDAMENTAL-BINARY-STREAM",NULL},
symbols_list2.h:{GRAY_ "FUNDAMENTAL-CHARACTER-INPUT-STREAM",NULL},
symbols_list2.h:{GRAY_ "FUNDAMENTAL-CHARACTER-OUTPUT-STREAM",NULL},
symbols_list2.h:{GRAY_ "FUNDAMENTAL-BINARY-INPUT-STREAM",NULL},
symbols_list2.h:{GRAY_ "FUNDAMENTAL-BINARY-OUTPUT-STREAM",NULL},
symbols_list2.h:{EXT_ "BC-FILE","si_compiled_function_file"},
symbols_list2.h:{EXT_ "COMPILED-FUNCTION-FILE","si_compiled_function_file"},
symbols_list2.h:{SYS_ "PROPERTY-LIST",NULL},
symbols_list2.h:{SYS_ "HASH-EQL","si_hash_eql"},
symbols_list2.h:{SYS_ "HASH-EQUAL","si_hash_equal"},
symbols_list2.h:{SYS_ "HASH-EQUALP","si_hash_equalp"},
symbols_list2.h:{EXT_ "INTERACTIVE-INTERRUPT",NULL},
symbols_list2.h:{EXT_ "STORAGE-EXHAUSTED",NULL},
symbols_list2.h:{EXT_ "STACK-OVERFLOW",NULL},
symbols_list2.h:{EXT_ "STACK-OVERFLOW-SIZE",NULL},
symbols_list2.h:{EXT_ "STACK-OVERFLOW-TYPE",NULL},
symbols_list2.h:{EXT_ "BINDING-STACK",NULL},
symbols_list2.h:{EXT_ "FRAME-STACK",NULL},
symbols_list2.h:{EXT_ "LISP-STACK",NULL},
symbols_list2.h:{EXT_ "C-STACK",NULL},
symbols_list2.h:{EXT_ "HEAP-SIZE",NULL},
symbols_list2.h:{EXT_ "ILLEGAL-INSTRUCTION",NULL},
symbols_list2.h:{EXT_ "SET-LIMIT","si_set_limit"},
symbols_list2.h:{EXT_ "GET-LIMIT","si_get_limit"},
symbols_list2.h:{EXT_ "SEGMENTATION-VIOLATION",NULL},
symbols_list2.h:{EXT_ "EXTENDED-STRING",NULL},
symbols_list2.h:{SYS_ "CHECK-PENDING-INTERRUPTS","si_check_pending_interrupts"},
symbols_list2.h:{KEY_ "LATIN-1",NULL},
symbols_list2.h:{KEY_ "ISO-8859-1",NULL},
symbols_list2.h:{KEY_ "UTF-8",NULL},
symbols_list2.h:{KEY_ "UCS-2",NULL},
symbols_list2.h:{KEY_ "UCS-4",NULL},
symbols_list2.h:{EXT_ "CONSTANTLY-T",NULL},
symbols_list2.h:{EXT_ "CONSTANTLY-NIL",NULL},
symbols_list2.h:{EXT_ "MAYBE-QUOTE",NULL},
symbols_list2.h:{EXT_ "MAYBE-UNQUOTE",NULL},
symbols_list2.h:{KEY_ "UCS-2BE",NULL},
symbols_list2.h:{KEY_ "UCS-4BE",NULL},
symbols_list2.h:{KEY_ "UCS-2LE",NULL},
symbols_list2.h:{KEY_ "UCS-4LE",NULL},
symbols_list2.h:{EXT_ "LOAD-ENCODING",NULL},
symbols_list2.h:{EXT_ "MAKE-ENCODING",NULL},
symbols_list2.h:{EXT_ "ALL-ENCODINGS",NULL},
symbols_list2.h:{KEY_ "US-ASCII",NULL},
symbols_list2.h:{KEY_ "LITTLE-ENDIAN",NULL},
symbols_list2.h:{KEY_ "BIG-ENDIAN",NULL},
symbols_list2.h:{SYS_ "+UNICODE-DATABASE+",NULL},
symbols_list2.h:{EXT_ "COPY-FILE","si_copy_file"},
symbols_list2.h:{EXT_ "FILL-ARRAY-WITH-ELT","si_fill_array_with_elt"},
symbols_list2.h:{EXT_ "+ECL-VERSION-NUMBER+",NULL},
symbols_list2.h:{EXT_ "*BYTECODES-COMPILER*",NULL},
symbols_list2.h:{EXT_ "SHORT-FLOAT-POSITIVE-INFINITY",NULL},
symbols_list2.h:{EXT_ "SINGLE-FLOAT-POSITIVE-INFINITY",NULL},
symbols_list2.h:{EXT_ "DOUBLE-FLOAT-POSITIVE-INFINITY",NULL},
symbols_list2.h:{EXT_ "LONG-FLOAT-POSITIVE-INFINITY",NULL},
symbols_list2.h:{EXT_ "SHORT-FLOAT-NEGATIVE-INFINITY",NULL},
symbols_list2.h:{EXT_ "SINGLE-FLOAT-NEGATIVE-INFINITY",NULL},
symbols_list2.h:{EXT_ "DOUBLE-FLOAT-NEGATIVE-INFINITY",NULL},
symbols_list2.h:{EXT_ "LONG-FLOAT-NEGATIVE-INFINITY",NULL},
symbols_list2.h:{EXT_ "FLOAT-NAN-P","si_float_nan_p"},
symbols_list2.h:{EXT_ "FLOAT-INFINITY-P","si_float_infinity_p"},
symbols_list2.h:{SYS_ "READ-OBJECT-OR-IGNORE","si_read_object_or_ignore"},
symbols_list2.h:{EXT_ "FLOAT-NAN-STRING",NULL},
symbols_list2.h:{EXT_ "FLOAT-INFINITY-STRING",NULL},
symbols_list2.h:{EXT_ "READTABLE-LOCK","si_readtable_lock"},
symbols_list2.h:{SYS_ "+IO-SYNTAX-PROGV-LIST+",NULL},
symbols_list2.h:{SYS_ "+ECL-SYNTAX-PROGV-LIST+",NULL},
symbols_list2.h:{SYS_ "WITH-ECL-IO-SYNTAX",NULL},
symbols_list2.h:{SYS_ "STREAM-EXTERNAL-FORMAT-SET","si_stream_external_format_set"},
symbols_list2.h:{EXT_ "WEAK-POINTER",NULL},
symbols_list2.h:{EXT_ "MAKE-WEAK-POINTER","si_make_weak_pointer"},
symbols_list2.h:{EXT_ "WEAK-POINTER-VALUE","si_weak_pointer_value"},
symbols_list2.h:{SYS_ "*ALLOW-WITH-INTERRUPTS*",NULL},
symbols_list2.h:{EXT_ "WITH-UNIQUE-NAMES",NULL},
symbols_list2.h:{SYS_ "HANDLE-SIGNAL","si_handle_signal"},
symbols_list2.h:{EXT_ "WITH-INTERRUPTS",NULL},
symbols_list2.h:{EXT_ "WITHOUT-INTERRUPTS",NULL},
symbols_list2.h:{EXT_ "WITH-LOCAL-INTERRUPTS",NULL},
symbols_list2.h:{EXT_ "ALLOW-WITH-INTERRUPTS",NULL},
symbols_list2.h:{SYS_ "*QUIT-TAG*",NULL},
symbols_list2.h:{EXT_ "ARRAY-RAW-DATA","si_array_raw_data"},
symbols_list2.h:{EXT_ "*PROGRAM-EXIT-CODE*",NULL},
symbols_list2.h:{EXT_ "MAKE-EXTERNAL-PROCESS",NULL},
symbols_list2.h:{EXT_ "EXTERNAL-PROCESS",NULL},
symbols_list2.h:{EXT_ "EXTERNAL-PROCESS-PID",NULL},
symbols_list2.h:{EXT_ "EXTERNAL-PROCESS-INPUT",NULL},
symbols_list2.h:{EXT_ "EXTERNAL-PROCESS-OUTPUT",NULL},
symbols_list2.h:{EXT_ "EXTERNAL-PROCESS-STATUS",NULL},
symbols_list2.h:{EXT_ "EXTERNAL-PROCESS-WAIT","si_external_process_wait"},
symbols_list2.h:{SYS_ "CLOSE-WINDOWS-HANDLE","si_close_windows_handle"},
symbols_list2.h:{SYS_ "CLOSE-WINDOWS-HANDLE",NULL},
symbols_list2.h:{EXT_ "*INVOKE-DEBUGGER-HOOK*",NULL},
symbols_list2.h:{EXT_ "*DOCUMENTATION-POOL*",NULL},
symbols_list2.h:{EXT_ "GET-ANNOTATION",NULL},
symbols_list2.h:{EXT_ "REMOVE-ANNOTATION",NULL},
symbols_list2.h:{EXT_ "FUNCTION-LAMBDA-LIST",NULL},
symbols_list2.h:{EXT_ "DEFAULT-ANNOTATION-LOGIC",NULL},
symbols_list2.h:{EXT_ "OPTIONAL-ANNOTATION",NULL},
symbols_list2.h:{EXT_ "LISP-IMPLEMENTATION-VCS-ID",NULL},
symbols_list2.h:{SYS_ "SIGNAL-SERVICING",NULL},
symbols_list2.h:{EXT_ "*DEFAULT-EXTERNAL-FORMAT*",NULL},
symbols_list2.h:{KEY_ "PASS-THROUGH",NULL},
symbols_list2.h:{EXT_ "WITH-BACKEND",NULL},
symbols_list2.h:{EXT_ "ARRAY-INDEX",NULL},
symbols_list2.h:{EXT_ "ANSI-STREAM",NULL},
symbols_list2.h:{EXT_ "COMPLEX-ARRAY",NULL},
symbols_list2.h:{SYS_ "SEQUENCE-START-END","si_sequence_start_end"},
symbols_list2.h:{SYS_ "SEQUENCE-COUNT",NULL},
symbols_list2.h:{SYS_ "SHRINK-VECTOR",NULL},
symbols_list2.h:{SYS_ "COPY-SUBARRAY","si_copy_subarray"},
symbols_list2.h:{SYS_ "CONS-CAR","cl_car"},
symbols_list2.h:{SYS_ "CONS-CDR","cl_cdr"},
symbols_list2.h:{EXT_ "COMPILER-TYPECASE",NULL},
symbols_list2.h:{SYS_ "ASSERT-FAILURE","ECL_NAME(si_assert_failure)"},
symbols_list2.h:{SYS_ "CCASE-ERROR","ECL_NAME(si_ccase_error)"},
symbols_list2.h:{SYS_ "ECASE-ERROR","ECL_NAME(si_ecase_error)"},
symbols_list2.h:{SYS_ "ETYPECASE-ERROR","ECL_NAME(si_etypecase_error)"},
symbols_list2.h:{SYS_ "CTYPECASE-ERROR","ECL_NAME(si_ctypecase_error)"},
symbols_list2.h:{SYS_ "DO-CHECK-TYPE","ECL_NAME(si_do_check_type)"},
symbols_list2.h:{EXT_ "ARRAY-ELEMENT-TYPE-BYTE-SIZE","si_array_element_type_byte_size"},
symbols_list2.h:{EXT_ "SSE-PACK",NULL},
symbols_list2.h:{EXT_ "SSE-PACK-P",IF_SSE2("si_sse_pack_p")},
symbols_list2.h:{EXT_ "SSE-PACK-AS-ELT-TYPE",IF_SSE2("si_sse_pack_as_elt_type")},
symbols_list2.h:{EXT_ "VECTOR-TO-SSE-PACK",IF_SSE2("si_vector_to_sse_pack")},
symbols_list2.h:{EXT_ "SSE-PACK-TO-VECTOR",IF_SSE2("si_sse_pack_to_vector")},
symbols_list2.h:{EXT_ "INT-SSE-PACK",NULL},
symbols_list2.h:{EXT_ "FLOAT-SSE-PACK",NULL},
symbols_list2.h:{EXT_ "DOUBLE-SSE-PACK",NULL},
symbols_list2.h:{EXT_ "SSE-PACK-ELEMENT-TYPE",IF_SSE2("si_sse_pack_element_type")},
symbols_list2.h:{EXT_ "*SSE-PACK-PRINT-MODE*",NULL},
symbols_list2.h:{EXT_ "UNIX-SIGNAL-RECEIVED",NULL},
symbols_list2.h:{EXT_ "UNIX-SIGNAL-RECEIVED-CODE",NULL},
symbols_list2.h:{EXT_ "ASSUME-RIGHT-TYPE",NULL},
symbols_list2.h:{SYS_ "FLOAT-TO-DIGITS","si_float_to_digits"},
symbols_list2.h:{SYS_ "FLOAT-TO-STRING-FREE","si_float_to_string_free"},
symbols_list2.h:{SYS_ "INTEGER-TO-STRING","si_integer_to_string"},
symbols_list2.h:{SYS_ "PRINT-UNREADABLE-OBJECT-FUNCTION","si_print_unreadable_object_function"},
symbols_list2.h:{EXT_ "DUMP-C-BACKTRACE","si_dump_c_backtrace"},
symbols_list2.h:{EXT_ "+PROCESS-STANDARD-INPUT+",NULL},
symbols_list2.h:{EXT_ "+PROCESS-STANDARD-OUTPUT+",NULL},
symbols_list2.h:{EXT_ "+PROCESS-ERROR-OUTPUT+",NULL},
symbols_list2.h:{EXT_ "*HELP-MESSAGE*",NULL},
symbols_list2.h:{EXT_ "*LISP-INIT-FILE-LIST*",NULL},
symbols_list2.h:{EXT_ "+DEFAULT-COMMAND-ARG-RULES+",NULL},
symbols_list2.h:{EXT_ "COMMAND-ARGS",NULL},
symbols_list2.h:{EXT_ "*COMMAND-ARGS*",NULL},
symbols_list2.h:{EXT_ "PROCESS-COMMAND-ARGS",NULL},
symbols_list2.h:{EXT_ "*UNPROCESSED-ECL-COMMAND-ARGS*",NULL},
symbols_list2.h:{EXT_ "CHARACTER-CODING-ERROR",NULL},
symbols_list2.h:{EXT_ "CHARACTER-CODING-ERROR-EXTERNAL-FORMAT",NULL},
symbols_list2.h:{EXT_ "CHARACTER-ENCODING-ERROR",NULL},
symbols_list2.h:{EXT_ "CHARACTER-ENCODING-ERROR-CODE",NULL},
symbols_list2.h:{EXT_ "CHARACTER-DECODING-ERROR",NULL},
symbols_list2.h:{EXT_ "CHARACTER-DECODING-ERROR-OCTETS",NULL},
symbols_list2.h:{EXT_ "STREAM-DECODING-ERROR",NULL},
symbols_list2.h:{EXT_ "STREAM-ENCODING-ERROR",NULL},
symbols_list2.h:{EXT_ "DECODING-ERROR",NULL},
symbols_list2.h:{EXT_ "ENCODING-ERROR",NULL},
symbols_list2.h:{SYS_ "PROPER-LIST-P","si_proper_list_p"},
symbols_list2.h:{SYS_ "TRACED-OLD-DEFINITION","ECL_NAME(si_traced_old_definition)"},
symbols_list2.h:{SYS_ "*TRACE-LIST*",NULL},
symbols_list2.h:{SYS_ "FUNCTION-BOUNDARY",NULL},
symbols_list2.h:{EXT_ "*INSPECTOR-HOOK*",NULL},
symbols_list2.h:{KEY_ "RESOLVE-SYMLINKS",NULL},
symbols_list2.h:{SYS_ "LOAD-BYTECODES","si_load_bytecodes"},
symbols_list2.h:{EXT_ "MMAP-ARRAY","si_mmap_array"},
symbols_list2.h:{SYS_ "GET-CDATA","si_get_cdata"},
symbols_list2.h:{SYS_ "ADD-CDATA","si_add_cdata"},
symbols_list2.h: * CDR-5 http://cdr.eurolisp.org/document/5/extra-num-types.html
symbols_list2.h:{EXT_ "NEGATIVE-FIXNUM",NULL},
symbols_list2.h:{EXT_ "NON-NEGATIVE-FIXNUM",NULL},
symbols_list2.h:{EXT_ "NON-POSITIVE-FIXNUM",NULL},
symbols_list2.h:{EXT_ "POSITIVE-FIXNUM",NULL},
symbols_list2.h:{EXT_ "NEGATIVE-FIXNUM-P","ECL_NAME(si_negative_fixnum_p)"},
symbols_list2.h:{EXT_ "POSITIVE-FIXNUM-P","ECL_NAME(si_positive_fixnum_p)"},
symbols_list2.h:{EXT_ "NON-NEGATIVE-FIXNUM-P","ECL_NAME(si_non_negative_fixnum_p)"},
symbols_list2.h:{EXT_ "NON-POSITIVE-FIXNUM-P","ECL_NAME(si_non_positive_fixnum_p)"},
symbols_list2.h:{EXT_ "NEGATIVE-INTEGER",NULL},
symbols_list2.h:{EXT_ "NON-NEGATIVE-INTEGER",NULL},
symbols_list2.h:{EXT_ "NON-POSITIVE-INTEGER",NULL},
symbols_list2.h:{EXT_ "POSITIVE-INTEGER",NULL},
symbols_list2.h:{EXT_ "NEGATIVE-INTEGER-P","ECL_NAME(si_negative_integer_p)"},
symbols_list2.h:{EXT_ "POSITIVE-INTEGER-P","ECL_NAME(si_positive_integer_p)"},
symbols_list2.h:{EXT_ "NON-NEGATIVE-INTEGER-P","ECL_NAME(si_non_negative_integer_p)"},
symbols_list2.h:{EXT_ "NON-POSITIVE-INTEGER-P","ECL_NAME(si_non_positive_integer_p)"},
symbols_list2.h:{EXT_ "NEGATIVE-RATIONAL",NULL},
symbols_list2.h:{EXT_ "NON-NEGATIVE-RATIONAL",NULL},
symbols_list2.h:{EXT_ "NON-POSITIVE-RATIONAL",NULL},
symbols_list2.h:{EXT_ "POSITIVE-RATIONAL",NULL},
symbols_list2.h:{EXT_ "NEGATIVE-RATIONAL-P","ECL_NAME(si_negative_rational_p)"},
symbols_list2.h:{EXT_ "POSITIVE-RATIONAL-P","ECL_NAME(si_positive_rational_p)"},
symbols_list2.h:{EXT_ "NON-NEGATIVE-RATIONAL-P","ECL_NAME(si_non_negative_rational_p)"},
symbols_list2.h:{EXT_ "NON-POSITIVE-RATIONAL-P","ECL_NAME(si_non_positive_rational_p)"},
symbols_list2.h:{EXT_ "NEGATIVE-RATIO",NULL},
symbols_list2.h:{EXT_ "NON-NEGATIVE-RATIO",NULL},
symbols_list2.h:{EXT_ "NON-POSITIVE-RATIO",NULL},
symbols_list2.h:{EXT_ "POSITIVE-RATIO",NULL},
symbols_list2.h:{EXT_ "NEGATIVE-RATIO-P","ECL_NAME(si_negative_ratio_p)"},
symbols_list2.h:{EXT_ "POSITIVE-RATIO-P","ECL_NAME(si_positive_ratio_p)"},
symbols_list2.h:{EXT_ "NON-NEGATIVE-RATIO-P","ECL_NAME(si_non_negative_ratio_p)"},
symbols_list2.h:{EXT_ "NON-POSITIVE-RATIO-P","ECL_NAME(si_non_positive_ratio_p)"},
symbols_list2.h:{EXT_ "NEGATIVE-REAL",NULL},
symbols_list2.h:{EXT_ "NON-NEGATIVE-REAL",NULL},
symbols_list2.h:{EXT_ "NON-POSITIVE-REAL",NULL},
symbols_list2.h:{EXT_ "POSITIVE-REAL",NULL},
symbols_list2.h:{EXT_ "NEGATIVE-REAL-P","ECL_NAME(si_negative_real_p)"},
symbols_list2.h:{EXT_ "POSITIVE-REAL-P","ECL_NAME(si_positive_real_p)"},
symbols_list2.h:{EXT_ "NON-NEGATIVE-REAL-P","ECL_NAME(si_non_negative_real_p)"},
symbols_list2.h:{EXT_ "NON-POSITIVE-REAL-P","ECL_NAME(si_non_positive_real_p)"},
symbols_list2.h:{EXT_ "NEGATIVE-FLOAT",NULL},
symbols_list2.h:{EXT_ "NON-NEGATIVE-FLOAT",NULL},
symbols_list2.h:{EXT_ "NON-POSITIVE-FLOAT",NULL},
symbols_list2.h:{EXT_ "POSITIVE-FLOAT",NULL},
symbols_list2.h:{EXT_ "NEGATIVE-FLOAT-P","ECL_NAME(si_negative_float_p)"},
symbols_list2.h:{EXT_ "POSITIVE-FLOAT-P","ECL_NAME(si_positive_float_p)"},
symbols_list2.h:{EXT_ "NON-NEGATIVE-FLOAT-P","ECL_NAME(si_non_negative_float_p)"},
symbols_list2.h:{EXT_ "NON-POSITIVE-FLOAT-P","ECL_NAME(si_non_positive_float_p)"},
symbols_list2.h:{EXT_ "NEGATIVE-SHORT-FLOAT",NULL},
symbols_list2.h:{EXT_ "NON-NEGATIVE-SHORT-FLOAT",NULL},
symbols_list2.h:{EXT_ "NON-POSITIVE-SHORT-FLOAT",NULL},
symbols_list2.h:{EXT_ "POSITIVE-SHORT-FLOAT",NULL},
symbols_list2.h:{EXT_ "NEGATIVE-SHORT-FLOAT-P","ECL_NAME(si_negative_short_float_p)"},
symbols_list2.h:{EXT_ "POSITIVE-SHORT-FLOAT-P","ECL_NAME(si_positive_short_float_p)"},
symbols_list2.h:{EXT_ "NON-NEGATIVE-SHORT-FLOAT-P","ECL_NAME(si_non_negative_short_float_p)"},
symbols_list2.h:{EXT_ "NON-POSITIVE-SHORT-FLOAT-P","ECL_NAME(si_non_positive_short_float_p)"},
symbols_list2.h:{EXT_ "NEGATIVE-SINGLE-FLOAT",NULL},
symbols_list2.h:{EXT_ "NON-NEGATIVE-SINGLE-FLOAT",NULL},
symbols_list2.h:{EXT_ "NON-POSITIVE-SINGLE-FLOAT",NULL},
symbols_list2.h:{EXT_ "POSITIVE-SINGLE-FLOAT",NULL},
symbols_list2.h:{EXT_ "NEGATIVE-SINGLE-FLOAT-P","ECL_NAME(si_negative_single_float_p)"},
symbols_list2.h:{EXT_ "POSITIVE-SINGLE-FLOAT-P","ECL_NAME(si_positive_single_float_p)"},
symbols_list2.h:{EXT_ "NON-NEGATIVE-SINGLE-FLOAT-P","ECL_NAME(si_non_negative_single_float_p)"},
symbols_list2.h:{EXT_ "NON-POSITIVE-SINGLE-FLOAT-P","ECL_NAME(si_non_positive_single_float_p)"},
symbols_list2.h:{EXT_ "NEGATIVE-DOUBLE-FLOAT",NULL},
symbols_list2.h:{EXT_ "NON-NEGATIVE-DOUBLE-FLOAT",NULL},
symbols_list2.h:{EXT_ "NON-POSITIVE-DOUBLE-FLOAT",NULL},
symbols_list2.h:{EXT_ "POSITIVE-DOUBLE-FLOAT",NULL},
symbols_list2.h:{EXT_ "NEGATIVE-DOUBLE-FLOAT-P","ECL_NAME(si_negative_double_float_p)"},
symbols_list2.h:{EXT_ "POSITIVE-DOUBLE-FLOAT-P","ECL_NAME(si_positive_double_float_p)"},
symbols_list2.h:{EXT_ "NON-NEGATIVE-DOUBLE-FLOAT-P","ECL_NAME(si_non_negative_double_float_p)"},
symbols_list2.h:{EXT_ "NON-POSITIVE-DOUBLE-FLOAT-P","ECL_NAME(si_non_positive_double_float_p)"},
symbols_list2.h:{EXT_ "NEGATIVE-LONG-FLOAT",NULL},
symbols_list2.h:{EXT_ "NON-NEGATIVE-LONG-FLOAT",NULL},
symbols_list2.h:{EXT_ "NON-POSITIVE-LONG-FLOAT",NULL},
symbols_list2.h:{EXT_ "POSITIVE-LONG-FLOAT",NULL},
symbols_list2.h:{EXT_ "NEGATIVE-LONG-FLOAT-P","ECL_NAME(si_negative_long_float_p)"},
symbols_list2.h:{EXT_ "POSITIVE-LONG-FLOAT-P","ECL_NAME(si_positive_long_float_p)"},
symbols_list2.h:{EXT_ "NON-NEGATIVE-LONG-FLOAT-P","ECL_NAME(si_non_negative_long_float_p)"},
symbols_list2.h:{EXT_ "NON-POSITIVE-LONG-FLOAT-P","ECL_NAME(si_non_positive_long_float_p)"},
symbols_list2.h:{EXT_ "ARRAY-INDEX-P","ECL_NAME(si_array_index_p)"},
symbols_list2.h:{EXT_ "SEQUENCE-STREAM",NULL},
symbols_list2.h:{EXT_ "MAKE-SEQUENCE-INPUT-STREAM","si_make_sequence_input_stream"},
symbols_list2.h:{EXT_ "MAKE-SEQUENCE-OUTPUT-STREAM","si_make_sequence_output_stream"},
symbols_list2.h:{SYS_ "MISSING-KEYWORD",NULL},
symbols_list2.h:{EXT_ "HASH-TABLE-CONTENT","si_hash_table_content"},
symbols_list2.h:{EXT_ "HASH-TABLE-FILL","si_hash_table_fill"},
symbols_list2.h:{SYS_ "REPORT-FUNCTION",NULL},
symbols_list2.h:{SYS_ "DO-DEFSETF","ECL_NAME(si_do_defsetf)"},
symbols_list2.h:{SYS_ "DO-DEFINE-SETF-METHOD","ECL_NAME(si_do_define_setf_method)"},
symbols_list2.h:{SYS_ "SETF-DEFINITION","ECL_NAME(si_setf_definition)"},
symbols_list2.h:{EXT_ "ASSUME-NO-ERRORS",NULL},
symbols_list2.h:{EXT_ "ASSUME-TYPES-DONT-CHANGE",NULL},
symbols_list2.h:{EXT_ "CHECK-ARGUMENTS-TYPE",NULL},
symbols_list2.h:{EXT_ "INLINE-ACCESSORS",NULL},
symbols_list2.h:{EXT_ "INLINE-TYPE-CHECKS",NULL},
symbols_list2.h:{EXT_ "EVALUATE-FORMS",NULL},
symbols_list2.h:{EXT_ "TYPE-ASSERTIONS",NULL},
symbols_list2.h:{EXT_ "CHECK-STACK-OVERFLOW",NULL},
symbols_list2.h:{EXT_ "ARRAY-BOUNDS-CHECK",NULL},
symbols_list2.h:{KEY_ "KEY-AND-VALUE",NULL},
symbols_list2.h:{EXT_ "HASH-TABLE-WEAKNESS","si_hash_table_weakness"},
symbols_list2.h:{EXT_ "TRULY-THE",NULL},
symbols_list2.h:{EXT_ "CHECKED-VALUE",NULL},
symbols_list2.h:{EXT_ "INSTALL-BYTECODES-COMPILER",NULL},
symbols_list2.h:{EXT_ "INSTALL-C-COMPILER",NULL},
symbols_list2.h:{FFI_ "C-CHAR-BIT",NULL},
symbols_list2.h:{FFI_ "C-CHAR-MAX",NULL},
symbols_list2.h:{FFI_ "C-CHAR-MIN",NULL},
symbols_list2.h:{FFI_ "C-INT-MAX",NULL}, /* See main.d */
symbols_list2.h:{FFI_ "C-INT-MIN",NULL}, /* See main.d */
symbols_list2.h:{FFI_ "C-SHORT-MAX",NULL},
symbols_list2.h:{FFI_ "C-SHORT-MIN",NULL},
symbols_list2.h:{FFI_ "C-LONG-MAX",NULL}, /* See main.d */
symbols_list2.h:{FFI_ "C-LONG-MIN",NULL}, /* See main.d */
symbols_list2.h:{FFI_ "C-LONG-LONG-MAX",NULL}, /* See main.d */
symbols_list2.h:{FFI_ "C-UCHAR-MAX",NULL},
symbols_list2.h:{FFI_ "C-UINT-MAX",NULL}, /* See main.d */
symbols_list2.h:{FFI_ "C-USHORT-MAX",NULL},
symbols_list2.h:{FFI_ "C-ULONG-MAX",NULL}, /* See main.d */
symbols_list2.h:{FFI_ "C-ULONG-LONG-MAX",NULL}, /* See main.d */
symbols_list2.h:{FFI_ "C-LONG-LONG-BIT",NULL},
symbols_list2.h:{FFI_ "C-LONG-LONG-BIT",NULL},
symbols_list2.h:{FFI_ "*USE-DFFI*",NULL},
symbols_list2.h:{FFI_ "+NULL-CSTRING-POINTER+",NULL},
symbols_list2.h:{FFI_ "ALLOCATE-FOREIGN-OBJECT",NULL},
symbols_list2.h:{FFI_ "ALLOCATE-FOREIGN-STRING",NULL},
symbols_list2.h:{FFI_ "C-INLINE",NULL},
symbols_list2.h:{FFI_ "CHAR-ARRAY-TO-POINTER",NULL},
symbols_list2.h:{FFI_ "CONVERT-FROM-CSTRING",NULL},
symbols_list2.h:{FFI_ "CONVERT-FROM-FOREIGN-STRING",NULL},
symbols_list2.h:{FFI_ "CONVERT-TO-CSTRING",NULL},
symbols_list2.h:{FFI_ "CONVERT-TO-FOREIGN-STRING",NULL},
symbols_list2.h:{FFI_ "DEF-ARRAY",NULL},
symbols_list2.h:{FFI_ "DEF-ARRAY-POINTER",NULL},
symbols_list2.h:{FFI_ "DEF-CONSTANT",NULL},
symbols_list2.h:{FFI_ "DEF-ENUM",NULL},
symbols_list2.h:{FFI_ "DEF-FOREIGN-TYPE",NULL},
symbols_list2.h:{FFI_ "DEF-FOREIGN-VAR",NULL},
symbols_list2.h:{FFI_ "DEF-FUNCTION",NULL},
symbols_list2.h:{FFI_ "DEF-STRUCT",NULL},
symbols_list2.h:{FFI_ "DEF-TYPE",NULL},
symbols_list2.h:{FFI_ "DEF-UNION",NULL},
symbols_list2.h:{FFI_ "DEREF-ARRAY",NULL},
symbols_list2.h:{FFI_ "DEREF-POINTER",NULL},
symbols_list2.h:{FFI_ "ENSURE-CHAR-CHARACTER",NULL},
symbols_list2.h:{FFI_ "ENSURE-CHAR-INTEGER",NULL},
symbols_list2.h:{FFI_ "ENSURE-CHAR-STORABLE",NULL},
symbols_list2.h:{FFI_ "FIND-FOREIGN-LIBRARY",NULL},
symbols_list2.h:{FFI_ "FOREIGN-STRING-LENGTH",NULL},
symbols_list2.h:{FFI_ "FREE-CSTRING",NULL},
symbols_list2.h:{FFI_ "FREE-FOREIGN-OBJECT",NULL},
symbols_list2.h:{FFI_ "GET-SLOT-POINTER",NULL},
symbols_list2.h:{FFI_ "GET-SLOT-VALUE",NULL},
symbols_list2.h:{FFI_ "LOAD-FOREIGN-LIBRARY",NULL},
symbols_list2.h:{FFI_ "MAKE-NULL-POINTER",NULL},
symbols_list2.h:{FFI_ "MAKE-POINTER",NULL},
symbols_list2.h:{FFI_ "NULL-CHAR-P",NULL},
symbols_list2.h:{FFI_ "POINTER-ADDRESS",NULL},
symbols_list2.h:{FFI_ "SIZE-OF-FOREIGN-TYPE",NULL},
symbols_list2.h:{FFI_ "WITH-CAST-POINTER",NULL},
symbols_list2.h:{FFI_ "WITH-CSTRING",NULL},
symbols_list2.h:{FFI_ "WITH-CSTRINGS",NULL},
symbols_list2.h:{FFI_ "WITH-FOREIGN-OBJECT",NULL},
symbols_list2.h:{FFI_ "WITH-FOREIGN-OBJECTS",NULL},
symbols_list2.h:{FFI_ "WITH-FOREIGN-STRING",NULL},
symbols_list2.h:{FFI_ "WITH-FOREIGN-STRINGS",NULL},
symbols_list2.h:{SYS_ "BIND-SIMPLE-RESTARTS","ECL_NAME(si_bind_simple_restarts)"},
symbols_list2.h:{SYS_ "BIND-SIMPLE-HANDLERS","ECL_NAME(si_bind_simple_handlers)"},
tcp.d:/* -*- mode: c; c-basic-offset: 8 -*- */
tcp.d:/* tcp.c  -- stream interface to TCP					*/
tcp.d:  if ((inaddr.sin_addr.s_addr = inet_addr(host)) == -1) {
tcp.d:    if (host_ptr->h_addrtype != AF_INET) {
tcp.d:    inaddr.sin_family = host_ptr->h_addrtype;
tcp.d:    memcpy((char *)&inaddr.sin_addr, (char *)host_ptr->h_addr,
tcp.d:  if ((fd = socket((int) addr->sa_family, SOCK_STREAM, 0)) < 0)
tcp.d:  if (connect(fd, addr, addrlen) == -1) {
tcp.d:  /* Don't make this file-descriptor non-blocking
tcp.d:   @open-client-stream --
tcp.d:   (setq s (si:open-client-stream "host" 13))
tcp.d:   (read-line s)
tcp.d:           FEwrong_type_nth_arg(@[si::open-client-stream], 2, port,
tcp.d:   if (host->base_string.fillp > BUFSIZ - 1)
tcp.d:   fd = connect_to_server((char*)host->base_string.self, ecl_fixnum(port)); 
tcp.d:           FEwrong_type_only_arg(@[si::open-client-stream], port,
tcp.d:                FEwrong_type_nth_arg(@[si::open-unix-socket-stream], 1, path,
tcp.d:	if (path->base_string.fillp > UNIX_MAX_PATH-1)
tcp.d:	memcpy(addr.sun_path, path->base_string.self, path->base_string.fillp);
tcp.d:	addr.sun_path[path->base_string.fillp] = 0;
tcp.d:		he = gethostbyname((char*)host_or_address->base_string.self);
tcp.d:		FEerror("LOOKUP-HOST-ENTRY: Number or string expected, got ~S",
tcp.d:	name = make_base_string_copy(he->h_name);
tcp.d:	for (i = 0; he->h_aliases[i] != 0; i++)
tcp.d:		aliases = CONS(make_base_string_copy(he->h_aliases[i]), aliases);
tcp.d:	for (i = 0; he->h_addr_list[i]; i++) {
tcp.d:		unsigned long *s = (unsigned long*)(he->h_addr_list[i]);
time.d:/* -*- mode: c; c-basic-offset: 8 -*- */
time.d:    time.c -- Time routines.
time.d:	tv->tv_usec = aux.tv_usec;
time.d:	tv->tv_sec = aux.tv_sec;
time.d:	tv->tv_sec = system_time.hundred_ns / 1000;
time.d:	tv->tv_usec = (system_time.hundred_ns % 1000) * 1000;
time.d:	tv->tv_sec = time_t;
time.d:	tv->tv_usec = 0;
time.d:	tv->tv_usec = r.ru_utime.tv_usec;
time.d:	tv->tv_sec = r.ru_utime.tv_sec;
time.d:	tv->tv_sec = buf.tms_utime / CLK_TCK;
time.d:	tv->tv_usec = (buf.tms_utime % CLK_TCK) * 1000000;
time.d:	tv->tv_sec = kernel_time.hundred_ns / 1000;
time.d:	tv->tv_usec = (kernel_time.hundred_ns % 1000) * 1000;
time.d:	tm.tv_nsec = (long)((time - floor(time)) * 1e9);
time.d:	 * and has to be converted to 100ns (1e-3 / 100e-9 = 1e4) */
time.d:			wait -= maxtime;
time.d:					wait = end.hundred_ns - now.hundred_ns;
time.d:	for (t = (time + 0.5); t > 1000; t -= 1000)
time.d:		cl_error(9, @'simple-type-error', @':format-control',
time.d:			    make_constant_base_string("Not a non-negative number ~S"),
time.d:			    @':format-arguments', cl_list(1, z),
time.d:			    @':expected-type', @'real', @':datum', z);
time.d:                } else if (time < 1e-9) {
time.d:                        time = 1e-9;
time.d:	return timeval_to_time(tv.tv_sec - beginning.tv_sec,
time.d:			       tv.tv_usec - beginning.tv_usec);
time.d:	ECL_SET(@'internal-time-units-per-second', ecl_make_fixnum(1000));
typespec.d:/* -*- mode: c; c-basic-offset: 8 -*- */
typespec.d:    typespec.c -- Type specifier routines.
typespec.d:	cl_error(9, @'simple-type-error', @':format-control',
typespec.d:		    @':format-arguments', cl_list(1, x),
typespec.d:		    @':expected-type', ecl_read_from_cstring("si::proper-list"),
typespec.d:	ecl_bds_bind(ecl_process_env(), @'*print-circle*', ECL_T);
typespec.d:	cl_error(9, @'simple-type-error', @':format-control',
typespec.d:		    @':format-arguments', cl_list(1, x),
typespec.d:		    @':expected-type', @'list',
typespec.d:	cl_index l = ECL_INSTANCEP(seq)? seq->instance.length : ecl_length(seq);
typespec.d:	cl_error(9, @'simple-type-error', @':format-control',
typespec.d:		    @':format-arguments', cl_list(2, n, seq),
typespec.d:		    @':expected-type', cl_list(3, @'integer', ecl_make_fixnum(0), ecl_make_fixnum(l-1)),
typespec.d:		return @'single-float';
typespec.d:		return @'double-float';
typespec.d:		return @'long-float';
typespec.d:		return @'hash-table';
typespec.d:		return @'bit-vector';
typespec.d:		return @'base-string';
typespec.d:		return @'random-state';
typespec.d:		return @'compiled-function';
typespec.d:		return @'mp::condition-variable';
typespec.d:		return @'si::code-block';
typespec.d:		return @'si::foreign-data';
typespec.d:		return @'ext::weak-pointer';
typespec.d:		return @'ext::sse-pack';
typespec.d:			t = @'standard-char';
typespec.d:			t = @'base-char';
typespec.d:		else if (x->symbol.hpack == cl_core.keyword_package)
typespec.d:		    !Null(CAR(x->array.displaced)))
typespec.d:			t = @'simple-array';
typespec.d:		    !Null(CAR(x->vector.displaced))) {
typespec.d:				    ecl_make_fixnum(x->vector.dim));
typespec.d:			   (cl_elttype)x->vector.elttype != ecl_aet_object) {
typespec.d:			t = cl_list(3, @'simple-array',
typespec.d:			t = cl_list(2, @'simple-vector', ecl_make_fixnum(x->vector.dim));
typespec.d:		    !Null(CAR(x->string.displaced)))
typespec.d:			t = @'simple-array';
typespec.d:		t = cl_list(3, t, @'character', cl_list(1, ecl_make_fixnum(x->string.dim)));
typespec.d:		    !Null(CAR(x->base_string.displaced)))
typespec.d:			t = @'simple-array';
typespec.d:		t = cl_list(3, t, @'base-char', cl_list(1, ecl_make_fixnum(x->base_string.dim)));
typespec.d:		    !Null(CAR(x->vector.displaced)))
typespec.d:			t = @'simple-array';
typespec.d:		t = cl_list(3, t, @'bit', cl_list(1, ecl_make_fixnum(x->vector.dim)));
typespec.d:		t = x->str.name; break;
typespec.d:		switch (x->stream.mode) {
typespec.d:		case ecl_smm_synonym:	t = @'synonym-stream'; break;
typespec.d:		case ecl_smm_broadcast:	t = @'broadcast-stream'; break;
typespec.d:		case ecl_smm_concatenated:	t = @'concatenated-stream'; break;
typespec.d:		case ecl_smm_two_way:	t =  @'two-way-stream'; break;
typespec.d:		case ecl_smm_string_output:	t = @'string-stream'; break;
typespec.d:		case ecl_smm_echo:		t = @'echo-stream'; break;
typespec.d:                case ecl_smm_sequence_output: t = @'ext::sequence-stream'; break;
typespec.d:		default:		t = @'file-stream'; break;
typespec.d:		t = x->pathname.logical? @'logical-pathname' : @'pathname';
typespec.d:		t = @'ext::sse-pack';
unify.d:/* -*- mode: c; c-basic-offset: 8 -*- */
unify.d:    unify.d -- Support for unification.
unify.d:/* -------------------- Trail Instructions -------------------- */
unify.d:/* -------------------- Mode Operators -------------------- */
unify.d:/* -------------------- Get Instructions -------------------- */
unify.d:	  slot = x->instance.slots;
unify.d:	    slot = new->instance.slots;
unify.d:/* -------------------- Unify Instructions --------------------  */
unify.d:  /* NOTE: x <- y */
unify.d:	   int l = x->instance.length; int i;
unify.d:	   object *slotx = x->instance.slots;
unify.d:	   object *sloty = y->instance.slots;
unify.d:/* -------------------- Test Functions -------------------- */
unify.d:/* (defmacro unify-variable (v) `(progn (setq ,v (si:unify-slot)) t) */
unify.d:	   x->symbol.mflag = TRUE; \
unify.d:	make_si_macro("UNIFY-VARIABLE", Lunify_variable);
unixfsys.d:/* -*- mode: c; c-basic-offset: 8 -*- */
unixfsys.d:    unixfsys.c  -- Unix file system interface.
unixfsys.d:#include <ecl/ecl-inl.h>
unixfsys.d:		return safe_chdir((char *)aux->base_string.self, ECL_NIL);
unixfsys.d:	cl_object device = pathname->pathname.device;
unixfsys.d:	cl_object host = pathname->pathname.host;
unixfsys.d:		output->base_string.self[0] = device->base_string.self[0];
unixfsys.d:	cl_object string = ecl_make_simple_base_string(s, -1);
unixfsys.d:		ok = getcwd((char*)output->base_string.self, size);
unixfsys.d:	size = strlen((char*)output->base_string.self);
unixfsys.d:	if ((size + 1 /* / */ + 1 /* 0 */) >= output->base_string.dim) {
unixfsys.d:		strcpy((char*)other->base_string.self, (char*)output->base_string.self);
unixfsys.d:	for (c = output->base_string.self; *c; c++)
unixfsys.d:	if (output->base_string.self[size-1] != '/') {
unixfsys.d:		output->base_string.self[size++] = '/';
unixfsys.d:		output->base_string.self[size] = 0;
unixfsys.d:	output->base_string.fillp = size;
unixfsys.d:	if (dw == -1)
unixfsys.d:	@(return file_kind((char*)filename->base_string.self, !Null(follow_links)))
unixfsys.d:		written = readlink((char*)filename->base_string.self,
unixfsys.d:				   (char*)output->base_string.self, size);
unixfsys.d:	output->base_string.self[written] = '\0';
unixfsys.d:	kind = file_kind((char*)output->base_string.self, FALSE);
unixfsys.d:		output->base_string.self[written++] = '/';
unixfsys.d:		output->base_string.self[written] = '\0';
unixfsys.d:	output->base_string.fillp = written;
unixfsys.d:         * path -- resolving any links in the process. */
unixfsys.d:        aux = ecl_append(base_dir->pathname.directory, ecl_list1(aux));
unixfsys.d:        aux->base_string.self[aux->base_string.fillp-1] = 0;
unixfsys.d:        kind = file_kind((char*)aux->base_string.self, FALSE);
unixfsys.d:                if (output->pathname.name != ECL_NIL ||
unixfsys.d:                    output->pathname.type != ECL_NIL)
unixfsys.d:                cl_object newdir= output->pathname.directory;
unixfsys.d:                output->pathname.directory = newdir;
unixfsys.d:        return ecl_make_pathname(pathname->pathname.host,
unixfsys.d:				 pathname->pathname.device,
unixfsys.d:        kind = file_kind((char*)filename->base_string.self, FALSE);
unixfsys.d:		pathname = ecl_make_pathname(pathname->pathname.host,
unixfsys.d:					     pathname->pathname.device,
unixfsys.d:					     pathname->pathname.directory,
unixfsys.d:                   separator and re-parsing again the namestring */
unixfsys.d:                if (pathname->pathname.name != ECL_NIL ||
unixfsys.d:                    pathname->pathname.type != ECL_NIL) {
unixfsys.d:        if (pathname->pathname.name == ECL_NIL &&
unixfsys.d:            pathname->pathname.type == ECL_NIL) {
unixfsys.d:                pathname->pathname.version = ECL_NIL;
unixfsys.d:                pathname->pathname.version = @':newest';
unixfsys.d:        for (dir = pathname->pathname.directory; !Null(dir); dir = ECL_CONS_CDR(dir))
unixfsys.d:                             ecl_make_constant_base_string(backupfilename,-1));
unixfsys.d:			     ecl_make_constant_base_string(filename,-1),
unixfsys.d:                             ecl_make_constant_base_string(backupfilename,-1));
unixfsys.d:@(defun rename-file (oldn newn &key (if_exists @':error'))
unixfsys.d:				(6, @'file-error', /* condition */
unixfsys.d:				 @':pathname', /* file-error options */
unixfsys.d:		FEerror("~S is an illegal IF-EXISTS option for RENAME-FILE.",
unixfsys.d:		if (MoveFile((char*)old_filename->base_string.self,
unixfsys.d:			     (char*)new_filename->base_string.self)) {
unixfsys.d:		if (MoveFileEx((char*)old_filename->base_string.self,
unixfsys.d:			       (char*)new_filename->base_string.self,
unixfsys.d:		chmod((char*)old_filename->base_string.self, 0777);
unixfsys.d:		chmod((char*)new_filename->base_string.self, 0777);
unixfsys.d:		SetFileAttributesA((char*)new_filename->base_string.self,
unixfsys.d:		SetFileAttributesA((char*)new_filename->base_string.self,
unixfsys.d:		if (MoveFile((char*)old_filename->base_string.self,
unixfsys.d:			     (char*)new_filename->base_string.self)) {
unixfsys.d:		(void)DeleteFileA((char*)new_filename->base_string.self);
unixfsys.d:		if (MoveFile((char*)old_filename->base_string.self,
unixfsys.d:			     (char*)new_filename->base_string.self)) {
unixfsys.d:		if (rename((char*)old_filename->base_string.self,
unixfsys.d:			   (char*)new_filename->base_string.self) == 0) {
unixfsys.d:			(6, @'file-error', /* condition */
unixfsys.d:			 @':pathname', /* file-error options */
unixfsys.d:        return (path->pathname.name == ECL_NIL) &&
unixfsys.d:                (path->pathname.type == ECL_NIL);
unixfsys.d:        ok = (isdir? rmdir : unlink)((char*)filename->base_string.self);
unixfsys.d:			(6, @'file-error', /* condition */
unixfsys.d:			 @':pathname', /* file-error options */
unixfsys.d:	/* INV: Both SI:FILE-KIND and TRUENAME complain if "file" has wildcards */
unixfsys.d:	if (safe_stat((char*)filename->base_string.self, &filestatus) < 0) {
unixfsys.d:	if (safe_stat((char*)filename->base_string.self, &filestatus) < 0) {
unixfsys.d:			(6, @'file-error', /* condition */
unixfsys.d:			 @':pathname', /* file-error options */
unixfsys.d:		output = make_base_string_copy(pwent->pw_name);
unixfsys.d:		p = (char*)user->base_string.self;
unixfsys.d:		i = user->base_string.fillp;
unixfsys.d:			i--;
unixfsys.d:		namestring = make_base_string_copy(pwent->pw_dir);
unixfsys.d:	if (namestring->base_string.self[0] == '~') {
unixfsys.d:	i = namestring->base_string.fillp;
unixfsys.d:	if (!IS_DIR_SEPARATOR(namestring->base_string.self[i-1]))
unixfsys.d: * true, the list is made of only the directories -- a propert which is checked
unixfsys.d:	dir = opendir((char*)prefix->base_string.self);
unixfsys.d:		text = entry->d_name;
unixfsys.d:			hFind = FindFirstFile((char*)mask->base_string.self, &fd);
unixfsys.d:	fp = fopen((char*)prefix->base_string.self, OPEN_R);
unixfsys.d:	cl_object name = pathname->pathname.name;
unixfsys.d:	cl_object type = pathname->pathname.type;
unixfsys.d:                                 name, type, pathname->pathname.version,
unixfsys.d:	} else if (item == @':wild-inferiors') {
unixfsys.d:		 * 2.2) If CAR(DIRECTORY) is :WILD-INFERIORS, we have to do
unixfsys.d:	output = dir_recursive(base_dir, mask->pathname.directory, mask,
unixfsys.d:		ECL_SETQ(the_env, @'*default-pathname-defaults*', output);
unixfsys.d:        buffer = (char*)s->base_string.self;
unixfsys.d:	len = GetModuleFileName(hnd, buffer, cl_core.path_max-1);
unixfsys.d:	s->base_string.fillp = len;
unixfsys.d:	if (directory->pathname.name != ECL_NIL ||
unixfsys.d:	    directory->pathname.type != ECL_NIL)
unixfsys.d:	if (safe_chdir((char*)namestring->base_string.self, ECL_NIL) < 0) {
unixfsys.d:			(6, @'file-error', /* condition */
unixfsys.d:			 @':pathname', /* file-error options */
unixfsys.d:		ECL_SETQ(the_env, @'*default-pathname-defaults*', directory);
unixfsys.d:		cl_index last = filename->base_string.fillp;
unixfsys.d:			ecl_character c = filename->base_string.self[last-1];
unixfsys.d:				last--;
unixfsys.d:	ok = mkdir((char*)filename->base_string.self);
unixfsys.d:	ok = mkdir((char*)filename->base_string.self, modeint);
unixfsys.d:			(6, @'file-error', /* condition */
unixfsys.d:			 @':pathname', /* file-error options */
unixfsys.d:	l = dir->base_string.fillp;
unixfsys.d:	memcpy(strTempDir, dir->base_string.self, l);
unixfsys.d:	ok = GetTempFileName(strTempDir, (char*)file->base_string.self, 0,
unixfsys.d:		memcpy(output->base_string.self, strTempFileName, l);
unixfsys.d:	l = template->base_string.fillp;
unixfsys.d:	memcpy(output->base_string.self, template->base_string.self, l);
unixfsys.d:	memcpy(output->base_string.self + l, "XXXXXX", 6);
unixfsys.d:	fd = mkstemp((char*)output->base_string.self);
unixfsys.d:	if (mktemp((char*)output->base_string.self)) {
unixfsys.d:		fd = open((char*)output->base_string.self, O_CREAT|O_TRUNC, 0666);
unixfsys.d:		fd = -1;
unixfsys.d:	in = fopen((char*)orig->base_string.self, OPEN_R);
unixfsys.d:		out = fopen((char*)dest->base_string.self, OPEN_W);
unixfsys.d:	unlikely_if (chmod((char*)filename->base_string.self, code)) {
unixfsys.d:			(6, @'file-error', /* condition */
unixfsys.d:			 @':pathname', /* file-error options */
unixint.d:/* -*- mode: c; c-basic-offset: 8 -*- */
unixint.d:    unixint.c -- Unix interrupt interface.
unixint.d: * function call, resolving thread-local variables, etc, etc, and it
unixint.d: * hander which reads a single, thread-local variable stored in the
unixint.d: * ecl_process_env()->disable_interrupts. If the variable marks that
unixint.d:#include <ecl/ecl-inl.h>
unixint.d:	{ SIGINT, "+SIGINT+", @'si::terminal-interrupt'},
unixint.d:	{ SIGILL, "+SIGILL+", @'ext::illegal-instruction'},
unixint.d:	{ SIGBUS, "+SIGBUS+", @'ext::segmentation-violation'},
unixint.d:	{ SIGSEGV, "+SIGSEGV+", @'ext::segmentation-violation'},
unixint.d:	{ SIGCHLD, "+SIGCHLD+", @'si::wait-for-all-processes'},
unixint.d:	{ -1, "", ECL_NIL }
unixint.d:		cl_object process = the_env->own_process;
unixint.d:		return (process->process.phase == ECL_PROCESS_INACTIVE);
unixint.d:	return the_env->disable_interrupts;
unixint.d:		Null(ECL_SYM_VAL(the_env, @'ext::*interrupts-enabled*'));
unixint.d:	pthread_sigmask(SIG_SETMASK, the_env->default_sigmask, NULL);
unixint.d:	sigprocmask(SIG_SETMASK, the_env->default_sigmask, NULL);
unixint.d:                cl_cerror(4, str_ignore_signal, @'ext::unix-signal-received',
unixint.d:	while (env->pending_interrupt != ECL_NIL) {
unixint.d:		handle_signal_now(pop_signal(env), env->own_process);
unixint.d:	ECL_WITH_SPINLOCK_BEGIN(env, &env->signal_queue_spinlock) {
unixint.d:			record = env->signal_queue;
unixint.d:				env->signal_queue = ECL_CONS_CDR(record);
unixint.d:			env->pending_interrupt =
unixint.d:				ecl_nconc(env->pending_interrupt,
unixint.d:	if (env->pending_interrupt == ECL_NIL) {
unixint.d:	ECL_WITH_SPINLOCK_BEGIN(env, &env->signal_queue_spinlock) {
unixint.d:		record = env->pending_interrupt;
unixint.d:		env->pending_interrupt = ECL_CONS_CDR(record);
unixint.d:			ECL_RPLACD(record, env->signal_queue);
unixint.d:			env->signal_queue = record;
unixint.d:		the_env->disable_interrupts = 3;
unixint.d:                handle_signal_now(signal_code, the_env->own_process);
unixint.d:        handle_signal_now(signal_object, the_env->own_process);
unixint.d:static int signal_thread_pipe[2] = {-1,-1};
unixint.d:	msg.process = the_env->own_process;
unixint.d:	int interrupt_signal = -1;
unixint.d:			    signal_thread_msg.process != the_env->own_process)
unixint.d:		    signal_thread_msg.process == the_env->own_process) {
unixint.d:			mp_process_run_function(4, @'si::handle-signal',
unixint.d:						@'si::handle-signal',
unixint.d:	if (!Null(the_env->pending_interrupt)) {
unixint.d:	condition = @'arithmetic-error';
unixint.d:		condition = @'floating-point-invalid-operation';
unixint.d:		condition = @'floating-point-overflow';
unixint.d:		condition = @'floating-point-underflow';
unixint.d:		condition = @'division-by-zero';
unixint.d:		condition = @'division-by-zero';
unixint.d:		condition = @'floating-point-invalid-operation';
unixint.d:		condition = @'floating-point-overflow';
unixint.d:		condition = @'floating-point-underflow';
unixint.d:		condition = @'floating-point-inexact';
unixint.d:		if (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV) {
unixint.d:			condition = @'division-by-zero';
unixint.d:		} else if (info->si_code == FPE_FLTOVF) {
unixint.d:			condition = @'floating-point-overflow';
unixint.d:		} else if (info->si_code == FPE_FLTUND) {
unixint.d:			condition = @'floating-point-underflow';
unixint.d:		} else if (info->si_code == FPE_FLTRES) {
unixint.d:			condition = @'floating-point-inexact';
unixint.d:		} else if (info->si_code == FPE_FLTINV) {
unixint.d:			condition = @'floating-point-invalid-operation';
unixint.d:	  if (code && !(code & the_env->trap_fpe_bits))
unixint.d:	handle_signal_now(condition, the_env->own_process);
unixint.d:	if (((char*)the_env <= (char*)info->si_addr) &&
unixint.d:            ((char*)info->si_addr <= (char*)(the_env+1)))
unixint.d:                the_env->disable_interrupts = 0;
unixint.d:	    (char*)info->si_addr > the_env->cs_barrier &&
unixint.d:	    (char*)info->si_addr <= the_env->cs_org) {
unixint.d:	    (char*)info->si_addr < the_env->cs_barrier &&
unixint.d:	    (char*)info->si_addr >= the_env->cs_org) {
unixint.d:	if (the_env->fault_address == info->si_addr) {
unixint.d:		the_env->fault_address = info->si_addr;
unixint.d:		the_env->fault_address = info->si_addr;
unixint.d:		handle_or_queue(the_env, @'ext::segmentation-violation', sig);
unixint.d:			cl_env_ptr env = process->process.env;
unixint.d:			sigset_t *handled_set = (sigset_t *)env->default_sigmask;
unixint.d:		FEerror("Unknown 2nd argument to EXT:CATCH-SIGNAL: ~A", 1,
unixint.d:@(defun ext::catch-signal (code flag &key process)
unixint.d:		FEerror("The signal handler for SIGPFE cannot be uninstalled. Use SI:TRAP-FPE instead.", 0);
unixint.d:	volatile i = env->nvalues;
unixint.d:	env->nvalues = i;
unixint.d:        HANDLE thread = (HANDLE)process->process.thread;
unixint.d:        void *trap_address = process->process.env;
unixint.d:        if (SuspendThread(thread) == (DWORD)-1) {
unixint.d:        process->process.interrupt = ECL_T;
unixint.d:        if (!VirtualProtect(process->process.env,
unixint.d:	if (ResumeThread(thread) == (DWORD)-1)  {
unixint.d:        if (pthread_kill(process->process.thread, signal)) {
unixint.d:         * - In Windows it sets up a trap in the stack, so that the
unixint.d:         * - In POSIX systems it sends a user level interrupt to
unixint.d:	    (process->process.phase >= ECL_PROCESS_BOOTING))
unixint.d:		queue_signal(process->process.env, function, 1);
unixint.d:	if (process->process.phase == ECL_PROCESS_ACTIVE)
unixint.d:        HANDLE thread = (HANDLE)process->process.thread;
unixint.d:	switch (ep->ExceptionRecord->ExceptionCode)
unixint.d:                        cl_object process = the_env->own_process;
unixint.d:                        if (!Null(process->process.interrupt)) {
unixint.d:                                process->process.interrupt = ECL_NIL;
unixint.d:                                        handle_signal_now(signal, the_env->own_process);
unixint.d:                        handle_signal_now(@'division-by-zero', the_env->own_process);
unixint.d:                        handle_signal_now(@'arithmetic-error', the_env->own_process);
unixint.d:                        handle_signal_now(@'floating-point-overflow', the_env->own_process);
unixint.d:                        handle_signal_now(@'floating-point-overflow', the_env->own_process);
unixint.d:                        handle_signal_now(@'floating-point-underflow', the_env->own_process);
unixint.d:                        handle_signal_now(@'floating-point-inexact', the_env->own_process);
unixint.d:                        handle_signal_now(@'floating-point-invalid-operation', the_env->own_process);
unixint.d:                        handle_signal_now(@'arithmetic-error', the_env->own_process);
unixint.d:                        handle_signal_now(@'ext::segmentation-violation', the_env->own_process);
unixint.d:			handle_signal_now(@'ext::illegal-instruction', the_env->own_process);
unixint.d:	int outside_ecl = ecl_import_current_thread(@'si::handle-signal', ECL_NIL);
unixint.d:	mp_process_run_function(4, @'si::handle-signal',
unixint.d:				@'si::handle-signal',
unixint.d:		/* Catch CTRL-C */
unixint.d:		cl_object function = ECL_SYM_FUN(@'si::terminal-interrupt');
unixint.d:				mp_process_run_function(3, @'si::handle-signal',
unixint.d:							@'si::handle-signal',
unixint.d:		bits = the_env->trap_fpe_bits;
unixint.d:		else if (condition == @'division-by-zero')
unixint.d:                else if (condition == @'floating-point-overflow')
unixint.d:                else if (condition == @'floating-point-underflow')
unixint.d:                else if (condition == @'floating-point-invalid-operation')
unixint.d:                else if (condition == @'floating-point-inexact')
unixint.d:                        bits = the_env->trap_fpe_bits & ~bits;
unixint.d:                        bits = the_env->trap_fpe_bits | bits;
unixint.d:        the_env->trap_fpe_bits = bits;
unixint.d: * In this code we decide whether to install a process-wide signal
unixint.d:        ecl_process_env()->default_sigmask = &main_thread_sigmask;
unixint.d:				      @'si::signal-servicing',
unixint.d:                                                     @'si::signal-servicing',
unixint.d:	/* In order to implement MP:INTERRUPT-PROCESS, MP:PROCESS-KILL
unixint.d:                sigdelset(ecl_process_env()->default_sigmask, signal);
unixint.d:                pthread_sigmask(SIG_SETMASK, ecl_process_env()->default_sigmask, NULL);
unixint.d:		si_trap_fpe(@'floating-point-invalid-operation', ECL_NIL);
unixint.d:		si_trap_fpe(@'division-by-zero', ECL_NIL);
unixint.d:		si_trap_fpe(@'floating-point-overflow', ECL_NIL);
unixint.d:		sprintf(buffer, "+SIGRT%d+", i-SIGRTMIN);
unixint.d:		ECL_SET(@'ext::*interrupts-enabled*', ECL_T);
unixint.d:		ecl_process_env()->disable_interrupts = 0;
unixsys.d:/* -*- mode: c; c-basic-offset: 8 -*- */
unixsys.d:    unixsys.s  -- Unix shell interface.
unixsys.d:#include <ecl/ecl-inl.h>
unixsys.d:ecl_def_ct_base_string(fake_in_name, "PIPE-READ-ENDPOINT", 18, static, const);
unixsys.d:ecl_def_ct_base_string(fake_out_name, "PIPE-WRITE-ENDPOINT", 19, static, const);
unixsys.d:                        FEerror("In EXT:RUN-PROGRAM, environment "
unixsys.d:                        FEerror("In EXT:RUN-PROGRAM, environment "
unixsys.d:                total_size += s->base_string.fillp + 1;
unixsys.d:                cl_index l = s->base_string.fillp;
unixsys.d:                        FEerror("In EXT:RUN-PROGRAM, environment list"
unixsys.d:                environ[j++] = (char*)(buffer->base_string.self + i);
unixsys.d:                memcpy(buffer->base_string.self + i,
unixsys.d:                       s->base_string.self,
unixsys.d:                buffer->base_string.self[i++] = 0;
unixsys.d:        buffer->base_string.self[i++] = 0;
unixsys.d:        return _ecl_funcall1(@'ext::make-external-process');
unixsys.d:        return ecl_structure_ref(p, @'ext::external-process', 0);
unixsys.d:        return ecl_structure_ref(p, @'ext::external-process', 3);
unixsys.d:        return ecl_structure_ref(p, @'ext::external-process', 4);
unixsys.d:        ecl_structure_set(process, @'ext::external-process', 0, pid);
unixsys.d:        ecl_structure_set(process, @'ext::external-process', 1, input);
unixsys.d:        ecl_structure_set(process, @'ext::external-process', 2, output);
unixsys.d:        ecl_structure_set(process, @'ext::external-process', 0, ECL_NIL);
unixsys.d:        ecl_structure_set(process, @'ext::external-process', 4, code);
unixsys.d:        ecl_structure_set(process, @'ext::external-process', 3, status);
unixsys.d:                pid->foreign.data = NULL;
unixsys.d:@(defun si::wait-for-all-processes (&key (process ECL_NIL))
unixsys.d:                cl_object status = ecl_waitpid(ecl_make_fixnum(-1), ECL_NIL);
unixsys.d:                cl_object code = env->values[1];
unixsys.d:                cl_object pid = env->values[2];
unixsys.d:                HANDLE *ph = (HANDLE*)h->foreign.data;
unixsys.d:        cl_object foreign = ecl_allocate_foreign_data(@':pointer-void',
unixsys.d:        HANDLE *ph = (HANDLE*)foreign->foreign.data;
unixsys.d:        si_set_finalizer(foreign, @'si::close-windows-handle');
unixsys.d:@(defun ext::external-process-wait (process &optional (wait ECL_NIL))
unixsys.d:	switch ((enum ecl_smmode)s->stream.mode) {
unixsys.d:@(defun ext::run-program (command argv &key (input @':stream') (output @':stream')
unixsys.d:	argv = cl_mapcar(2, @'si::copy-to-simple-base-string', argv);
unixsys.d:			  ecl_make_simple_base_string("~S~{ ~S~}", -1),
unixsys.d:                env = env_buffer->base_string.self;
unixsys.d:                                        (0, -1, tmp, S_IRWXU, GENERIC_WRITE);
unixsys.d:		input = ecl_symbol_value(@'*standard-input*');
unixsys.d:                        FEerror(":INPUT argument to RUN-PROGRAM does not "
unixsys.d:                                @':if-does-not-exist', @':error');
unixsys.d:                FEerror("Invalid :INPUT argument to EXT:RUN-PROGRAM", 1,
unixsys.d:                                        (0, -1, tmp, S_IRWXU, GENERIC_READ);
unixsys.d:		output = ecl_symbol_value(@'*standard-output*');
unixsys.d:                                 @':if-exists', if_output_exists,
unixsys.d:                                 @':if-does-not-exist', @':create');
unixsys.d:                        FEerror(":OUTPUT argument to RUN-PROGRAM does not "
unixsys.d:                FEerror("Invalid :OUTPUT argument to EXT:RUN-PROGRAM", 1,
unixsys.d:		error = ecl_symbol_value(@'*error-output*');
unixsys.d:                        FEerror(":ERROR argument to RUN-PROGRAM does not "
unixsys.d:                FEerror("Invalid :ERROR argument to EXT:RUN-PROGRAM:~%~S", 1,
unixsys.d:	ok = CreateProcess(NULL, command->base_string.self,
unixsys.d:	ok = CreateProcess(NULL, command->base_string.self,
unixsys.d:                input = ecl_symbol_value(@'*standard-input*');
unixsys.d:                        FEerror(":INPUT argument to RUN-PROGRAM does not "
unixsys.d:                                @':if-does-not-exist', @':error');
unixsys.d:                FEerror("Invalid :INPUT argument to EXT:RUN-PROGRAM:~%~S", 1,
unixsys.d:                output = ecl_symbol_value(@'*standard-output*');
unixsys.d:                                 @':if-exists', if_output_exists,
unixsys.d:                                 @':if-does-not-exist', @':create');
unixsys.d:                        FEerror(":OUTPUT argument to RUN-PROGRAM does not "
unixsys.d:                FEerror("Invalid :OUTPUT argument to EXT:RUN-PROGRAM:~%~S", 1,
unixsys.d:		error = ecl_symbol_value(@'*error-output*');
unixsys.d:                        FEerror(":ERROR argument to RUN-PROGRAM does not "
unixsys.d:                FEerror("Invalid :ERROR argument to EXT:RUN-PROGRAM:~%~S", 1,
unixsys.d:		void **argv_ptr = (void **)argv->vector.self.t;
unixsys.d:		for (j = 0; j < argv->vector.fillp; j++) {
unixsys.d:			cl_object arg = argv->vector.self.t[j];
unixsys.d:				argv_ptr[j] = arg->base_string.self;
unixsys.d:                        execve((char*)command->base_string.self, argv_ptr, pstrings);
unixsys.d:                        execvp((char*)command->base_string.self, argv_ptr);
unixsys.d:		 * set_external_process_pid() and our call to external-process-wait
vector_push.d:/* -*- mode: c; c-basic-offset: 8 -*- */
vector_push.d:    string.d -- String routines.
vector_push.d:		FEwrong_type_nth_arg(@[vector-push-extend],1,v,@[vector]);
vector_push.d:		FEerror("vector-push-extend: the array ~S is not adjustable.",
vector_push.d:	if (v->vector.dim >= ECL_ARRAY_DIMENSION_LIMIT)
vector_push.d:		amount = v->vector.dim / 2 + 1;
vector_push.d:	new_length = v->vector.dim + amount;
vector_push.d:			       ecl_make_fixnum(v->vector.fillp),
vector_push.d:	ecl_copy_subarray(other, 0, v, 0, v->vector.fillp);
vector_push.d:		   byte-compatible except for the data. */
vector_push.d:		if (s->base_string.fillp >= s->base_string.dim) {
vector_push.d:		ecl_char_set(s, s->base_string.fillp++, c);
vector_push.d:                FEwrong_type_nth_arg(@[vector-push-extend],1,s,@[string]);
vector_push.d:	if (f >= v->vector.dim) {
vector_push.d:		ecl_aset1(v, v->vector.fillp, value);
vector_push.d:		@(return ecl_make_fixnum(v->vector.fillp++));
vector_push.d:@(defun vector-push-extend (value v &optional (extent ecl_make_fixnum(0)))
vector_push.d:	if (f >= v->vector.dim) {
vector_push.d:	ecl_aset1(v, v->vector.fillp, value);
vector_push.d:	@(return ecl_make_fixnum(v->vector.fillp++));
