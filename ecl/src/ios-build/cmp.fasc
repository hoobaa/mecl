(#Y(si::bytecodes nil nil (15 0 75 17 1 29) #A(t (2) ("CL" ext::package-lock)) #1=#P"/Users/strobolights/dev/mecl/ecl/src/ios-build/compile.lsp" 0) #Y(si::bytecodes nil nil (15 0 15 1 77 15 2 77 77 15 3 77 15 4 77 19 10 5 29) #A(t (6) ("C" ("COMPILER") ("FFI" "EXT" "MP" "CL") ("*COMPILER-BREAK-ENABLE*" "*COMPILE-PRINT*" "*COMPILE-TO-LINKING-CALL*" "*COMPILE-VERBOSE*" "*COMPILER-FEATURES*" "*CC*" "*CC-OPTIMIZE*" "*USER-CC-FLAGS*" "*USER-LD-FLAGS*" "*SUPPRESS-COMPILER-NOTES*" "*SUPPRESS-COMPILER-WARNINGS*" "*SUPPRESS-COMPILER-MESSAGES*" "BUILD-ECL" "BUILD-PROGRAM" "BUILD-FASL" "BUILD-STATIC-LIBRARY" "BUILD-SHARED-LIBRARY" "COMPILER-WARNING" "COMPILER-NOTE" "COMPILER-MESSAGE" "COMPILER-ERROR" "COMPILER-FATAL-ERROR" "COMPILER-INTERNAL-ERROR" "COMPILER-UNDEFINED-VARIABLE" "COMPILER-MESSAGE-FILE" "COMPILER-MESSAGE-FILE-POSITION" "COMPILER-MESSAGE-FORM" "*SUPPRESS-COMPILER-WARNINGS*" "*SUPPRESS-COMPILER-NOTES*" "*SUPPRESS-COMPILER-MESSAGES*" "INSTALL-C-COMPILER" "UPDATE-COMPILER-FEATURES") (("SI" "GET-SYSPROP" "PUT-SYSPROP" "REM-SYSPROP" "MACRO" "*COMPILER-CONSTANTS*" "REGISTER-GLOBAL" "CMP-ENV-REGISTER-MACROLET" "COMPILER-LET")) si::dodefpackage)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 77 77 15 5 15 6 9 5 77 77 15 7 19 15 8 15 0 19 1 23 78 19 15 9 1 21 12 19 2 22 1 0 73 29) #2=#A(t (24) (c::ref "REF-" (c::name (c::ref 0 :type fixnum) c::ref-ccb c::ref-clb c::read-nodes) ((c::name nil t nil 0 nil) (c::ref 0 fixnum nil 1 nil) (c::ref-ccb nil t nil 2 nil) (c::ref-clb nil t nil 3 nil) (c::read-nodes nil t nil 4 nil)) c::copy-ref c::print-ref (c::make-ref) c::ref-p si::define-structure c::make-ref (nil :read-nodes :ref-clb :ref-ccb :ref :name) #:name #:ref #:ref-ccb #:ref-clb #:read-nodes fixnum typep si::structure-type-error 0 si::make-structure #Y(c::make-ref nil nil (28 10 22 40 2 77 46 11 22 40 3 9 0 46 12 22 40 2 77 46 13 22 40 2 77 46 14 22 40 2 77 46 15 13 3 15 16 19 2 17 76 39 12 13 3 15 16 15 0 15 0 19 4 18 15 19 13 4 13 3 13 2 13 1 13 0 19 6 20 29) #2# #1# 0) si::fset find-class)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 3 12 19 3 4 29) #3=#A(t (5) (ffi::object (deftype ffi::object nil `#4=(not (or fixnum character float))) #4# #Y(ffi::object nil nil (26 1 2 73 29) #3# #1# 0) si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 15 5 77 15 6 15 7 9 14 77 77 15 8 19 15 9 15 0 19 1 36 78 32 15 10 1 34 12 19 2 35 1 0 73 29) #5=#A(t (37) (c::var "VAR-" (c::set-nodes c::kind #'c::*current-function* (c::functions-setting nil) (c::functions-reading nil) (c::loc #6='ffi::object) (type t) (c::index -1) (ignorable nil)) (#7=(c::name nil t nil 0 c::ref-name) #8=(c::ref 0 fixnum nil 1 c::ref-ref) #9=(c::ref-ccb nil t nil 2 c::ref-ref-ccb) #10=(c::ref-clb nil t nil 3 c::ref-ref-clb) #11=(c::read-nodes nil t nil 4 c::ref-read-nodes) (c::set-nodes nil t nil 5 nil) (c::kind nil t nil 6 nil) (function c::*current-function* t nil 7 nil) (c::functions-setting nil t nil 8 nil) (c::functions-reading nil t nil 9 nil) (c::loc #6# t nil 10 nil) (type t t nil 11 nil) (c::index -1 t nil 12 nil) (ignorable nil t nil 13 nil)) c::copy-var c::ref c::print-var (c::%make-var) c::var-p si::define-structure c::%make-var (nil :ignorable :index :type :loc :functions-reading :functions-setting :function :kind :set-nodes :read-nodes :ref-clb :ref-ccb :ref :name) #:name #:ref #:ref-ccb #:ref-clb #:read-nodes #:set-nodes #:kind c::*current-function* #:function #:functions-setting #:functions-reading ffi::object #:loc t #:type #:index #:ignorable fixnum typep si::structure-type-error 0 si::make-structure #Y(c::%make-var nil nil (28 11 22 40 2 77 46 12 22 40 3 9 0 46 13 22 40 2 77 46 14 22 40 2 77 46 15 22 40 2 77 46 16 22 40 2 77 46 17 22 40 2 77 46 18 22 40 3 14 19 46 20 22 40 2 77 46 21 22 40 2 77 46 22 22 40 3 15 23 46 24 22 40 3 14 25 46 26 22 40 3 9 -1 46 27 22 40 2 77 46 28 13 12 15 29 19 2 30 76 39 12 13 12 15 29 15 0 15 5 19 4 31 15 32 13 13 13 12 13 11 13 10 13 9 13 8 13 7 13 6 13 5 13 4 13 3 13 2 13 1 13 0 19 15 33 29) #5# #1# 0) si::fset find-class)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 15 5 77 77 15 6 9 30 77 77 15 7 19 15 8 15 0 19 1 54 78 50 15 9 1 52 12 19 2 53 1 0 73 29) #12=#A(t (55) (c::fun "FUN-" (c::cfun (c::level 0) (c::env 0) (c::global nil) (c::exported nil) (c::no-entry nil) (c::shares-with nil) c::closure c::var c::description lambda c::lambda-expression (c::minarg 0) (c::maxarg call-arguments-limit) (c::return-type #13='(values &rest t)) (c::parent c::*current-function*) (c::local-vars nil) (c::referenced-vars nil) (c::referenced-funs nil) (c::referencing-funs nil) (c::child-funs nil) (c::file #14=(car ext::*source-location*)) (file-position #15=(or (cdr ext::*source-location*) c::*compile-file-position*)) (c::cmp-env #16=(c::cmp-env-copy)) c::required-lcls) (#7# #8# #9# #10# #11# (c::cfun nil t nil 5 nil) (c::level 0 t nil 6 nil) (c::env 0 t nil 7 nil) (c::global nil t nil 8 nil) (c::exported nil t nil 9 nil) (c::no-entry nil t nil 10 nil) (c::shares-with nil t nil 11 nil) (c::closure nil t nil 12 nil) (c::var nil t nil 13 nil) (c::description nil t nil 14 nil) (lambda nil t nil 15 nil) (c::lambda-expression nil t nil 16 nil) (c::minarg 0 t nil 17 nil) (c::maxarg call-arguments-limit t nil 18 nil) (c::return-type #13# t nil 19 nil) (c::parent c::*current-function* t nil 20 nil) (c::local-vars nil t nil 21 nil) (c::referenced-vars nil t nil 22 nil) (c::referenced-funs nil t nil 23 nil) (c::referencing-funs nil t nil 24 nil) (c::child-funs nil t nil 25 nil) (c::file #14# t nil 26 nil) (file-position #15# t nil 27 nil) (c::cmp-env #16# t nil 28 nil) (c::required-lcls nil t nil 29 nil)) c::copy-fun c::ref (c::make-fun) c::fun-p si::define-structure c::make-fun (nil :required-lcls :cmp-env :file-position :file :child-funs :referencing-funs :referenced-funs :referenced-vars :local-vars :parent :return-type :maxarg :minarg :lambda-expression :lambda :description :var :closure :shares-with :no-entry :exported :global :env :level :cfun :read-nodes :ref-clb :ref-ccb :ref :name) #:name #:ref #:ref-ccb #:ref-clb #:read-nodes #:cfun #:level #:env #:global #:exported #:no-entry #:shares-with #:closure #:var #:description #:lambda #:lambda-expression #:minarg call-arguments-limit #:maxarg (values &rest t) #:return-type c::*current-function* #:parent #:local-vars #:referenced-vars #:referenced-funs #:referencing-funs #:child-funs ext::*source-location* #:file c::*compile-file-position* #:file-position c::cmp-env-copy #:cmp-env #:required-lcls fixnum typep si::structure-type-error 0 si::make-structure #Y(c::make-fun nil nil (28 10 22 40 2 77 46 11 22 40 3 9 0 46 12 22 40 2 77 46 13 22 40 2 77 46 14 22 40 2 77 46 15 22 40 2 77 46 16 22 40 3 9 0 46 17 22 40 3 9 0 46 18 22 40 2 77 46 19 22 40 2 77 46 20 22 40 2 77 46 21 22 40 2 77 46 22 22 40 2 77 46 23 22 40 2 77 46 24 22 40 2 77 46 25 22 40 2 77 46 26 22 40 2 77 46 27 22 40 3 9 0 46 28 22 40 3 14 29 46 30 22 40 3 15 31 46 32 22 40 3 14 33 46 34 22 40 2 77 46 35 22 40 2 77 46 36 22 40 2 77 46 37 22 40 2 77 46 38 22 40 2 77 46 39 22 40 5 11 40 4 12 46 41 22 40 11 11 40 5 73 40 4 11 42 73 12 46 43 22 40 5 19 0 44 12 46 45 22 40 2 77 46 46 13 28 15 47 19 2 48 76 39 12 13 28 15 47 15 0 15 5 19 4 49 15 50 13 29 13 28 13 27 13 26 13 25 13 24 13 23 13 22 13 21 13 20 13 19 13 18 13 17 13 16 13 15 13 14 13 13 13 12 13 11 13 10 13 9 13 8 13 7 13 6 13 5 13 4 13 3 13 2 13 1 13 0 19 31 51 29) #12# #1# 0) si::fset find-class)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 15 5 77 77 15 6 9 9 77 77 15 7 19 15 8 15 0 19 1 28 78 24 15 9 1 26 12 19 2 27 1 0 73 29) #17=#A(t (29) (c::blk "BLK-" (ext::exit c::destination c::var (type #18='(values &rest t))) (#7# #8# #9# #10# #11# (ext::exit nil t nil 5 nil) (c::destination nil t nil 6 nil) (c::var nil t nil 7 nil) (type #18# t nil 8 nil)) c::copy-blk c::ref (c::make-blk) c::blk-p si::define-structure c::make-blk (nil :type :var :destination :exit :read-nodes :ref-clb :ref-ccb :ref :name) #:name #:ref #:ref-ccb #:ref-clb #:read-nodes #:exit #:destination #:var (values &rest t) #:type fixnum typep si::structure-type-error 0 si::make-structure #Y(c::make-blk nil nil (28 10 22 40 2 77 46 11 22 40 3 9 0 46 12 22 40 2 77 46 13 22 40 2 77 46 14 22 40 2 77 46 15 22 40 2 77 46 16 22 40 2 77 46 17 22 40 2 77 46 18 22 40 3 15 19 46 20 13 7 15 21 19 2 22 76 39 12 13 7 15 21 15 0 15 5 19 4 23 15 24 13 8 13 7 13 6 13 5 13 4 13 3 13 2 13 1 13 0 19 10 25 29) #17# #1# 0) si::fset find-class)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 15 5 77 77 15 6 9 9 77 77 15 7 19 15 8 15 0 19 1 27 78 23 15 9 1 25 12 19 2 26 1 0 73 29) #19=#A(t (28) (c::tag "TAG-" (c::label c::unwind-exit c::var c::index) (#7# #8# #9# #10# #11# (c::label nil t nil 5 nil) (c::unwind-exit nil t nil 6 nil) (c::var nil t nil 7 nil) (c::index nil t nil 8 nil)) c::copy-tag c::ref (c::make-tag) c::tag-p si::define-structure c::make-tag (nil :index :var :unwind-exit :label :read-nodes :ref-clb :ref-ccb :ref :name) #:name #:ref #:ref-ccb #:ref-clb #:read-nodes #:label #:unwind-exit #:var #:index fixnum typep si::structure-type-error 0 si::make-structure #Y(c::make-tag nil nil (28 10 22 40 2 77 46 11 22 40 3 9 0 46 12 22 40 2 77 46 13 22 40 2 77 46 14 22 40 2 77 46 15 22 40 2 77 46 16 22 40 2 77 46 17 22 40 2 77 46 18 22 40 2 77 46 19 13 7 15 20 19 2 21 76 39 12 13 7 15 20 15 0 15 5 19 4 22 15 23 13 8 13 7 13 6 13 5 13 4 13 3 13 2 13 1 13 0 19 10 24 29) #19# #1# 0) si::fset find-class)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 77 77 77 15 5 9 4 77 77 15 6 19 15 7 15 0 19 1 19 78 15 15 8 1 17 12 19 2 18 1 0 73 29) #20=#A(t (20) (c::info "INFO-" ((c::local-vars nil) (type #21='(values &rest t)) (c::sp-change nil) (c::volatile nil)) ((c::local-vars nil t nil 0 nil) (type #21# t nil 1 nil) (c::sp-change nil t nil 2 nil) (c::volatile nil t nil 3 nil)) c::copy-info (c::make-info) c::info-p si::define-structure c::make-info (nil :volatile :sp-change :type :local-vars) #:local-vars (values &rest t) #:type #:sp-change #:volatile 0 si::make-structure #Y(c::make-info nil nil (28 9 22 40 2 77 46 10 22 40 3 15 11 46 12 22 40 2 77 46 13 22 40 2 77 46 14 15 15 13 3 13 2 13 1 13 0 19 5 16 29) #20# #1# 0) si::fset find-class)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 77 77 77 15 5 9 9 77 77 15 6 19 15 7 15 0 19 1 23 78 19 15 8 1 21 12 19 2 22 1 0 73 29) #22=#A(t (24) (c::inline-info "INLINE-INFO-" (c::name c::arg-rep-types c::return-rep-type c::arg-types c::return-type c::exact-return-type c::multiple-values c::expansion c::one-liner) ((c::name nil t nil 0 nil) (c::arg-rep-types nil t nil 1 nil) (c::return-rep-type nil t nil 2 nil) (c::arg-types nil t nil 3 nil) (c::return-type nil t nil 4 nil) (c::exact-return-type nil t nil 5 nil) (c::multiple-values nil t nil 6 nil) (c::expansion nil t nil 7 nil) (c::one-liner nil t nil 8 nil)) c::copy-inline-info (c::make-inline-info) c::inline-info-p si::define-structure c::make-inline-info (nil :one-liner :expansion :multiple-values :exact-return-type :return-type :arg-types :return-rep-type :arg-rep-types :name) #:name #:arg-rep-types #:return-rep-type #:arg-types #:return-type #:exact-return-type #:multiple-values #:expansion #:one-liner 0 si::make-structure #Y(c::make-inline-info nil nil (28 9 22 40 2 77 46 10 22 40 2 77 46 11 22 40 2 77 46 12 22 40 2 77 46 13 22 40 2 77 46 14 22 40 2 77 46 15 22 40 2 77 46 16 22 40 2 77 46 17 22 40 2 77 46 18 15 19 13 8 13 7 13 6 13 5 13 4 13 3 13 2 13 1 13 0 19 10 20 29) #22# #1# 0) si::fset find-class)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 15 5 77 15 6 15 7 9 13 77 77 15 8 19 15 9 15 0 19 1 31 78 27 15 10 1 29 12 19 2 30 1 0 73 29) #23=#A(t (32) (c::c1form "C1FORM-" ((c::name nil) (c::parents nil) (c::env #24=(c::cmp-env-copy)) (c::args #25='nil) (c::side-effects nil) (c::form nil) (c::toplevel-form nil) (c::file nil) (file-position 0)) ((c::local-vars nil t nil 0 c::info-local-vars) (type '(values &rest t) t nil 1 c::info-type) (c::sp-change nil t nil 2 c::info-sp-change) (c::volatile nil t nil 3 c::info-volatile) (c::name nil t nil 4 nil) (c::parents nil t nil 5 nil) (c::env #24# t nil 6 nil) (c::args #25# t nil 7 nil) (c::side-effects nil t nil 8 nil) (c::form nil t nil 9 nil) (c::toplevel-form nil t nil 10 nil) (c::file nil t nil 11 nil) (file-position 0 t nil 12 nil)) c::copy-c1form c::info c::print-c1form (c::do-make-c1form) c::c1form-p si::define-structure c::do-make-c1form (nil :file-position :file :toplevel-form :form :side-effects :args :env :parents :name :volatile :sp-change :type :local-vars) #:local-vars (values &rest t) #:type #:sp-change #:volatile #:name #:parents c::cmp-env-copy #:env #:args #:side-effects #:form #:toplevel-form #:file #:file-position 0 si::make-structure #Y(c::do-make-c1form nil nil (28 11 22 40 2 77 46 12 22 40 3 15 13 46 14 22 40 2 77 46 15 22 40 2 77 46 16 22 40 2 77 46 17 22 40 2 77 46 18 22 40 5 19 0 19 12 46 20 22 40 2 77 46 21 22 40 2 77 46 22 22 40 2 77 46 23 22 40 2 77 46 24 22 40 2 77 46 25 22 40 3 9 0 46 26 15 27 13 12 13 11 13 10 13 9 13 8 13 7 13 6 13 5 13 4 13 3 13 2 13 1 13 0 19 14 28 29) #23# #1# 0) si::fset find-class)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 15 2 15 3 15 4 77 77 77 15 5 9 4 77 77 15 6 19 15 7 15 0 19 1 19 78 15 15 8 1 17 12 19 2 18 1 0 73 29) #26=#A(t (20) (c::vv "VV-" ((ext::location nil) (c::used-p nil) (c::permanent-p t) (c::value nil)) ((ext::location nil t nil 0 nil) (c::used-p nil t nil 1 nil) (c::permanent-p t t nil 2 nil) (c::value nil t nil 3 nil)) c::copy-vv (c::make-vv) c::vv-p si::define-structure c::make-vv (nil :value :permanent-p :used-p :location) #:location #:used-p t #:permanent-p #:value 0 si::make-structure #Y(c::make-vv nil nil (28 9 22 40 2 77 46 10 22 40 2 77 46 11 22 40 3 14 12 46 13 22 40 2 77 46 14 15 15 13 3 13 2 13 1 13 0 19 5 16 29) #26# #1# 0) si::fset find-class)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 6 19 0 3 52 0 1 0 73 29) #A(t (4) (c::*info* si::*make-special boundp c::make-info)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*inline-blocks* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*opened-c-braces* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 3 52 0 1 0 73 29) #A(t (3) (c::*inline-max-depth* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*current-form* si::*make-special boundp c::|compiler preprocess|)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*current-toplevel-form* si::*make-special boundp c::|compiler preprocess|)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 -1 52 0 1 0 73 29) #A(t (3) (c::*compile-file-position* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 1 0 73 29) #A(t (4) (c::*first-error* si::*make-special boundp t)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*active-protection* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*pending-actions* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*compiler-conditions* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (*compile-print* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (*compile-verbose* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*compiler-features* si::*make-special boundp (:gcc-compiler :lp64))) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*suppress-compiler-messages* si::*make-special boundp c::compiler-note)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*suppress-compiler-notes* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*suppress-compiler-warnings* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*compiler-break-enable* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*compiler-in-use* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 73 29) #A(t (2) (c::*compiler-input* si::*make-special)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 73 29) #A(t (2) (c::*compiler-output1* si::*make-special)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 73 29) #A(t (2) (c::*compiler-output2* si::*make-special)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*callbacks* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 1 0 73 29) #A(t (4) (c::*compile-to-linking-call* si::*make-special boundp t)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 73 29) #A(t (2) (c::*compiler-declared-globals* si::*make-special)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 2 52 0 1 0 73 29) #A(t (3) (c::*safety* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 3 52 0 1 0 73 29) #A(t (3) (c::*speed* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*space* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*debug* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 1 0 73 29) #A(t (4) (c::*automatic-check-type-in-lambda* si::*make-special boundp t)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*lcl* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*temp* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*max-temp* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*level* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*lex* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*max-lex* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*env* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*max-env* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*env-lvl* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*aux-closure* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*ihs-used-p* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*next-cmacro* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*next-cfun* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*tail-recursion-info* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 1 0 73 29) #A(t (4) (c::*allow-c-local-declaration* si::*make-special boundp t)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*last-label* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 73 29) #A(t (2) (c::*exit* si::*make-special)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 73 29) #A(t (2) (c::*unwind-exit* si::*make-special)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*current-function* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*cmp-env* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 17 77 15 3 15 4 77 19 1 5 6 3 6 1 3 52 0 1 0 73 29) #A(t (6) (c::*cmp-env-root* si::*make-special boundp #:no-macro si::macro constantly)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 73 29) #A(t (2) (c::*destination* si::*make-special)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*debug-compiler* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 1 0 73 29) #A(t (4) (c::*delete-files* si::*make-special boundp t)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*files-to-be-deleted* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*user-ld-flags* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*user-cc-flags* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 1 0 73 29) #A(t (4) (c::*do-type-propagation* si::*make-special boundp t)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*compiler-phase* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 73 29) #A(t (2) (c::*volatile* si::*make-special)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*setjmps* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 1 0 73 29) #A(t (4) (c::*compile-toplevel* si::*make-special boundp t)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*clines-string-list* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*compile-time-too* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*not-compile-time* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*permanent-data* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*permanent-objects* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*temporary-objects* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*load-objects* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*load-time-values* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*setf-definitions* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*use-static-constants-p* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*static-constants* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (si::*compiler-constants* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 11 3 52 0 1 0 73 29) #A(t (4) (c::*compile-in-constants* si::*make-special boundp t)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*proclaim-fixed-args* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*global-vars* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*global-funs* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*global-cfuns-array* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*linking-calls* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*local-funs* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*top-level-forms* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*make-forms* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*global-entries* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*global-macros* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*self-destructing-fasl* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*undefined-vars* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+init-env-form+ ((*gensym-counter* 0) (c::*compiler-in-use* t) (c::*compiler-phase* 'c::t1) (c::*callbacks* nil) (c::*cmp-env-root* (copy-tree c::*cmp-env-root*)) (c::*cmp-env* nil) (c::*max-temp* 0) (c::*temp* 0) (c::*next-cmacro* 0) (c::*next-cfun* 0) (c::*last-label* 0) (c::*load-objects* (make-hash-table :size 128 :test #'equal)) (c::*setf-definitions* nil) (c::*make-forms* nil) (c::*static-constants* nil) (c::*permanent-objects* nil) (c::*temporary-objects* nil) (c::*local-funs* nil) (c::*global-vars* nil) (c::*global-funs* nil) (c::*global-cfuns-array* nil) (c::*linking-calls* nil) (c::*global-entries* nil) (c::*undefined-vars* nil) (c::*top-level-forms* nil) (c::*compile-time-too* nil) (c::*clines-string-list* 'nil) (c::*inline-blocks* 0) (c::*open-c-braces* 0) (si::*defun-inline-hook* 'c::maybe-install-inline-function)) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*cmpinclude* si::*make-special boundp "<ecl/ecl-cmp.h>")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*cc* si::*make-special boundp "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*ld* si::*make-special boundp "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*ranlib* si::*make-special boundp "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ranlib")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*ar* si::*make-special boundp "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ar")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*cc-flags* si::*make-special boundp "  -arch arm64 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.4.sdk/ -DAPPLE -I/Users/strobolights/dev/mecl/local-install/iPhoneOS-arm64/include -D_THREAD_SAFE -Ddarwin")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*cc-optimize* si::*make-special boundp "-O2")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*ld-format* si::*make-special boundp "~A -o ~S -L~S ~{~S ~} ~@[~S~]~{ '~A'~} ~A")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 31 14 3 14 4 19 2 5 39 5 1 6 38 16 14 7 14 4 19 2 5 39 5 1 8 38 3 1 9 52 0 1 0 73 29) #A(t (10) (c::*cc-format* si::*make-special boundp :msvc *features* member "~A -I. \"-I~A\" ~A ~:[~*~;~A~] -w -c \"~A\" -o \"~A\"~{ '~A'~}" :nacl "~A -I. \"-I~A\" ~A ~:[~*~;~A~] -c \"~A\" -o \"~A\"~{ '~A'~}" "~A -I. \"-I~A\" ~A ~:[~*~;~A~] -w -c \"~A\" -o \"~A\"~{ '~A'~}")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*ld-flags* si::*make-special boundp " -L/Users/strobolights/dev/mecl/local-install/iPhoneOS-arm64/lib   -lecl -latomic_ops   -lgmp -lgc -lpthread   -lm ")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::+shared-library-prefix+ si::*make-special boundp "lib")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::+shared-library-extension+ si::*make-special boundp "dylib")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::+shared-library-format+ si::*make-special boundp "lib~a.dylib")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::+static-library-prefix+ si::*make-special boundp "lib")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::+static-library-extension+ si::*make-special boundp "a")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::+static-library-format+ si::*make-special boundp "lib~a.a")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::+object-file-extension+ si::*make-special boundp "o")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::+executable-file-format+ si::*make-special boundp "~a")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*ecl-include-directory* si::*make-special boundp "/Users/strobolights/dev/mecl/local-install/iPhoneOS-arm64/include/")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*ecl-library-directory* si::*make-special boundp "/Users/strobolights/dev/mecl/local-install/iPhoneOS-arm64/lib/")) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 25 1 3 45 4 10 0 16 5 16 6 39 9 77 13 0 14 7 19 3 8 43 1 52 0 1 0 73 29) #A(t (9) (c::*ld-rpath* si::*make-special boundp "" c::x length plusp c::*ecl-library-directory* format)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 19 2 2 29) #A(t (3) (si::arglist "COMPILER" import)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 19 2 2 29) #A(t (3) (si::with-clean-symbols "COMPILER" import)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 60 12 14 61 9 4 19 4 62 1 0 73 29) #27=#A(t (63) (c::defun-cached #:g18662 #:g18661 #:g18663 si::dm-too-few-arguments c::name c::lambda-list c::test c::body string "*" "-CACHE*" concatenate symbol-package intern c::cache-name "-EMPTY-CACHE" c::reset-name eq si::hash-eq eql si::hash-eql equal si::hash-equal equalp si::hash-equalp c::hash-function progn eval-when (:compile-toplevel :load-toplevel :execute) defparameter (make-array 1024 :element-type t :adjustable nil) defun (nil (make-array 1024 :element-type t :adjustable nil)) flet let* c::hash logand elt aref declare (type (integer 0 1023) c::hash) type (array t (*)) if and #:loop-list18677 c::arg #:loop-list-head18678 #:loop-list-tail18679 0 (pop (ext::truly-the cons elt)) rplacd (first (ext::truly-the cons elt)) let c::output setf list (c::output) append #Y(c::defun-cached nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 76 39 6 13 4 19 1 4 10 2 4 12 10 2 5 51 2 22 45 7 10 3 45 8 15 9 15 10 10 3 16 9 12 15 11 19 4 12 12 10 3 16 13 12 19 2 14 45 15 15 9 10 4 16 9 12 15 16 19 3 12 12 10 4 16 13 12 19 2 14 45 17 10 3 42 18 5 1 19 38 21 42 20 5 1 21 38 14 42 22 5 1 23 38 7 1 24 51 3 1 25 45 26 15 27 15 28 15 29 15 30 13 2 1 31 6 3 6 3 12 15 32 13 1 1 33 7 3 12 15 32 13 6 13 5 15 34 13 6 13 5 10 3 7 3 6 1 12 15 35 15 36 15 37 13 0 10 5 7 2 12 8 1023 6 3 6 2 12 15 38 15 39 13 2 1 36 6 3 6 2 6 2 12 15 40 15 41 15 42 15 43 10 2 6 3 6 3 12 15 44 15 45 15 38 58 60 72 77 13 6 46 46 46 47 75 6 1 45 48 10 0 45 49 57 50 61 2 2 38 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 13 10 15 51 10 3 6 3 6 1 51 1 17 52 35 0 0 10 2 5 73 36 5 62 43 2 43 2 63 7 3 12 15 53 15 54 15 55 13 6 10 5 7 2 6 2 6 1 12 15 56 15 39 13 2 1 36 6 3 12 15 57 13 5 15 58 19 2 59 7 2 6 3 12 1 55 6 4 6 4 6 4 6 3 6 4 6 4 73 43 3 29) #27# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 14 11 9 3 19 4 12 1 0 73 29) #28=#A(t (13) (c::defun-equal-cached #:g18681 #:g18680 #:g18682 si::dm-too-few-arguments c::name c::lambda-list c::body c::defun-cached equal #Y(c::defun-equal-cached nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 45 7 15 8 13 2 13 1 15 9 10 0 7 5 73 29) #28# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 9 1024 14 2 14 3 14 4 77 19 5 5 52 0 15 6 1 7 12 19 2 8 15 9 1 23 12 19 2 8 1 9 73 29) #29=#A(t (24) (c::*env-var-name-cache* si::*make-special :element-type t :adjustable make-array c::env-var-name-empty-cache #Y(c::env-var-name-empty-cache nil nil (26 9 1024 14 2 14 3 14 4 77 19 5 5 29) #29# #1# 0) si::fset c::env-var-name c::n "env~D" format #Y(c::env-var-name nil nil (24 45 10 26 77 15 11 13 0 19 3 12 29) #29# #1# 0) si::hash-eql logand c::hash aref elt #:g18687 eql c::output si::aset #Y(c::env-var-name nil nil (24 45 10 26 30 1 13 13 1 19 1 14 12 9 1023 19 2 15 45 16 14 0 13 0 19 2 17 45 18 10 0 39 24 10 0 45 19 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 3 17 20 39 7 10 0 4 73 38 28 13 3 32 2 18 1 45 21 14 0 13 2 13 4 10 0 6 2 12 19 3 22 10 0 73 43 1 43 2 43 1 29) #29# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 9 1024 14 2 14 3 14 4 77 19 5 5 52 0 15 6 1 7 12 19 2 8 15 9 1 23 12 19 2 8 1 9 73 29) #30=#A(t (24) (c::*lex-env-var-name-cache* si::*make-special :element-type t :adjustable make-array c::lex-env-var-name-empty-cache #Y(c::lex-env-var-name-empty-cache nil nil (26 9 1024 14 2 14 3 14 4 77 19 5 5 29) #30# #1# 0) si::fset c::lex-env-var-name c::n "lex~D" format #Y(c::lex-env-var-name nil nil (24 45 10 26 77 15 11 13 0 19 3 12 29) #30# #1# 0) si::hash-eql logand c::hash aref elt #:g18695 eql c::output si::aset #Y(c::lex-env-var-name nil nil (24 45 10 26 30 1 13 13 1 19 1 14 12 9 1023 19 2 15 45 16 14 0 13 0 19 2 17 45 18 10 0 39 24 10 0 45 19 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 3 17 20 39 7 10 0 4 73 38 28 13 3 32 2 18 1 45 21 14 0 13 2 13 4 10 0 6 2 12 19 3 22 10 0 73 43 1 43 2 43 1 29) #30# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #31=#A(t (6) (c::same-fname-p c::name1 c::name2 equal #Y(c::same-fname-p nil nil (24 45 1 24 45 2 26 13 1 10 0 17 3 29) #31# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 14 7 9 1 19 4 8 1 0 73 29) #32=#A(t (9) (c::next-cmacro #:g18700 #:g18699 #:g18701 si::dm-too-many-arguments (incf c::*next-cmacro*) #Y(c::next-cmacro nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 39 6 13 2 19 1 4 1 5 73 29) #32# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #33=#A(t (6) (c::next-label #:g18705 c::*last-label* + #Y(c::next-label nil nil (26 8 1 45 1 14 2 13 0 19 2 3 52 2 12 43 1 75 3 73 29) #33# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #34=#A(t (7) (c::next-label* #:g18709 c::*last-label* + t #Y(c::next-label* nil nil (26 8 1 45 1 14 2 13 0 19 2 3 52 2 12 43 1 11 4 3 73 29) #34# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #35=#A(t (6) (c::labelp c::x consp integerp #Y(c::labelp nil nil (24 45 1 26 10 0 16 2 73 39 6 10 0 4 16 3 29) #35# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #36=#A(t (6) (c::maybe-next-label c::*exit* c::labelp c::next-label #Y(c::maybe-next-label nil nil (26 14 1 19 1 2 39 6 11 1 73 38 4 19 0 3 29) #36# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #37=#A(t (7) (c::maybe-wt-label c::label c::*exit* eq c::wt-label #Y(c::maybe-wt-label nil nil (24 45 1 26 13 0 11 2 17 3 76 73 39 6 13 0 19 1 4 29) #37# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 14 17 9 2 19 4 18 1 0 73 29) #38=#A(t (19) (c::with-exit-label #:g18711 #:g18710 #:g18712 si::dm-too-few-arguments #:g18713 #:g18714 c::label c::body si::dm-too-many-arguments let* (c::next-label) c::*unwind-exit* cons c::wt-label append #Y(c::with-exit-label nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 3 45 8 10 2 39 6 13 6 19 1 9 15 10 13 1 1 11 6 2 12 15 12 15 13 13 1 1 12 6 3 6 2 6 2 12 13 0 15 14 10 1 6 2 6 1 12 19 2 15 7 3 73 29) #38# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 14 17 9 2 19 4 18 1 0 73 29) #39=#A(t (19) (c::with-optional-exit-label #:g18716 #:g18715 #:g18717 si::dm-too-few-arguments #:g18718 #:g18719 c::label c::body si::dm-too-many-arguments let* (c::maybe-next-label) c::*unwind-exit* adjoin c::maybe-wt-label append #Y(c::with-optional-exit-label nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 3 45 8 10 2 39 6 13 6 19 1 9 15 10 13 1 1 11 6 2 12 15 12 15 13 13 1 1 12 6 3 6 2 6 2 12 13 0 15 14 10 1 6 2 6 1 12 19 2 15 7 3 73 29) #39# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #40=#A(t (12) (c::next-lcl c::name c::lcl #:g18723 c::*lcl* + t symbol-package c::lisp-to-c-name "" #Y(c::next-lcl nil nil (25 40 2 77 46 1 26 15 2 8 1 45 3 14 4 13 0 19 2 5 52 4 12 43 1 14 6 10 0 39 5 10 0 16 7 39 8 13 0 19 1 8 38 3 1 9 6 4 73 29) #40# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #41=#A(t (12) (c::next-cfun "L~D~A" c::prefix c::lisp-name #:g18727 c::*next-cfun* + c::code c::lisp-to-c-name format #Y(c::next-cfun nil nil (25 40 3 15 1 46 2 25 40 2 77 46 3 26 8 1 45 4 14 5 13 0 19 2 6 52 5 43 1 45 7 77 13 2 13 0 13 1 19 1 8 12 19 4 9 43 1 29) #41# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #42=#A(t (8) (c::next-temp c::*temp* #:g18731 + c::*max-temp* max #Y(c::next-temp nil nil (26 14 1 8 1 45 2 14 1 13 0 19 2 3 52 1 43 1 14 1 14 4 19 2 5 52 4 22 73 29) #42# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #43=#A(t (9) (c::next-lex c::*level* c::*lex* #:g18735 + c::*max-lex* max #Y(c::next-lex nil nil (26 14 1 11 2 3 12 8 1 45 3 14 2 13 0 19 2 4 52 2 43 1 14 2 14 5 19 2 6 52 5 22 73 29) #43# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #44=#A(t (8) (c::next-env c::*env* #:g18739 + c::*max-env* max #Y(c::next-env nil nil (26 14 1 8 1 45 2 14 1 13 0 19 2 3 52 1 43 1 14 1 14 4 19 2 5 52 4 22 73 29) #44# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 14 8 9 1 19 4 9 1 0 73 29) #45=#A(t (10) (c::reckless #:g18741 #:g18740 #:g18742 c::body locally (declare (optimize (safety 0))) #Y(c::reckless nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 45 4 15 5 15 6 10 0 7 3 73 29) #45# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #46=#A(t (9) (c::print-c1form c::form stream "#<form ~A ~X>" c::c1form-name si::pointer format #Y(c::print-c1form nil nil (24 45 1 24 45 2 26 13 0 15 3 13 1 19 1 4 12 10 1 16 5 12 19 4 6 29) #46# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 1 0 73 29) #47=#A(t (25) (c::make-c1form c::name c::subform c::args :name :args :type c::info-type :sp-change c::info-sp-change :volatile c::info-volatile :form c::*current-form* :toplevel-form c::*current-toplevel-form* :file *compile-file-truename* :file-position c::*compile-file-position* c::do-make-c1form c::form c::c1form-add-info #Y(c::make-c1form nil nil (24 45 1 24 45 2 27 45 3 14 4 13 2 14 5 13 0 14 6 13 1 19 1 7 12 14 8 13 1 19 1 9 12 14 10 13 1 19 1 11 12 14 12 14 13 14 14 14 15 14 16 14 17 14 18 14 19 19 18 20 45 21 13 0 13 1 19 2 22 10 0 73 43 1 29) #47# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #48=#A(t (27) (c::make-c1form* c::name c::args c::form-args c::info-args c::l c::key keywordp c::baboon :args eq second c::do-make-c1form :name :form c::*current-form* :toplevel-form c::*current-toplevel-form* :file *compile-file-truename* :file-position c::*compile-file-position* apply c::form c::c1form-add-info #Y(c::make-c1form* nil nil (24 45 1 27 45 2 77 77 46 3 46 4 58 60 77 10 3 45 5 38 63 10 0 4 45 6 10 0 16 7 76 39 6 19 0 8 38 38 13 0 1 9 17 10 39 12 10 1 5 51 4 75 73 36 2 38 19 13 0 10 1 16 11 12 10 3 7 3 51 3 10 1 5 51 1 43 1 10 0 5 12 53 0 10 0 2 39 -66 43 1 63 33 12 12 14 13 13 3 14 9 13 1 14 14 14 15 14 16 14 17 14 18 14 19 14 20 14 21 13 0 19 14 22 45 23 13 0 13 2 19 2 24 10 0 73 43 1 43 2 29) #48# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 28 12 19 2 29 1 0 73 29) #49=#A(t (30) (c::c1form-add-info-loop c::form c::dependents c::subform 0 consp #:g18780 c::c1form-p c::c1form-sp-change #:g18781 t #:g18782 c::c1form si::structure-set #:g18783 #:g18784 c::c1form-side-effects #:g18785 #:g18786 c::c1form-name ext::location eq c::c1form-parents "Running twice through same form" error #:g18787 nconc #:g18788 #Y(c::c1form-add-info-loop nil nil (24 45 1 24 45 2 26 75 45 3 57 4 61 2 2 200 10 2 16 5 76 39 4 35 0 1 10 2 45 6 10 0 4 12 10 0 5 51 0 10 0 51 3 22 43 1 51 1 12 19 1 7 39 146 13 1 19 1 8 39 47 10 3 45 9 11 10 45 11 13 1 15 12 9 2 13 0 19 4 13 43 1 43 1 10 3 45 14 11 10 45 15 13 1 15 12 9 8 13 0 19 4 13 43 1 43 1 13 1 19 1 16 39 24 10 3 45 17 11 10 45 18 13 1 15 12 9 8 13 0 19 4 13 43 1 43 1 13 1 19 1 19 12 1 20 17 21 76 39 50 13 1 19 1 22 5 39 6 15 23 19 1 24 10 1 45 25 13 2 19 1 22 12 13 4 19 1 22 12 19 2 26 45 27 13 1 15 12 9 5 13 0 19 4 13 43 1 43 1 10 1 16 5 39 8 13 3 13 1 19 2 0 35 0 0 62 73 43 1 29) #49# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #50=#A(t (27) (c::c1form-add-info c::form c::dependents c::c1form-name c::+c1-form-hash+ gethash c::record "Internal error: unknown C1FORM name ~A" error c::c1form-sp-change second c::side-effects c::sp-change length #:g18793 c::c1form-side-effects #:g18794 c::c1form si::structure-set #:g18795 #:g18796 c::c1form-args = "Internal error: illegal number of arguments in ~A" c::c1form-add-info-loop #Y(c::c1form-add-info nil nil (24 45 1 24 45 2 26 13 1 19 1 3 12 14 4 19 2 5 45 6 10 0 76 39 12 15 7 13 2 19 1 3 12 19 2 8 10 0 4 12 13 2 19 1 9 12 10 0 16 10 12 46 11 46 12 46 13 10 5 45 14 13 6 19 1 15 40 7 10 2 40 3 10 3 45 16 13 1 15 17 9 8 13 0 19 4 18 43 1 43 1 10 5 45 19 10 6 6 1 45 20 13 1 15 17 9 5 13 0 19 4 18 43 1 43 1 10 0 76 40 14 13 0 13 5 19 1 21 16 13 12 19 2 22 76 39 8 15 23 13 5 19 2 8 43 3 43 1 13 1 13 0 19 2 24 29) #50# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #51=#A(t (5) (c::copy-c1form c::form copy-structure #Y(c::copy-c1form nil nil (24 45 1 26 10 0 16 2 29) #51# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 14 14 9 3 19 4 15 1 0 73 29) #52=#A(t (16) (c::c1form-arg #:g18798 #:g18797 #:g18799 si::dm-too-few-arguments nth c::form si::dm-too-many-arguments 0 first c::c1form-args 1 second #Y(c::c1form-arg nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 39 6 13 4 19 1 7 10 1 42 8 14 15 9 15 10 10 0 6 2 6 2 73 38 30 42 11 14 15 12 15 10 10 0 6 2 6 2 73 38 14 15 5 13 1 15 10 10 0 6 2 6 3 73 29) #52# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #53=#A(t (7) (c::c1form-volatile* c::form c::c1form-volatile "volatile " "" #Y(c::c1form-volatile* nil nil (24 45 1 26 13 0 19 1 2 39 6 1 3 73 38 4 1 4 73 29) #53# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #54=#A(t (6) (c::c1form-primary-type c::form c::c1form-type c::values-type-primary-type #Y(c::c1form-primary-type nil nil (24 45 1 26 13 0 19 1 2 12 19 1 3 29) #54# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #55=#A(t (5) (c::location-primary-type c::form c::c1form-primary-type #Y(c::location-primary-type nil nil (24 45 1 26 13 0 19 1 2 29) #55# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #56=#A(t (23) (c::find-form-in-node-list c::form list c::c1form-parents c::form-parents #:loop-list18804 c::presumed-child-parents #:loop-it-18805 0 tailp #:loop-list18806 #:loop-it-18807 :test eq member c::v2 c::v1 t :format-control "Mismatch between FIND-FORM-IN-NODE-LISTs" c::baboon #Y(c::find-form-in-node-list nil nil (24 45 1 24 45 2 26 58 60 69 13 2 19 1 3 45 4 77 13 2 46 5 46 6 75 45 7 57 8 61 2 2 37 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 13 4 10 2 17 9 51 1 39 6 10 1 73 36 5 35 0 0 62 73 43 1 43 2 43 1 63 12 58 60 66 77 13 1 46 10 46 6 75 45 11 57 8 61 2 2 43 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 13 6 13 2 14 12 33 13 12 19 4 14 51 1 39 6 10 1 73 36 4 35 0 0 62 73 43 1 43 2 63 12 46 15 46 16 10 0 73 39 4 11 17 73 12 10 1 39 3 11 17 17 13 76 39 8 14 18 15 19 19 2 20 10 0 73 43 2 29) #56# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #57=#A(t (6) (c::add-form-to-node-list c::form list c::c1form-parents #Y(c::add-form-to-node-list nil nil (24 45 1 24 45 2 26 13 1 19 1 3 12 10 0 7 2 73 29) #57# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #58=#A(t (13) (c::delete-form-from-node-list c::form list c::c1form-parents c::parents member :format-control "Unable to find C1FORM~%~4I~A~%in node list~%~4I~A" :format-arguments c::baboon delete #Y(c::delete-form-from-node-list nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 13 0 13 1 19 2 5 76 39 17 14 6 15 7 14 8 13 2 10 1 6 2 12 19 4 9 13 0 13 1 19 2 10 43 1 29) #58# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #59=#A(t (12) (c::traverse-c1form-tree c::tree function consp #:loop-list18810 c::f 0 c::c1form-p c::c1form-args #:loop-list18811 #Y(c::traverse-c1form-tree nil nil (24 45 1 24 45 2 26 10 1 16 3 39 48 77 13 1 46 4 46 5 57 6 61 2 2 29 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 3 19 2 0 35 0 0 62 73 43 2 38 64 13 1 19 1 7 73 39 56 77 13 1 19 1 8 12 46 9 46 5 57 6 61 2 2 29 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 3 19 2 0 35 0 0 62 43 2 13 0 13 1 20 1 23 29) #59# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #60=#A(t (16) (c::c1form-movable-p c::form c::c1form-name c::name c::var eq c::c1form-args c::global-var-p c::var-set-nodes c::c1form-side-effects c::+c1-form-hash+ gethash third #Y(c::abort-on-not-pure nil nil (24 45 1 26 13 0 19 1 2 45 3 13 0 1 4 17 5 39 32 13 1 19 1 6 4 45 4 13 0 19 1 7 40 6 13 0 19 1 8 73 39 5 75 73 36 3 43 1 38 25 13 1 19 1 9 40 11 13 0 14 10 19 2 11 16 12 76 73 39 5 75 73 36 2 43 1 29) #60# #1# 0) #Y(c::c1form-movable-p nil nil (24 45 1 26 57 0 60 13 30 1 13 13 2 32 0 18 1 43 1 63 29) #60# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #61=#A(t (8) (c::c1form-pure-p c::form c::c1form-name c::+c1-form-hash+ gethash third #Y(c::c1form-pure-p nil nil (24 45 1 26 13 0 19 1 2 12 14 3 19 2 4 16 5 29) #61# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #62=#A(t (17) (c::c1form-unmodified-p c::form c::rest-form c::c1form-name c::name c::var eq c::c1form-args c::global-var-p c::var-changed-in-form-list c::c1form-side-effects c::c1form-pure-p #Y(c::abort-on-not-pure nil nil (24 45 1 26 13 0 19 1 3 45 4 13 0 1 5 17 6 39 34 13 1 19 1 7 4 45 5 13 0 19 1 8 40 8 13 0 13 4 19 2 9 73 39 5 75 73 36 3 43 1 38 21 13 1 19 1 10 40 7 13 1 19 1 11 76 73 39 5 75 73 36 2 43 1 29) #62# #1# 0) c::traverse-c1form-tree t #Y(c::c1form-unmodified-p nil nil (24 45 1 24 45 2 26 57 0 60 18 30 1 12 13 3 32 0 12 19 2 13 11 14 73 43 1 63 29) #62# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #63=#A(t (10) (c::c1form-values-number c::form c::c1form-name c::+c1-form-hash+ gethash fourth c::c1form-type c::values-number-from-type #Y(c::c1form-values-number nil nil (24 45 1 26 13 0 19 1 2 12 14 3 19 2 4 16 5 39 9 9 1 9 1 72 2 38 10 13 0 19 1 6 12 19 1 7 29) #63# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #64=#A(t (10) (c::c1form-single-valued-p c::form c::c1form-name c::+c1-form-hash+ gethash fourth c::c1form-values-number <= #Y(c::c1form-single-valued-p nil nil (24 45 1 26 13 0 19 1 2 12 14 3 19 2 4 16 5 73 40 15 9 1 13 0 19 1 6 74 12 9 1 19 2 7 29) #64# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 14 23 9 2 19 4 24 1 0 73 29) #65=#A(t (25) (c::with-c1form-env #:g18813 #:g18812 #:g18814 si::dm-too-few-arguments #:g18815 #:g18816 c::form c::value c::body si::dm-too-many-arguments let* *compile-file-truename* c::c1form-file c::*compile-file-position* c::c1form-file-position c::*current-toplevel-form* c::c1form-toplevel-form c::*current-form* c::c1form-form c::*cmp-env* c::c1form-env #Y(c::with-c1form-env nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 5 19 1 4 10 1 4 12 10 1 5 51 1 22 45 8 10 4 45 9 10 3 39 6 13 7 19 1 10 15 11 13 2 10 1 6 2 12 15 12 15 13 10 2 6 2 6 2 12 15 14 15 15 10 2 6 2 6 2 12 15 16 15 17 10 2 6 2 6 2 12 15 18 15 19 10 2 6 2 6 2 12 15 20 15 21 10 2 6 2 6 2 6 6 12 10 0 7 3 73 29) #65# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #66=#A(t (20) (c::relocate-parents-list c::dest c::new-fields c::c1form-parents c::old c::first-cons #:g18825 #:g18826 rplaca #:g18827 #:g18828 rplacd #:g18829 #:g18830 c::c1form si::structure-set #:g18831 #:g18832 #Y(c::relocate-parents-list nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 13 1 19 1 3 40 3 10 0 45 5 10 0 45 6 10 4 45 7 13 1 10 0 17 8 10 0 43 1 43 1 10 0 45 9 10 2 5 45 10 13 1 10 0 17 11 10 0 43 1 43 1 10 2 45 12 75 45 13 13 1 15 14 9 5 13 0 19 4 15 43 1 43 1 10 3 45 16 10 1 45 17 13 1 15 14 9 5 13 0 19 4 15 43 1 43 1 43 2 29) #66# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 53 12 19 2 54 1 0 73 29) #67=#A(t (55) (c::c1form-replace-with c::dest c::new-fields c::c1form-side-effects :format-control "Attempted to move a form with side-effects" c::baboon c::c1form-name c::var eq "Cannot replace forms other than VARs:~%~4I~A" ext::location c::c1form-args c::c1form-parents c::delete-from-read-nodes c::relocate-parents-list c::add-to-read-nodes #:g18857 #:g18858 c::c1form si::structure-set #:g18859 c::c1form-local-vars #:g18860 #:g18861 c::c1form-type c::values-type-and #:g18862 #:g18863 c::c1form-sp-change #:g18864 #:g18865 #:g18866 #:g18867 c::c1form-volatile #:g18868 #:g18869 #:g18870 #:g18871 c::c1form-env #:g18872 #:g18873 c::c1form-form #:g18874 #:g18875 c::c1form-toplevel-form #:g18876 #:g18877 c::c1form-file #:g18878 #:g18879 c::c1form-file-position #:g18880 #Y(c::c1form-replace-with nil nil (24 45 1 24 45 2 26 13 0 19 1 3 39 8 14 4 15 5 19 2 6 13 1 19 1 7 12 1 8 17 9 76 39 10 14 4 15 10 13 1 19 3 6 13 0 19 1 7 42 11 3 38 51 42 8 41 13 0 19 1 12 4 45 8 13 1 19 1 13 39 8 13 0 13 1 19 2 14 13 2 13 1 19 2 15 13 0 13 2 19 2 16 43 1 38 8 13 1 13 0 19 2 15 10 1 45 17 13 1 19 1 7 45 18 13 1 15 19 9 4 13 0 19 4 20 43 1 43 1 10 1 45 21 13 1 19 1 22 45 23 13 1 15 19 9 0 13 0 19 4 20 43 1 43 1 10 1 45 24 13 1 19 1 25 12 13 2 19 1 25 12 19 2 26 45 27 13 1 15 19 9 1 13 0 19 4 20 43 1 43 1 10 1 45 28 13 1 19 1 29 45 30 13 1 15 19 9 2 13 0 19 4 20 43 1 43 1 10 1 45 31 13 1 19 1 3 45 32 13 1 15 19 9 8 13 0 19 4 20 43 1 43 1 10 1 45 33 13 1 19 1 34 45 35 13 1 15 19 9 3 13 0 19 4 20 43 1 43 1 10 1 45 36 13 1 19 1 12 45 37 13 1 15 19 9 7 13 0 19 4 20 43 1 43 1 10 1 45 38 13 1 19 1 39 45 40 13 1 15 19 9 6 13 0 19 4 20 43 1 43 1 10 1 45 41 13 1 19 1 42 45 43 13 1 15 19 9 9 13 0 19 4 20 43 1 43 1 10 1 45 44 13 1 19 1 45 45 46 13 1 15 19 9 10 13 0 19 4 20 43 1 43 1 10 1 45 47 13 1 19 1 48 45 49 13 1 15 19 9 11 13 0 19 4 20 43 1 43 1 10 1 45 50 13 1 19 1 51 45 52 13 1 15 19 9 12 13 0 19 4 20 43 1 43 1 29) #67# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #68=#A(t (11) (c::delete-c1forms c::form c::c1form-name c::var eq c::c1form-args c::delete-from-read-nodes #Y(c::eliminate-references nil nil (24 45 1 26 13 0 19 1 2 12 1 3 17 4 73 39 23 13 0 19 1 5 4 45 3 10 0 73 39 8 13 0 13 1 19 2 6 43 1 29) #68# #1# 0) c::traverse-c1form-tree #Y(c::delete-c1forms nil nil (24 45 1 26 30 1 7 13 1 32 0 12 19 2 8 43 1 29) #68# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #69=#A(t (9) (c::c1form-constant-p c::form c::c1form-name ext::location eq c::c1form-args c::loc-immediate-value-p #Y(c::c1form-constant-p nil nil (24 45 1 26 13 0 19 1 2 12 1 3 17 4 73 39 11 13 0 19 1 5 4 12 19 1 6 29) #69# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (75 73 29) #A(t (0) ()) #1# 0) #Y(si::bytecodes nil nil (14 3 9 128 14 4 15 5 14 6 15 7 14 8 15 9 19 8 10 12 1 11 17 12 78 1 15 0 1 1 17 2 1 0 73 29) #A(t (13) (c::+c1-form-hash+ 0 si::*make-constant :size :rehash-size 1.5d0 :rehash-threshold #70=0.75 :test eq make-hash-table ((multiple-value-setq 2 t nil nil) (block 2 nil t nil) (tagbody 2 nil t nil) (psetq 2 t nil nil) (ext::compiler-let 3 nil nil nil) (catch 2 t nil nil) (values 1 nil t nil) (throw 2 t nil nil) (ext::location 1 nil t t) (ffi::c-inline 6 nil nil nil) (c::fmla-not 1 nil t nil) (c::call-local 2 t nil nil) (ext::compiler-typecase 2 nil nil nil) (c::make-form 2 t nil nil) (c::stack-push-values 2 t nil nil) (c::fmla-and nil nil t nil) (progv 3 t nil nil) (multiple-value-bind 3 nil t nil) (c::init-form 2 t nil nil) (c::fmla-or nil nil t nil) (c::call-global 2 nil nil nil) (c::var 1 nil nil t) (load-time-value 2 nil t t) (if 3 nil t nil) (lambda 3 nil nil nil) (c::ordinary 1 nil t nil) (progn 1 nil t nil) (ext::checked-value 3 nil nil nil) (c::with-stack 1 t nil nil) (function 3 nil nil t) (let* 3 nil t nil) (return-from 4 t nil nil) (c::locals 3 nil t nil) (go 2 t nil nil) (si::structure-set 4 t nil nil) (rplacd 1 t nil nil) (setq 2 t nil nil) (si::fset 5 t nil nil) (unwind-protect 2 t nil nil) (si::structure-ref 4 nil t nil) (funcall 2 t nil nil)) ext::hash-table-fill)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+c1-dispatch-alist+ ((block . c::c1block) (return-from . c::c1return-from) (funcall . c::c1funcall) (catch . c::c1catch) (unwind-protect . c::c1unwind-protect) (throw . c::c1throw) (ffi::defcallback . c::c1-defcallback) (progn . c::c1progn) (ext::with-backend . c::c1with-backend) (ffi::clines . c::c1clines) (ffi::c-inline . c::c1c-inline) (flet . c::c1flet) (labels . c::c1labels) (locally . c::c1locally) (macrolet . c::c1macrolet) (symbol-macrolet . c::c1symbol-macrolet) (if . c::c1if) (not . c::c1not) (and . c::c1and) (or . c::c1or) (let . c::c1let) (let* . c::c1let*) (multiple-value-call . c::c1multiple-value-call) (multiple-value-prog1 . c::c1multiple-value-prog1) (values . c::c1values) (multiple-value-setq . c::c1multiple-value-setq) (multiple-value-bind . c::c1multiple-value-bind) (ext::compiler-typecase . c::c1compiler-typecase) (ext::checked-value . c::c1checked-value) (quote . c::c1quote) (function . c::c1function) (the . c::c1the) (ext::truly-the . c::c1truly-the) (eval-when . c::c1eval-when) (declare . c::c1declare) (ext::compiler-let . c::c1compiler-let) (c::with-stack . c::c1with-stack) (c::innermost-stack-frame . c::c1innermost-stack-frame) (c::stack-push . c::c1stack-push) (c::stack-push-values . c::c1stack-push-values) (c::stack-pop . c::c1stack-pop) (si::apply-from-stack-frame . c::c1apply-from-stack-frame) (tagbody . c::c1tagbody) (go . c::c1go) (setq . c::c1setq) (progv . c::c1progv) (psetq . c::c1psetq) (load-time-value . c::c1load-time-value) (si::fset . c::c1fset) (apply . c::c1apply)) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+t1-dispatch-alist+ ((ext::with-backend . c::c1with-backend) (defmacro . c::t1defmacro) (ext::compiler-let . c::c1compiler-let) (eval-when . c::c1eval-when) (progn . c::c1progn) (macrolet . c::c1macrolet) (locally . c::c1locally) (symbol-macrolet . c::c1symbol-macrolet)) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+set-loc-dispatch-alist+ ((c::bind . c::bind) (c::jump-true . c::set-jump-true) (c::jump-false . c::set-jump-false) (values . c::set-values-loc) (c::value0 . c::set-value0-loc) (return . c::set-return-loc) (c::trash . c::set-trash-loc) (the . c::set-the-loc)) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+wt-loc-dispatch-alist+ ((c::call-normal . c::wt-call-normal) (c::call-indirect . c::wt-call-indirect) (ffi::c-inline . c::wt-c-inline-loc) (c::coerce-loc . c::wt-coerce-loc) (c::temp . c::wt-temp) (c::lcl . c::wt-lcl-loc) (c::fixnum-value . c::wt-number) (c::long-float-value . c::wt-number) (c::double-float-value . c::wt-number) (c::single-float-value . c::wt-number) (c::short-float-value . c::wt-number) (c::character-value . c::wt-character) (c::value . c::wt-value) (c::keyvars . c::wt-keyvars) (the . c::wt-the) (fdefinition . c::wt-fdefinition) (c::make-cclosure . c::wt-make-closure) (c::structure-ref . c::wt-structure-ref) (nil . "ECL_NIL") (t . "ECL_T") (return . "value0") (values . "cl_env_copy->values[0]") (c::va-arg . "va_arg(args,cl_object)") (c::cl-va-arg . "ecl_va_arg(args)") (c::value0 . "value0")) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+c2-dispatch-alist+ ((block . c::c2block) (return-from . c::c2return-from) (funcall . c::c2funcall) (c::call-global . c::c2call-global) (catch . c::c2catch) (unwind-protect . c::c2unwind-protect) (throw . c::c2throw) (progn . c::c2progn) (ffi::c-inline . c::c2c-inline) (c::locals . c::c2locals) (c::call-local . c::c2call-local) (if . c::c2if) (c::fmla-not . c::c2fmla-not) (c::fmla-and . c::c2fmla-and) (c::fmla-or . c::c2fmla-or) (let* . c::c2let*) (values . c::c2values) (multiple-value-setq . c::c2multiple-value-setq) (multiple-value-bind . c::c2multiple-value-bind) (function . c::c2function) (ext::compiler-let . c::c2compiler-let) (c::with-stack . c::c2with-stack) (c::stack-push-values . c::c2stack-push-values) (tagbody . c::c2tagbody) (go . c::c2go) (c::var . c::c2var/location) (ext::location . c::c2var/location) (setq . c::c2setq) (progv . c::c2progv) (psetq . c::c2psetq) (si::fset . c::c2fset) (ext::compiler-typecase . c::c2compiler-typecase) (ext::checked-value . c::c2checked-value)) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+t2-dispatch-alist+ ((ext::compiler-let . c::t2compiler-let) (progn . c::t2progn) (c::ordinary . c::t2ordinary) (load-time-value . c::t2load-time-value) (c::make-form . c::t2make-form) (c::init-form . c::t2init-form)) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+p1-dispatch-alist+ ((block . c::p1block) (return-from . c::p1return-from) (c::call-global . c::p1call-global) (c::call-local . c::p1call-local) (catch . c::p1catch) (throw . c::p1throw) (if . c::p1if) (c::fmla-not . c::p1fmla-not) (c::fmla-and . c::p1fmla-and) (c::fmla-or . c::p1fmla-or) (lambda . c::p1lambda) (let* . c::p1let*) (c::locals . c::p1locals) (multiple-value-bind . c::p1multiple-value-bind) (multiple-value-setq . c::p1multiple-value-setq) (progn . c::p1progn) (progv . c::p1progv) (setq . c::p1setq) (psetq . c::p1psetq) (tagbody . c::p1tagbody) (go . c::p1go) (unwind-protect . c::p1unwind-protect) (c::ordinary . c::p1ordinary) (si::fset . c::p1fset) (c::var . c::p1var) (values . c::p1values) (ext::location . c::p1trivial) (ffi::c-inline . c::p1trivial) (function . c::p1trivial) (funcall . c::p1trivial) (load-time-value . c::p1trivial) (c::make-form . c::p1trivial) (c::init-form . c::p1trivial) (c::with-stack . c::p1with-stack) (c::stack-push-values . c::p1stack-push-values) (ext::compiler-typecase . c::p1compiler-typecase) (ext::checked-value . c::p1checked-value)) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #71=#A(t (18) (c::make-dispatch-table c::alist :size length * max :test eq make-hash-table c::hash #:loop-list18895 function c::name 0 #72=#:loop-desetq-temp si::hash-set #Y(c::make-dispatch-table nil nil (24 45 1 26 58 60 104 14 2 9 128 9 2 10 1 16 3 12 19 2 4 12 19 2 5 12 14 6 33 7 12 19 4 8 45 9 77 77 13 2 46 10 46 11 46 12 57 13 61 2 2 47 10 3 2 39 4 35 0 1 10 3 4 45 14 10 0 4 51 2 10 0 5 51 0 10 0 51 3 43 1 10 3 5 51 3 13 1 13 4 13 2 19 3 15 35 0 0 10 4 73 36 5 62 73 43 3 43 1 63 29) #71# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 14 2 19 1 3 52 0 1 0 73 29) #A(t (4) (c::*c1-dispatch-table* si::*make-special c::+c1-dispatch-alist+ c::make-dispatch-table)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 14 2 19 1 3 52 0 1 0 73 29) #A(t (4) (c::*t1-dispatch-table* si::*make-special c::+t1-dispatch-alist+ c::make-dispatch-table)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 14 2 19 1 3 52 0 1 0 73 29) #A(t (4) (c::*c2-dispatch-table* si::*make-special c::+c2-dispatch-alist+ c::make-dispatch-table)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 14 2 19 1 3 52 0 1 0 73 29) #A(t (4) (c::*set-loc-dispatch-table* si::*make-special c::+set-loc-dispatch-alist+ c::make-dispatch-table)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 14 2 19 1 3 52 0 1 0 73 29) #A(t (4) (c::*wt-loc-dispatch-table* si::*make-special c::+wt-loc-dispatch-alist+ c::make-dispatch-table)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 14 2 19 1 3 52 0 1 0 73 29) #A(t (4) (c::*t2-dispatch-table* si::*make-special c::+t2-dispatch-alist+ c::make-dispatch-table)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 14 2 19 1 3 52 0 1 0 73 29) #A(t (4) (c::*p1-dispatch-table* si::*make-special c::+p1-dispatch-alist+ c::make-dispatch-table)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 77 19 1 2 52 0 1 0 73 29) #A(t (3) (c::*p0-dispatch-table* si::*make-special c::make-dispatch-table)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 77 19 1 2 52 0 1 0 73 29) #A(t (3) (c::*cinline-dispatch-table* si::*make-special c::make-dispatch-table)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #73=#A(t (19) (c::make-inline-temp-var c::value-type c::rep-type c::lisp-type->rep-type c::out-rep-type :object eq c::make-temp-var :rep-type :type c::make-lcl-var c::var c::open-inline-block c::rep-type-name " " ";" c::wt-nl #Y(c::make-inline-temp-var nil nil (24 45 1 25 40 2 77 46 2 26 10 0 40 6 13 1 19 1 3 45 4 13 0 11 5 17 6 39 6 19 0 7 38 37 14 8 13 0 14 9 13 2 19 4 10 45 11 19 0 12 13 1 19 1 13 12 15 14 13 0 15 15 19 4 16 10 0 73 43 1 43 1 29) #73# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #74=#A(t (11) (c::save-inline-loc c::loc second c::loc-representation-type c::rep-type c::make-inline-temp-var c::temp c::*destination* c::set-loc #Y(c::save-inline-loc nil nil (24 45 1 26 10 0 16 2 12 19 1 3 45 4 10 1 4 12 13 0 19 2 5 45 6 10 0 48 7 13 2 19 1 8 10 0 73 43 2 44 1 29) #74# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 14 17 9 2 19 4 18 1 0 73 29) #75=#A(t (19) (c::with-inlined-loc #:g18900 #:g18899 #:g18901 si::dm-too-few-arguments #:g18902 #:g18903 c::temp-loc c::loc c::body si::dm-too-many-arguments let c::save-inline-loc setf list c::var-type #Y(c::with-inlined-loc nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 5 19 1 4 10 1 4 12 10 1 5 51 1 22 45 8 10 4 45 9 10 3 39 6 13 7 19 1 10 15 11 13 2 15 12 10 1 6 2 6 2 6 1 12 15 13 13 2 15 14 15 15 10 2 6 2 12 10 2 6 3 6 3 12 10 0 7 4 73 29) #75# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #76=#A(t (15) (c::emit-inlined-variable c::form c::rest-forms c::c1form-args c::c1form-primary-type c::value-type c::var c::var-changed-in-form-list c::var-rep-type c::make-inline-temp-var c::temp c::*destination* c::set-loc #Y(c::emit-inlined-variable nil nil (24 45 1 24 45 2 26 13 1 19 1 3 4 12 13 1 19 1 4 12 46 5 46 6 13 0 13 2 19 2 7 39 36 13 1 13 0 19 1 8 12 19 2 9 45 10 10 0 48 11 13 1 19 1 12 44 1 13 2 10 0 6 2 73 43 1 38 8 13 1 10 0 6 2 73 43 2 29) #76# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #77=#A(t (18) (c::emit-inlined-setq c::form c::rest-forms c::c1form-args second c::form1 c::vref c::*destination* c::c2expr* c::c1form-name ext::location eq c::c1form-primary-type c::var c::make-c1form c::emit-inlined-variable #Y(c::emit-inlined-setq nil nil (24 45 1 24 45 2 26 13 1 19 1 3 4 12 13 1 19 1 3 16 4 12 46 5 46 6 10 0 48 7 13 1 19 1 8 44 1 13 1 19 1 9 12 1 10 17 11 39 18 13 1 19 1 12 12 13 1 19 1 3 4 6 2 73 38 16 15 13 13 3 13 0 19 3 14 12 13 2 19 2 15 43 2 29) #77# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 1 0 73 29) #78=#A(t (28) (c::emit-inlined-call-global c::form c::expected-type c::c1form-args c::fname second c::args c::c1form-primary-type c::return-type c::*global-funs* :key c::fun-name :test c::same-fname-p find c::fun c::call-global-loc c::loc c::loc-type c::type-and type c::loc-representation-type c::make-inline-temp-var c::temp c::*destination* c::set-loc #Y(c::emit-inlined-call-global nil nil (24 45 1 24 45 2 26 13 1 19 1 3 4 45 4 13 2 19 1 3 16 5 45 6 13 3 19 1 7 45 8 13 2 14 9 14 10 33 11 12 14 12 33 13 12 19 6 14 45 15 13 3 13 0 13 2 13 1 13 4 19 5 16 45 17 13 2 13 0 19 1 18 12 19 2 19 45 20 13 0 13 1 19 1 21 12 19 2 22 45 23 10 0 48 24 13 2 19 1 25 13 1 10 0 6 2 73 43 7 44 1 29) #78# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #79=#A(t (13) (c::emit-inlined-progn c::form c::forms c::c1form-args c::args c::trash c::*destination* 0 #:g18907 c::c2expr* c::emit-inline-form #Y(c::emit-inlined-progn nil nil (24 45 1 24 45 2 26 13 1 19 1 3 4 45 4 1 5 48 6 57 7 61 2 2 35 10 1 5 76 39 4 35 0 1 10 1 45 8 10 0 4 12 10 0 5 51 0 10 0 51 2 43 1 19 1 9 35 0 0 62 44 1 10 0 4 12 13 1 19 2 10 43 1 29) #79# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #80=#A(t (14) (c::emit-inlined-values c::form c::forms c::c1form-args c::args #:g18910 c::emit-inline-form c::trash c::*destination* #:loop-list18911 0 c::c2expr* #Y(c::emit-inlined-values nil nil (24 45 1 24 45 2 26 13 1 19 1 3 4 45 4 10 0 45 5 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 13 1 19 2 6 12 1 7 48 8 77 13 0 46 9 46 1 57 10 61 2 2 27 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 19 1 11 35 0 0 62 43 2 44 1 22 73 43 1 29) #80# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #81=#A(t (19) (c::emit-inlined-structure-ref c::form c::rest-forms c::c1form-primary-type type c::args-cause-side-effect :object c::make-inline-temp-var c::temp c::*destination* c::c2expr* si::structure-ref c::c1form-args c::inline-args c::coerce-locs second nth #Y(c::emit-inlined-structure-ref nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 13 1 19 1 5 39 32 13 0 14 6 19 2 7 45 8 10 0 48 9 13 3 19 1 10 13 1 10 0 6 2 73 43 1 44 1 38 55 13 0 15 11 13 2 19 1 12 4 6 1 12 19 1 13 12 19 1 14 4 12 13 2 19 1 12 16 15 12 9 2 13 2 19 1 12 17 16 12 9 3 13 2 19 1 12 17 16 6 5 6 2 73 43 1 29) #81# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #82=#A(t (18) (c::emit-inlined-instance-ref c::form c::rest-forms c::c1form-primary-type type c::args-cause-side-effect :object c::make-inline-temp-var c::temp c::*destination* c::c2expr* si::instance-ref c::c1form-args c::inline-args c::coerce-locs second #Y(c::emit-inlined-instance-ref nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 13 1 19 1 5 39 32 13 0 14 6 19 2 7 45 8 10 0 48 9 13 3 19 1 10 13 1 10 0 6 2 73 43 1 44 1 38 35 13 0 15 11 13 2 19 1 12 4 6 1 12 19 1 13 12 19 1 14 4 12 13 2 19 1 12 16 15 6 3 6 2 73 43 1 29) #82# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 36 12 19 2 37 1 0 73 29) #83=#A(t (38) (c::emit-inline-form c::form c::forms c::c1form-file *compile-file-truename* c::c1form-file-position c::*compile-file-position* c::c1form-toplevel-form c::*current-toplevel-form* c::c1form-form c::*current-form* c::c1form-env c::*cmp-env* c::c1form-name ext::location c::c1form-primary-type c::c1form-args c::var c::emit-inlined-variable c::call-global c::emit-inlined-call-global si::structure-ref c::emit-inlined-structure-ref si::instance-ref c::emit-inlined-instance-ref setq c::emit-inlined-setq progn c::emit-inlined-progn values c::emit-inlined-values type c::make-inline-temp-var c::temp c::*destination* c::c2expr* #Y(c::emit-inline-form nil nil (24 45 1 24 45 2 26 10 1 45 1 13 0 19 1 3 48 4 13 0 19 1 5 48 6 13 0 19 1 7 48 8 13 0 19 1 9 48 10 13 0 19 1 11 48 12 13 0 19 1 13 42 14 18 13 0 19 1 15 12 13 0 19 1 16 4 6 2 73 38 123 42 17 10 13 0 13 1 19 2 18 38 111 42 19 14 13 0 13 0 19 1 15 12 19 2 20 38 95 42 21 10 13 0 13 1 19 2 22 38 83 42 23 10 13 0 13 1 19 2 24 38 71 42 25 10 13 0 13 1 19 2 26 38 59 42 27 10 13 0 13 1 19 2 28 38 47 42 29 10 13 0 13 1 19 2 30 38 35 13 0 19 1 15 45 31 13 0 19 1 32 45 33 10 0 48 34 13 2 19 1 35 44 1 13 1 10 0 6 2 73 43 2 43 1 44 5 29) #83# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #84=#A(t (12) (c::inline-args c::forms c::form-list c::form #:loop-list-head18914 #:loop-list-tail18915 0 atom c::emit-inline-form rplacd #Y(c::inline-args nil nil (24 45 1 26 58 60 77 10 1 45 2 75 45 3 75 6 1 45 4 10 0 45 5 57 6 61 2 2 40 10 4 16 7 39 4 35 0 1 10 4 4 51 3 13 1 13 3 10 4 5 12 19 2 8 6 1 51 1 17 9 10 4 5 51 4 35 0 0 10 2 5 73 36 5 62 73 43 2 43 1 43 1 63 29) #84# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #85=#A(t (6) (c::destination-type c::*destination* c::loc-representation-type c::rep-type->lisp-type #Y(c::destination-type nil nil (26 14 1 19 1 2 12 19 1 3 29) #85# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #86=#A(t (6) (c::maybe-open-inline-block c::*inline-blocks* plusp c::open-inline-block #Y(c::maybe-open-inline-block nil nil (26 11 1 16 2 76 73 39 4 19 0 3 29) #86# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #87=#A(t (7) (c::open-inline-block c::wt-nl-open-brace #:g18919 c::*inline-blocks* + #Y(c::open-inline-block nil nil (26 19 0 1 8 1 45 2 14 3 13 0 19 2 4 52 3 73 43 1 29) #87# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #88=#A(t (11) (c::close-inline-blocks c::new-line c::*inline-blocks* #:loop-limit18921 c::i 0 >= c::wt-nl-close-brace 1+ #Y(c::close-inline-blocks nil nil (25 40 2 77 46 1 26 9 0 14 2 46 3 46 4 57 5 61 2 2 25 13 1 13 2 19 2 6 39 4 35 0 1 19 0 7 10 1 16 8 51 1 35 0 0 62 73 43 2 29) #88# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #89=#A(t (5) (c::form-causes-side-effect c::form c::c1form-side-effects #Y(c::form-causes-side-effect nil nil (24 45 1 26 13 0 19 1 2 29) #89# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #90=#A(t (6) (c::args-cause-side-effect c::forms c::c1form-side-effects some #Y(c::args-cause-side-effect nil nil (24 45 1 26 33 2 12 13 0 19 2 3 29) #90# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #91=#A(t (6) (c::function-may-have-side-effects c::fname c::no-side-effects si::get-sysprop #Y(c::function-may-have-side-effects nil nil (24 45 1 26 13 0 1 2 17 3 76 73 29) #91# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #92=#A(t (7) (c::function-may-change-sp c::fname c::no-side-effects si::get-sysprop c::no-sp-change #Y(c::function-may-change-sp nil nil (24 45 1 26 13 0 1 2 17 3 40 7 13 0 1 4 17 3 76 73 29) #92# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 15 3 1 4 17 2 15 5 1 6 17 2 15 7 1 8 17 2 1 7 73 29) #A(t (9) (c::+note-format+ "~&~@<  ~;~?~;~:@>" si::*make-constant c::+warn-format+ "~&~@<  ! ~;~?~;~:@>" c::+error-format+ "~&~@<  * ~;~?~;~:@>" c::+fatal-format+ "~&~@<  ** ~;~?~;~:@>")) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #93=#A(t (6) (c::brief-namestring c::path si::coerce-to-filename enough-namestring #Y(c::brief-namestring nil nil (24 45 1 26 10 0 16 2 12 19 1 3 29) #93# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #94=#A(t (11) (c::innermost-non-expanded-form c::form listp c::output #:loop-list18925 c::f 0 macroexpand eq #Y(c::innermost-non-expanded-form nil nil (24 45 1 26 10 0 16 2 73 39 75 58 60 72 75 45 3 77 13 2 46 4 46 5 57 6 61 2 2 44 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 1 7 17 8 39 6 75 51 3 38 10 10 3 76 39 5 10 1 51 3 35 0 0 10 3 73 36 4 62 73 43 2 43 1 63 29) #94# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 30 12 19 2 31 1 0 73 29) #95=#A(t (32) (c::compiler-message-report stream c::c c::format-control c::format-arguments c::compiler-message-file-position c::compiler-message-prefix c::compiler-message-file c::compiler-message-toplevel-form c::innermost-non-expanded-form c::form c::file c::prefix position minusp c::|compiler preprocess| equalp *print-length* *print-level* "~A:~%  in file ~A, position ~D~&  at ~A" :name pathname-name :type pathname-type :version pathname-version make-pathname format "~A:" c::compiler-message-format #Y(c::compiler-message-report nil nil (24 45 1 24 45 2 24 45 3 27 45 4 13 2 19 1 5 12 13 2 19 1 6 12 13 2 19 1 7 12 13 2 19 1 8 12 19 1 9 12 46 10 46 11 46 12 46 13 10 3 39 19 10 0 39 15 10 0 16 14 76 39 8 13 3 1 15 17 16 76 39 53 8 2 48 17 8 2 48 18 13 7 15 19 13 1 14 20 13 2 19 1 21 12 14 22 13 2 19 1 23 12 14 24 10 2 16 25 12 19 6 26 12 13 0 13 3 19 6 27 44 2 38 10 13 7 15 28 13 1 19 3 27 13 7 13 6 19 1 29 12 13 5 13 4 19 4 27 43 4 29) #95# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 14 2 1 10 12 1 11 7 3 12 15 12 15 13 14 2 1 15 12 1 16 7 3 12 14 2 1 18 12 1 19 7 3 12 14 2 1 21 12 1 22 7 3 12 14 2 1 24 12 1 25 7 3 6 7 12 77 19 4 26 1 0 73 29) #96=#A(t (27) (c::compiler-message (simple-condition) :initfunction c::c stream c::compiler-message-report simple-condition-format-control simple-condition-format-arguments apply #Y(nil nil nil (24 45 3 24 45 4 26 33 5 12 13 0 13 1 13 1 19 1 6 12 13 1 19 1 7 12 19 5 8 29) #96# #1# 0) #Y(nil nil nil (26 34 9 73 29) #96# #1# 0) (:initform (lambda (c::c stream) (apply #'c::compiler-message-report stream c::c (simple-condition-format-control c::c) (simple-condition-format-arguments c::c))) :name si::report-function) (:writers ((setf c::compiler-message-prefix)) :readers (c::compiler-message-prefix) :initform "Note" :name c::prefix) (:writers ((setf c::compiler-message-format)) :readers (c::compiler-message-format) :initform c::+note-format+ :name format) *compile-file-pathname* #Y(nil nil nil (26 11 14 73 29) #96# #1# 0) (:writers ((setf c::compiler-message-file)) :readers (c::compiler-message-file) :initform *compile-file-pathname* :initargs (:file) :name c::file) c::*compile-file-position* #Y(nil nil nil (26 11 17 73 29) #96# #1# 0) (:writers ((setf c::compiler-message-file-position)) :readers (c::compiler-message-file-position) :initform c::*compile-file-position* :initargs (:file) :name position) c::*current-toplevel-form* #Y(nil nil nil (26 11 20 73 29) #96# #1# 0) (:writers ((setf c::compiler-message-toplevel-form)) :readers (c::compiler-message-toplevel-form) :initform c::*current-toplevel-form* :initargs (:form) :name c::toplevel-form) c::*current-form* #Y(nil nil nil (26 11 23 73 29) #96# #1# 0) (:writers ((setf c::compiler-message-form)) :readers (c::compiler-message-form) :initform c::*current-form* :initargs (:form) :name c::form) clos::load-defclass)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 19 4 2 1 0 73 29) #A(t (3) (c::compiler-note (c::compiler-message) clos::load-defclass)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 19 4 2 1 0 73 29) #A(t (3) (c::compiler-debug-note (c::compiler-note) clos::load-defclass)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 77 19 4 3 1 0 73 29) #A(t (4) (c::compiler-warning (c::compiler-message style-warning) ((:initform "Warning" :name c::prefix) (:initform c::+warn-format+ :name format)) clos::load-defclass)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 77 77 19 4 2 1 0 73 29) #A(t (3) (c::compiler-macro-expansion-failed (c::compiler-warning) clos::load-defclass)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 77 19 4 3 1 0 73 29) #A(t (4) (c::compiler-error (c::compiler-message) ((:initform "Error" :name c::prefix) (:initform c::+error-format+ :name format)) clos::load-defclass)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 77 19 4 3 1 0 73 29) #A(t (4) (c::compiler-fatal-error (c::compiler-error) ((:initform c::+fatal-format+ :name format)) clos::load-defclass)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 77 19 4 3 1 0 73 29) #A(t (4) (c::compiler-internal-error (c::compiler-fatal-error) ((:initform "Internal error" :name c::prefix)) clos::load-defclass)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 77 19 4 3 1 0 73 29) #A(t (4) (c::compiler-style-warning (c::compiler-message style-warning) ((:initform "Style warning" :name c::prefix) (:initform c::+warn-format+ :name format)) clos::load-defclass)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 14 2 1 10 12 1 11 7 3 12 1 12 6 2 12 77 19 4 13 1 0 73 29) #97=#A(t (14) (c::compiler-undefined-variable (c::compiler-style-warning) :initfunction c::c stream #98="Variable ~A was undefined. ~
                               Compiler assumes it is a global." variable slot-value c::compiler-message-report #Y(nil nil nil (24 45 3 24 45 4 26 13 0 13 1 15 5 13 1 15 6 19 2 7 12 19 4 8 29) #97# #1# 0) #Y(nil nil nil (26 34 9 73 29) #97# #1# 0) (:initform (lambda (c::c stream) (c::compiler-message-report stream c::c #98# (slot-value c::c 'variable))) :name si::report-function) (:initform nil :initargs (:name) :name variable) clos::load-defclass)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #99=#A(t (9) (c::print-compiler-message c::c stream c::*suppress-compiler-messages* typep "~&~@<;;; ~@;~A~:>" format #Y(c::print-compiler-message nil nil (24 45 1 24 45 2 26 13 1 14 3 19 2 4 76 73 39 10 13 0 15 5 13 1 19 3 6 29) #99# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 1 0 73 29) #100=#A(t (4) (c::handle-compiler-note c::c #Y(c::handle-compiler-note nil nil (24 45 1 26 75 73 29) #100# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #101=#A(t (5) (c::handle-compiler-warning c::c c::*compiler-conditions* #Y(c::handle-compiler-warning nil nil (24 45 1 26 13 0 11 2 3 52 2 75 73 29) #101# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #102=#A(t (9) (c::handle-compiler-error c::c signal c::*compiler-conditions* t c::print-compiler-message abort #Y(c::handle-compiler-error nil nil (24 45 1 26 13 0 19 1 2 13 0 11 3 3 52 3 13 0 14 4 19 2 5 19 0 6 29) #102# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #103=#A(t (16) (c::handle-compiler-internal-error c::c c::*compiler-break-enable* invoke-debugger c::compiler-internal-error :format-control "~A" :format-arguments make-condition c::*compiler-conditions* signal t c::print-compiler-message abort #Y(c::handle-compiler-internal-error nil nil (24 45 1 26 11 2 39 6 13 0 19 1 3 15 4 14 5 15 6 14 7 10 0 6 1 12 19 5 8 51 0 13 0 11 9 3 52 9 13 0 19 1 10 13 0 14 11 19 2 12 19 0 13 29) #103# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #104=#A(t (12) (c::do-compilation-unit c::closure (nil :override) c::override c::*active-protection* t c::*pending-actions* #:loop-list18937 c::action 0 #Y(c::do-compilation-unit nil nil (24 45 1 28 2 22 40 2 77 46 3 10 0 39 13 75 48 4 13 1 19 1 0 44 1 38 73 11 4 76 39 63 11 5 48 4 75 48 6 64 7 13 1 19 1 0 65 77 14 6 46 7 46 8 57 9 61 2 2 27 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 20 0 23 35 0 0 62 43 2 66 44 2 38 6 13 1 20 0 23 29) #104# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 14 13 9 2 19 4 14 1 0 73 29) #105=#A(t (15) (with-compilation-unit #:g18939 #:g18938 #:g18940 si::dm-too-few-arguments #:g18941 #:g18942 c::options c::body c::do-compilation-unit function lambda #Y(with-compilation-unit nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 45 7 10 3 45 8 15 9 15 10 15 11 77 10 0 7 3 6 2 12 10 1 7 3 73 29) #105# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 23 12 14 24 9 2 19 4 25 1 0 73 29) #106=#A(t (26) (c::with-compiler-env #:g18944 #:g18943 #:g18945 si::dm-too-few-arguments #:g18946 #:g18947 c::compiler-conditions c::body si::dm-too-many-arguments let ((c::*compiler-conditions* nil)) (declare (special c::*compiler-conditions*)) restart-case handler-bind ((c::compiler-note #'c::handle-compiler-note) (warning #'c::handle-compiler-warning) (c::compiler-error #'c::handle-compiler-error) (c::compiler-internal-error #'c::handle-compiler-internal-error) (serious-condition #'c::handle-compiler-internal-error)) mp::with-lock (mp::+load-compile-lock+) c::+init-env-form+ with-compilation-unit (abort nil) setf c::*compiler-conditions* #Y(c::with-compiler-env nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 3 45 8 10 2 39 6 13 6 19 1 9 15 10 15 11 15 12 15 13 15 14 15 15 15 16 15 17 15 10 14 18 15 19 77 10 0 7 3 6 3 6 3 6 3 12 1 20 6 3 12 15 21 13 1 1 22 6 3 6 5 73 29) #106# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*c1form-level* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #107=#A(t (14) (c::print-c1forms c::form consp c::*c1form-level* 1+ mapc c::c1form-p t "~% ~D > ~A, parent ~A" c::c1form-parent format c::c1form-args #Y(c::print-c1forms nil nil (24 45 1 26 10 0 16 2 39 19 11 3 16 4 48 3 33 0 12 13 0 19 2 5 44 1 38 38 13 0 19 1 6 73 39 30 14 7 15 8 14 3 13 0 13 0 19 1 9 12 19 5 10 13 0 19 1 11 12 19 1 0 10 0 73 29) #107# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #108=#A(t (11) (c::print-ref c::ref-object stream c::ref-name c::name "#<a ~A: ~A>" type-of format "#<a ~A>" #Y(c::print-ref nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 10 0 39 17 13 1 15 5 10 2 16 6 12 13 0 19 4 7 38 13 13 1 15 8 10 2 16 6 12 19 3 7 43 1 29) #108# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #109=#A(t (9) (c::print-var c::var-object stream "#<a VAR: ~A KIND: ~A>" c::var-name c::var-kind format #Y(c::print-var nil nil (24 45 1 24 45 2 26 13 0 15 3 13 1 19 1 4 12 13 1 19 1 5 12 19 4 6 29) #109# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #110=#A(t (8) (c::cmpprogress c::args *compile-verbose* format t apply #Y(c::cmpprogress nil nil (27 45 1 11 2 73 39 11 33 3 12 14 4 13 0 19 3 5 29) #110# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 14 11 9 3 19 4 12 1 0 73 29) #111=#A(t (13) (c::cmpck #:g18949 #:g18948 #:g18950 si::dm-too-few-arguments condition string c::args if c::cmperr #Y(c::cmpck nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 45 7 15 8 13 2 15 9 13 1 10 0 7 3 6 3 73 29) #111# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 14 11 9 3 19 4 12 1 0 73 29) #112=#A(t (13) (c::cmpassert #:g18952 #:g18951 #:g18953 si::dm-too-few-arguments condition string c::args unless c::cmperr #Y(c::cmpassert nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 45 7 15 8 13 2 15 9 13 1 10 0 7 3 6 3 73 29) #112# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #113=#A(t (14) (c::cmperr string c::args c::compiler-error :format-control :format-arguments make-condition c::c signal t c::print-compiler-message abort #Y(c::cmperr nil nil (24 45 1 27 45 2 15 3 14 4 13 1 14 5 13 0 19 5 6 45 7 13 0 19 1 8 13 0 14 9 19 2 10 19 0 11 43 1 29) #113# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #114=#A(t (12) (c::safe-list-length c::l c::slow c::fast t c::flag 0 consp eq 1+ #Y(c::safe-list-length nil nil (24 45 1 26 58 60 115 10 1 45 2 10 2 45 3 11 4 45 5 8 0 45 1 57 6 61 2 2 77 10 3 76 39 8 10 1 73 36 5 38 56 10 3 16 7 76 39 7 75 73 36 5 38 43 10 2 39 11 75 51 2 10 3 5 51 3 38 29 13 4 10 3 17 8 39 7 75 73 36 5 38 15 11 4 51 2 10 4 5 51 4 10 3 5 51 3 10 1 16 9 51 1 35 0 0 10 1 73 36 5 62 73 43 1 43 1 43 1 43 1 63 29) #114# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #115=#A(t (18) (c::check-args-number c::operator c::args min most-positive-fixnum max c::safe-list-length c::l t *print-circle* "Improper or circular list passed to ~A~%~A" c::cmperr < c::too-few-args > c::too-many-args #Y(c::check-args-number nil nil (24 45 1 24 45 2 25 40 3 9 0 46 3 25 40 3 14 4 46 5 26 13 2 19 1 6 45 7 10 0 76 39 16 11 8 48 9 15 10 13 4 13 3 19 3 11 44 1 13 0 13 2 19 2 12 39 10 13 4 13 2 13 0 19 3 13 10 1 39 8 13 0 13 1 19 2 14 73 39 10 13 4 13 1 13 0 19 3 15 43 1 29) #115# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #116=#A(t (10) (c::too-many-args c::name c::upper-bound c::n :upcase *print-case* "~S requires at most ~R argument~:p, but ~R ~:*~[were~;was~:;were~] supplied.~%" c::cmperr #Y(c::too-many-args nil nil (24 45 1 24 45 2 24 45 3 26 11 4 48 5 15 6 13 2 13 1 13 0 19 4 7 44 1 29) #116# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #117=#A(t (8) (c::too-few-args c::name c::lower-bound c::n "~S requires at least ~R argument~:p, but only ~R ~:*~[were~;was~:;were~] supplied.~%" c::cmperr #Y(c::too-few-args nil nil (24 45 1 24 45 2 24 45 3 26 15 4 13 2 13 1 13 0 19 4 5 29) #117# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 1 0 73 29) #118=#A(t (28) (c::do-cmpwarn c::args make-condition apply condition #:g18964 #:g18965 0 :name muffle-warning :function si::temp #Y(nil nil nil (27 45 11 10 0 51 2 35 1 0 29) #118# #1# 0) :report-function stream "Skip warning" write-string #Y(nil nil nil (24 45 14 26 15 15 13 0 19 2 16 29) #118# #1# 0) si::make-restart si::*restart-clusters* #:g18967 si::*condition-restarts* signal #Y(nil nil nil (26 75 73 36 4 29) #118# #1# 0) t c::print-compiler-message #Y(c::do-cmpwarn nil nil (27 45 1 57 0 60 101 33 2 12 13 1 19 2 3 45 4 57 5 60 77 75 45 6 57 7 61 1 55 14 8 15 9 14 10 34 12 12 14 13 34 17 12 19 6 18 6 1 12 11 19 3 48 19 10 3 45 20 13 0 11 19 4 3 12 11 21 3 48 21 13 0 19 1 22 44 1 43 1 36 2 44 1 34 23 12 13 1 19 2 3 36 2 62 43 1 63 13 0 14 24 19 2 25 43 1 63 29) #118# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #119=#A(t (9) (c::cmpwarn-style string c::args c::compiler-style-warning :format-control :format-arguments c::do-cmpwarn #Y(c::cmpwarn-style nil nil (24 45 1 27 45 2 15 3 14 4 13 1 14 5 13 0 19 5 6 29) #119# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #120=#A(t (9) (c::cmpwarn string c::args c::compiler-warning :format-control :format-arguments c::do-cmpwarn #Y(c::cmpwarn nil nil (24 45 1 27 45 2 15 3 14 4 13 1 14 5 13 0 19 5 6 29) #120# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #121=#A(t (9) (c::cmpnote string c::args c::compiler-note :format-control :format-arguments c::do-cmpwarn #Y(c::cmpnote nil nil (24 45 1 27 45 2 15 3 14 4 13 1 14 5 13 0 19 5 6 29) #121# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #122=#A(t (9) (c::cmpdebug string c::args c::compiler-debug-note :format-control :format-arguments c::do-cmpwarn #Y(c::cmpdebug nil nil (24 45 1 27 45 2 15 3 14 4 13 1 14 5 13 0 19 5 6 29) #122# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #123=#A(t (11) (c::print-current-form *compile-print* *print-level* *print-length* t "~&;;; Compiling ~s.~%" c::*current-toplevel-form* c::innermost-non-expanded-form format #Y(c::print-current-form nil nil (26 11 1 39 24 9 2 9 2 49 2 49 3 14 4 15 5 14 6 19 1 7 12 19 3 8 44 2 75 73 29) #123# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #124=#A(t (11) (c::print-emitting c::f *compile-print* c::fun-name c::fun-description c::name t "~&;;; Emitting code for ~s.~%" format #Y(c::print-emitting nil nil (24 45 1 26 11 2 73 39 31 13 0 19 1 3 40 6 13 0 19 1 4 45 5 10 0 73 39 10 14 6 15 7 13 0 19 3 8 43 1 29) #124# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #125=#A(t (7) (c::undefined-variable c::sym c::compiler-undefined-variable :name c::do-cmpwarn #Y(c::undefined-variable nil nil (24 45 1 26 15 2 14 3 13 0 19 3 4 29) #125# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #126=#A(t (11) (c::baboon (nil :format-arguments :format-control) "A bug was found in the compiler" c::format-control c::format-arguments c::compiler-internal-error :format-control :format-arguments signal #Y(c::baboon nil nil (28 1 22 40 3 15 2 46 3 22 40 2 77 46 4 15 5 14 6 13 1 14 7 13 0 19 5 8 29) #126# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 14 20 9 3 19 4 21 1 0 73 29) #127=#A(t (22) (c::with-cmp-protection #:g18969 #:g18968 #:g18970 si::dm-too-few-arguments c::main-form c::error-form si::dm-too-many-arguments let* ((si::*break-enable* c::*compiler-break-enable*) (c::throw-flag t)) unwind-protect multiple-value-prog1 if c::*compiler-break-enable* handler-bind ((error #'invoke-debugger)) (setf c::throw-flag nil) when c::throw-flag #Y(c::with-cmp-protection nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 39 6 13 4 19 1 7 15 8 15 9 15 10 15 11 15 12 15 13 15 14 15 15 10 1 6 3 12 10 1 6 4 12 1 16 6 3 12 15 17 15 18 10 0 6 3 6 3 6 3 73 29) #127# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #128=#A(t (20) (c::cmp-eval c::form c::*cmp-env* c::env #:g18974 #:g18975 0 serious-condition si::temp #Y(nil nil nil (24 45 8 26 10 0 51 2 35 1 0 29) #128# #1# 0) si::*handler-clusters* t si::eval-with-env c::c c::*compiler-break-enable* invoke-debugger "The form ~s was not evaluated successfully.~%Error detected:~%~A" c::cmperr #Y(c::cmp-eval nil nil (24 45 1 25 40 3 14 2 46 3 26 57 4 60 71 75 45 5 57 6 61 1 30 15 7 34 9 3 6 1 12 11 10 3 48 10 13 4 13 3 77 14 11 14 11 19 5 12 36 2 44 1 10 1 45 13 11 14 39 6 13 0 19 1 15 15 16 13 5 13 0 19 3 17 75 73 43 1 36 2 62 73 43 1 63 29) #128# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #129=#A(t (6) (c::cmp-macro-function c::name c::cmp-env-search-macro macro-function #Y(c::cmp-macro-function nil nil (24 45 1 26 13 0 19 1 2 73 40 6 13 0 19 1 3 29) #129# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #130=#A(t (22) (c::cmp-expand-macro c::fd c::form c::*cmp-env* c::env #:g18980 #:g18981 0 serious-condition si::temp #Y(nil nil nil (24 45 9 26 10 0 51 2 35 1 0 29) #130# #1# 0) si::*handler-clusters* *macroexpand-hook* c::new-form eql c::c c::*compiler-break-enable* invoke-debugger "The macro form ~s was not expanded successfully.~%Error detected:~%~A" c::cmperr #Y(c::cmp-expand-macro nil nil (24 45 1 24 45 2 25 40 3 14 3 46 4 26 57 5 60 88 75 45 6 57 7 61 1 45 15 8 34 10 3 6 1 12 11 11 3 48 11 14 12 13 5 13 4 13 3 20 3 23 45 13 13 0 13 0 10 5 17 14 76 12 72 2 43 1 36 2 44 1 10 1 45 15 11 16 39 6 13 0 19 1 17 15 18 13 5 13 0 19 3 19 77 77 72 2 43 1 36 2 62 73 43 1 63 29) #130# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #131=#A(t (22) (c::cmp-expand-compiler-macro c::fd c::fname c::args c::*cmp-env* c::env #:g18986 #:g18987 0 serious-condition si::temp #Y(nil nil nil (24 45 10 26 10 0 51 2 35 1 0 29) #131# #1# 0) si::*handler-clusters* c::cmp-expand-macro c::c c::compiler-macro-expansion-failed :format-control "The expansion of the compiler macro~%~T~A~%was aborted because of a serious condition~%~A" :format-arguments c::do-cmpwarn #Y(c::cmp-expand-compiler-macro nil nil (24 45 1 24 45 2 24 45 3 25 40 3 14 4 46 5 26 57 6 60 75 75 45 7 57 8 61 1 32 15 9 34 11 3 6 1 12 11 12 3 48 12 13 6 13 5 10 4 7 2 12 13 3 19 3 13 36 2 44 1 10 1 45 14 15 15 14 16 15 17 14 18 13 6 10 0 6 2 12 19 5 19 77 77 72 2 43 1 36 2 62 73 43 1 63 29) #131# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #132=#A(t (15) (si::compiler-clear-compiler-properties symbol c::t1 si::rem-sysprop c::t2 c::t3 c::c1 c::c2 c::c1conditional :inline-always :inline-unsafe :inline-safe c::lfun #Y(si::compiler-clear-compiler-properties nil nil (24 45 1 26 13 0 1 2 17 3 13 0 1 4 17 3 13 0 1 5 17 3 13 0 1 6 17 3 13 0 1 7 17 3 13 0 1 8 17 3 13 0 1 9 17 3 13 0 1 10 17 3 13 0 1 11 17 3 13 0 1 12 17 3 29) #132# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #133=#A(t (14) (c::lisp-to-c-name c::obj string c::c char-code c::cc <= #\_ #Y(nil nil nil (24 45 3 26 10 0 16 4 45 5 9 97 13 0 9 122 19 3 6 40 10 9 48 13 0 9 57 19 3 6 39 6 10 1 73 38 4 1 7 73 43 1 29) #133# #1# 0) prin1-to-string string-downcase map #Y(c::lisp-to-c-name nil nil (24 45 1 26 10 0 73 39 19 15 2 34 8 12 13 0 19 1 9 12 19 1 10 12 19 3 11 29) #133# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::any (deftype c::any nil 't) t si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #134=#A(t (8) (c::member-type type c::disjoint-supertypes :test subtypep member #Y(c::member-type nil nil (24 45 1 24 45 2 26 13 1 13 0 14 3 33 4 12 19 4 5 29) #134# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 24 12 19 2 25 1 0 73 29) #135=#A(t (26) (c::object-type c::thing type-of symbol type fixnum short-float single-float double-float long-float null base-char standard-char character extended-char string base-string bit-vector vector array-element-type array standard-object structure-object t #Y(c::object-type nil nil (24 45 1 26 10 0 39 7 10 0 16 2 38 3 1 3 45 4 10 0 41 5 19 41 6 16 41 7 13 41 8 10 41 9 7 41 3 4 42 10 6 10 0 73 38 79 41 11 10 41 12 7 41 13 4 42 14 6 1 13 73 38 62 41 15 7 41 16 4 42 17 6 10 0 73 38 48 42 18 12 15 18 10 1 16 19 6 2 73 38 34 42 20 12 15 20 10 1 16 19 6 2 73 38 20 42 21 6 1 21 73 38 12 42 22 6 1 22 73 38 4 11 23 73 43 1 29) #135# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #136=#A(t (14) (c::valid-type-specifier type #:g18992 #:g18993 0 error si::temp #Y(nil nil nil (24 45 6 26 10 0 51 2 35 1 0 29) #136# #1# 0) si::*handler-clusters* t subtypep c::c #Y(c::valid-type-specifier nil nil (24 45 1 26 57 2 60 64 75 45 3 57 4 61 1 39 15 5 34 7 3 6 1 12 11 8 3 48 8 13 3 15 9 19 2 10 39 9 14 9 13 3 72 2 38 5 77 77 72 2 36 2 44 1 10 1 45 11 77 77 72 2 43 1 36 2 62 73 43 1 63 29) #136# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #137=#A(t (6) (c::known-type-p type t subtypep #Y(c::known-type-p nil nil (24 45 1 26 13 0 14 2 19 2 3 29) #137# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #138=#A(t (6) (c::trivial-type-p type t subtypep #Y(c::trivial-type-p nil nil (24 45 1 26 14 2 13 0 19 2 3 29) #138# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 9 1024 14 2 14 3 14 4 77 19 5 5 52 0 15 6 1 7 12 19 2 8 15 9 1 43 12 19 2 8 1 9 73 29) #139=#A(t (44) (c::*type-and-cache* si::*make-special :element-type t :adjustable make-array c::type-and-empty-cache #Y(c::type-and-empty-cache nil nil (26 9 1024 14 2 14 3 14 4 77 19 5 5 29) #139# #1# 0) si::fset c::type-and c::t1 c::t2 eq * si::*highest-type-tag* si::*save-types-database* si::*member-types* si::*elementary-types* si::safe-canonical-type c::tag1 c::tag2 numberp logand zerop logandc2 and cons "Unsupported CONS type ~S. Replacing it with T." c::cmpwarn "Unsupported CONS type ~S. Replacing it with T." "Unknown type ~S. Assuming it is T." c::cmpnote "Unknown type ~S. Assuming it is T." #Y(c::type-and nil nil (24 45 10 24 45 11 26 57 9 60 219 13 2 10 1 17 12 40 7 13 1 1 13 17 12 39 6 10 2 73 36 0 13 2 1 13 17 12 39 6 10 1 73 36 0 11 14 48 14 11 3 48 15 11 16 48 16 11 17 48 17 13 2 19 1 18 45 19 13 2 19 1 18 45 20 10 1 16 21 39 5 10 0 16 21 39 71 13 4 19 1 18 51 1 13 3 19 1 18 51 0 13 1 13 0 19 2 22 16 23 39 5 75 73 38 40 13 1 10 0 17 24 16 23 39 6 10 4 73 38 25 13 0 10 1 17 24 16 23 39 6 10 3 73 38 10 15 25 13 4 10 3 6 3 73 38 68 13 1 1 26 17 12 39 13 15 27 13 4 19 2 28 10 3 73 38 48 13 0 1 26 17 12 39 13 15 29 13 3 19 2 28 10 4 73 38 28 10 1 76 39 13 15 30 13 4 19 2 31 10 3 73 38 11 15 32 13 3 19 2 31 10 4 73 43 2 44 4 63 29) #139# #1# 0) si::hash-equal c::hash aref elt #:g19004 equal #:g19005 c::output si::aset #Y(c::type-and nil nil (24 45 10 24 45 11 26 30 1 33 13 2 13 1 19 2 34 12 9 1023 19 2 22 45 35 14 0 13 0 19 2 36 45 37 10 0 39 49 10 0 45 38 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 4 17 39 39 24 10 0 45 40 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 3 17 39 39 7 10 0 4 73 38 32 13 4 13 3 32 2 18 2 45 41 14 0 13 2 13 5 13 4 10 0 6 3 12 19 3 42 10 0 73 43 1 43 2 43 1 29) #139# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #140=#A(t (16) (c::values-number-from-type type t eq * multiple-values-limit atom values &rest member &optional length 1- c::l #Y(c::values-number-from-type nil nil (24 45 1 26 13 0 1 2 17 3 40 7 13 0 1 4 17 3 39 9 9 0 14 5 72 2 38 68 10 0 16 6 40 10 10 0 4 12 1 7 17 3 76 39 9 9 1 9 1 72 2 38 43 15 8 13 0 19 2 9 40 8 15 10 13 0 19 2 9 39 9 9 0 14 5 72 2 38 17 10 0 16 11 16 12 45 13 13 0 13 0 72 2 43 1 29) #140# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 9 1024 14 2 14 3 14 4 77 19 5 5 52 0 15 6 1 7 12 19 2 8 15 9 1 33 12 19 2 8 1 9 73 29) #141=#A(t (34) (c::*values-type-primary-type-cache* si::*make-special :element-type t :adjustable make-array c::values-type-primary-type-empty-cache #Y(c::values-type-primary-type-empty-cache nil nil (26 9 1024 14 2 14 3 14 4 77 19 5 5 29) #141# #1# 0) si::fset c::values-type-primary-type type consp values eq null second c::subtype &optional &rest cddr "Syntax error in type expression ~S" c::cmperr c::type-or #Y(c::values-type-primary-type nil nil (24 45 10 26 10 0 16 11 39 9 10 0 4 12 1 12 17 13 39 88 10 0 5 76 39 7 1 14 51 0 38 76 10 0 16 15 45 16 13 0 1 17 17 13 40 7 13 0 1 18 17 13 39 48 10 1 16 19 51 1 10 1 76 40 19 10 1 4 51 0 12 1 17 17 13 40 7 13 0 1 18 17 13 39 8 15 20 13 1 19 2 21 15 14 13 0 19 2 22 51 0 10 0 51 1 43 1 10 0 73 29) #141# #1# 0) si::hash-equal logand c::hash aref elt #:g19033 equal c::output si::aset #Y(c::values-type-primary-type nil nil (24 45 10 26 30 1 23 13 1 19 1 24 12 9 1023 19 2 25 45 26 14 0 13 0 19 2 27 45 28 10 0 39 24 10 0 45 29 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 3 17 30 39 7 10 0 4 73 38 28 13 3 32 2 18 1 45 31 14 0 13 2 13 4 10 0 6 2 12 19 3 32 10 0 73 43 1 43 2 43 1 29) #141# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 9 1024 14 2 14 3 14 4 77 19 5 5 52 0 15 6 1 7 12 19 2 8 15 9 1 43 12 19 2 8 1 9 73 29) #142=#A(t (44) (c::*values-type-to-n-types-cache* si::*make-special :element-type t :adjustable make-array c::values-type-to-n-types-empty-cache #Y(c::values-type-to-n-types-empty-cache nil nil (26 9 1024 14 2 14 3 14 4 77 19 5 5 29) #142# #1# 0) si::fset c::values-type-to-n-types type length atom values eql plusp 1- :initial-element null make-list c::l c::output c::n #:g19054 &optional "Syntax error in type expression ~S" c::cmperr #:g19056 &rest "Syntax error in type expression ~S" nreconc zerop nreverse #Y(c::values-type-to-n-types nil nil (24 45 10 24 45 11 26 57 9 60 186 10 2 16 12 40 10 10 2 4 12 1 13 17 14 76 39 27 10 1 16 15 73 39 18 13 2 10 1 16 16 12 14 17 15 18 19 3 19 7 2 73 38 142 10 2 5 45 20 75 45 21 10 3 45 22 38 111 10 2 45 23 10 0 4 12 10 0 5 51 0 10 0 51 3 22 43 1 45 10 10 0 42 24 37 10 3 76 39 8 15 25 13 0 19 2 26 10 3 45 27 10 0 4 12 10 0 5 51 0 10 0 51 4 22 43 1 51 0 38 33 42 28 30 10 3 76 39 8 15 29 13 0 19 2 26 13 2 13 1 14 17 10 3 4 12 19 3 19 17 30 36 4 13 0 10 2 3 51 2 43 1 10 0 16 16 51 0 10 2 76 40 5 10 0 16 31 39 -120 10 1 16 32 43 3 63 29) #142# #1# 0) si::hash-equal logand c::hash aref elt #:g19058 equal #:g19059 si::aset #Y(c::values-type-to-n-types nil nil (24 45 10 24 45 11 26 30 1 33 13 2 13 1 19 2 34 12 9 1023 19 2 35 45 36 14 0 13 0 19 2 37 45 38 10 0 39 49 10 0 45 39 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 4 17 40 39 24 10 0 45 41 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 3 17 40 39 7 10 0 4 73 38 32 13 4 13 3 32 2 18 2 45 21 14 0 13 2 13 5 13 4 10 0 6 3 12 19 3 42 10 0 73 43 1 43 2 43 1 29) #142# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #143=#A(t (13) (c::split-values-type type atom values eq &rest member &optional c::opt rest ldiff #Y(c::split-values-type nil nil (24 45 1 26 10 0 16 2 40 10 10 0 4 12 1 3 17 4 76 39 12 10 0 6 1 12 77 77 72 3 38 61 15 5 13 0 19 2 6 12 15 7 13 0 19 2 6 12 46 8 46 9 10 2 5 12 10 0 40 3 10 1 17 10 12 15 7 13 2 19 2 6 5 12 10 0 17 10 12 15 5 13 2 19 2 6 5 12 72 3 43 2 29) #143# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 9 1024 14 2 14 3 14 4 77 19 5 5 52 0 15 6 1 7 12 19 2 8 15 9 1 51 12 19 2 8 1 9 73 29) #144=#A(t (52) (c::*values-type-or-cache* si::*make-special :element-type t :adjustable make-array c::values-type-or-empty-cache #Y(c::values-type-or-empty-cache nil nil (26 9 1024 14 2 14 3 14 4 77 19 5 5 29) #144# #1# 0) si::fset c::values-type-or c::t1 c::t2 eq (values &rest t) equalp (values &rest t) c::split-values-type c::rest1 c::opt1 c::req1 c::rest2 c::opt2 c::req2 rest c::opt c::req #:loop-list19102 0 #:g19110 c::type-or #:g19112 #:loop-list19115 #:g19123 #:g19125 #:loop-list19128 #:loop-list19131 values nreverse &optional append #Y(c::values-type-or nil nil (24 45 10 24 45 11 26 57 9 60 556 13 1 1 3 17 12 40 7 13 1 1 13 17 14 39 6 10 1 73 36 0 13 2 1 3 17 12 40 7 13 2 1 15 17 14 39 6 10 2 73 36 0 10 2 76 39 6 10 1 73 36 0 10 1 76 39 6 10 2 73 36 0 13 2 19 1 16 47 2 17 47 1 18 45 19 13 4 19 1 16 47 2 20 47 1 21 45 22 77 77 77 46 23 46 24 46 25 77 13 6 46 26 46 10 57 27 61 2 2 122 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 10 6 39 33 13 1 10 6 45 28 10 0 4 12 10 0 5 51 0 10 0 51 7 43 1 19 2 29 12 10 3 3 51 3 38 65 10 7 39 33 13 1 10 7 45 30 10 0 4 12 10 0 5 51 0 10 0 51 8 43 1 19 2 29 12 10 4 3 51 4 38 29 10 8 39 18 13 1 10 8 4 12 19 2 29 12 10 4 3 51 4 38 8 13 1 10 4 3 51 4 35 0 0 62 43 2 77 13 7 46 31 46 10 57 27 61 2 2 122 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 10 6 39 33 13 1 10 6 45 32 10 0 4 12 10 0 5 51 0 10 0 51 7 43 1 19 2 29 12 10 4 3 51 4 38 65 10 7 39 33 13 1 10 7 45 33 10 0 4 12 10 0 5 51 0 10 0 51 8 43 1 19 2 29 12 10 4 3 51 4 38 29 10 8 39 18 13 1 10 8 4 12 19 2 29 12 10 4 3 51 4 38 8 13 1 10 4 3 51 4 35 0 0 62 43 2 10 8 39 6 10 8 4 38 3 11 3 45 10 77 13 4 46 34 46 11 57 27 61 2 2 35 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 3 13 1 19 2 29 12 10 5 3 51 5 35 0 0 62 43 2 77 13 5 46 35 46 11 57 27 61 2 2 35 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 3 13 1 19 2 29 12 10 5 3 51 5 35 0 0 62 43 2 10 6 39 16 13 0 10 6 4 12 19 2 29 6 1 51 3 38 5 10 9 51 3 43 1 15 36 10 0 16 37 12 10 1 73 39 9 15 38 10 1 16 37 3 73 12 10 2 73 39 7 15 38 10 2 3 73 12 19 3 39 7 2 73 43 3 43 3 43 3 63 29) #144# #1# 0) si::hash-equal logand c::hash aref elt #:g19136 equal #:g19137 c::output si::aset #Y(c::values-type-or nil nil (24 45 10 24 45 11 26 30 1 40 13 2 13 1 19 2 41 12 9 1023 19 2 42 45 43 14 0 13 0 19 2 44 45 45 10 0 39 49 10 0 45 46 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 4 17 47 39 24 10 0 45 48 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 3 17 47 39 7 10 0 4 73 38 32 13 4 13 3 32 2 18 2 45 49 14 0 13 2 13 5 13 4 10 0 6 3 12 19 3 50 10 0 73 43 1 43 2 43 1 29) #144# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 9 1024 14 2 14 3 14 4 77 19 5 5 52 0 15 6 1 7 12 19 2 8 15 9 1 51 12 19 2 8 1 9 73 29) #145=#A(t (52) (c::*values-type-and-cache* si::*make-special :element-type t :adjustable make-array c::values-type-and-empty-cache #Y(c::values-type-and-empty-cache nil nil (26 9 1024 14 2 14 3 14 4 77 19 5 5 29) #145# #1# 0) si::fset c::values-type-and c::t1 c::t2 eq (values &rest t) equalp (values &rest t) c::split-values-type c::rest1 c::opt1 c::req1 c::rest2 c::opt2 c::req2 rest c::opt c::req #:loop-list19169 0 #:g19171 c::type-and #:g19173 #:loop-list19177 #:g19179 #:g19181 #:loop-list19185 #:loop-list19188 values nreverse &optional append #Y(c::values-type-and nil nil (24 45 10 24 45 11 26 57 9 60 554 13 1 1 3 17 12 40 7 13 1 1 13 17 14 39 6 10 2 73 36 0 13 2 1 3 17 12 40 7 13 2 1 15 17 14 39 6 10 1 73 36 0 10 2 76 40 4 10 1 76 39 5 75 73 36 0 13 2 19 1 16 47 2 17 47 1 18 45 19 13 4 19 1 16 47 2 20 47 1 21 45 22 77 77 77 46 23 46 24 46 25 58 60 142 77 13 7 46 26 46 10 57 27 61 2 2 125 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 10 7 39 33 13 1 10 7 45 28 10 0 4 12 10 0 5 51 0 10 0 51 8 43 1 19 2 29 12 10 4 3 51 4 38 68 10 8 39 33 13 1 10 8 45 30 10 0 4 12 10 0 5 51 0 10 0 51 9 43 1 19 2 29 12 10 4 3 51 4 38 32 10 9 39 18 13 1 10 9 4 12 19 2 29 12 10 4 3 51 4 38 11 75 51 11 75 51 12 75 73 36 3 35 0 0 62 43 2 63 58 60 142 77 13 8 46 31 46 10 57 27 61 2 2 125 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 10 7 39 33 13 1 10 7 45 32 10 0 4 12 10 0 5 51 0 10 0 51 8 43 1 19 2 29 12 10 4 3 51 4 38 68 10 8 39 33 13 1 10 8 45 33 10 0 4 12 10 0 5 51 0 10 0 51 9 43 1 19 2 29 12 10 5 3 51 5 38 32 10 9 39 18 13 1 10 9 4 12 19 2 29 12 10 5 3 51 5 38 11 75 51 11 75 51 12 75 73 36 3 35 0 0 62 43 2 63 10 2 39 125 10 2 4 45 10 77 13 4 46 34 46 11 57 27 61 2 2 35 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 3 13 1 19 2 29 12 10 4 3 51 4 35 0 0 62 43 2 77 13 5 46 35 46 11 57 27 61 2 2 35 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 3 13 1 19 2 29 12 10 5 3 51 5 35 0 0 62 43 2 10 6 39 14 13 0 10 6 4 12 19 2 29 6 1 51 3 43 1 15 36 10 0 16 37 12 10 1 73 39 9 15 38 10 1 16 37 3 73 12 10 2 73 39 7 15 38 10 2 3 73 12 19 3 39 7 2 73 43 3 43 3 43 3 63 29) #145# #1# 0) si::hash-equal logand c::hash aref elt #:g19192 equal #:g19193 c::output si::aset #Y(c::values-type-and nil nil (24 45 10 24 45 11 26 30 1 40 13 2 13 1 19 2 41 12 9 1023 19 2 42 45 43 14 0 13 0 19 2 44 45 45 10 0 39 49 10 0 45 46 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 4 17 47 39 24 10 0 45 48 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 3 17 47 39 7 10 0 4 73 38 32 13 4 13 3 32 2 18 2 45 49 14 0 13 2 13 5 13 4 10 0 6 3 12 19 3 50 10 0 73 43 1 43 2 43 1 29) #145# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 9 1024 14 2 14 3 14 4 77 19 5 5 52 0 15 6 1 7 12 19 2 8 15 9 1 43 12 19 2 8 1 9 73 29) #146=#A(t (44) (c::*type-or-cache* si::*make-special :element-type t :adjustable make-array c::type-or-empty-cache #Y(c::type-or-empty-cache nil nil (26 9 1024 14 2 14 3 14 4 77 19 5 5 29) #146# #1# 0) si::fset c::type-or c::t1 c::t2 eq * si::*highest-type-tag* si::*save-types-database* si::*member-types* si::*elementary-types* si::safe-canonical-type c::tag1 c::tag2 numberp logandc2 zerop or cons "Unsupported CONS type ~S. Replacing it with T." c::cmpwarn "Unsupported CONS type ~S. Replacing it with T." "Unknown type ~S" c::cmpnote "Unknown type ~S" #Y(c::type-or nil nil (24 45 10 24 45 11 26 57 9 60 204 13 2 10 1 17 12 40 7 13 1 1 13 17 12 39 6 10 2 73 36 0 13 2 1 13 17 12 39 6 10 1 73 36 0 11 14 48 14 11 3 48 15 11 16 48 16 11 17 48 17 13 2 19 1 18 45 19 13 2 19 1 18 45 20 10 1 16 21 39 5 10 0 16 21 39 56 13 4 19 1 18 51 1 13 3 19 1 18 51 0 13 1 10 0 17 22 16 23 39 6 10 3 73 38 25 13 0 10 1 17 22 16 23 39 6 10 4 73 38 10 15 24 13 4 10 3 6 3 73 38 68 13 1 1 25 17 12 39 13 15 26 13 4 19 2 27 11 3 73 38 48 13 0 1 25 17 12 39 13 15 28 13 3 19 2 27 11 3 73 38 28 10 1 76 39 13 15 29 13 4 19 2 30 11 3 73 38 11 15 31 13 3 19 2 30 11 3 73 43 2 44 4 63 29) #146# #1# 0) si::hash-equal logand c::hash aref elt #:g19206 equal #:g19207 c::output si::aset #Y(c::type-or nil nil (24 45 10 24 45 11 26 30 1 32 13 2 13 1 19 2 33 12 9 1023 19 2 34 45 35 14 0 13 0 19 2 36 45 37 10 0 39 49 10 0 45 38 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 4 17 39 39 24 10 0 45 40 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 3 17 39 39 7 10 0 4 73 38 32 13 4 13 3 32 2 18 2 45 41 14 0 13 2 13 5 13 4 10 0 6 3 12 19 3 42 10 0 73 43 1 43 2 43 1 29) #146# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #147=#A(t (6) (c::type>= c::type1 c::type2 subtypep #Y(c::type>= nil nil (24 45 1 24 45 2 26 13 0 13 1 19 2 3 29) #147# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #148=#A(t (18) (c::infer-arg-and-return-types c::fname c::forms c::*cmp-env* c::env c::*p0-dispatch-table* gethash (values &rest t) c::return-type c::arg-types c::found c::location-primary-type mapcar apply c::get-arg-types c::get-return-type #Y(c::infer-arg-and-return-types nil nil (24 45 1 24 45 2 25 40 3 14 3 46 4 26 13 2 14 5 19 2 6 12 77 15 7 46 8 46 9 46 10 10 0 39 24 13 0 13 5 33 11 12 13 4 19 2 12 12 19 3 13 51 1 55 2 1 38 26 13 5 13 3 19 2 14 51 1 55 0 1 39 12 13 5 19 1 15 40 3 10 2 51 2 13 1 13 2 13 0 72 3 43 3 29) #148# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 34 12 19 2 35 1 0 73 29) #149=#A(t (36) (c::enforce-types c::fname c::arg-types c::arguments c::types c::args c::i c::in-optionals c::expected-type (* &rest &key &allow-other-keys) :test eq member &optional "Syntax error in type proclamation for function ~A.~&~A" c::cmpwarn t "Too few arguments for proclaimed function ~A" c::value c::location-primary-type c::actual-type c::type-and intersection "The argument ~d of function ~a has type~&~4T~A~&instead of expected~&~4T~A" c::cmpwarn-style safety c::cmp-env-optimization zerop #:g19219 #:g19220 c::c1form si::structure-set 1+ "Too many arguments passed to ~A" #Y(c::enforce-types nil nil (24 45 1 24 45 2 24 45 3 26 58 60 209 10 2 45 4 10 2 45 5 8 1 45 6 75 45 7 38 172 10 3 4 45 8 13 0 15 9 14 10 33 11 12 19 4 12 39 7 75 73 36 5 38 129 13 0 1 13 17 11 39 25 10 1 39 10 15 14 13 8 13 7 19 3 15 11 16 51 1 10 4 5 51 4 38 97 10 3 2 39 19 10 1 76 39 8 15 17 13 8 19 2 15 75 73 36 5 38 74 10 3 4 45 18 13 0 19 1 19 45 20 13 0 13 2 19 2 21 45 22 10 0 76 39 14 15 23 13 5 13 11 13 1 13 3 19 5 24 15 25 19 1 26 16 27 39 24 10 2 45 28 10 1 45 29 13 1 15 30 9 1 13 0 19 4 31 43 1 43 1 43 3 43 1 10 3 5 51 3 10 2 5 51 2 10 1 16 32 51 1 10 3 2 39 -175 10 3 73 39 8 15 33 13 7 19 2 15 43 4 63 29) #149# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #150=#A(t (10) (c::propagate-types c::fname c::forms c::infer-arg-and-return-types c::found c::return-type c::arg-types c::enforce-types #Y(c::propagate-types nil nil (24 45 1 24 45 2 26 13 1 13 0 19 2 3 47 2 4 47 1 5 45 6 10 2 39 10 13 4 13 0 13 3 19 3 7 10 1 73 43 3 29) #150# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 14 22 9 3 19 4 23 1 0 73 29) #151=#A(t (24) (c::def-type-propagator #:g19222 #:g19221 #:g19223 si::dm-too-few-arguments c::fname c::lambda-list c::body &rest member gensym c::var append declare ignorable setf gethash quote c::*p0-dispatch-table* function lambda #Y(c::def-type-propagator nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 45 7 15 8 13 1 19 2 9 76 39 39 19 0 10 45 11 13 2 15 8 10 0 6 2 12 19 2 12 51 2 15 13 15 14 10 0 6 2 6 2 12 10 1 7 2 51 1 43 1 15 15 15 16 15 17 10 2 6 2 12 1 18 6 3 12 15 19 15 20 13 1 15 13 15 14 10 1 4 6 2 6 2 12 10 0 7 4 6 2 6 3 73 29) #151# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #152=#A(t (12) (c::copy-type-propagator c::orig c::dest-list c::*p0-dispatch-table* gethash function #:loop-list19239 c::name 0 si::hash-set #Y(c::copy-type-propagator nil nil (24 45 1 24 45 2 26 13 1 14 3 19 2 4 45 5 77 13 1 46 6 46 7 57 8 61 2 2 35 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 10 3 39 10 13 1 14 3 13 3 19 3 9 35 0 0 62 73 43 2 43 1 29) #152# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #153=#A(t (23) (c::and-form-type type c::form c::original-form :safe c::mode "" c::format-string c::format-args c::c1form-primary-type c::type2 c::type-and c::type1 #:g19248 #:g19249 c::c1form si::structure-set eq c::cmperr c::cmpwarn "~?, the type of the form ~s is ~s, not ~s." #Y(c::and-form-type nil nil (24 45 1 24 45 2 24 45 3 25 40 3 14 4 46 5 25 40 3 15 6 46 7 27 45 8 13 4 19 1 9 45 10 13 6 13 0 19 2 11 45 12 10 0 39 26 10 6 45 13 10 1 45 14 13 1 15 15 9 1 13 0 19 4 16 43 1 43 1 38 33 13 4 11 4 17 17 39 6 33 18 73 38 4 33 19 73 12 15 20 13 3 13 2 13 5 13 1 13 7 20 6 23 10 6 73 43 2 29) #153# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #154=#A(t (15) (c::default-init c::var warn c::var-type ((fixnum . 0) (character . #\ ) (long-float #155=0.0l0) (double-float . #156=0.0d0) (single-float . #157=0.0)) :test subtypep assoc c::new-value :only-small-values t c::c1constant-value c::c1nil #Y(c::default-init nil nil (24 45 1 25 40 2 77 46 2 26 13 1 19 1 3 12 15 4 14 5 33 6 12 19 4 7 5 45 8 10 0 39 12 13 0 14 9 14 10 19 3 11 38 4 19 0 12 43 1 29) #154# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #158=#A(t (11) (c::expand-deftype type c::args c::base atom si::deftype-definition si::get-sysprop c::fn apply #Y(c::expand-deftype nil nil (24 45 1 26 77 77 46 2 46 3 10 2 16 4 39 10 10 2 51 0 75 51 1 38 11 10 2 4 51 0 10 2 5 51 1 13 0 1 5 17 6 45 7 10 0 39 14 13 0 13 2 19 2 8 12 19 1 0 38 4 10 3 73 43 1 43 2 29) #158# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 52 12 19 2 53 1 0 73 29) #159=#A(t (54) (c::lambda-type-check-associate c::fname c::requireds c::optionals c::keywords c::global-fun-p c::*cmp-env* c::get-arg-types c::found c::arg-types ftype si::process-lambda-list c::allow-other-keys c::key-types c::key-flag c::rest-flag c::opt-types c::req-types #:loop-list19276 c::var #:loop-list19277 type #:loop-list-head19278 #:loop-list-tail19279 0 rplacd #:loop-list19280 c::optional #:loop-list19281 #:loop-list-head19282 #:loop-list-tail19283 cdddr c::key-list keyword c::key-var #:loop-list-head19284 #:loop-list-tail19285 atom second eq cddr t cddddr nconc #:loop-list19286 #:loop-list-head19287 #:loop-list-tail19288 #:loop-list19289 #:loop-list-head19290 #:loop-list-tail19291 #:loop-list-head19292 #:loop-list-tail19293 #Y(c::lambda-type-check-associate nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 10 0 73 39 10 13 4 14 6 13 0 19 3 7 47 1 8 45 9 10 1 39 388 13 0 1 10 17 11 47 5 12 47 4 13 47 3 14 47 2 15 47 1 16 45 17 58 60 99 77 13 12 46 18 46 19 77 10 3 5 12 46 20 46 21 75 6 1 45 22 10 0 45 23 57 24 61 2 2 53 10 6 2 39 4 35 0 1 10 6 4 51 5 10 6 5 51 6 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 13 5 10 3 3 6 1 51 1 17 25 35 0 0 10 2 5 73 36 7 62 73 43 2 43 2 43 2 63 12 58 60 101 77 13 11 46 26 46 27 77 10 4 5 12 46 28 46 21 75 6 1 45 29 10 0 45 30 57 24 61 2 2 55 10 6 2 39 4 35 0 1 10 6 4 51 5 10 6 16 31 51 6 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 16 31 51 4 13 1 13 5 10 3 3 6 1 51 1 17 25 35 0 0 10 2 5 73 36 7 62 73 43 2 43 2 43 2 63 12 58 60 148 10 10 45 32 75 45 33 75 45 34 75 45 21 75 6 1 45 35 10 0 45 36 57 24 61 2 2 101 10 6 16 37 39 4 35 0 1 10 6 4 51 5 10 6 16 38 51 4 58 60 54 10 13 5 45 32 57 24 61 2 2 34 10 1 16 37 39 4 35 0 1 13 8 10 1 4 17 39 39 7 10 1 16 38 36 2 10 1 16 40 51 1 35 0 0 11 41 73 36 2 62 43 1 63 51 3 13 1 13 4 10 3 3 6 1 51 1 17 25 10 6 16 42 51 6 35 0 0 10 2 5 73 36 7 62 73 43 2 43 1 43 1 43 1 43 1 63 12 19 3 43 43 6 38 229 58 60 70 77 13 6 46 44 46 19 75 6 1 45 45 10 0 45 46 57 24 61 2 2 35 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 13 3 11 41 3 6 1 51 1 17 25 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 12 58 60 71 77 13 5 46 47 46 27 75 6 1 45 48 10 0 45 49 57 24 61 2 2 36 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 16 31 51 4 13 1 13 3 11 41 3 6 1 51 1 17 25 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 12 58 60 75 10 4 45 32 75 45 34 75 6 1 45 50 10 0 45 51 57 24 61 2 2 38 10 4 16 37 39 4 35 0 1 10 4 16 38 51 3 13 1 13 3 11 41 3 6 1 51 1 17 25 10 4 16 42 51 4 35 0 0 10 2 5 73 36 5 62 73 43 2 43 1 43 1 63 12 19 3 43 43 2 29) #159# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #160=#A(t (13) (c::lambda-type-check-precise c::assoc-list c::ts #:loop-list19295 c::record c::var type 0 c::var-name assoc rplacd #Y(c::lambda-type-check-precise nil nil (24 45 1 24 45 2 26 77 13 1 46 3 46 4 75 45 5 75 45 6 57 7 61 2 2 51 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 3 4 51 2 13 2 19 1 8 12 13 5 19 2 9 51 1 10 1 39 8 13 3 10 1 5 17 10 35 0 0 62 43 1 43 1 43 2 10 1 73 29) #160# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 48 12 19 2 49 1 0 73 29) #161=#A(t (50) (c::extract-lambda-type-checks c::fname c::requireds c::optionals c::keywords c::ts c::other-decls c::policy-check-arguments-type c::policy-check-type c::checks c::new-auxs (si::c-global) :test equal member c::global-fun-p c::lambda-type-check-associate c::lambda-type-check-precise c::type-checks #:loop-list19304 type c::var c::name 0 #72# c::var-name t eq #:loop-list19305 c::decl consp si::no-check-type #:g19306 #:g19307 si::structure-set c::type-assertion ext::truly-the #:g19310 c::var-type c::type-and #:g19311 "In ~:[an anonymous function~;function ~:*~A~], checking types of argument~@[s~]~{ ~A~}." c::*current-function* c::fun-name second mapcar c::cmpnote nreverse #Y(c::extract-lambda-type-checks nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 24 45 6 26 58 60 345 19 0 7 45 8 75 45 9 75 45 10 15 11 13 4 14 12 33 13 12 19 4 14 45 15 13 10 13 9 13 8 13 7 13 0 19 5 16 12 13 6 19 2 17 45 18 77 77 13 0 46 19 46 20 46 21 75 45 22 57 23 61 2 2 226 10 4 2 39 4 35 0 1 10 4 4 45 24 10 0 4 51 3 10 0 5 51 0 10 0 51 4 43 1 10 4 5 51 4 13 2 19 1 25 51 1 13 3 11 26 17 27 76 39 173 10 9 39 78 58 60 75 77 13 12 46 28 46 29 57 23 61 2 2 53 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 10 1 16 30 39 20 10 1 4 12 1 31 17 27 39 10 13 5 10 1 5 12 19 2 14 39 5 75 73 36 3 35 0 0 11 26 73 36 3 62 43 2 63 39 58 10 2 45 32 11 26 45 33 13 1 15 21 9 11 13 0 19 4 34 43 1 43 1 15 35 13 1 10 3 6 3 12 10 8 7 2 51 8 15 36 13 3 10 1 6 3 12 13 1 10 7 7 3 51 7 38 33 10 2 45 37 13 3 19 1 38 12 13 4 19 2 39 45 40 13 1 15 21 9 11 13 0 19 4 34 43 1 43 1 35 0 0 10 8 39 21 15 41 14 42 19 1 43 12 33 44 12 13 8 19 2 45 12 19 3 46 10 8 16 47 12 10 7 16 47 3 73 36 10 62 73 43 1 43 3 43 1 43 1 43 1 43 1 43 1 63 29) #161# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #162=#A(t (17) (c::type-error-check c::value type cons ffi::c-inline ((:object) :void "@0;if (ecl_unlikely(ECL_ATOM(#0))) FEtype_error_cons(#0);" :one-liner nil) array ((:object) :void "if (ecl_unlikely(!ECL_ARRAYP(#0))) FEtype_error_array(#0);" :one-liner nil) list ((:object) :void "if (ecl_unlikely(!ECL_LISTP(#0))) FEtype_error_list(#0);" :one-liner nil) sequence ((:object) :void "if (ecl_unlikely(!(ECL_LISTP(#0) || ECL_VECTORP(#0))))
           FEtype_error_sequence(#0);" :one-liner nil) typep quote ((:bool :object :object) :void "if (ecl_unlikely(!(#0)))
         FEwrong_type_argument(#1,#2);" :one-liner nil) #Y(c::type-error-check nil nil (24 45 1 24 45 2 26 10 0 42 3 15 15 4 10 1 6 1 12 1 5 7 3 73 38 84 42 6 15 15 4 10 1 6 1 12 1 7 7 3 73 38 67 42 8 15 15 4 10 1 6 1 12 1 9 7 3 73 38 50 42 10 15 15 4 10 1 6 1 12 1 11 7 3 73 38 33 15 4 15 12 13 1 15 13 10 0 6 2 6 3 12 15 13 10 0 6 2 12 10 1 6 3 12 1 14 7 3 73 29) #162# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 14 9 9 3 19 4 19 1 0 73 29) #163=#A(t (20) (c::assert-type-if-known #:g19312 c::env c::whole #:g19313 si::dm-too-few-arguments c::value type si::dm-too-many-arguments t subtypep c::valid c::trivial let* #:%value c::replace-invalid-types c::type-error-check ext::truly-the #Y(c::assert-type-if-known nil nil (24 45 1 24 45 2 26 10 1 45 3 10 2 5 45 4 10 0 76 39 6 13 3 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 76 39 6 13 4 19 1 5 10 1 4 12 10 1 5 51 1 22 45 7 10 2 39 6 13 5 19 1 8 15 9 13 0 19 2 10 47 1 11 45 12 10 0 39 3 10 1 39 6 10 3 73 38 35 15 13 15 14 10 3 6 2 6 1 12 15 14 13 2 19 1 15 12 19 2 16 12 15 17 13 2 1 14 6 3 6 4 73 43 2 29) #163# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #164=#A(t (12) (c::replace-invalid-types type atom c::name function or and not cons mapcar #Y(c::replace-invalid-types nil nil (24 45 1 26 10 0 16 2 39 6 10 0 73 38 50 10 0 4 45 3 10 0 42 4 6 1 4 73 38 33 41 5 10 41 6 7 41 7 4 42 8 18 13 0 33 0 12 10 1 5 12 19 2 9 7 2 73 38 4 10 1 73 43 1 29) #164# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 14 12 9 3 19 4 13 1 0 73 29) #165=#A(t (14) (c::optional-type-check #:g19314 c::env c::whole #:g19315 si::dm-too-few-arguments c::value type si::dm-too-many-arguments c::policy-assume-right-type c::assert-type-if-known #Y(c::optional-type-check nil nil (24 45 1 24 45 2 26 10 1 45 3 10 2 5 45 4 10 0 76 39 6 13 3 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 76 39 6 13 4 19 1 5 10 1 4 12 10 1 5 51 1 22 45 7 10 2 39 6 13 5 19 1 8 19 0 9 39 6 10 1 73 38 10 15 10 13 1 10 0 6 3 73 29) #165# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 29 12 19 2 30 1 0 73 29) #166=#A(t (31) (c::c1compiler-typecase c::args #:g19321 c::var-name c::c1vref c::var c::first-case c::var-type subtypep c::c1progn c::types #:loop-list19322 c::forms type c::c1form c::c1form-type #:loop-list-head19323 #:loop-list-tail19324 0 #72# c::c1form-primary-type rplacd c::expressions ext::compiler-typecase :type c::type-or reduce :args c::make-c1form* #Y(c::c1compiler-typecase nil nil (24 45 1 26 10 0 45 2 10 0 4 12 10 0 5 51 0 10 0 51 1 22 43 1 45 3 13 0 19 1 4 45 5 10 2 4 45 6 13 1 19 1 7 12 10 0 4 12 19 2 8 39 10 10 0 5 12 19 1 9 38 152 75 45 10 58 60 120 77 77 13 5 46 11 46 12 46 13 75 45 14 75 45 15 75 6 1 45 16 10 0 45 17 57 18 61 2 2 73 10 7 2 39 4 35 0 1 10 7 4 45 19 10 0 4 51 6 10 0 5 51 0 10 0 51 7 43 1 10 7 5 51 7 13 6 19 1 9 51 4 13 4 19 1 20 51 3 13 3 10 9 3 51 9 13 1 13 5 10 4 6 2 6 1 51 1 17 21 35 0 0 10 2 5 73 36 8 62 43 2 43 1 43 1 43 3 63 45 22 15 23 14 24 33 25 12 13 1 19 2 26 12 14 27 13 3 13 0 19 6 28 43 2 43 3 29) #166# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #167=#A(t (16) (c::c2compiler-typecase c::c1form c::var c::expressions c::var-type #:loop-list19327 c::form type 0 #72# (t otherwise) member subtypep c::c2expr #Y(c::c2compiler-typecase nil nil (24 45 1 24 45 2 24 45 3 26 58 60 94 13 2 19 1 4 45 4 77 77 13 2 46 5 46 6 46 7 57 8 61 2 2 64 10 3 2 39 4 35 0 1 10 3 4 45 9 10 0 4 51 2 10 0 5 51 0 10 0 4 51 3 43 1 10 3 5 51 3 13 1 15 10 19 2 11 40 8 13 4 13 1 19 2 12 39 8 13 2 19 1 13 36 5 35 0 0 62 73 43 3 43 1 63 29) #167# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+simple-type-assertions+ ((cons . "if (ecl_unlikely(ECL_ATOM(#0))) FEtype_error_cons(#0);") (array . "if (ecl_unlikely(!ECL_ARRAYP(#0))) FEtype_error_array(#0);") (list . "if (ecl_unlikely(!ECL_LISTP(#0))) FEtype_error_list(#0);") (sequence . "if (ecl_unlikely(!(ECL_LISTP(#0) || ECL_VECTORP(#0))))
           FEtype_error_sequence(#0);") (vector . "if (ecl_unlikely(!ECL_VECTORP(#0))) FEtype_error_vector(#0);")) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #168=#A(t (16) (c::simple-type-assertion c::value type c::env c::+simple-type-assertions+ assoc c::simple-form ffi::c-inline (:object) :void (:one-liner nil) typep quote ((:bool :object :object) :void "if (ecl_unlikely(!(#0)))
         FEwrong_type_argument(#1,#2);" :one-liner nil) #Y(c::simple-type-assertion nil nil (24 45 1 24 45 2 24 45 3 26 13 1 14 4 19 2 5 5 45 6 10 0 39 21 15 7 10 3 6 1 12 15 8 14 9 13 0 1 10 7 6 73 38 33 15 7 15 11 13 3 15 12 10 2 6 2 6 3 12 15 12 10 2 6 2 12 10 3 6 3 12 1 13 7 3 73 43 1 29) #168# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #169=#A(t (16) (c::expand-type-assertion c::value type c::env c::compulsory symbolp c::special-variable-p c::symbol-macro-p let* #170=#:%asserted-value (declare (:read-only #170#)) c::simple-type-assertion ext::compiler-typecase t #Y(c::expand-type-assertion nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 10 3 16 5 76 40 13 13 3 19 1 6 40 6 13 3 19 1 7 39 30 15 8 15 9 10 3 6 2 6 1 12 15 10 15 9 13 2 13 1 13 0 19 4 0 6 4 73 38 41 10 0 39 12 13 3 13 2 13 1 19 3 11 38 26 15 12 13 3 10 2 6 1 12 15 13 13 3 13 2 13 1 19 3 11 6 2 6 4 73 29) #169# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 38 12 19 2 39 1 0 73 29) #171=#A(t (40) (c::c1checked-value c::args #:g19333 type #:g19334 c::value c::form c::form-type c::and-type c::trivial-type-p c::policy-type-assertions consp values eq c::values-type-primary-type c::policy-evaluate-forms constantp c::cmp-eval typep "Failed type assertion for value ~A and type ~A" c::cmpwarn c::c1expr c::c1form-primary-type c::type-and "The expression ~S is not of the expected type ~S" "Checking type of ~S to be ~S" c::cmpnote let* #172=#:%checked-value (declare (:read-only #172#)) c::*cmp-env* c::expand-type-assertion ext::truly-the c::full-check ext::checked-value :type :args c::make-c1form* #Y(c::c1checked-value nil nil (24 45 1 26 10 0 45 2 10 0 4 12 10 0 5 51 0 10 0 51 1 22 43 1 45 3 10 1 45 4 10 0 4 12 10 0 5 51 0 10 0 51 2 22 43 1 45 5 75 45 6 75 45 7 75 45 8 13 5 19 1 9 40 5 19 0 10 76 39 6 10 3 73 38 196 10 4 16 11 39 9 10 4 4 12 1 12 17 13 39 17 13 4 19 1 14 12 10 3 6 2 12 19 1 0 38 164 19 0 15 39 6 13 3 19 1 16 39 29 13 3 19 1 17 12 13 4 19 2 18 76 39 10 15 19 13 3 13 4 19 3 20 10 3 73 38 124 13 3 19 1 21 51 2 13 2 19 1 22 51 1 13 1 13 4 19 2 23 51 0 13 0 10 1 17 13 39 6 10 2 73 38 88 10 0 76 39 15 15 24 13 3 13 4 19 3 20 10 2 73 38 69 15 25 13 3 13 4 19 3 26 15 27 15 28 10 3 6 2 6 1 12 15 29 15 28 13 4 14 30 77 19 4 31 12 15 32 13 4 1 28 6 3 6 5 45 33 15 34 14 35 13 5 14 36 13 5 13 3 13 0 19 1 21 12 19 7 37 43 1 43 5 29) #171# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #173=#A(t (10) (c::c2checked-value c::c1form type c::value c::let-form c::c1form-primary-type subtypep c::c2expr #Y(c::c2checked-value nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 1 19 1 5 12 13 2 19 2 6 39 6 10 1 73 38 4 10 0 73 12 19 1 7 29) #173# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 14 15 9 3 19 4 16 1 0 73 29) #174=#A(t (17) (c::optional-type-assertion #:g19338 c::env c::whole #:g19339 si::dm-too-few-arguments c::value type si::dm-too-many-arguments c::policy-type-assertions c::trivial-type-p "Checking type of ~A to be ~A" c::cmpnote ext::checked-value #Y(c::optional-type-assertion nil nil (24 45 1 24 45 2 26 10 1 45 3 10 2 5 45 4 10 0 76 39 6 13 3 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 76 39 6 13 4 19 1 5 10 1 4 12 10 1 5 51 1 22 45 7 10 2 39 6 13 5 19 1 8 13 4 19 1 9 39 7 13 0 19 1 10 76 73 39 19 15 11 13 1 13 0 19 3 12 15 13 13 0 10 1 6 3 73 29) #174# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 14 12 9 3 19 4 15 1 0 73 29) #175=#A(t (16) (c::type-assertion #:g19340 c::env c::whole #:g19341 si::dm-too-few-arguments c::value type si::dm-too-many-arguments "Checking type of ~A to be ~A" c::cmpnote c::trivial-type-p t c::expand-type-assertion #Y(c::type-assertion nil nil (24 45 1 24 45 2 26 10 1 45 3 10 2 5 45 4 10 0 76 39 6 13 3 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 76 39 6 13 4 19 1 5 10 1 4 12 10 1 5 51 1 22 45 7 10 2 39 6 13 5 19 1 8 15 9 13 1 13 0 19 3 10 13 0 19 1 11 76 73 39 12 13 1 13 0 13 4 14 12 19 4 13 29) #175# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #176=#A(t (19) (c::wt1 c::form #:g19343 (or string integer character) typep c::*compiler-output1* princ single-float "(float)~10,,,,,,'eG" format double-float "~10,,,,,,'eG" long-float "~,,,,,,'eEl" c::var c::wt-var c::wt-loc #Y(c::wt1 nil nil (24 45 1 26 10 0 45 2 13 0 15 3 19 2 4 39 10 13 1 14 5 19 2 6 38 82 13 0 15 7 19 2 4 39 12 14 5 15 8 13 1 19 3 9 38 62 13 0 15 10 19 2 4 39 12 14 5 15 11 13 1 19 3 9 38 42 13 0 15 12 19 2 4 39 12 14 5 15 13 13 1 19 3 9 38 22 13 0 15 14 19 2 4 39 8 13 1 19 1 15 38 6 13 1 19 1 16 43 1 75 73 29) #176# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #177=#A(t (7) (c::wt-h1 c::form c::*compiler-output2* c::*compiler-output1* c::wt1 #Y(c::wt-h1 nil nil (24 45 1 26 11 2 48 3 13 0 19 1 4 44 1 29) #177# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #178=#A(t (6) (c::wt c::forms c::wt1 mapc #Y(c::wt nil nil (27 45 1 33 2 12 13 0 19 2 3 29) #178# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #179=#A(t (6) (c::wt-h c::forms c::wt-h1 mapc #Y(c::wt-h nil nil (27 45 1 33 2 12 13 0 19 2 3 29) #179# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #180=#A(t (8) (c::wt-nl-h c::forms c::*compiler-output2* terpri c::wt-h1 mapc #Y(c::wt-nl-h nil nil (27 45 1 14 2 19 1 3 33 4 12 13 0 19 2 5 29) #180# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #181=#A(t (6) (c::princ-h c::form c::*compiler-output2* princ #Y(c::princ-h nil nil (24 45 1 26 13 0 14 2 19 2 3 29) #181# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #182=#A(t (7) (c::wt-nl c::forms c::wt-nl-indent c::wt1 mapc #Y(c::wt-nl nil nil (27 45 1 19 0 2 33 3 12 13 0 19 2 4 29) #182# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #183=#A(t (7) (c::wt-nl1 c::forms #\Newline c::wt1 mapc #Y(c::wt-nl1 nil nil (27 45 1 15 2 19 1 3 33 3 12 13 0 19 2 4 29) #183# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 10 52 0 1 0 73 29) #A(t (3) (c::+max-depth+ si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::+c-newline-indent-strings+ si::*make-special boundp #A(t (11) ("
" "
 " "
  " "
   " "
    " "
     " "
      " "
       " "
        " "
         " "
          ")))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #184=#A(t (9) (c::wt-nl-indent c::+c-newline-indent-strings+ c::*opened-c-braces* c::+max-depth+ min aref c::wt1 #Y(c::wt-nl-indent nil nil (26 14 1 14 2 14 3 19 2 4 12 19 2 5 12 19 1 6 29) #184# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #185=#A(t (8) (c::wt-open-brace #\{ c::wt1 #:g19352 c::*opened-c-braces* + #Y(c::wt-open-brace nil nil (26 15 1 19 1 2 8 1 45 3 14 4 13 0 19 2 5 52 4 73 43 1 29) #185# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #186=#A(t (5) (c::wt-nl-open-brace c::wt-nl-indent c::wt-open-brace #Y(c::wt-nl-open-brace nil nil (26 19 0 1 19 0 2 29) #186# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #187=#A(t (17) (c::wt-nl-close-many-braces c::final-value c::*opened-c-braces* - c::diff minusp :format-control "Mismatch in C blocks" c::baboon #:loop-limit19354 c::i 0 >= c::wt-nl-close-brace 1+ #Y(c::wt-nl-close-many-braces nil nil (24 45 1 26 14 2 13 0 19 2 3 45 4 10 0 16 5 39 8 14 6 15 7 19 2 8 9 0 13 0 46 9 46 10 57 11 61 2 2 25 13 1 13 2 19 2 12 39 4 35 0 1 19 0 13 10 1 16 14 51 1 35 0 0 62 73 43 2 43 1 29) #187# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #188=#A(t (13) (c::wt-nl-close-brace c::*opened-c-braces* plusp #:g19358 - c::wt-nl-indent #\} c::wt1 :format-control "Mismatch in C blocks" c::baboon #Y(c::wt-nl-close-brace nil nil (26 11 1 16 2 39 26 8 1 45 3 14 1 13 0 19 2 4 52 1 43 1 19 0 5 15 6 19 1 7 38 8 14 8 15 9 19 2 10 29) #188# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 14 8 9 1 19 4 9 1 0 73 29) #189=#A(t (10) (c::with-indentation #:g19360 #:g19359 #:g19361 c::body let ((c::*opened-c-braces* (1+ c::*opened-c-braces*))) #Y(c::with-indentation nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 45 4 15 5 15 6 10 0 7 3 73 29) #189# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #190=#A(t (11) (c::wt-go c::label #:g19365 t #:g19366 rplacd "goto L" ";" c::wt #Y(c::wt-go nil nil (24 45 1 26 10 0 45 2 11 3 45 4 13 1 10 0 17 5 10 0 43 1 43 1 10 0 4 51 0 15 6 13 0 15 7 19 3 8 29) #190# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #191=#A(t (7) (c::wt-label c::label "L" ":;" c::wt-nl1 #Y(c::wt-label nil nil (24 45 1 26 10 0 5 73 39 12 15 2 10 0 4 12 15 3 19 3 4 29) #191# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 30 12 19 2 31 1 0 73 29) #192=#A(t (32) (c::wt-filtered-comment c::text stream c::single-line fresh-line "/*	" princ "~50T/*  " format length 1- c::l si::%dotimes-var c::n schar c::c char-code c::code #\Newline eq #\Tab < > "ux" #\* char= 1+ #\/ #\\ "~70T*/" #Y(c::wt-filtered-comment nil nil (24 45 1 24 45 2 24 45 3 26 10 0 39 15 13 1 19 1 4 15 5 13 1 19 2 6 38 8 13 1 15 7 19 2 8 10 2 16 9 16 10 45 11 10 0 45 12 8 0 45 13 38 118 13 5 10 0 17 14 45 15 10 0 16 16 45 17 13 1 1 18 17 19 40 7 13 1 1 20 17 19 39 10 13 1 13 6 19 2 6 38 71 13 0 9 32 19 2 21 40 8 13 0 9 127 19 2 22 39 12 13 6 15 23 13 0 19 3 8 38 42 13 1 15 24 19 2 25 39 15 13 7 10 2 16 26 17 14 12 15 27 19 2 25 39 10 15 28 13 6 19 2 6 38 8 13 1 13 6 19 2 6 43 2 10 0 16 26 51 0 13 0 13 1 19 2 21 40 -125 43 2 13 3 10 0 17 14 12 13 2 19 2 6 43 1 13 1 15 29 19 2 8 29) #192# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #193=#A(t (14) (c::do-wt-comment c::message-or-format c::args c::single-line-p symbolp symbol-package stringp format apply princ-to-string c::*compiler-output1* c::wt-filtered-comment #Y(c::do-wt-comment nil nil (24 45 1 24 45 2 24 45 3 26 10 2 16 4 39 6 10 2 16 5 76 76 73 39 42 10 2 16 6 39 23 10 1 39 14 33 7 12 77 13 2 13 1 19 4 8 38 4 10 2 73 38 6 13 2 19 1 9 12 14 10 13 0 19 3 11 29) #193# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #194=#A(t (6) (c::wt-comment c::message c::extra c::do-wt-comment #Y(c::wt-comment nil nil (24 45 1 27 45 2 13 1 13 0 77 19 3 3 29) #194# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #195=#A(t (7) (c::wt-comment-nl c::message c::extra t c::do-wt-comment #Y(c::wt-comment-nl nil nil (24 45 1 27 45 2 13 1 13 0 14 3 19 3 4 29) #195# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 0 52 0 1 0 73 29) #A(t (3) (c::*wt-string-size* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #196=#A(t (20) (c::encode-string string format 1.2 length * round :element-type base-char :adjustable t :fill-pointer make-array c::output :external-format ext::make-sequence-output-stream stream write-string #Y(c::encode-string nil nil (24 45 1 24 45 2 26 15 3 10 1 16 4 12 19 2 5 12 19 1 6 12 14 7 15 8 14 9 14 10 14 11 9 0 19 7 12 45 13 13 0 14 14 13 1 19 3 15 45 16 13 3 13 0 19 2 17 10 1 73 43 2 29) #196# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 41 12 19 2 42 1 0 73 29) #197=#A(t (43) (c::wt-filtered-data string stream (nil :external-format :one-liner) c::one-liner :utf-8 c::external-format c::encode-string length c::wt-data-column c::n 1+ #:g19377 c::*wt-string-size* + "\"" "~%\"" format si::%dotimes-var c::i #:g19381 - < "\"~% \"" aref c::x char-code > #\Newline "\\n" princ #\Tab "\\t" "\\~3,'0o" #\\ char= "\\\\" #\" "\\\"" "\"" " \"" #Y(c::wt-filtered-data nil nil (24 45 1 24 45 2 28 3 22 40 2 77 46 4 22 40 3 14 5 46 6 13 3 13 0 19 2 7 51 3 10 3 16 8 12 9 80 46 9 46 10 10 0 16 11 45 12 14 13 13 0 19 2 14 52 13 43 1 13 4 10 3 39 6 1 15 73 38 4 1 16 73 12 19 2 17 10 0 45 18 8 0 45 19 38 160 8 1 45 20 13 4 13 0 19 2 21 51 4 43 1 13 3 9 0 19 2 22 39 12 13 6 15 23 19 2 17 8 79 51 3 13 7 13 0 19 2 24 45 25 10 0 16 26 12 9 32 19 2 22 40 11 10 0 16 26 12 9 127 19 2 27 39 41 10 0 42 28 10 15 29 13 7 19 2 30 38 25 42 31 10 15 32 13 7 19 2 30 38 13 13 7 15 33 10 0 16 26 12 19 3 17 38 44 13 0 15 34 19 2 35 39 10 15 36 13 7 19 2 30 38 26 13 0 15 37 19 2 35 39 10 15 38 13 7 19 2 30 38 8 13 0 13 7 19 2 30 43 1 10 0 16 11 51 0 13 0 13 1 19 2 22 40 -167 43 2 10 3 39 6 1 39 73 38 4 1 40 73 12 13 4 19 2 30 10 5 73 43 2 29) #197# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #198=#A(t (12) (c::c-filtered-string string c::args make-string-output-stream c::aux-stream c::wt-filtered-data :one-liner t apply get-output-stream-string #Y(c::c-filtered-string nil nil (24 45 1 27 45 2 19 0 3 45 4 33 5 12 13 2 13 0 14 6 14 7 13 1 19 6 8 10 0 16 9 43 1 29) #198# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #199=#A(t (5) (c::inlined-arg-loc c::arg second #Y(c::inlined-arg-loc nil nil (24 45 1 26 10 0 16 2 29) #199# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 1 0 73 29) #200=#A(t (4) (c::inlined-arg-type c::arg #Y(c::inlined-arg-type nil nil (24 45 1 26 10 0 4 73 29) #200# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #201=#A(t (6) (c::inlined-arg-rep-type c::arg second c::loc-representation-type #Y(c::inlined-arg-rep-type nil nil (24 45 1 26 10 0 16 2 12 19 1 3 29) #201# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 14 16 9 3 19 4 17 1 0 73 29) #202=#A(t (18) (c::define-c-inliner #:g19383 #:g19382 #:g19384 si::dm-too-few-arguments c::fname c::lambda-list c::body setf gethash quote c::*cinline-dispatch-table* function lambda block #Y(c::define-c-inliner nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 45 7 15 8 15 9 15 10 10 2 6 2 12 1 11 6 3 12 15 12 15 13 13 1 15 14 77 10 0 7 3 6 3 6 2 6 3 73 29) #202# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #203=#A(t (11) (c::apply-inliner c::fname c::return-type c::inlined-args c::*cinline-dispatch-table* gethash c::fd apply c::default-c-inliner #Y(c::apply-inliner nil nil (24 45 1 24 45 2 24 45 3 26 13 2 14 4 19 2 5 45 6 10 0 39 12 13 0 13 2 13 1 19 3 7 38 10 13 3 13 2 13 1 19 3 8 43 1 29) #203# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #204=#A(t (12) (c::default-c-inliner c::fname c::return-type c::inlined-args first mapcar c::arg-types c::inline-function c::ii c::apply-inline-info #Y(c::default-c-inliner nil nil (24 45 1 24 45 2 24 45 3 26 33 4 12 13 0 19 2 5 45 6 13 3 13 0 13 2 19 3 7 45 8 10 0 73 39 8 13 0 13 2 19 2 9 43 2 29) #204# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #205=#A(t (16) (c::inline-function c::fname c::arg-types c::return-type c::any c::return-rep-type c::inline-possible c::*c2-dispatch-table* gethash c::*destination* c::loc-representation-type c::dest-rep-type c::get-inline-info c::ii #Y(c::inline-function nil nil (24 45 1 24 45 2 24 45 3 25 40 3 15 4 46 5 26 13 3 19 1 6 73 39 37 13 3 14 7 19 2 8 76 73 39 26 14 9 19 1 10 45 11 13 4 13 3 13 2 13 1 19 4 12 45 13 10 0 73 43 2 29) #205# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #206=#A(t (19) (c::apply-inline-info c::ii c::inlined-locs c::inline-info-arg-types c::arg-types c::inline-info-return-rep-type c::out-rep-type c::inline-info-return-type c::out-type c::inline-info-name c::function-may-have-side-effects c::side-effects-p c::inline-info-expansion c::fun c::inline-info-one-liner c::one-liner c::produce-inline-loc #Y(c::apply-inline-info nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 13 2 19 1 5 45 6 13 3 19 1 7 45 8 13 4 19 1 9 12 19 1 10 45 11 13 5 19 1 12 45 13 13 6 19 1 14 45 15 13 6 13 5 10 4 6 1 12 13 1 13 2 13 0 19 6 16 43 6 29) #206# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #207=#A(t (17) (c::choose-inline-info c::ia c::ib c::return-type c::return-rep-type c::any eq :void c::inline-info-return-rep-type c::info-type :bool c::inline-info-arg-types equal c::type>= every #Y(c::choose-inline-info nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 0 1 5 17 6 40 32 13 0 11 7 17 6 40 24 13 2 19 1 8 45 9 13 1 10 0 17 6 40 7 13 0 11 10 17 6 43 1 76 39 6 10 3 73 38 59 10 3 76 39 6 10 2 73 38 49 13 3 19 1 11 12 13 2 19 1 11 17 12 39 6 10 3 73 38 29 33 13 12 13 3 19 1 11 12 13 2 19 1 11 12 19 3 14 39 6 10 2 73 38 4 10 3 73 29) #207# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 1 0 73 29) #208=#A(t (24) (c::get-inline-info c::fname c::types c::return-type c::return-rep-type c::output c::safe-compile :inline-unsafe si::get-sysprop si::%dolist-var c::x c::inline-type-matches c::other c::choose-inline-info :inline-safe :inline-always c::should-be-inlined speed c::cmp-env-optimization >= "Could not inline call to ~S ~S - performance may be degraded." c::cmpwarn-style #Y(c::get-inline-info nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 75 45 5 19 0 6 76 39 60 13 4 1 7 17 8 45 9 75 45 10 38 41 10 1 4 51 0 13 0 13 5 13 4 19 3 11 45 12 10 0 39 14 13 3 13 0 13 5 13 4 19 4 13 51 3 43 1 10 1 5 51 1 10 1 40 -43 43 2 13 4 1 14 17 8 45 9 75 45 10 38 41 10 1 4 51 0 13 0 13 5 13 4 19 3 11 45 12 10 0 39 14 13 3 13 0 13 5 13 4 19 4 13 51 3 43 1 10 1 5 51 1 10 1 40 -43 43 2 13 4 1 15 17 8 45 9 75 45 10 38 41 10 1 4 51 0 13 0 13 5 13 4 19 3 11 45 12 10 0 39 14 13 3 13 0 13 5 13 4 19 4 13 51 3 43 1 10 1 5 51 1 10 1 40 -43 43 2 10 0 76 39 20 13 4 1 16 17 8 39 12 15 17 19 1 18 12 9 1 19 2 19 39 10 15 20 13 4 13 3 19 3 21 10 0 73 43 1 29) #208# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #209=#A(t (8) (c::to-fixnum-float-type type (fixnum double-float single-float long-float) si::%dolist-var c::i c::type>= #Y(c::to-fixnum-float-type nil nil (24 45 1 26 58 60 46 1 2 45 3 75 45 4 38 25 10 1 4 51 0 13 0 13 3 19 2 5 39 6 10 0 73 36 2 10 1 5 51 1 10 1 40 -27 75 51 0 75 73 43 2 63 29) #209# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #210=#A(t (10) (c::maximum-float-type c::t1 c::t2 long-float eq double-float single-float fixnum #Y(c::maximum-float-type nil nil (24 45 1 24 45 2 26 10 1 76 39 6 10 0 73 38 67 13 1 1 3 17 4 40 7 13 0 1 3 17 4 39 6 1 3 73 38 46 13 1 1 5 17 4 40 7 13 0 1 5 17 4 39 6 1 5 73 38 25 13 1 1 6 17 4 40 7 13 0 1 6 17 4 39 6 1 6 73 38 4 1 7 73 29) #210# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 33 12 19 2 34 1 0 73 29) #211=#A(t (35) (c::inline-type-matches c::inline-info c::arg-types c::return-type c::inline-info-multiple-values c::*destination* (values return) member c::rts c::number-max c::inline-info-arg-types c::types c::arg-type type c::fixnum-float eq c::to-fixnum-float-type c::new-type c::maximum-float-type c::type>= c::inline-info-return-rep-type :bool c::inline-info-exact-return-type c::policy-assume-right-type c::inline-info-return-type c::inline-return-type fixnum integer copy-structure #:g19402 nreverse #:g19403 si::structure-set #Y(c::inline-type-matches nil nil (24 45 1 24 45 2 24 45 3 26 57 0 60 276 13 3 19 1 4 76 39 8 14 5 15 6 19 2 7 39 5 75 73 36 0 75 45 8 75 45 9 10 4 45 2 13 6 19 1 10 45 11 38 89 10 1 4 45 12 10 1 4 45 13 13 0 1 14 17 15 39 37 13 1 19 1 16 45 17 10 0 76 39 5 75 73 36 7 13 0 10 6 3 51 6 13 5 13 0 19 2 18 51 5 43 1 38 23 13 0 13 1 19 2 19 39 10 13 0 10 5 3 51 5 38 5 75 73 36 6 43 2 10 1 5 51 1 10 0 5 51 0 10 1 2 40 4 10 0 2 39 -97 10 1 40 3 10 0 39 5 75 73 36 4 43 2 13 5 19 1 20 12 11 21 17 15 40 70 13 5 19 1 22 76 40 62 19 0 23 39 57 13 5 19 1 24 45 25 10 1 39 37 13 1 1 26 17 15 39 5 1 27 38 3 10 1 51 1 39 17 13 0 13 1 19 2 19 39 8 13 1 13 4 19 2 19 38 8 13 0 13 4 19 2 19 43 1 73 39 37 10 5 16 28 45 1 10 0 45 29 10 3 16 30 45 31 13 1 15 1 9 3 13 0 19 4 32 43 1 43 1 10 0 73 43 1 43 2 63 29) #211# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 49 12 19 2 50 1 0 73 29) #212=#A(t (51) (c::bind c::loc c::var c::var-kind c::closure c::var-loc fixnum typep c::next-env #:g19410 #:g19411 si::structure-set zerop "env" c::*env-lvl* " = ECL_NIL;" c::wt-nl "CLV" " = env" " = CONS(" :object c::wt-coerce-loc ",env" ");" c::wt c::var-name c::wt-comment c::lexical consp c::next-lex #:g19412 #:g19413 c::wt-lex " = " ";" special c::global c::bds-bind ffi::object eq equal " = " c::var-rep-type ";" c::lcl eql #:g19414 #:g19415 c::baboon #Y(c::bind nil nil (24 45 1 24 45 2 26 13 0 19 1 3 42 4 103 13 0 19 1 5 45 5 13 0 15 6 19 2 7 76 39 29 19 0 8 51 0 10 1 45 9 10 1 45 10 13 1 15 2 9 10 13 0 19 4 11 43 1 43 1 10 0 16 12 39 10 15 13 14 14 15 15 19 3 16 15 17 13 0 15 18 14 14 15 19 19 5 16 14 20 13 2 19 2 21 15 22 14 14 15 23 19 3 24 13 1 19 1 25 12 19 1 26 43 1 38 195 42 27 81 13 0 19 1 5 45 5 10 0 16 28 76 39 29 19 0 29 51 0 10 1 45 30 10 1 45 31 13 1 15 2 9 10 13 0 19 4 11 43 1 43 1 19 0 16 13 0 19 1 32 15 33 19 1 24 14 20 13 2 19 2 21 15 34 19 1 24 43 1 13 0 19 1 25 12 19 1 26 38 112 41 35 4 42 36 10 13 1 13 0 19 2 37 38 97 13 0 19 1 5 12 1 38 17 39 76 39 40 13 0 19 1 5 12 10 1 17 40 76 73 39 24 13 0 15 41 19 2 16 13 0 19 1 42 12 13 1 19 2 21 15 43 19 1 24 38 45 10 1 16 28 39 9 10 1 4 12 1 44 17 45 39 26 10 0 45 46 10 2 45 47 13 1 15 2 9 10 13 0 19 4 11 43 1 43 1 38 4 19 0 48 29) #212# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #213=#A(t (18) (c::bind-init c::form c::var c::var-kind c::kind (c::closure c::lexical special c::global) member c::*inline-blocks* c::*temp* c::inline-args c::coerce-locs c::locs c::bind c::close-inline-blocks c::*destination* c::c2expr* #Y(c::bind-init nil nil (24 45 1 24 45 2 26 13 0 19 1 3 45 4 13 0 15 5 19 2 6 39 41 8 0 48 7 11 8 48 8 10 2 6 1 12 19 1 9 12 19 1 10 45 11 10 0 4 12 13 2 19 2 12 19 0 13 43 1 44 2 38 16 15 12 10 1 6 2 48 14 13 2 19 1 15 44 1 43 1 29) #213# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #214=#A(t (23) (c::bds-bind c::loc c::var c::var-p c::var-kind (c::global special) member c::var-name eq "ecl_bds_push(cl_env_copy," c::var-loc ");" c::wt-nl "ecl_bds_bind(cl_env_copy," "," :object c::wt-coerce-loc ");" c::wt c::*unwind-exit* c::wt-comment #Y(c::bds-bind nil nil (24 45 1 24 45 2 26 13 1 19 1 3 39 27 13 1 19 1 4 12 15 5 19 2 6 39 14 13 1 19 1 7 12 13 0 19 1 7 17 8 39 16 15 9 13 0 19 1 10 12 15 11 19 3 12 38 26 15 13 13 0 19 1 10 12 15 14 19 3 12 14 15 13 1 19 2 16 15 17 19 1 18 15 0 11 19 3 52 19 13 0 19 1 7 12 19 1 20 29) #214# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 35 12 19 2 36 1 0 73 29) #215=#A(t (37) (c::c1block c::args block c::check-args-number c::block-name symbolp "The block name ~s is not a symbol." c::cmperr :name :kind c::lexical c::make-var c::blk-var :var c::make-blk c::blk c::cmp-env-copy c::*cmp-env* c::cmp-env-register-block c::c1progn c::body c::blk-ref-ccb c::blk-ref-clb #:g19421 c::*setjmps* + c::blk-ref plusp :local-vars :type c::blk-type c::c1form-type c::values-type-or :args c::make-c1form* #Y(c::c1block nil nil (24 45 1 26 15 2 13 0 9 1 19 3 3 10 0 4 45 4 10 0 16 5 76 39 8 15 6 13 0 19 2 7 14 8 13 0 14 9 15 10 19 4 11 45 12 14 13 13 0 14 8 13 1 19 4 14 45 15 19 0 16 48 17 13 0 19 1 18 10 3 5 12 19 1 19 44 1 45 20 13 1 19 1 21 40 6 13 1 19 1 22 39 16 8 1 45 23 14 24 13 0 19 2 25 52 24 43 1 13 1 19 1 26 16 27 39 39 15 2 14 28 10 2 6 1 12 14 29 13 1 19 1 30 12 13 0 19 1 31 12 19 2 32 12 14 33 13 1 13 0 19 8 34 38 4 10 0 73 43 3 43 1 29) #215# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 56 12 19 2 57 1 0 73 29) #216=#A(t (58) (c::c2block c::c1form c::blk c::body c::blk-var c::var-ref plusp c::*env-lvl* #:g19438 c::*exit* #:g19439 si::structure-set #:g19440 c::*destination* #:g19441 c::wt-nl-open-brace c::blk-ref-ccb c::blk-ref-clb #:g19442 :object #:g19443 c::var #:g19444 c::next-lcl #:g19445 "cl_object " ";" c::wt-nl c::env-grows c::env-lvl c::*volatile* "cl_object env" #:g19447 + " = env" ";" "ECL_NEW_FRAME_ID(cl_env_copy)" c::bind "if (ecl_frs_push(cl_env_copy," ")!=0) {" c::frame c::*unwind-exit* values c::unwind-exit "} else {" c::c2expr "}" c::wt #:g19449 c::*env* - c::wt-nl-close-brace #:g19450 #:g19451 #:g19452 #:g19453 #Y(c::c2block nil nil (24 45 1 24 45 2 24 45 3 26 13 1 19 1 4 12 19 1 5 16 6 39 254 13 1 19 1 4 45 4 11 7 48 7 10 2 45 8 11 9 45 10 13 1 15 2 9 5 13 0 19 4 11 43 1 43 1 10 2 45 12 11 13 45 14 13 1 15 2 9 6 13 0 19 4 11 43 1 43 1 19 0 15 13 2 19 1 16 40 6 13 2 19 1 17 76 39 57 10 0 45 18 11 19 45 20 13 1 15 21 9 6 13 0 19 4 11 43 1 43 1 10 0 45 22 19 0 23 45 24 13 1 15 21 9 10 13 0 19 4 11 43 1 43 1 15 25 13 0 15 26 19 3 27 13 2 19 1 16 12 19 1 28 39 36 11 7 45 29 14 30 15 31 8 1 45 32 14 7 13 0 19 2 33 52 7 12 43 1 15 34 13 0 15 35 19 6 27 43 1 15 36 13 0 19 2 37 15 38 13 0 15 39 19 3 27 15 40 11 41 3 48 41 15 42 19 1 43 15 44 19 1 27 13 1 19 1 45 15 46 19 1 47 44 1 13 2 19 1 16 39 16 8 1 45 48 14 49 13 0 19 2 50 52 49 43 1 19 0 51 43 1 44 1 38 52 10 1 45 52 11 9 45 53 13 1 15 2 9 5 13 0 19 4 11 43 1 43 1 10 1 45 54 11 13 45 55 13 1 15 2 9 6 13 0 19 4 11 43 1 43 1 13 0 19 1 45 29) #216# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 47 12 19 2 48 1 0 73 29) #217=#A(t (49) (c::c1return-from c::args return-from c::check-args-number c::name symbolp "The block name ~s is not a symbol." c::cmperr c::cmp-env-search-block c::unw c::clb c::ccb c::blk "The block ~s is undefined." second c::c1expr c::val c::var t type #:g19473 #:g19474 si::structure-set c::blk-var #:g19477 c::closure #:g19478 #:g19479 #:g19480 #:g19481 #:g19482 unwind-protect #:g19487 #:g19489 c::blk-ref + #:g19488 #:g19490 c::blk-type c::c1form-type c::values-type-or #:g19491 :type :args c::make-c1form* c::output c::add-to-read-nodes #Y(c::c1return-from nil nil (24 45 1 26 15 2 13 0 9 1 9 2 19 4 3 10 0 4 45 4 10 0 16 5 76 39 8 15 6 13 0 19 2 7 13 0 19 1 8 47 3 9 47 2 10 47 1 11 45 12 10 0 76 39 8 15 13 13 4 19 2 7 10 5 16 14 12 19 1 15 45 16 75 45 17 11 18 45 19 10 4 39 83 10 3 45 20 11 18 45 21 13 1 15 12 9 2 13 0 19 4 22 43 1 43 1 1 11 51 0 13 3 19 1 23 51 1 10 1 45 24 1 25 45 26 13 1 15 17 9 6 13 0 19 4 22 43 1 43 1 10 1 45 27 11 18 45 28 13 1 15 17 9 2 13 0 19 4 22 43 1 43 1 38 56 10 5 39 37 10 3 45 29 11 18 45 30 13 1 15 12 9 3 13 0 19 4 22 43 1 43 1 1 10 51 0 13 3 19 1 23 51 1 38 16 10 6 39 12 1 31 51 0 13 3 19 1 23 51 1 10 3 45 32 8 1 45 33 13 1 19 1 34 12 13 0 19 2 35 45 36 13 2 15 12 9 1 13 0 19 4 22 43 3 10 3 45 37 13 4 19 1 38 12 13 3 19 1 39 12 19 2 40 45 41 13 1 15 12 9 8 13 0 19 4 22 43 1 43 1 15 2 14 42 15 18 14 43 13 3 13 0 13 2 13 1 19 8 44 45 45 10 2 39 8 13 2 13 0 19 2 46 10 0 73 43 1 43 3 43 4 43 1 29) #217# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #218=#A(t (27) (c::c2return-from c::c1form c::blk type c::val c::var c::ccb values c::*destination* c::c2expr* "cl_return_from(" c::blk-var "," c::blk-name c::add-symbol ");" c::wt-nl c::clb unwind-protect "cl_return_from(" ",ECL_NIL);" c::blk-destination c::blk-exit c::*exit* c::c2expr #Y(c::c2return-from nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 10 2 42 6 39 1 7 48 8 13 1 19 1 9 44 1 15 10 13 3 19 1 11 12 15 12 13 3 19 1 13 12 19 1 14 12 15 15 19 5 16 38 56 41 17 4 42 18 27 1 7 48 8 13 1 19 1 9 44 1 15 19 13 3 19 1 11 12 15 20 19 3 16 38 24 13 3 19 1 21 12 13 3 19 1 22 12 49 23 49 8 13 1 19 1 24 44 2 29) #218# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #219=#A(t (17) (c::unoptimized-long-call c::fun c::arguments gensym c::frame c::with-stack #:loop-list19495 c::i #:loop-list-head19496 #:loop-list-tail19497 0 c::stack-push rplacd si::apply-from-stack-frame append #Y(c::unoptimized-long-call nil nil (24 45 1 24 45 2 26 19 0 3 45 4 15 5 13 0 58 60 73 77 13 2 46 6 46 7 75 6 1 45 8 10 0 45 9 57 10 61 2 2 38 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 15 11 13 6 10 3 6 3 6 1 51 1 17 12 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 12 15 13 13 0 10 2 6 3 6 1 12 19 2 14 7 3 73 43 1 29) #219# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #220=#A(t (18) (c::unoptimized-funcall c::fun c::arguments length c::l si::c-arguments-limit <= funcall :sp-change t :side-effects :args c::c1expr c::c1args* c::make-c1form* c::unoptimized-long-call #Y(c::unoptimized-funcall nil nil (24 45 1 24 45 2 26 10 0 16 3 45 4 13 0 14 5 19 2 6 39 30 15 7 14 8 14 9 14 10 14 9 14 11 13 2 19 1 12 12 13 1 19 1 13 12 19 8 14 38 8 13 2 13 1 19 2 15 43 1 29) #220# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 1 0 73 29) #221=#A(t (28) (c::c1funcall c::args funcall c::check-args-number c::fd c::arguments c::fun consp lambda eq c::optimize-funcall/apply-lambda ext::lambda-block macroexpand-1 atom c::unoptimized-funcall c::name symbolp the c::cmp-macro-function c::cmp-expand-macro function second si::valid-function-name-p c::c1call "Malformed function name: ~A" c::cmperr #Y(c::c1funcall nil nil (24 45 1 26 15 2 13 0 9 1 19 3 3 10 0 4 12 10 0 5 12 77 46 4 46 5 46 6 10 0 16 7 39 9 10 0 4 12 1 8 17 9 39 13 10 0 5 12 13 1 77 19 3 10 38 210 10 0 16 7 39 9 10 0 4 12 1 11 17 9 39 20 13 0 19 1 12 51 0 10 0 5 12 13 1 77 19 3 10 38 175 10 0 16 13 39 10 13 0 13 1 19 2 14 38 160 10 0 4 45 15 10 0 16 16 39 15 13 0 1 17 17 9 76 39 6 13 0 19 1 18 51 3 43 1 39 19 13 2 13 0 19 2 19 12 10 1 7 2 12 19 1 0 38 111 10 0 4 12 1 20 17 9 76 39 10 13 0 13 1 19 2 14 38 91 10 0 16 21 51 0 16 22 39 11 13 0 13 1 77 19 3 23 38 71 10 0 16 7 39 9 10 0 4 12 1 8 17 9 39 13 10 0 5 12 13 1 77 19 3 10 38 43 10 0 16 7 39 9 10 0 4 12 1 11 17 9 39 20 13 0 19 1 12 51 0 10 0 5 12 13 1 77 19 3 10 38 8 15 24 13 0 19 2 25 43 3 29) #221# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #222=#A(t (20) (c::c2funcall c::c1form c::form c::args c::*inline-blocks* c::*temp* c::c1form-primary-type c::form-type function subtypep c::policy-assume-right-type c::function-p c::maybe-save-value c::loc c::inline-args c::call-unknown-global-loc c::unwind-exit c::close-inline-blocks #Y(c::c2funcall nil nil (24 45 1 24 45 2 24 45 3 26 8 0 48 4 11 5 48 5 13 1 19 1 6 45 7 13 0 15 8 19 2 9 39 4 19 0 10 45 11 13 3 13 2 19 2 12 45 13 77 13 0 13 3 19 1 14 12 13 1 19 4 15 12 19 1 16 19 0 17 43 3 44 2 29) #222# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #223=#A(t (22) (c::c2call-global c::c1form c::fname c::args c::*global-funs* :key c::fun-name :test c::same-fname-p find c::fun c::c2try-tail-recursive-call c::*inline-blocks* c::*temp* c::c1form-primary-type c::*destination* c::loc-type c::call-global-loc c::unwind-exit c::close-inline-blocks #Y(c::c2call-global nil nil (24 45 1 24 45 2 24 45 3 26 57 0 60 78 13 2 14 4 14 5 33 6 12 14 7 33 8 12 19 6 9 45 10 10 0 39 8 13 0 13 2 19 2 11 39 5 75 73 36 1 8 0 48 12 11 13 48 13 13 3 13 0 13 2 13 4 19 1 14 12 14 15 19 1 16 12 19 5 17 12 19 1 18 19 0 19 44 2 43 1 63 29) #223# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 35 12 19 2 36 1 0 73 29) #224=#A(t (37) (c::call-global-loc c::fname c::fun c::args c::return-type c::expected-type c::fun-global c::inline-possible c::inline-args c::call-unknown-global-loc c::type-and c::apply-inliner c::inline-loc c::policy-use-direct-c-call c::fun-p c::*global-funs* :test c::same-fname-p :key c::fun-name find c::call-loc symbolp c::lfun si::get-sysprop c::fd c::get-proclaimed-narg c::maxarg c::minarg c::*in-all-symbols-functions* member c::call-exported-function-loc t si::mangle-name c::found #Y(c::call-global-loc nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 57 0 60 246 10 4 76 40 6 13 4 19 1 6 39 7 13 5 19 1 7 76 39 15 13 5 77 13 3 19 1 8 12 19 3 9 36 0 13 3 19 1 8 51 3 13 5 13 2 13 1 19 2 10 12 13 3 19 3 11 45 12 10 0 39 6 10 0 73 36 1 43 1 19 0 13 39 32 13 4 19 1 14 40 25 10 4 76 39 20 13 5 14 15 14 16 33 17 12 14 18 33 19 12 19 6 20 51 4 39 14 13 5 13 4 13 3 13 2 19 4 21 36 0 10 5 16 22 76 39 11 13 5 77 13 3 19 3 9 36 0 19 0 13 39 52 13 5 1 23 17 24 45 25 10 0 39 38 13 6 19 1 26 47 1 27 45 28 13 8 13 6 13 2 13 0 13 1 13 8 14 29 19 2 30 12 13 5 19 7 31 36 3 43 2 43 1 13 5 14 32 19 2 33 47 3 27 47 2 28 47 1 25 45 34 10 0 39 20 13 9 13 7 13 1 13 2 13 3 14 32 13 6 19 7 31 36 4 43 4 13 5 77 13 3 19 3 9 63 29) #224# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #225=#A(t (9) (c::call-loc c::fname c::fun c::args type c::call-normal c::coerce-locs #Y(c::call-loc nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 15 5 13 2 13 1 19 1 6 12 10 0 6 4 73 29) #225# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 43 12 19 2 44 1 0 73 29) #226=#A(t (45) (c::call-exported-function-loc c::fname c::args c::fun-c-name c::minarg c::maxarg c::in-core c::return-type c::*compiler-declared-globals* gethash c::declared c::val = "extern cl_object " "(" c::wt-nl-h si::%dotimes-var c::i > "," c::wt-h1 "cl_object" 1+ < ");" "#ifdef __cplusplus" "extern cl_object " "(...);" "#else" "extern cl_object " "();" "#endif" si::hash-set :name :global t :cfun :lambda :minarg :maxarg c::make-fun c::fun c::call-loc #Y(c::call-exported-function-loc nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 24 45 6 24 45 7 26 10 1 76 39 133 13 4 14 8 19 2 9 47 1 10 45 11 10 1 76 39 114 13 4 13 5 19 2 12 39 63 15 13 13 6 15 14 19 3 15 10 4 45 16 8 0 45 17 38 26 13 0 9 0 19 2 18 39 6 15 19 19 1 20 15 21 19 1 20 10 0 16 22 51 0 13 0 13 1 19 2 23 40 -33 43 2 15 24 19 1 20 38 34 15 25 19 1 15 15 26 13 6 15 27 19 3 15 15 28 19 1 15 15 29 13 6 15 30 19 3 15 15 31 19 1 15 13 6 14 8 9 1 19 3 32 43 2 14 33 13 6 14 34 14 35 14 36 13 4 14 37 77 14 38 13 3 14 39 13 2 19 12 40 45 41 13 7 13 0 13 6 13 1 19 4 42 43 1 29) #226# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #227=#A(t (17) (c::call-unknown-global-loc c::fname c::loc c::args c::function-p symbolp symbol-package "CL" find-package eql c::add-symbol fdefinition t c::call-indirect c::coerce-locs #Y(c::call-unknown-global-loc nil nil (24 45 1 24 45 2 24 45 3 25 40 2 77 46 4 26 10 2 76 39 45 10 3 16 5 39 13 10 3 16 6 12 1 7 16 8 17 9 76 39 13 13 3 19 1 10 51 2 75 51 0 38 13 15 11 10 3 6 2 51 2 11 12 51 0 15 13 13 2 13 1 19 1 14 12 13 3 10 0 6 5 73 29) #227# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #228=#A(t (17) (c::maybe-save-value c::value c::other-forms-flag c::other-forms c::c1form-name c::name ext::location eq c::c1form-args c::var c::var-changed-in-form-list c::make-temp-var c::temp c::*destination* c::c2expr* #Y(c::maybe-save-value nil nil (24 45 1 25 40 3 77 75 45 2 46 3 26 13 2 19 1 4 45 5 13 0 1 6 17 7 39 10 13 3 19 1 8 4 73 38 58 13 0 1 9 17 7 39 18 10 2 39 14 13 3 19 1 8 4 12 13 1 19 2 10 76 39 10 13 3 19 1 8 4 73 38 22 19 0 11 45 12 10 0 48 13 13 4 19 1 14 10 0 73 43 1 44 1 43 1 29) #228# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*text-for-lexical-level* si::*make-special boundp ("lex0" "lex1" "lex2" "lex3" "lex4" "lex5" "lex6" "lex7" "lex8" "lex9"))) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*text-for-closure* si::*make-special boundp ("env0" "env1" "env2" "env3" "env4" "env5" "env6" "env7" "env8" "env9"))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #229=#A(t (8) (c::env-var-name c::n c::*text-for-closure* nth "env~D" format #Y(c::env-var-name nil nil (24 45 1 26 13 0 11 2 17 3 73 40 9 77 15 4 13 0 19 3 5 29) #229# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #230=#A(t (6) (c::wt-stack-pointer c::narg "cl_env_copy->stack_top-" c::wt #Y(c::wt-stack-pointer nil nil (24 45 1 26 15 2 13 0 19 2 3 29) #230# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #231=#A(t (21) (c::wt-call c::fun c::args c::fname c::env t c::*aux-closure* "(aux_closure.env=" ",cl_env_copy->function=(cl_object)&aux_closure," c::wt ")" "(" "" c::comma si::%dolist-var c::arg ", " ")" c::wt-comment #Y(c::wt-call nil nil (24 45 1 24 45 2 25 40 2 77 46 3 25 40 2 77 46 4 26 10 0 39 28 11 5 52 6 15 7 13 0 15 8 19 3 9 13 3 13 2 19 2 0 15 10 19 1 9 38 55 13 3 15 11 19 2 9 1 12 45 13 10 3 45 14 75 45 15 38 22 10 1 4 51 0 13 2 13 0 19 2 9 1 16 51 2 10 1 5 51 1 10 1 40 -24 43 2 43 1 15 17 19 1 9 10 1 73 39 6 13 1 19 1 18 29) #231# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #232=#A(t (19) (c::wt-call-indirect c::fun-loc c::args c::fname c::function-p length c::narg "(cl_env_copy->function=" ")->cfun.entry(" c::wt "ecl_function_dispatch(cl_env_copy," ")(" si::%dolist-var c::arg ", " ")" c::wt-comment #Y(c::wt-call-indirect nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 10 2 16 5 45 6 10 1 39 14 15 7 13 4 15 8 13 0 19 4 9 38 12 15 10 13 4 15 11 13 0 19 4 9 10 3 45 12 75 45 13 38 18 10 1 4 51 0 15 14 13 0 19 2 9 10 1 5 51 1 10 1 40 -20 43 2 15 15 19 1 9 10 2 73 39 6 13 2 19 1 16 43 1 29) #232# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 45 12 19 2 46 1 0 73 29) #233=#A(t (47) (c::wt-call-normal c::fun c::args type c::fun-cfun "Function without a C name: ~A" c::fun-name c::baboon c::fun-minarg c::minarg c::fun-maxarg c::maxarg c::fun-c-name c::fun-lisp-name length c::narg c::env c::fun-closure c::closure c::environment-accessor c::lexical c::fun-level c::lex-lvl si::%dotimes-var c::n - c::j c::*text-for-lexical-level* nth c::x "lex~d" format #:g19543 #:g19544 #:g19545 nthcdr rplaca 1+ < <= "Wrong number of arguments for function ~S" c::anonymous c::cmperr c::fun-needs-narg c::wt-call #Y(c::wt-call-normal nil nil (24 45 1 24 45 2 24 45 3 26 13 2 19 1 4 76 39 12 15 5 13 2 19 1 6 12 19 2 7 13 2 19 1 8 45 9 13 3 19 1 10 45 11 13 4 19 1 4 45 12 13 5 19 1 6 45 13 10 5 16 14 45 15 75 45 16 13 8 19 1 17 42 18 10 13 8 19 1 19 51 0 38 112 42 20 109 13 8 19 1 21 45 22 10 0 45 23 8 0 45 24 38 79 13 2 13 0 9 1 19 3 25 45 26 13 0 11 27 17 28 45 29 10 0 76 39 40 77 15 30 13 1 19 3 31 51 0 10 2 45 32 11 27 45 33 10 2 45 34 13 2 10 1 17 35 12 10 0 17 36 10 0 43 1 43 2 13 0 10 12 3 51 12 43 2 10 0 16 37 51 0 13 0 13 1 19 2 38 40 -86 43 2 43 1 13 5 13 1 13 4 19 3 39 76 39 15 15 40 10 2 73 40 4 1 41 73 12 19 2 42 13 8 19 1 43 39 8 13 1 10 7 3 51 7 13 3 13 7 77 13 0 19 4 44 43 6 29) #233# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #234=#A(t (16) (c::c1catch c::args catch c::check-args-number #:g19551 c::*setjmps* + :sp-change t :type :args c::c1expr c::c1progn c::make-c1form* #Y(c::c1catch nil nil (24 45 1 26 15 2 13 0 9 1 19 3 3 8 1 45 4 14 5 13 0 19 2 6 52 5 43 1 15 2 14 7 14 8 14 9 14 8 14 10 10 0 4 12 19 1 11 12 10 0 5 12 19 1 12 12 19 8 13 29) #234# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 37 12 19 2 38 1 0 73 29) #235=#A(t (39) (c::c2catch c::c1form c::tag c::body c::*destination* c::tmp-destination c::new-destination #:g19555 c::*last-label* + c::code c::value0 c::c2expr* c::frame c::*unwind-exit* (c::trash values) member "if (ecl_frs_push(cl_env_copy," ")==0) {" c::wt-nl "BEGIN CATCH ~A" c::wt-comment c::*opened-c-braces* 1+ "if (ecl_frs_push(cl_env_copy," ")) {" "BEGIN CATCH ~A" c::next-label c::label c::*exit* values c::unwind-exit c::wt-label "} else {" "}" "ecl_frs_pop(cl_env_copy);" "END CATCH ~A" #Y(c::c2catch nil nil (24 45 1 24 45 2 24 45 3 26 14 4 19 1 5 45 6 8 1 45 7 14 8 13 0 19 2 9 52 8 43 1 45 10 1 11 48 4 13 3 19 1 12 44 1 10 1 48 4 15 13 11 14 3 48 14 13 1 15 15 19 2 16 39 32 15 17 15 11 15 18 19 3 19 15 20 13 0 19 2 21 11 22 16 23 48 22 13 2 19 1 12 44 1 38 75 15 24 15 11 15 25 19 3 19 15 26 13 0 19 2 21 11 22 16 23 48 22 19 0 27 45 28 13 0 11 14 3 48 14 10 0 48 29 15 30 19 1 31 44 1 13 0 19 1 32 43 1 44 1 44 1 15 33 19 1 19 11 22 16 23 48 22 13 2 19 1 12 44 1 44 2 15 34 19 1 19 15 35 19 1 19 15 36 13 0 19 2 21 13 1 19 1 31 43 2 29) #235# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #236=#A(t (20) (c::c1unwind-protect c::args unwind-protect c::check-args-number #:g19559 c::*setjmps* + c::cmp-env-mark c::*cmp-env* c::c1expr c::form :type c::c1form-type :sp-change t :args c::c1progn c::make-c1form* #Y(c::c1unwind-protect nil nil (24 45 1 26 15 2 13 0 9 1 19 3 3 8 1 45 4 14 5 13 0 19 2 6 52 5 43 1 15 2 19 1 7 48 8 10 0 4 12 19 1 9 44 1 45 10 15 2 14 11 13 0 19 1 12 12 14 13 14 14 14 15 13 0 10 1 5 12 19 1 16 12 19 8 17 43 1 29) #236# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 34 12 19 2 35 1 0 73 29) #237=#A(t (36) (c::c2unwind-protect c::c1form c::form c::body :rep-type :cl-index c::make-lcl-var c::sp c::nargs c::stack c::*unwind-exit* c::wt-nl-open-brace "volatile bool unwinding = FALSE;" c::wt-nl "cl_index " "=ECL_STACK_INDEX(cl_env_copy)," ";" "ecl_frame_ptr next_fr;" "if (ecl_frs_push(cl_env_copy,ECL_PROTECT_TAG)) {" "  unwinding = TRUE; next_fr=cl_env_copy->nlj_fr;" "} else {" c::frame values c::*destination* c::c2expr* "}" "ecl_frs_pop(cl_env_copy);" "=ecl_stack_push_values(cl_env_copy);" c::trash "ecl_stack_pop_values(cl_env_copy," ");" "if (unwinding) ecl_unwind(cl_env_copy,next_fr);" c::unwind-exit c::wt-nl-close-brace #Y(c::c2unwind-protect nil nil (24 45 1 24 45 2 24 45 3 26 14 4 14 5 19 2 6 45 7 14 4 14 5 19 2 6 45 8 15 9 10 1 6 2 12 11 10 7 2 48 10 19 0 11 15 12 19 1 13 15 14 13 1 15 15 13 0 15 16 19 5 13 15 17 19 1 13 15 18 19 1 13 15 19 19 1 13 15 20 19 1 13 15 21 11 10 3 12 15 22 49 23 49 10 13 3 19 1 24 44 2 15 25 19 1 13 15 26 19 1 13 13 0 15 27 19 2 13 1 28 48 23 13 2 19 1 24 44 1 15 29 13 0 15 30 19 3 13 15 31 19 1 13 15 22 19 1 32 19 0 33 43 2 44 1 29) #237# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #238=#A(t (10) (c::c1throw c::args throw c::check-args-number :args c::c1expr second c::make-c1form* #Y(c::c1throw nil nil (24 45 1 26 15 2 13 0 9 2 9 2 19 4 3 15 2 14 4 10 0 4 12 19 1 5 12 10 0 16 6 12 19 1 5 12 19 4 7 29) #238# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #239=#A(t (18) (c::c2throw c::c1form c::tag c::val c::loc c::c1form-name c::var ext::location c::c1form-args c::make-temp-var c::*destination* c::c2expr* values "cl_throw(" ");" c::wt-nl #Y(c::c2throw nil nil (24 45 1 24 45 2 24 45 3 26 75 45 4 13 2 19 1 5 41 6 4 42 7 11 13 2 19 1 8 4 51 0 38 17 19 0 9 51 0 10 0 48 10 13 2 19 1 11 44 1 1 12 48 10 13 1 19 1 11 44 1 15 13 13 0 15 14 19 3 15 29) #239# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #240=#A(t (7) (c::cmp-env-root c::*cmp-env-root* c::env c::cmp-env-copy c::add-default-optimizations #Y(c::cmp-env-root nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 2 13 0 19 1 4 43 1 29) #240# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #241=#A(t (5) (c::cmp-env-copy c::*cmp-env* c::env #Y(c::cmp-env-copy nil nil (25 40 3 14 1 46 2 26 10 0 4 12 10 0 5 3 73 29) #241# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 14 9 9 2 19 4 10 1 0 73 29) #242=#A(t (11) (c::cmp-env-variables #:g19561 #:g19560 #:g19562 c::*cmp-env* c::env si::dm-too-many-arguments car #Y(c::cmp-env-variables nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 39 13 10 0 4 12 10 0 5 51 0 22 38 3 1 4 45 5 10 1 39 6 13 3 19 1 6 15 7 10 0 6 2 73 29) #242# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 14 9 9 2 19 4 10 1 0 73 29) #243=#A(t (11) (c::cmp-env-functions #:g19564 #:g19563 #:g19565 c::*cmp-env* c::env si::dm-too-many-arguments cdr #Y(c::cmp-env-functions nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 39 13 10 0 4 12 10 0 5 51 0 22 38 3 1 4 45 5 10 1 39 6 13 3 19 1 6 15 7 10 0 6 2 73 29) #243# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 1 0 73 29) #244=#A(t (25) (c::cmp-env-cleanups c::env c::specials c::end c::cleanup-forms c::aux c::*cmp-env* c::records-list 0 atom eq c::record symbolp second :special fourth :cleanup "Inconsistency in environment." error nconc copy-list mapcar apply #Y(c::cmp-env-cleanups nil nil (24 45 1 26 58 60 166 75 45 2 10 2 4 45 3 75 45 4 75 45 5 11 6 4 45 7 57 8 61 2 2 92 10 1 16 9 39 4 35 0 1 13 1 10 4 17 10 39 4 35 0 1 10 1 4 45 11 10 0 16 9 40 51 10 0 4 16 12 39 10 10 0 16 13 12 11 14 17 10 39 13 10 0 16 15 12 10 6 3 51 6 38 21 10 0 4 12 11 16 17 10 39 11 10 0 16 13 12 10 4 3 51 4 43 1 10 1 5 51 1 35 0 0 13 1 10 4 17 10 76 39 6 15 17 19 1 18 13 5 33 19 12 33 20 12 13 3 19 2 21 12 19 2 22 12 72 2 36 6 62 73 43 1 43 1 43 1 43 1 43 1 63 29) #244# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #245=#A(t (17) (c::cmp-env-register-var c::var c::*cmp-env* c::env t boundp c::var-name c::var-kind (special c::global) member :special #:g19575 #:g19573 #:g19574 rplaca #Y(c::cmp-env-register-var nil nil (24 45 1 25 40 3 14 2 46 3 25 40 3 14 4 46 5 26 13 2 19 1 6 12 13 2 19 1 7 12 15 8 19 2 9 39 6 11 10 73 38 4 11 4 73 12 13 0 10 2 6 4 45 11 10 2 45 12 13 1 10 0 4 3 45 13 13 1 10 0 17 14 10 0 43 3 10 1 73 29) #245# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #246=#A(t (11) (c::cmp-env-declare-special c::name c::*cmp-env* c::env :warn :kind special c::c1make-global-variable c::cmp-env-register-var #Y(c::cmp-env-declare-special nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 14 4 77 14 5 15 6 19 5 7 12 13 0 77 19 3 8 10 0 73 29) #246# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #247=#A(t (12) (c::cmp-env-add-declaration type c::arguments c::*cmp-env* c::env :declare #:g19581 #:g19579 #:g19580 rplaca #Y(c::cmp-env-add-declaration nil nil (24 45 1 24 45 2 25 40 3 14 3 46 4 26 14 5 13 2 10 1 7 3 45 6 10 1 45 7 13 1 10 0 4 3 45 8 13 1 10 0 17 9 10 0 43 3 10 0 73 29) #247# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #248=#A(t (11) (c::cmp-env-extend-declaration type c::arguments c::*cmp-env* c::env c::cmp-env-search-declaration c::x append c::cmp-env-add-declaration #Y(c::cmp-env-extend-declaration nil nil (24 45 1 24 45 2 25 40 3 14 3 46 4 26 13 2 19 1 5 45 6 13 3 13 2 13 0 19 2 7 12 13 1 19 3 8 10 1 73 43 1 29) #248# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #249=#A(t (12) (c::cmp-env-register-function c::fun c::*cmp-env* c::env c::fun-name function #:g19587 #:g19585 #:g19586 rplacd #Y(c::cmp-env-register-function nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 19 1 4 12 15 5 10 1 6 3 45 6 10 1 45 7 13 1 10 0 5 3 45 8 13 1 10 0 17 9 10 0 43 3 10 0 73 29) #249# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #250=#A(t (8) (c::cmp-env-register-global-macro c::name function c::*cmp-env* c::cmp-env-register-macro c::*cmp-env-root* #Y(c::cmp-env-register-global-macro nil nil (24 45 1 24 45 2 26 13 1 13 0 14 3 19 3 4 13 1 13 0 14 5 19 3 4 0 29) #250# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #251=#A(t (12) (c::cmp-env-register-macro c::name function c::*cmp-env* c::env si::macro #:g19593 #:g19591 #:g19592 rplacd #Y(c::cmp-env-register-macro nil nil (24 45 1 24 45 2 25 40 3 14 3 46 4 26 13 2 15 5 10 1 6 3 45 6 10 1 45 7 13 1 10 0 5 3 45 8 13 1 10 0 17 9 10 0 43 3 10 0 73 29) #251# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #252=#A(t (12) (c::cmp-env-register-ftype c::name declaration c::*cmp-env* c::env :declare #:g19599 #:g19597 #:g19598 rplacd #Y(c::cmp-env-register-ftype nil nil (24 45 1 24 45 2 25 40 3 14 3 46 4 26 14 5 13 2 10 1 7 3 45 6 10 1 45 7 13 1 10 0 5 3 45 8 13 1 10 0 17 9 10 0 43 3 10 0 73 29) #252# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #253=#A(t (14) (c::cmp-env-register-symbol-macro c::name c::form c::*cmp-env* c::env si::symbol-macro c::whole #Y(nil nil nil (24 45 6 24 45 4 26 10 3 73 29) #253# #1# 0) #:g19605 #:g19603 #:g19604 rplaca #Y(c::cmp-env-register-symbol-macro nil nil (24 45 1 24 45 2 25 40 3 14 3 46 4 26 13 2 15 5 34 7 6 3 45 8 10 1 45 9 13 1 10 0 4 3 45 10 13 1 10 0 17 11 10 0 43 3 10 0 73 29) #253# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #254=#A(t (12) (c::cmp-env-register-block c::blk c::*cmp-env* c::env :block c::blk-name #:g19611 #:g19609 #:g19610 rplaca #Y(c::cmp-env-register-block nil nil (24 45 1 25 40 3 14 2 46 3 26 14 4 13 1 19 1 5 12 10 1 6 3 45 6 10 1 45 7 13 1 10 0 4 3 45 8 13 1 10 0 17 9 10 0 43 3 10 0 73 29) #254# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #255=#A(t (12) (c::cmp-env-register-tag c::name c::tag c::*cmp-env* c::env :tag #:g19617 #:g19615 #:g19616 rplaca #Y(c::cmp-env-register-tag nil nil (24 45 1 24 45 2 25 40 3 14 3 46 4 26 14 5 10 2 6 1 12 10 1 6 3 45 6 10 1 45 7 13 1 10 0 4 3 45 8 13 1 10 0 17 9 10 0 43 3 10 0 73 29) #255# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #256=#A(t (12) (c::cmp-env-register-cleanup c::form c::*cmp-env* c::env :cleanup copy-list #:g19623 #:g19621 #:g19622 rplaca #Y(c::cmp-env-register-cleanup nil nil (24 45 1 25 40 3 14 2 46 3 26 14 4 10 1 16 5 6 2 45 6 10 1 45 7 13 1 10 0 4 3 45 8 13 1 10 0 17 9 10 0 43 3 10 0 73 29) #256# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 1 0 73 29) #257=#A(t (24) (c::cmp-env-search-function c::name c::*cmp-env* c::env c::found c::unw c::clb c::ccb si::%dolist-var c::record c::cb eq t c::lb unwind-protect atom :format-control "Uknown record found in environment~%~S" :format-arguments c::baboon equal last #Y(c::cmp-env-search-function nil nil (24 45 1 25 40 3 14 2 46 3 26 77 77 77 77 46 4 46 5 46 6 46 7 58 60 114 10 5 5 45 8 75 45 9 38 97 10 1 4 51 0 13 0 1 10 17 11 39 7 11 12 51 3 38 73 13 0 1 13 17 11 39 7 11 12 51 4 38 59 13 0 1 14 17 11 39 7 11 12 51 5 38 45 10 0 16 15 39 17 14 16 15 17 14 18 10 0 6 1 12 19 4 19 38 23 10 0 4 12 10 8 17 20 39 13 13 0 19 1 21 4 51 6 75 73 36 2 10 1 5 51 1 10 1 40 -99 43 2 63 13 3 13 0 13 1 13 2 72 4 43 4 29) #257# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 28 12 19 2 29 1 0 73 29) #258=#A(t (30) (c::cmp-env-search-variables type c::name c::env c::found c::unw c::clb c::ccb si::%dolist-var c::record c::cb eq t c::lb unwind-protect atom :format-control "Uknown record found in environment~%~S" :format-arguments c::baboon :block second :tag :test eql member si::symbol-macro last #Y(c::cmp-env-search-variables nil nil (24 45 1 24 45 2 24 45 3 26 77 77 77 77 46 4 46 5 46 6 46 7 58 60 203 10 5 4 45 8 75 45 9 38 186 10 1 4 51 0 13 0 1 10 17 11 39 7 11 12 51 3 38 162 13 0 1 13 17 11 39 7 11 12 51 4 38 148 13 0 1 14 17 11 39 7 11 12 51 5 38 134 10 0 16 15 39 17 14 16 15 17 14 18 10 0 6 1 12 19 4 19 38 112 10 0 4 12 10 9 17 11 76 40 101 13 9 11 20 17 11 39 21 13 8 10 0 16 21 17 11 39 9 10 0 51 6 75 73 36 2 38 73 13 9 11 22 17 11 39 28 13 8 10 0 16 21 12 14 23 33 24 12 19 4 25 39 9 10 0 51 6 75 73 36 2 38 38 10 0 16 21 12 1 26 17 11 39 19 13 8 1 26 17 11 39 5 10 0 51 6 75 73 36 2 38 9 10 0 51 6 75 73 36 2 10 1 5 51 1 10 1 40 -188 43 2 63 13 3 19 1 27 4 12 13 0 13 1 13 2 72 4 43 4 29) #258# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #259=#A(t (8) (c::cmp-env-search-block c::name c::*cmp-env* c::env :block c::cmp-env-search-variables #Y(c::cmp-env-search-block nil nil (24 45 1 25 40 3 14 2 46 3 26 14 4 13 1 13 0 19 3 5 29) #259# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #260=#A(t (8) (c::cmp-env-search-tag c::name c::*cmp-env* c::env :tag c::cmp-env-search-variables #Y(c::cmp-env-search-tag nil nil (24 45 1 25 40 3 14 2 46 3 26 14 4 13 1 13 0 19 3 5 29) #260# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #261=#A(t (8) (c::cmp-env-search-symbol-macro c::name c::*cmp-env* c::env si::symbol-macro c::cmp-env-search-variables #Y(c::cmp-env-search-symbol-macro nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 15 4 13 0 19 3 5 29) #261# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #262=#A(t (8) (c::cmp-env-search-var c::name c::*cmp-env* c::env t c::cmp-env-search-variables #Y(c::cmp-env-search-var nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 14 4 13 0 19 3 5 29) #262# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #263=#A(t (9) (c::cmp-env-search-macro c::name c::*cmp-env* c::env c::cmp-env-search-function c::f functionp #Y(c::cmp-env-search-macro nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 13 0 19 2 4 45 5 10 0 16 6 39 6 10 0 73 38 3 75 73 43 1 29) #263# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #264=#A(t (14) (c::cmp-env-search-ftype c::name c::*cmp-env* c::env si::%dolist-var c::i consp #:g19648 :declare eq #:g19649 c::same-fname-p #Y(c::cmp-env-search-ftype nil nil (24 45 1 25 40 3 14 2 46 3 26 58 60 94 10 1 45 4 75 45 5 38 73 10 1 4 51 0 10 0 16 6 39 50 10 0 45 7 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 11 8 17 9 39 25 10 0 45 10 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 13 4 19 2 11 39 6 10 0 73 36 2 10 1 5 51 1 10 1 40 -75 75 51 0 75 73 43 2 63 29) #264# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #265=#A(t (6) (c::cmp-env-mark c::mark c::*cmp-env* c::env #Y(c::cmp-env-mark nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 10 0 4 3 12 13 1 10 0 5 3 3 73 29) #265# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #266=#A(t (15) (c::cmp-env-new-variables c::new-env c::old-env ldiff #:loop-list19653 c::i #:loop-list-head19654 #:loop-list-tail19655 0 consp fourth c::var-p rplacd #Y(c::cmp-env-new-variables nil nil (24 45 1 24 45 2 26 58 60 93 77 10 2 4 12 10 1 4 17 3 12 46 4 46 5 75 6 1 45 6 10 0 45 7 57 8 61 2 2 50 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 3 16 9 39 9 10 3 16 10 12 19 1 11 39 13 13 1 10 3 16 10 6 1 51 1 17 12 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 29) #266# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #267=#A(t (14) (c::cmp-env-search-declaration c::kind c::*cmp-env* c::env #:loop-list19657 c::i 0 consp :declare eq second cddr #Y(c::cmp-env-search-declaration nil nil (24 45 1 25 40 3 14 2 46 3 26 58 60 75 77 10 1 4 12 46 4 46 5 57 6 61 2 2 55 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 10 1 16 7 39 20 10 1 4 12 11 8 17 9 39 10 10 1 16 10 12 10 5 17 9 39 7 10 1 16 11 36 3 35 0 0 62 73 43 2 63 29) #267# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #268=#A(t (9) (c::function-arg-types c::arg-types c::types c::al (&optional &rest &key) member nreverse #Y(c::function-arg-types nil nil (24 45 1 26 75 45 2 10 1 45 3 38 16 10 0 4 12 10 1 3 51 1 10 0 5 12 53 0 10 0 2 40 10 10 0 4 12 15 4 19 2 5 39 -30 10 1 16 6 43 1 29) #268# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #269=#A(t (27) (c::proclaim-function c::fname c::decl si::valid-function-name-p * c::arg-types c::return-types c::l consp #:g19667 "The function proclamation ~s ~s is not valid." warn atom "The function proclamation ~s ~s is not valid." eq (&optional) c::proclaimed-arg-types si::rem-sysprop si::put-sysprop (* (values &rest t)) :test equalp member c::proclaimed-return-type "The function proclamation ~s ~s is not valid." #Y(c::proclaim-function nil nil (24 45 1 24 45 2 26 10 1 16 3 39 160 1 4 45 5 1 4 45 6 10 2 45 7 10 0 76 40 40 10 0 16 8 39 25 10 0 45 9 10 0 4 12 10 0 5 51 0 10 0 51 1 22 43 1 51 2 38 10 15 10 13 4 13 3 19 3 11 10 0 76 40 28 10 0 16 12 40 4 10 0 5 39 12 15 13 13 4 13 3 19 3 11 38 6 10 0 4 51 1 13 2 75 17 14 39 5 1 15 51 2 13 2 1 4 17 14 39 9 13 4 1 16 17 17 38 10 13 4 15 16 13 2 19 3 18 13 1 15 19 14 20 33 21 12 19 4 22 39 9 13 4 1 23 17 17 38 10 13 4 15 23 13 1 19 3 18 43 3 38 10 15 24 13 1 13 0 19 3 11 29) #269# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #270=#A(t (15) (c::add-function-declaration c::fname ftype c::*cmp-env* c::env si::valid-function-name-p c::cmp-env-search-function c::fun functionp "Found function declaration for local macro ~A" warn c::cmp-env-register-ftype "In (DECLARE (FTYPE ...)): ~s is not a valid function name" #Y(c::add-function-declaration nil nil (24 45 1 24 45 2 25 40 3 14 3 46 4 26 10 2 16 5 39 36 13 2 19 1 6 45 7 10 0 16 8 39 10 15 9 13 3 19 2 10 38 10 13 3 13 2 13 1 19 3 11 43 1 38 8 15 12 13 2 19 2 10 10 0 73 29) #270# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #271=#A(t (19) (c::get-arg-types c::fname c::*cmp-env* c::env t c::may-be-global c::cmp-env-search-ftype c::x c::arg-types * eq c::cmp-env-search-function c::fun c::fun-p c::fun-global c::proclaimed-arg-types si::get-sysprop #Y(c::get-arg-types nil nil (24 45 1 25 40 3 14 2 46 3 25 40 3 14 4 46 5 26 13 2 13 1 19 2 6 45 7 10 0 39 26 10 0 4 45 8 13 0 1 9 17 10 76 73 39 7 13 0 14 4 72 2 43 1 38 43 10 1 73 39 38 13 3 13 2 19 2 11 45 12 10 0 76 40 13 13 0 19 1 13 39 6 13 0 19 1 14 73 39 7 13 4 1 15 17 16 43 1 43 1 29) #271# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #272=#A(t (19) (c::get-return-type c::fname c::*cmp-env* c::env c::cmp-env-search-ftype c::x second c::return-types * eq t c::cmp-env-search-function c::fun c::fun-p c::fun-global c::proclaimed-return-type si::get-sysprop #Y(c::get-return-type nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 13 0 19 2 4 45 5 10 0 39 27 10 0 16 6 45 7 13 0 1 8 17 9 76 73 39 7 13 0 14 10 72 2 43 1 38 38 13 2 13 1 19 2 11 45 12 10 0 76 40 13 13 0 19 1 13 39 6 13 0 19 1 14 73 39 7 13 3 1 15 17 16 43 1 43 1 29) #272# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #273=#A(t (10) (c::get-local-arg-types c::fun c::*cmp-env* c::env c::fun-name c::cmp-env-search-ftype c::x t #Y(c::get-local-arg-types nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 19 1 4 12 13 0 19 2 5 45 6 10 0 39 11 10 0 4 12 14 7 72 2 38 5 77 77 72 2 43 1 29) #273# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #274=#A(t (11) (c::get-local-return-type c::fun c::*cmp-env* c::env c::fun-name c::cmp-env-search-ftype c::x second t #Y(c::get-local-return-type nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 19 1 4 12 19 1 5 45 6 10 0 39 12 10 0 16 7 12 14 8 72 2 38 5 77 77 72 2 43 1 29) #274# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 24 12 19 2 25 1 0 73 29) #275=#A(t (26) (c::get-proclaimed-narg c::fun c::*cmp-env* c::env c::get-arg-types c::found c::arg-list #:loop-list19679 type c::in-optionals c::maxarg c::minarg 0 (* &rest &key &allow-other-keys) :test eq member call-arguments-limit &optional t #:g19683 + #:g19685 #:g19687 #Y(c::get-proclaimed-narg nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 13 0 19 2 4 47 1 5 45 6 10 1 39 161 58 60 156 77 13 1 46 7 46 8 9 0 9 0 77 46 9 46 10 46 11 57 12 61 2 2 115 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 13 4 15 13 14 14 33 15 12 19 4 16 39 11 13 1 14 17 72 2 36 6 38 70 13 4 1 18 17 15 39 11 11 19 51 3 10 1 51 2 38 52 10 3 39 18 8 1 45 20 13 3 13 0 19 2 21 51 3 43 1 38 31 8 1 45 22 13 2 13 0 19 2 21 51 2 43 1 8 1 45 23 13 3 13 0 19 2 21 51 3 43 1 35 0 0 13 1 13 2 13 8 72 3 36 6 62 73 43 3 43 2 63 38 9 9 0 14 17 13 1 72 3 43 2 29) #275# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #276=#A(t (13) (c::declare-inline c::fname c::*cmp-env* c::env t c::definition si::valid-function-name-p "Not a valid argument to INLINE declaration~%~4I~A" c::cmperr inline c::cmp-env-extend-declaration #Y(c::declare-inline nil nil (24 45 1 25 40 3 14 2 46 3 25 40 3 14 4 46 5 26 10 2 16 6 76 39 8 15 7 13 2 19 2 8 15 9 13 2 10 0 3 6 1 12 13 1 19 3 10 29) #276# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #277=#A(t (7) (c::declare-notinline c::fname c::*cmp-env* c::env c::declare-inline #Y(c::declare-notinline nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 13 0 77 19 3 4 29) #277# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #278=#A(t (15) (c::proclaim-inline c::fname-list si::%dolist-var c::fun si::valid-function-name-p "Not a valid function name ~s in INLINE proclamation" error inline si::get-sysprop t si::put-sysprop notinline si::rem-sysprop #Y(c::proclaim-inline nil nil (24 45 1 26 10 0 45 2 75 45 3 38 49 10 1 4 51 0 10 0 16 4 76 39 8 15 5 13 0 19 2 6 13 0 1 7 17 8 76 39 16 13 0 15 7 14 9 19 3 10 13 0 1 11 17 12 10 1 5 51 1 10 1 40 -51 75 73 43 2 29) #278# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #279=#A(t (14) (c::proclaim-notinline c::fname-list si::%dolist-var c::fun si::valid-function-name-p "Not a valid function name ~s in NOTINLINE proclamation" error inline si::rem-sysprop notinline t si::put-sysprop #Y(c::proclaim-notinline nil nil (24 45 1 26 10 0 45 2 75 45 3 38 40 10 1 4 51 0 10 0 16 4 76 39 8 15 5 13 0 19 2 6 13 0 1 7 17 8 13 0 15 9 14 10 19 3 11 10 1 5 51 1 10 1 40 -42 75 73 43 2 29) #279# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #280=#A(t (14) (c::declared-inline-p c::fname c::*cmp-env* c::env inline c::cmp-env-search-declaration c::x :test c::same-fname-p assoc c::flag si::get-sysprop #Y(c::declared-inline-p nil nil (24 45 1 25 40 3 14 2 46 3 26 15 4 13 0 19 2 5 45 6 13 2 13 0 14 7 33 8 12 19 4 9 45 10 10 0 39 7 10 0 5 73 38 7 13 3 1 4 17 11 43 2 29) #280# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #281=#A(t (15) (c::declared-notinline-p c::fname c::*cmp-env* c::env inline c::cmp-env-search-declaration c::x :test c::same-fname-p assoc c::flag notinline si::get-sysprop #Y(c::declared-notinline-p nil nil (24 45 1 25 40 3 14 2 46 3 26 15 4 13 0 19 2 5 45 6 13 2 13 0 14 7 33 8 12 19 4 9 45 10 10 0 39 8 10 0 5 76 73 38 7 13 3 1 11 17 12 43 2 29) #281# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #282=#A(t (7) (c::inline-possible c::fname c::*cmp-env* c::env c::declared-notinline-p #Y(c::inline-possible nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 13 0 19 2 4 76 73 29) #282# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 1 0 73 29) #283=#A(t (25) (c::maybe-install-inline-function c::fname c::form c::env inline c::cmp-env-search-declaration c::x :test c::same-fname-p assoc c::flag c::declared si::get-sysprop c::proclaimed progn eval-when (:compile-toplevel) c::declare-inline quote c::*cmp-env-root* (:compile-toplevel :load-toplevel :execute) si::put-sysprop 'inline #Y(c::maybe-install-inline-function nil nil (24 45 1 24 45 2 24 45 3 26 15 4 13 0 19 2 5 45 6 13 3 13 0 14 7 33 8 12 19 4 9 45 10 10 0 39 4 10 0 5 45 11 13 5 1 4 17 12 45 13 15 14 10 1 73 39 27 15 15 15 16 15 17 15 18 10 6 6 2 12 15 19 15 18 10 5 6 2 6 4 6 3 73 12 10 0 39 26 15 15 15 20 15 21 15 18 10 6 6 2 12 15 22 15 18 10 5 6 2 6 4 6 3 6 3 73 43 4 29) #283# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #284=#A(t (7) (c::valid-form-p c::x c::test si::proper-list-p every #Y(c::valid-form-p nil nil (24 45 1 25 40 2 77 46 2 26 10 1 16 3 73 39 14 10 0 76 73 40 8 13 0 13 1 19 2 4 29) #284# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #285=#A(t (8) (c::type-name-p c::name si::deftype-definition si::get-sysprop find-class si::structure-type #Y(c::type-name-p nil nil (24 45 1 26 13 0 1 2 17 3 73 40 16 13 0 77 19 2 4 73 40 7 13 0 1 5 17 3 29) #285# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #286=#A(t (12) (c::validate-alien-declaration c::names-list error si::%dolist-var c::new-declaration symbolp "The declaration ~s is not a symbol" c::cmperr c::type-name-p "Symbol name ~S cannot be both the name of a type and of a declaration" #Y(c::validate-alien-declaration nil nil (24 45 1 24 45 2 26 10 1 45 3 75 45 4 38 39 10 1 4 51 0 10 0 16 5 76 39 8 15 6 13 0 19 2 7 13 0 19 1 8 39 8 15 9 13 0 19 2 7 10 1 5 51 1 10 1 40 -41 75 73 43 2 29) #286# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #287=#A(t (10) (c::alien-declaration-p c::name c::*cmp-env* c::env si::*alien-declarations* member c::alien c::cmp-env-search-declaration #Y(c::alien-declaration-p nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 14 4 19 2 5 73 40 14 13 1 15 6 13 0 19 2 7 12 19 2 5 29) #287# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #288=#A(t (17) (c::parse-ignore-declaration c::decl-args c::expected-ref-number c::tail #:loop-list19691 c::name 0 symbolp consp length = function eq "Invalid argument to IGNORE/IGNORABLE declaration:~&~A" c::cmperr #Y(c::parse-ignore-declaration nil nil (24 45 1 24 45 2 24 45 3 26 77 13 2 46 4 46 5 57 6 61 2 2 77 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 10 1 16 7 39 14 13 1 10 4 3 12 10 3 3 51 3 38 37 10 1 16 8 39 21 10 1 16 9 12 9 2 19 2 10 39 9 10 1 4 12 1 11 17 12 76 39 8 15 13 13 1 19 2 14 35 0 0 62 43 2 10 0 73 29) #288# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #289=#A(t (13) (c::collect-declared type c::var-list c::tail symbolp c::valid-form-p "Syntax error in declaration ~s" c::cmperr #:loop-list19697 c::var-name 0 #Y(c::collect-declared nil nil (24 45 1 24 45 2 24 45 3 26 13 1 33 4 12 19 2 5 76 39 15 15 6 15 1 13 2 10 1 6 3 12 19 2 7 77 13 1 46 8 46 9 57 10 61 2 2 33 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 10 5 3 12 10 3 3 51 3 35 0 0 62 43 2 10 0 73 29) #289# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 49 12 19 2 50 1 0 73 29) #290=#A(t (51) (c::c1body c::body c::doc-p si::process-declarations c::specials c::doc c::all-declarations c::others c::types c::ignored #:loop-list19708 c::decl c::decl-name c::decl-args 0 c::valid-form-p symbolp "Syntax error in declaration ~s" c::cmperr special ignore "Syntax error in declaration ~s" c::parse-ignore-declaration ignorable "Syntax error in declaration ~s" type consp "Syntax error in declaration ~s" c::collect-declared ffi::object "Syntax error in declaration ~s" optimize ftype inline notinline declaration si::c-local si::c-global dynamic-extent values si::no-check-type c::policy-debug-ihs-frame :read-only c::alien-declaration-p c::policy-declaration-name-p c::valid-type-specifier c::ok "Unknown declaration specifier ~s" nreverse #Y(c::c1body nil nil (24 45 1 24 45 2 26 13 1 13 0 19 2 3 47 3 4 47 2 5 47 1 1 45 6 58 60 372 75 45 7 75 45 8 75 45 9 77 13 4 46 10 46 11 75 45 12 75 45 13 57 14 61 2 2 308 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 3 4 51 2 10 3 5 51 1 13 1 19 1 15 39 5 10 2 16 16 76 39 8 15 17 13 3 19 2 18 10 2 42 19 3 38 249 42 20 29 13 1 19 1 15 76 39 8 15 21 13 3 19 2 18 13 1 9 -1 13 5 19 3 22 51 5 38 218 42 23 29 13 1 19 1 15 76 39 8 15 24 13 3 19 2 18 13 1 9 0 13 5 19 3 22 51 5 38 187 42 25 44 10 1 16 26 39 11 10 1 5 12 33 16 12 19 2 15 76 39 8 15 27 13 3 19 2 18 10 1 4 12 10 1 5 12 13 6 19 3 28 51 6 38 141 42 29 32 13 1 33 16 12 19 2 15 76 39 8 15 30 13 3 19 2 18 15 29 13 1 13 6 19 3 28 51 6 38 107 41 31 37 41 32 34 41 33 31 41 34 28 41 35 25 41 36 22 41 37 19 41 38 16 41 23 13 41 39 10 41 40 7 41 41 4 42 42 10 13 3 10 7 3 51 7 38 59 13 2 19 1 43 40 6 13 2 19 1 44 39 10 13 3 10 7 3 51 7 38 36 13 2 19 1 45 47 1 25 45 46 10 0 76 39 8 15 47 13 4 19 2 18 13 1 13 3 13 8 19 3 28 51 8 43 2 35 0 0 13 10 13 12 13 6 13 5 10 7 16 48 12 13 11 13 9 72 7 36 8 62 73 43 1 43 1 43 2 43 1 43 1 43 1 63 43 4 29) #290# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 48 12 19 2 49 1 0 73 29) #291=#A(t (50) (c::add-one-declaration c::env c::decl optimize c::cmp-env-add-optimizations c::policy-debug-ihs-frame (t) c::flag c::*current-function* c::fun-cmp-env c::cmp-env-add-declaration ftype atom "Syntax error in declaration ~a" c::cmpwarn second si::normalize-type c::args c::type-name function eq cddr si::%dolist-var c::v c::add-function-declaration "In an FTYPE declaration, found ~A which is not a function type." inline #:loop-list19726 c::name 0 c::declare-inline notinline #:loop-list19729 c::declare-notinline declaration c::cmperr c::validate-alien-declaration c::alien c::cmp-env-extend-declaration si::c-local si::c-global si::no-check-type :read-only dynamic-extent ignorable c::alien-declaration-p c::maybe-add-policy "Unknown declaration specifier ~s" #Y(c::add-one-declaration nil nil (24 45 1 24 45 2 26 10 0 4 42 3 12 10 0 5 12 13 1 19 2 4 38 349 42 5 45 10 0 5 40 3 1 6 45 7 11 8 39 19 15 5 13 0 14 8 19 1 9 12 19 3 10 10 2 73 38 10 15 5 13 0 13 2 19 3 10 43 1 38 302 42 11 95 10 0 5 16 12 39 10 15 13 13 0 19 2 14 38 74 10 0 16 15 12 19 1 16 47 1 17 45 18 13 0 1 19 17 20 39 41 10 2 16 21 45 22 75 45 23 38 22 10 1 4 51 0 13 0 13 3 13 5 19 3 24 51 5 10 1 5 51 1 10 1 40 -24 43 2 38 11 15 25 10 2 16 15 12 19 2 14 43 2 10 1 73 38 205 42 26 54 77 10 0 5 12 46 27 46 28 57 29 61 2 2 31 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 4 19 2 30 51 4 35 0 0 62 43 2 10 1 73 38 149 42 31 54 77 10 0 5 12 46 32 46 28 57 29 61 2 2 31 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 4 19 2 33 51 4 35 0 0 62 43 2 10 1 73 38 93 42 34 24 10 0 5 12 33 35 12 19 2 36 15 37 10 0 5 12 13 1 19 3 38 38 67 41 39 10 41 40 7 41 41 4 42 42 6 10 1 73 38 50 41 43 4 42 44 6 10 1 73 38 39 10 0 4 12 13 1 19 2 45 39 6 10 1 73 38 23 13 0 13 1 19 2 46 73 40 13 15 47 10 0 4 12 19 2 14 10 1 73 29) #291# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #292=#A(t (12) (c::symbol-macro-declaration-p c::name type c::cmp-env-search-symbol-macro c::record functionp c::expression the c::cmp-env-register-symbol-macro t #Y(c::symbol-macro-declaration-p nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 10 0 39 5 10 0 16 5 73 39 30 13 0 13 2 77 20 2 23 45 6 13 3 15 7 13 2 10 0 6 3 12 19 2 8 43 1 11 9 73 43 1 29) #292# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 1 0 73 29) #293=#A(t (24) (c::check-vdecl c::vnames c::ts c::is #:loop-list19734 type c::name 0 #72# :test eq member c::symbol-macro-declaration-p "Declaration of type~&~4T~A~&was found for not bound variable ~s." c::cmpwarn #:loop-list19735 c::expected-uses c::cmp-env-search-symbol-macro c::cmp-env-search-macro minusp "IGNORE declaration was found for not bound variable ~s." "IGNORABLE declaration was found for not bound variable ~s." #Y(c::check-vdecl nil nil (24 45 1 24 45 2 24 45 3 26 77 77 13 1 46 4 46 5 46 6 57 7 61 2 2 71 10 3 2 39 4 35 0 1 10 3 4 45 8 10 0 4 51 2 10 0 5 51 0 10 0 51 3 43 1 10 3 5 51 3 13 1 13 6 14 9 33 10 12 19 4 11 40 8 13 1 13 2 19 2 12 76 39 10 15 13 13 2 13 1 19 3 14 35 0 0 62 43 3 77 77 13 0 46 15 46 16 46 6 57 7 61 2 2 87 10 3 2 39 4 35 0 1 10 3 4 45 8 10 0 4 51 2 10 0 5 51 0 10 0 51 3 43 1 10 3 5 51 3 13 1 13 6 14 9 33 10 12 19 4 11 40 13 13 1 19 1 17 40 6 13 1 19 1 18 76 39 21 10 2 16 19 39 6 1 20 73 38 4 1 21 73 12 13 1 19 2 14 35 0 0 62 73 43 3 29) #293# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 127 12 19 2 128 1 0 73 29) #294=#A(t (129) (proclaim c::decl c::decl-name listp "The proclamation specification ~s is not a list" error special si::%dolist-var c::var symbolp si::*make-special "Syntax error in proclamation ~s" optimize c::x consp second numberp <= "The OPTIMIZE proclamation ~s is illegal." warn debug c::*debug* safety c::*safety* space c::*space* speed c::*speed* compilation-speed - "The OPTIMIZE quality ~s is unknown." type cddr c::proclaim-var "Syntax error in proclamation ~s" ftype atom "Syntax error in proclamation ~a" si::normalize-type c::args c::type-name function eq c::v c::proclaim-function "In an FTYPE proclamation, found ~A which is not a function type." inline c::proclaim-inline notinline c::proclaim-notinline ffi::object ignore dynamic-extent ignorable si::valid-function-name-p "Not a valid function name ~s in ~s proclamation" declaration c::validate-alien-declaration si::*alien-declarations* append si::c-export-fname t si::mangle-name c::c-name c::found "The function ~s is already in the runtime.~%C-EXPORT-FNAME declaration ignored." c::lfun si::put-sysprop #:g19746 #:g19747 si::dm-too-few-arguments c::lisp-name si::dm-too-many-arguments "The funciton ~s is already in the runtime.~%C-EXPORT-FNAME declaration ignored." "Syntax error in proclamation ~s" array base-char bignum bit bit-vector character compiled-function complex cons double-float extended-char fixnum float hash-table integer keyword list long-float nil null number package pathname random-state ratio rational readtable sequence short-float simple-array simple-bit-vector simple-string simple-vector single-float standard-char stream string symbol vector signed-byte unsigned-byte member c::valid-type-specifier c::ok c::*cmp-env-root* c::maybe-add-policy :proclaim si::get-sysprop c::proclaimer functionp mapc "Unknown declaration specifier ~s" #Y(proclaim nil nil (24 45 1 26 75 45 2 10 1 16 3 76 39 8 15 4 13 1 19 2 5 10 1 4 51 0 42 6 50 10 1 5 45 7 75 45 8 38 30 10 1 4 51 0 10 0 16 9 39 7 10 0 16 10 38 8 15 11 13 3 19 2 5 10 1 5 51 1 10 1 40 -32 75 73 43 2 38 818 42 12 166 10 1 5 45 7 75 45 13 38 146 10 1 4 51 0 10 0 16 9 39 9 13 0 8 3 6 2 51 0 10 0 16 14 76 40 31 10 0 5 16 14 76 40 23 10 0 16 15 16 16 76 40 14 9 0 10 0 16 15 12 9 3 19 3 17 76 39 10 15 18 13 0 19 2 19 38 74 10 0 4 42 20 9 10 0 16 15 52 21 38 60 42 22 9 10 0 16 15 52 23 38 49 42 24 9 10 0 16 15 52 25 38 38 42 26 9 10 0 16 15 52 27 38 27 42 28 15 9 3 10 0 16 15 12 19 2 29 52 27 38 10 15 30 10 0 4 12 19 2 19 10 1 5 51 1 10 1 40 -148 75 73 43 2 38 650 42 31 32 10 1 5 16 14 39 16 10 1 16 15 12 10 1 16 32 12 19 2 33 38 8 15 34 13 1 19 2 5 38 616 42 35 90 10 1 5 16 36 39 10 15 37 13 1 19 2 5 38 72 10 1 16 15 12 19 1 38 47 1 39 45 40 13 0 1 41 17 42 39 39 10 3 16 32 45 7 75 45 43 38 18 10 1 4 51 0 13 0 13 3 19 2 44 10 1 5 51 1 10 1 40 -20 75 73 43 2 38 11 15 45 10 3 16 15 12 19 2 5 43 2 38 524 42 46 10 10 1 5 12 19 1 47 38 512 42 48 10 10 1 5 12 19 1 49 38 500 41 50 10 41 51 7 41 52 4 42 53 47 10 1 5 45 7 75 45 8 38 27 10 1 4 51 0 10 0 16 54 76 39 10 15 55 13 0 13 2 19 3 5 10 1 5 51 1 10 1 40 -29 75 73 43 2 38 442 42 56 25 10 1 5 12 33 5 12 19 2 57 10 1 5 12 14 58 19 2 59 52 58 73 38 415 42 60 178 10 1 5 45 7 75 45 13 38 158 10 1 4 51 0 10 0 16 9 39 39 13 0 14 61 19 2 62 47 1 63 45 64 10 0 39 10 15 65 13 2 19 2 19 38 10 13 2 15 66 13 1 19 3 67 43 2 38 104 10 0 16 14 39 91 10 0 45 68 10 0 45 69 10 0 76 39 6 13 1 19 1 70 10 0 4 12 10 0 5 51 0 22 45 63 10 1 76 39 6 13 2 19 1 70 10 1 4 12 10 1 5 51 1 22 45 71 10 2 39 6 13 3 19 1 72 13 0 19 1 62 39 10 15 73 13 0 19 2 19 38 10 13 0 15 66 13 1 19 3 67 43 4 38 8 15 74 13 3 19 2 5 10 1 5 51 1 10 1 40 -160 75 73 43 2 38 235 41 75 130 41 36 127 41 76 124 41 77 121 41 78 118 41 79 115 41 80 112 41 81 109 41 82 106 41 83 103 41 84 100 41 85 97 41 86 94 41 87 91 41 88 88 41 89 85 41 90 82 41 91 79 41 92 76 41 93 73 41 94 70 41 95 67 41 96 64 41 97 61 41 98 58 41 99 55 41 100 52 41 101 49 41 102 46 41 103 43 41 104 40 41 105 37 41 106 34 41 107 31 41 108 28 41 109 25 41 110 22 41 111 19 41 112 16 41 61 13 41 113 10 41 114 7 41 115 4 42 41 12 13 0 10 1 5 12 19 2 33 38 92 10 1 4 12 14 58 19 2 116 73 40 80 13 0 19 1 117 47 1 31 45 118 10 0 39 12 13 1 10 3 5 12 19 2 33 11 61 43 2 73 40 50 13 1 14 119 19 2 120 73 40 40 10 1 4 12 11 121 17 122 45 123 10 0 16 124 39 12 13 0 10 2 5 12 19 2 125 11 61 43 1 73 40 8 15 126 13 0 19 2 19 29) #294# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #295=#A(t (17) (c::proclaim-var type c::vl si::%dolist-var c::var symbolp c::cmp-type si::get-sysprop c::type1 c::type-and "Inconsistent type declaration was found for the variable ~s." warn t si::put-sysprop "The variable name ~s is not a symbol." #Y(c::proclaim-var nil nil (24 45 1 24 45 2 26 10 0 45 3 75 45 4 38 78 10 1 4 51 0 10 0 16 5 39 55 13 0 1 6 17 7 45 8 10 0 39 10 13 0 13 4 19 2 9 38 3 10 4 51 0 10 0 76 39 12 15 10 13 1 19 2 11 11 12 51 0 13 1 15 6 13 0 19 3 13 43 1 38 8 15 14 13 0 19 2 11 10 1 5 51 1 10 1 40 -80 75 73 43 2 29) #295# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 38 12 19 2 39 1 0 73 29) #296=#A(t (40) (c::process-declaim-args c::args c::env c::types c::specials #:loop-list19766 c::name 0 assoc :kind special c::c1make-global-variable c::v c::cmp-env-register-var #:loop-list19769 type c::specialp c::kind #72# si::specialp member c::global :type #Y(c::add-variables nil nil (24 45 2 24 45 3 24 45 4 26 77 13 0 46 5 46 6 57 7 61 2 2 55 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 4 19 2 8 76 39 24 13 1 14 9 15 10 19 3 11 45 12 13 0 13 6 77 19 3 13 51 6 43 1 35 0 0 62 43 2 77 77 13 1 46 14 46 15 46 6 75 45 16 75 45 17 75 45 12 57 7 61 2 2 90 10 6 2 39 4 35 0 1 10 6 4 45 18 10 0 4 51 5 10 0 5 51 0 10 0 51 6 43 1 10 6 5 51 6 10 4 16 19 40 8 13 4 13 7 19 2 20 51 3 10 3 39 5 1 10 38 3 1 21 51 2 13 4 14 22 13 5 14 9 13 2 19 5 11 51 1 13 1 13 9 77 19 3 13 51 9 35 0 0 62 43 1 43 1 43 1 43 3 10 2 73 29) #296# #1# 0) declare c::c1body c::all c::doc c::others c::ignored c::body "IGNORE/IGNORABLE declarations in DECLAIM are ignored" c::cmpwarn-style c::add-one-declaration :initial-value c::*cmp-env* reduce c::*cmp-env-root* #Y(c::process-declaim-args nil nil (24 45 1 26 30 1 23 15 24 10 1 7 2 6 1 12 77 19 2 25 47 6 26 47 5 27 47 4 28 47 3 29 47 2 3 47 1 4 45 30 10 3 39 6 15 31 19 1 32 33 33 12 13 4 14 34 14 35 13 2 13 1 32 7 18 3 12 19 4 36 33 33 12 13 4 14 34 14 37 13 2 13 1 32 7 18 3 12 19 4 36 43 7 43 1 29) #296# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 14 20 9 1 19 4 21 1 0 73 29) #297=#A(t (22) (declaim #:g19773 #:g19772 #:g19774 c::declarations locally (declare (notinline mapc)) ext::with-backend :c/c++ eval-when (:compile-toplevel) c::process-declaim-args quote :bytecodes (:compile-toplevel) mapc 'proclaim (:load-toplevel :execute) 'proclaim #Y(declaim nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 45 4 15 5 15 6 15 7 14 8 15 9 15 10 15 11 15 12 10 0 6 2 6 2 6 3 12 14 13 15 9 15 14 15 15 15 16 15 12 10 0 6 2 6 3 6 3 6 5 12 15 9 15 17 15 15 15 18 15 12 10 0 6 2 6 3 6 3 6 4 73 29) #297# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 14 12 9 1 19 4 13 1 0 73 29) #298=#A(t (14) (ext::c-declaim #:g19776 #:g19775 #:g19777 c::declarations ext::with-backend :c/c++ eval-when (:compile-toplevel) c::process-declaim-args quote #Y(ext::c-declaim nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 45 4 15 5 14 6 15 7 15 8 15 9 15 10 10 0 6 2 6 2 6 3 6 3 73 29) #298# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (75 73 29) #A(t (0) ()) #1# 0) #Y(si::bytecodes nil nil (75 73 29) #A(t (0) ()) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 15 10 1 11 12 19 2 9 15 12 1 13 12 19 2 9 15 14 1 15 12 19 2 9 1 14 73 29) #299=#A(t (16) (c::policy-to-debug-level c::policy c::level 0 + logbitp 1+ > #Y(c::policy-to-debug-level nil nil (24 45 1 26 58 60 56 8 0 45 2 57 3 61 2 2 41 13 1 9 0 19 2 4 12 10 3 17 5 39 6 10 1 73 36 2 10 1 16 6 51 1 13 1 9 3 19 2 7 39 4 35 0 1 35 0 0 62 73 43 1 63 29) #299# #1# 0) si::fset c::policy-to-safety-level #Y(c::policy-to-safety-level nil nil (24 45 1 26 58 60 56 8 0 45 2 57 3 61 2 2 41 13 1 9 4 19 2 4 12 10 3 17 5 39 6 10 1 73 36 2 10 1 16 6 51 1 13 1 9 3 19 2 7 39 4 35 0 1 35 0 0 62 73 43 1 63 29) #299# #1# 0) c::policy-to-speed-level #Y(c::policy-to-speed-level nil nil (24 45 1 26 58 60 56 8 0 45 2 57 3 61 2 2 41 13 1 9 8 19 2 4 12 10 3 17 5 39 6 10 1 73 36 2 10 1 16 6 51 1 13 1 9 3 19 2 7 39 4 35 0 1 35 0 0 62 73 43 1 63 29) #299# #1# 0) c::policy-to-space-level #Y(c::policy-to-space-level nil nil (24 45 1 26 58 60 56 8 0 45 2 57 3 61 2 2 41 13 1 9 12 19 2 4 12 10 3 17 5 39 6 10 1 73 36 2 10 1 16 6 51 1 13 1 9 3 19 2 7 39 4 35 0 1 35 0 0 62 73 43 1 63 29) #299# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #300=#A(t (8) (c::optimization-quality-switches type c::index c::*optimization-quality-switches* gethash nth #Y(c::optimization-quality-switches nil nil (24 45 1 24 45 2 26 13 0 13 1 14 3 19 2 4 17 5 29) #300# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #301=#A(t (23) (c::compute-policy c::arguments c::old-bits c::bits c::on c::off si::%dolist-var c::x c::value c::name c::flags symbolp c::optimization-quality-switches consp second numberp <= "Illegal or unknown OPTIMIZE proclamation ~s" c::cmpwarn logior logandc2 #Y(c::compute-policy nil nil (24 45 1 24 45 2 26 10 0 45 3 8 0 45 4 8 0 45 5 10 4 45 6 75 45 7 38 145 10 1 4 51 0 77 77 77 46 8 46 9 46 10 10 3 16 11 39 20 13 3 9 3 19 2 12 51 0 8 3 51 2 10 3 51 1 38 63 10 3 16 13 76 40 31 10 3 5 16 13 76 40 23 10 3 16 14 16 15 76 40 14 9 0 10 3 16 14 12 9 3 19 3 16 76 40 24 10 3 4 51 1 10 3 16 14 51 2 13 1 10 3 16 14 12 19 2 12 51 0 10 0 76 39 10 15 17 13 3 19 2 18 38 23 13 6 10 0 4 12 19 2 19 51 6 13 5 10 0 5 12 19 2 19 51 5 43 3 10 1 5 51 1 10 1 40 -147 43 2 13 2 13 1 19 2 19 12 10 0 17 20 43 3 29) #301# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #302=#A(t (12) (c::default-policy space c::*space* safety c::*safety* debug c::*debug* speed c::*speed* c::compute-policy #Y(c::default-policy nil nil (26 15 1 11 2 6 2 12 15 3 11 4 6 2 12 15 5 11 6 6 2 12 15 7 11 8 6 2 6 4 12 9 0 19 2 9 29) #302# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #303=#A(t (7) (c::cmp-env-policy c::env c::optimization c::cmp-env-search-declaration c::default-policy #Y(c::cmp-env-policy nil nil (24 45 1 26 15 2 13 0 19 2 3 4 73 40 4 19 0 4 29) #303# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #304=#A(t (12) (c::cmp-env-add-optimizations c::decl c::*cmp-env* c::env c::cmp-env-policy c::old c::compute-policy c::new c::optimization c::cmp-env-add-declaration #Y(c::cmp-env-add-optimizations nil nil (24 45 1 25 40 3 14 2 46 3 26 13 0 19 1 4 45 5 13 2 13 0 19 2 6 45 7 15 8 10 0 6 1 12 13 2 19 3 9 43 2 29) #304# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #305=#A(t (7) (c::policy-declaration-name-p c::name c::*optimization-quality-switches* gethash t #Y(c::policy-declaration-name-p nil nil (24 45 1 26 13 0 14 2 19 2 3 73 39 4 11 4 73 29) #305# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #306=#A(t (19) (c::maybe-add-policy c::decl c::*cmp-env* c::env consp list-length <= c::*optimization-quality-switches* gethash c::cmp-env-policy c::old second c::flag c::compute-policy c::new c::optimization c::cmp-env-add-declaration #Y(c::maybe-add-policy nil nil (24 45 1 25 40 3 14 2 46 3 26 10 1 16 4 39 22 10 1 16 5 12 9 2 19 2 6 39 10 10 1 4 12 14 7 19 2 8 73 39 60 13 0 19 1 9 45 10 10 2 5 2 40 5 10 2 16 11 39 5 8 3 38 3 8 0 45 12 10 3 4 12 10 0 6 2 6 1 12 13 1 19 2 13 45 14 15 15 10 0 6 1 12 13 3 19 3 16 43 3 29) #306# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #307=#A(t (8) (c::add-default-optimizations c::env c::optimization c::cmp-env-search-declaration c::default-policy c::cmp-env-add-declaration #Y(c::add-default-optimizations nil nil (24 45 1 26 15 2 13 0 19 2 3 39 6 10 0 73 38 14 15 2 19 0 4 6 1 12 13 0 19 3 5 29) #307# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #308=#A(t (11) (c::cmp-env-all-optimizations c::*cmp-env* c::env c::cmp-env-policy c::o c::policy-to-debug-level c::policy-to-safety-level c::policy-to-space-level c::policy-to-speed-level #Y(c::cmp-env-all-optimizations nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 19 1 5 12 13 0 19 1 6 12 13 0 19 1 7 12 13 0 19 1 8 6 4 73 43 1 29) #308# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #309=#A(t (16) (c::cmp-env-optimization c::property c::*cmp-env* c::env c::cmp-env-policy c::o debug c::policy-to-debug-level safety c::policy-to-safety-level space c::policy-to-space-level speed c::policy-to-speed-level #Y(c::cmp-env-optimization nil nil (24 45 1 25 40 3 14 2 46 3 26 13 0 19 1 4 45 5 10 2 42 6 8 13 0 19 1 7 38 33 42 8 8 13 0 19 1 9 38 23 42 10 8 13 0 19 1 11 38 13 42 12 8 13 0 19 1 13 38 3 75 73 43 1 29) #309# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (75 73 29) #A(t (0) ()) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 15 9 1 10 12 19 2 8 15 11 1 12 12 19 2 8 15 13 1 15 12 19 2 8 15 16 1 18 12 19 2 8 15 19 1 21 12 19 2 8 15 22 1 24 12 19 2 8 15 25 1 27 12 19 2 8 15 28 1 30 12 19 2 8 15 31 1 33 12 19 2 8 15 34 1 36 12 19 2 8 15 37 1 39 12 19 2 8 15 40 1 42 12 19 2 8 15 43 1 44 12 19 2 8 15 45 1 47 12 19 2 8 15 48 1 50 12 19 2 8 15 51 1 53 12 19 2 8 15 54 1 56 12 19 2 8 15 57 1 60 12 19 2 8 15 59 1 62 12 19 2 8 1 59 73 29) #310=#A(t (63) (c::policy-assume-no-errors c::*cmp-env* c::env c::cmp-env-policy c::bits 17179869184 logtest #Y(c::policy-assume-no-errors nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 5 19 2 6 43 1 29) #310# #1# 0) si::fset c::policy-assume-right-type #Y(c::policy-assume-right-type nil nil (25 40 3 14 1 46 2 26 13 0 19 1 0 29) #310# #1# 0) c::policy-type-assertions #Y(c::policy-type-assertions nil nil (25 40 3 14 1 46 2 26 13 0 19 1 0 76 73 29) #310# #1# 0) c::policy-check-stack-overflow 34359738368 #Y(c::policy-check-stack-overflow nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 14 19 2 6 43 1 29) #310# #1# 0) c::policy-check-arguments-type 68719476736 #Y(c::policy-check-arguments-type nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 17 19 2 6 43 1 29) #310# #1# 0) c::policy-array-bounds-check 137438953472 #Y(c::policy-array-bounds-check nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 20 19 2 6 43 1 29) #310# #1# 0) c::policy-global-var-checking 274877906944 #Y(c::policy-global-var-checking nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 23 19 2 6 43 1 29) #310# #1# 0) c::policy-global-function-checking 549755813888 #Y(c::policy-global-function-checking nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 26 19 2 6 43 1 29) #310# #1# 0) c::policy-check-nargs 1099511627776 #Y(c::policy-check-nargs nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 29 19 2 6 43 1 29) #310# #1# 0) c::policy-the-is-checked 2199023255552 #Y(c::policy-the-is-checked nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 32 19 2 6 43 1 29) #310# #1# 0) c::policy-assume-types-dont-change 4398046511104 #Y(c::policy-assume-types-dont-change nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 35 19 2 6 43 1 29) #310# #1# 0) c::policy-inline-slot-access 8796093022208 #Y(c::policy-inline-slot-access nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 38 19 2 6 43 1 29) #310# #1# 0) c::policy-inline-accessors 17592186044416 #Y(c::policy-inline-accessors nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 41 19 2 6 43 1 29) #310# #1# 0) c::policy-open-code-aref/aset #Y(c::policy-open-code-aref/aset nil nil (25 40 3 14 1 46 2 26 13 0 19 1 40 29) #310# #1# 0) c::policy-evaluate-forms 35184372088832 #Y(c::policy-evaluate-forms nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 46 19 2 6 43 1 29) #310# #1# 0) c::policy-use-direct-c-call 70368744177664 #Y(c::policy-use-direct-c-call nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 49 19 2 6 43 1 29) #310# #1# 0) c::policy-inline-type-checks 140737488355328 #Y(c::policy-inline-type-checks nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 52 19 2 6 43 1 29) #310# #1# 0) c::policy-inline-sequence-functions 281474976710656 #Y(c::policy-inline-sequence-functions nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 55 19 2 6 43 1 29) #310# #1# 0) c::policy-debug-variable-bindings 562949953421312 c::policy-debug-ihs-frame #Y(c::policy-debug-variable-bindings nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 58 19 2 6 73 39 6 13 1 19 1 59 43 1 29) #310# #1# 0) 1125899906842624 #Y(c::policy-debug-ihs-frame nil nil (25 40 3 14 1 46 2 26 13 0 19 1 3 45 4 13 0 15 61 19 2 6 43 1 29) #310# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #311=#A(t (6) (c::safe-compile safety c::cmp-env-optimization >= #Y(c::safe-compile nil nil (26 15 1 19 1 2 12 9 2 19 2 3 29) #311# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #312=#A(t (6) (c::compiler-push-events safety c::cmp-env-optimization >= #Y(c::compiler-push-events nil nil (26 15 1 19 1 2 12 9 3 19 2 3 29) #312# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 14 3 9 64 14 4 15 5 14 6 15 7 14 8 15 9 19 8 10 12 1 11 17 12 78 2 1 2 52 0 1 0 73 29) #A(t (13) (c::*optimization-quality-switches* si::*make-special 0 :size :rehash-size 1.5d0 :rehash-threshold #70# :test eq make-hash-table ((ext::check-stack-overflow (0 . 34359738368) . #313=((34359738368 . 0) . #313#)) (speed (256 . 8796160134656) (8796160131584 . 3328) (8796160132096 . 2816) (8796160133120 . 1792)) (ext::check-arguments-type (0 . 68719476736) . #314=((1168231104512 . 0) . #314#)) (ext::debug-variable-bindings (0 . 562949953421312) . #315=((562949953421312 . 0) . #315#)) (ext::inline-slot-access (0 . 8796093022208) . #316=((8796093022208 . 0) . #316#)) (ext::global-var-checking (0 . 274877906944) . #317=((274877906944 . 0) . #317#)) (ext::type-assertions #318=(17179869184 . 0) . #319=(#320=(0 . 17179869184) . #319#)) (compilation-speed . #321=((0 . 0) . #321#)) (ext::assume-types-dont-change (0 . 4398046511104) . #322=((4398046511104 . 0) . #322#)) (ext::debug-ihs-frame (0 . 1125899906842624) . #323=((1125899906842624 . 0) . #323#)) (ext::evaluate-forms (0 . 35184372088832) . #324=((35184372088832 . 0) . #324#)) (ext::open-code-aref/aset . #325=((0 . 17592186044416) . #326=((17592186044416 . 0) . #326#))) (ext::global-function-checking (0 . 549755813888) . #327=((549755813888 . 0) . #327#)) (safety (13211420196880 . 4363720065248) (12300880183328 . 5274260078800) (3539080052800 . 14036060209328) (4363720065152 . 13211420196976)) (ext::assume-no-errors . #328=(#320# . #329=(#318# . #329#))) (ext::assume-right-type . #328#) (ext::inline-type-checks (0 . 140737488355328) . #330=((140737488355328 . 0) . #330#)) (space (439808006557696 . 57344) (439808006561792 . 53248) (16384 . 439808006598656) (32768 . 439808006582272)) (ext::use-direct-c-call (0 . 70368744177664) . #331=((70368744177664 . 0) . #331#)) (ext::check-nargs (0 . 1099511627776) . #332=((1099511627776 . 0) . #332#)) (ext::array-bounds-check (0 . 137438953472) . #333=((137438953472 . 0) . #333#)) (ext::inline-accessors . #325#) (ext::inline-sequence-functions (0 . 281474976710656) . #334=((281474976710656 . 0) . #334#)) (ext::the-is-checked (0 . 2199023255552) . #335=((2199023255552 . 0) . #335#)) (debug (131942401966081 . 1688862745165838) (96757761441794 . 1724047385690125) (4 . 1820805147131915) (1688862745165832 . 131942401966087))) ext::hash-table-fill)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 33 12 19 2 34 1 0 73 29) #336=#A(t (35) (c::c1expr-inner c::form symbolp c::chk-symbol-macrolet eq c::c1nil t c::c1t keywordp ext::location :type c::object-type :args c::add-symbol c::make-c1form* constantp symbol-value :only-small-values c::c1constant-value c::c1var consp si::proper-list-p "Improper list found in lisp form~%~A" c::cmperr c::fun c::*c1-dispatch-table* gethash c::fd c::c1call lambda c::c1funcall "~s is not a legal function name." :always #Y(c::c1expr-inner nil nil (24 45 1 26 10 0 16 2 39 110 13 0 19 1 3 51 0 10 0 16 2 76 39 6 10 0 73 38 89 13 0 75 17 4 39 6 19 0 5 38 77 13 0 11 6 17 4 39 6 19 0 7 38 64 10 0 16 8 39 24 15 9 14 10 13 0 19 1 11 12 14 12 13 0 19 1 13 12 19 5 14 38 35 13 0 19 1 15 39 23 10 0 16 16 12 14 17 14 6 19 3 18 73 40 6 13 0 19 1 19 38 6 13 0 19 1 19 38 120 10 0 16 20 39 105 10 0 16 21 76 39 8 15 22 13 0 19 2 23 10 0 4 45 24 13 0 14 25 19 2 26 45 27 10 0 39 5 10 0 51 1 43 1 39 12 13 0 10 1 5 12 20 1 23 38 50 10 0 16 2 39 14 13 0 10 1 5 12 14 6 19 3 28 38 31 10 0 16 20 39 9 10 0 4 12 1 29 17 4 39 8 13 1 19 1 30 38 8 15 31 13 0 19 2 23 43 1 38 10 13 0 14 32 14 6 19 3 18 29) #336# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #337=#A(t (8) (c::c1expr c::form c::*current-form* 0 c::c1expr-inner c::c1form-p #Y(c::c1expr nil nil (24 45 1 26 10 0 48 2 58 60 31 57 3 61 1 1 13 2 19 1 4 51 2 13 2 19 1 5 39 6 10 2 73 36 1 35 0 0 62 73 63 44 1 29) #337# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 18 15 3 14 4 77 19 1 5 12 14 6 77 19 5 7 52 0 1 0 73 29) #A(t (8) (c::*c1nil* si::*make-special boundp ext::location :type c::object-type :args c::make-c1form*)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 1 0 73 29) #338=#A(t (4) (c::c1nil c::*c1nil* #Y(c::c1nil nil nil (26 11 1 73 29) #338# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 20 15 3 14 4 14 5 19 1 6 12 14 7 14 5 19 5 8 52 0 1 0 73 29) #A(t (9) (c::*c1t* si::*make-special boundp ext::location :type t c::object-type :args c::make-c1form*)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 1 0 73 29) #339=#A(t (4) (c::c1t c::*c1t* #Y(c::c1t nil nil (26 11 1 73 29) #339# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 33 12 19 2 34 1 0 73 29) #340=#A(t (35) (c::c1call c::fname c::args c::macros-allowed c::fd c::success c::can-inline length si::c-arguments-limit > c::cmp-macro-function c::cmp-expand-macro function c::unoptimized-long-call c::local-function-ref c::c1call-local c::inline-possible compiler-macro-function c::cmp-expand-compiler-macro c::clos-compiler-macro-expand c::declared-inline-p consp eq c::*inline-max-depth* plusp space c::cmp-env-optimization <= 1- "Inlining ~a" c::cmpnote funcall c::c1call-global #Y(c::c1call nil nil (24 45 1 24 45 2 24 45 3 26 75 45 4 75 45 5 75 45 6 10 4 16 7 12 14 8 19 2 9 39 42 10 3 39 8 13 5 19 1 10 51 2 39 15 13 2 13 5 10 4 7 2 12 19 2 11 38 13 15 12 10 5 6 2 12 13 4 19 2 13 38 191 13 5 19 1 14 51 2 39 12 13 5 13 2 13 4 19 3 15 38 171 13 5 19 1 16 51 0 39 26 13 5 19 1 17 51 2 39 17 13 2 13 5 13 4 19 3 18 51 2 55 1 1 10 1 39 6 10 2 73 38 130 10 0 39 15 13 5 13 4 19 2 19 51 2 55 1 1 10 1 39 6 10 2 73 38 105 10 3 39 8 13 5 19 1 10 51 2 39 15 13 2 13 5 10 4 7 2 12 19 2 11 38 78 13 5 19 1 20 51 0 39 34 10 0 16 21 39 28 10 0 4 12 1 12 17 22 39 18 11 23 16 24 39 12 15 25 19 1 26 12 9 1 19 2 27 39 27 11 23 16 28 48 23 15 29 13 5 19 2 30 15 31 13 0 10 4 7 3 73 44 1 38 8 13 5 13 4 19 2 32 29) #340# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 34 12 19 2 35 1 0 73 29) #341=#A(t (36) (c::c1call-local c::fname c::fun c::args c::fun-lambda-expression lambda c::declared-inline-p c::*inline-max-depth* plusp 1- funcall function c::c1args* c::forms c::get-local-return-type t c::return-type c::get-local-arg-types c::arg-types c::fl si::%dolist-var c::form :safe "In a call to ~a" c::and-form-type #:g19871 #:g19872 nreverse c::call-local :sp-change :side-effects :type :args c::make-c1form* #Y(c::c1call-local nil nil (24 45 1 24 45 2 24 45 3 26 57 0 60 217 13 2 19 1 4 45 5 10 0 39 12 13 4 19 1 6 39 5 11 7 16 8 39 25 11 7 16 9 48 7 15 10 15 11 10 0 6 2 12 10 2 7 3 73 44 1 36 1 43 1 13 1 19 1 12 45 13 13 3 19 1 14 40 3 1 15 45 16 13 4 19 1 17 45 18 10 0 39 112 75 45 19 10 3 45 20 75 45 21 38 86 10 1 4 51 0 10 3 2 39 10 13 0 10 2 3 51 2 38 62 10 3 4 12 13 0 10 7 4 12 14 22 15 23 13 9 19 6 24 12 10 2 3 51 2 10 3 45 25 10 0 4 10 0 5 51 0 10 0 51 4 43 1 10 7 45 26 10 0 4 10 0 5 51 0 10 0 51 8 43 1 10 1 5 51 1 10 1 40 -88 43 2 10 0 16 27 51 3 43 1 15 28 14 29 14 15 14 30 14 15 14 31 13 1 14 32 13 5 13 2 19 10 33 43 3 63 29) #341# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #342=#A(t (18) (c::c1call-global c::fname c::args c::c1args* c::forms c::c1call-constant-fold c::value c::call-global :sp-change c::function-may-change-sp :side-effects c::function-may-have-side-effects :type c::propagate-types :args c::make-c1form* #Y(c::c1call-global nil nil (24 45 1 24 45 2 26 57 0 60 68 13 1 19 1 3 45 4 13 3 13 0 19 2 5 45 6 10 0 39 6 10 0 73 36 2 43 1 15 7 14 8 13 3 19 1 9 12 14 10 13 3 19 1 11 12 14 12 13 3 13 0 19 2 13 12 14 14 13 3 13 0 19 10 15 43 1 63 29) #342# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #343=#A(t (27) (c::c1call-constant-fold c::fname c::forms c::pure si::get-sysprop c::policy-evaluate-forms c::inline-possible #:g19878 #:g19879 0 error si::temp #Y(nil nil nil (24 45 11 26 10 0 51 2 35 1 0 29) #343# #1# 0) si::*handler-clusters* c::all-values c::constant-p c::v #:loop-list19881 c::form c::c1form-constant-p nreverse apply :only-small-values c::c1constant-value c::c #Y(c::c1call-constant-fold nil nil (24 45 1 24 45 2 26 13 1 1 3 17 4 39 11 19 0 5 39 6 13 1 19 1 6 73 39 146 57 7 60 142 75 45 8 57 9 61 1 119 15 10 34 12 3 6 1 12 11 13 3 48 13 58 60 99 75 45 14 75 45 15 75 45 16 77 13 7 46 17 46 18 57 9 61 2 2 47 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 19 1 19 51 4 55 3 1 39 10 13 3 10 5 3 51 5 38 5 75 73 36 6 35 0 0 13 11 10 5 16 20 12 19 2 21 12 14 22 77 19 3 23 36 6 62 73 43 2 43 1 43 1 43 1 63 36 2 44 1 10 1 45 24 75 73 43 1 36 2 62 73 43 1 63 29) #343# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #344=#A(t (22) (c::c2expr c::form c::c1form-file *compile-file-truename* c::c1form-file-position c::*compile-file-position* c::c1form-toplevel-form c::*current-toplevel-form* c::c1form-form c::*current-form* c::c1form-env c::*cmp-env* c::c1form-name c::name c::c1form-args c::args c::*c2-dispatch-table* gethash c::dispatch apply #Y(c::c2expr nil nil (24 45 1 26 10 0 45 1 13 0 19 1 2 48 3 13 0 19 1 4 48 5 13 0 19 1 6 48 7 13 0 19 1 8 48 9 13 0 19 1 10 48 11 13 0 19 1 12 45 13 13 1 19 1 14 45 15 13 1 14 16 19 2 17 45 18 13 0 13 3 13 1 19 3 19 43 3 43 1 44 5 29) #344# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #345=#A(t (12) (c::c2expr* c::form c::next-label c::label c::*unwind-exit* c::*exit* c::*lcl* c::*temp* c::c2expr c::wt-label #Y(c::c2expr* nil nil (24 45 1 26 19 0 2 45 3 13 0 11 4 3 48 4 10 0 48 5 14 5 11 4 3 48 4 11 6 48 6 11 7 48 7 13 1 19 1 8 44 4 13 0 19 1 9 43 1 44 1 29) #345# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #346=#A(t (15) (c::c1with-backend c::forms c::tag c::form #:loop-list-head19887 #:loop-list-tail19888 0 #:g19889 #:g19890 :c/c++ eq rplacd c::c1progn #Y(c::c1with-backend nil nil (24 45 1 26 58 60 110 75 45 2 75 45 3 75 6 1 45 4 10 0 45 5 57 6 61 2 2 74 10 6 45 7 10 0 4 12 10 0 5 51 0 10 0 51 7 22 43 1 51 4 10 6 45 8 10 0 4 12 10 0 5 51 0 10 0 51 7 22 43 1 51 3 10 4 76 39 4 35 0 1 13 4 11 9 17 10 39 11 13 1 10 3 6 1 51 1 17 11 35 0 0 10 2 5 73 36 5 62 73 43 2 43 1 43 1 63 12 19 1 12 29) #346# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #347=#A(t (15) (c::c1progn c::forms c::t1/c1expr mapcar c::fl last c::output-form c::c1form-type c::output-type progn :type :args c::make-c1form* #Y(c::c1progn nil nil (24 45 1 26 10 0 2 39 7 77 19 1 2 38 60 10 0 5 2 39 10 10 0 4 12 19 1 2 38 45 33 2 12 13 0 19 2 3 45 4 13 0 19 1 5 4 45 6 10 0 39 6 13 0 19 1 7 45 8 15 9 14 10 13 0 14 11 13 2 19 5 12 43 3 29) #347# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #348=#A(t (18) (c::c2progn c::c1form c::forms c::*lex* c::lex c::l c::this-form c::c1form-name c::name c::trash c::*destination* c::c2expr* go eq return-from c::c2expr #Y(c::c2progn nil nil (24 45 1 24 45 2 26 58 60 84 13 1 14 3 46 4 46 5 38 58 10 0 4 45 6 13 0 19 1 7 45 8 1 9 48 10 10 2 4 12 19 1 11 44 1 10 3 52 3 13 0 1 12 17 13 40 7 13 0 1 14 17 13 39 5 75 73 36 4 43 2 10 0 5 12 53 0 10 0 5 2 39 -62 10 0 4 12 19 1 15 43 2 63 29) #348# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #349=#A(t (6) (c::c1args* c::forms c::c1expr mapcar #Y(c::c1args* nil nil (24 45 1 26 33 2 12 13 0 19 2 3 29) #349# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*compiler-temps* si::*make-special boundp (c::tmp0 c::tmp1 c::tmp2 c::tmp3 c::tmp4 c::tmp5 c::tmp6 c::tmp7 c::tmp8 c::tmp9))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 35 12 14 36 9 3 19 4 37 1 0 73 29) #350=#A(t (38) (si::define-inline-function #:g19892 #:g19891 #:g19893 si::dm-too-few-arguments c::name c::vars c::body c::*compiler-temps* c::temps si::%dolist-var c::var symbolp (&optional &rest &key &aux) :test eq member #:g19909 "TMP" c::compiler find-package gentemp "The parameter ~s for the inline function ~s is illegal." error list c::temp quote #Y(nil nil nil (24 45 11 24 45 25 26 15 24 15 26 10 1 6 2 12 10 0 6 3 73 29) #350# #1# 0) mapcar c::binding progn defun define-compiler-macro list* 'let #Y(si::define-inline-function nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 45 7 77 14 8 49 8 46 9 10 2 45 10 75 45 11 38 82 10 1 4 51 0 10 0 16 12 39 14 13 0 15 13 14 14 33 15 12 19 4 16 76 39 42 11 8 45 17 10 0 4 12 10 0 5 51 0 10 0 52 8 22 43 1 73 40 11 15 18 1 19 16 20 12 19 2 21 12 10 2 3 51 2 38 10 15 22 13 0 13 5 19 3 23 10 1 5 51 1 10 1 40 -84 43 2 15 24 34 27 12 13 2 13 0 19 3 28 3 45 29 15 30 15 31 13 4 13 3 10 2 7 4 12 15 32 13 4 13 1 15 33 15 34 13 0 15 26 10 2 6 2 6 4 6 4 6 3 73 43 1 43 1 44 1 29) #350# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 1 0 73 29) #351=#A(t (28) (c::unwind-bds c::bds-lcl c::bds-bind c::stack-frame c::ihs-p some t stringp "ecl_stack_frame_close(" ");" c::wt-nl "ECL_STACK_SET_INDEX(cl_env_copy," ");" "ecl_bds_unwind(cl_env_copy," ");" < si::%dotimes-var c::n "ecl_bds_unwind1(cl_env_copy);" 1+ "ecl_bds_unwind_n(cl_env_copy," ");" c::ihs "ecl_ihs_pop(cl_env_copy);" c::ihs-env "ihs.lex_env = _ecl_debug_env;" #Y(c::unwind-bds nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 75 45 5 10 2 39 31 11 6 51 0 10 2 16 7 39 12 15 8 13 2 15 9 19 3 10 38 10 15 11 13 2 15 12 19 3 10 10 4 39 14 11 6 51 0 15 13 13 4 15 14 19 3 10 13 3 9 4 19 2 15 39 39 10 3 45 16 8 0 45 17 38 16 11 6 51 2 15 18 19 1 10 10 0 16 19 51 0 13 0 13 1 19 2 15 40 -23 43 2 38 14 11 6 51 0 15 20 13 3 15 21 19 3 10 10 1 42 22 12 11 6 51 0 15 23 19 1 10 38 13 42 24 10 11 6 51 0 15 25 19 1 10 10 0 73 43 1 29) #351# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 67 12 19 2 68 1 0 73 29) #352=#A(t (69) (c::unwind-exit c::loc c::jump-p c::bds-lcl c::bds-bind c::stack-frame c::ihs-p c::*destination* consp c::jump-true second c::set-jump-true t eq c::jump-false c::set-jump-false c::*unwind-exit* si::%dolist-var c::ue c::stack c::lcl c::*exit* c::unwind-bds plusp c::set-loc c::loc-refers-to-special c::*temp* c::make-temp-var c::temp c::wt-nl c::wt-go numberp c::baboon-unwind-exit c::ihs c::ihs-env #:g19928 + return values "return cl_env_copy->values[0];" "return value0;" "return value0;" c::return-fixnum c::return-character c::return-double-float c::return-single-float c::return-object c::coerce-loc (c::return-fixnum :fixnum c::return-character :char c::return-single-float :float c::return-double-float :double c::return-object :object) getf :type c::make-lcl-var c::wt-nl-open-brace "cl_fixnum " "= " ";" "return(" ");" c::wt-nl-close-brace "return(" ");" c::frame c::tmp-destination "ecl_frs_pop(cl_env_copy);" c::tail-recursion-mark c::jump c::baboon-improper-*exit* #Y(c::unwind-exit nil nil (24 45 1 25 40 2 77 46 2 26 75 45 3 8 0 45 4 75 45 5 75 45 6 57 0 60 639 11 7 16 8 39 55 11 7 4 42 9 25 13 6 11 7 16 10 12 19 2 11 13 6 11 12 17 13 39 5 75 73 36 0 38 25 42 14 22 13 6 11 7 16 10 12 19 2 15 13 6 75 17 13 39 5 75 73 36 0 58 60 575 11 16 45 17 75 45 18 38 553 10 1 4 51 0 10 0 16 8 39 204 10 0 4 12 1 19 17 13 39 9 10 0 16 10 51 5 38 184 10 0 4 12 1 20 17 13 39 11 10 0 51 7 8 0 51 6 38 164 13 0 11 21 17 13 39 152 11 7 16 8 39 19 11 7 4 12 1 9 17 13 40 9 11 7 4 12 1 14 17 13 39 14 13 7 13 6 13 5 13 4 19 4 22 38 95 10 7 40 9 10 6 16 23 40 3 10 5 76 39 8 13 9 19 1 24 38 73 13 9 19 1 25 40 6 14 7 19 1 25 39 43 11 26 48 26 19 0 27 45 28 10 0 48 7 13 10 19 1 24 44 1 13 8 13 7 13 6 13 5 19 4 22 13 0 19 1 24 43 1 44 1 38 17 13 9 19 1 24 13 7 13 6 13 5 13 4 19 4 22 10 8 39 9 19 0 29 14 21 19 1 30 75 73 36 2 38 5 11 12 51 8 38 334 10 0 16 31 39 16 13 0 19 1 32 10 0 51 7 8 0 51 6 38 313 10 0 42 33 7 10 0 51 4 38 302 42 34 11 10 4 40 3 10 0 51 4 38 289 42 4 18 8 1 45 35 13 7 13 0 19 2 36 51 7 43 1 38 269 42 37 100 14 21 1 37 17 13 76 39 6 13 0 19 1 32 13 9 1 38 17 13 39 19 13 7 13 6 13 5 13 4 19 4 22 15 39 19 1 29 38 54 13 9 1 37 17 13 39 19 13 7 13 6 13 5 13 4 19 4 22 15 40 19 1 29 38 28 1 37 48 7 13 9 19 1 24 44 1 13 7 13 6 13 5 13 4 19 4 22 15 41 19 1 29 75 73 36 2 38 167 41 42 13 41 43 10 41 44 7 41 45 4 42 46 105 14 21 10 0 17 13 39 95 15 47 15 48 13 0 19 2 49 12 10 9 6 3 51 9 10 7 40 5 10 6 16 23 39 56 14 50 10 9 16 10 12 19 2 51 45 20 19 0 52 15 53 13 0 15 54 13 10 15 55 19 5 29 13 8 13 7 13 6 13 5 19 4 22 15 56 13 0 15 57 19 3 29 19 0 58 43 1 38 10 15 59 13 9 15 60 19 3 29 75 73 36 2 38 48 42 61 26 14 7 19 1 62 48 7 13 9 19 1 24 11 7 51 9 44 1 15 63 19 1 29 38 20 42 64 3 38 15 42 65 7 11 12 51 8 38 6 13 0 19 1 32 10 1 5 51 1 10 1 40 -555 75 51 0 19 0 66 43 2 63 63 29) #352# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #353=#A(t (9) (c::baboon-improper-*exit* :format-control "The value of *EXIT*~%~A~%is not found in *UNWIND-EXIT*~%~A" :format-arguments c::*exit* c::*unwind-exit* c::baboon #Y(c::baboon-improper-*exit* nil nil (26 14 1 15 2 14 3 14 4 11 5 6 2 12 19 4 6 29) #353# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #354=#A(t (9) (c::baboon-unwind-exit c::ue :format-control "The value of unwind exit~%~A~%found in *UNWIND-EXIT*~%~A~%is not valid." :format-arguments c::*unwind-exit* c::baboon #Y(c::baboon-unwind-exit nil nil (24 45 1 26 14 2 15 3 14 4 13 0 11 5 6 2 12 19 4 6 29) #354# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #355=#A(t (27) (c::unwind-no-exit-until c::last-cons c::bds-lcl c::bds-bind c::stack-frame c::ihs-p c::*unwind-exit* c::unwind-exit c::ue 0 atom eq consp c::stack second numberp #:g19935 + c::frame "ecl_frs_pop(cl_env_copy);" c::wt-nl c::jump c::ihs-env c::baboon-unwind-exit c::unwind-bds #Y(c::unwind-no-exit-until nil nil (24 45 1 26 58 60 195 75 45 2 8 0 45 3 75 45 4 75 45 5 11 6 45 7 75 45 8 57 9 61 2 2 141 10 2 16 10 39 4 35 0 1 10 2 4 51 1 13 2 10 8 17 11 39 4 35 0 1 10 1 16 12 39 19 10 1 4 12 1 13 17 11 39 7 10 1 16 14 51 4 38 84 10 1 16 15 39 11 10 1 51 6 8 0 51 5 38 68 13 1 1 3 17 11 39 18 8 1 45 16 13 6 13 0 19 2 17 51 6 43 1 38 43 13 1 1 18 17 11 39 8 15 19 19 1 20 38 28 13 1 1 21 17 11 40 20 13 1 1 22 17 11 39 7 10 1 51 3 38 6 13 1 19 1 23 10 2 5 51 2 35 0 0 13 6 13 5 13 4 13 3 19 4 24 36 7 62 73 43 1 43 1 43 1 43 1 43 1 43 1 63 29) #355# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #356=#A(t (14) (c::unwind-no-exit ext::exit c::*unwind-exit* :test eq member c::where :format-control "Unwind-exit label ~A not found" :format-arguments c::baboon c::unwind-no-exit-until #Y(c::unwind-no-exit nil nil (24 45 1 26 13 0 14 2 14 3 33 4 12 19 4 5 45 6 10 0 76 39 15 14 7 15 8 14 9 10 1 6 1 12 19 4 10 13 0 19 1 11 43 1 29) #356# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #357=#A(t (16) (c::tail-recursion-possible c::*unwind-exit* si::%dolist-var c::ue c::tail-recursion-mark eq t numberp c::bds-bind c::frame consp c::jump c::ihs-env c::baboon #Y(c::tail-recursion-possible nil nil (26 58 60 101 11 1 45 2 75 45 3 38 79 10 1 4 51 0 13 0 1 4 17 5 39 8 11 6 73 36 2 38 54 10 0 16 7 40 15 13 0 1 8 17 5 40 7 13 0 1 9 17 5 39 7 75 73 36 2 38 26 10 0 16 10 40 15 13 0 1 11 17 5 40 7 13 0 1 12 17 5 40 4 19 0 13 10 1 5 51 1 10 1 40 -81 75 51 0 19 0 13 43 2 63 29) #357# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #358=#A(t (27) (c::c2try-tail-recursive-call c::fun c::args c::*tail-recursion-info* eq c::last-call-p c::tail-recursion-possible c::fun-name c::inline-possible length = c::trash c::*destination* c::next-label c::*exit* c::*unwind-exit* c::c2psetq c::wt-label c::tail-recursion-mark c::unwind-no-exit "goto TTL;" c::wt-nl "Tail-recursive call of ~s was replaced by iteration." c::cmpdebug t #Y(c::c2try-tail-recursive-call nil nil (24 45 1 24 45 2 26 11 3 39 45 13 1 11 3 4 17 4 39 36 19 0 5 39 31 19 0 6 39 26 13 1 19 1 7 12 19 1 8 39 15 10 0 16 9 12 11 3 5 16 9 12 19 2 10 73 39 58 1 11 48 12 19 0 13 48 14 14 14 11 15 3 48 15 77 11 3 5 12 13 0 19 3 16 14 14 19 1 17 44 3 15 18 19 1 19 15 20 19 1 21 15 22 13 1 19 1 7 12 19 2 23 11 24 73 29) #358# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #359=#A(t (6) (c::c1labels c::args labels c::c1labels/flet #Y(c::c1labels nil nil (24 45 1 26 15 2 13 0 19 2 3 29) #359# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #360=#A(t (6) (c::c1flet c::args flet c::c1labels/flet #Y(c::c1flet nil nil (24 45 1 26 15 2 13 0 19 2 3 29) #360# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 75 12 19 2 76 1 0 73 29) #361=#A(t (77) (c::c1labels/flet c::origin c::args c::check-args-number c::cmp-env-copy c::body-c1form c::fnames c::local-funs c::defs c::new-env si::%dolist-var c::def si::valid-function-name-p "The local function definition ~s is illegal." c::cmperr member "The function ~s was already defined." c::name :name :kind :object c::make-var c::var :var c::make-fun c::fun c::cmp-env-register-function flet eq c::*cmp-env* nreverse :fun :cb/lb c::lb c::c1compile-function labels c::change 0 #:loop-list19963 c::f1 c::vars c::funs c::fun-referenced-vars c::fun-referenced-funs c::fun-referencing-funs #:loop-list19967 c::f2 c::c1 c::c2 c::c3 c::add-to-fun-referenced-vars c::add-to-fun-referenced-funs c::update-fun-closure-type t c::c1body c::other-decl c::is c::ts c::ss c::body c::c1declare-specials c::check-vdecl c::c1decl-body plusp :key c::fun-ref remove-if-not c::x #:loop-list19974 c::f c::locals :type c::c1form-type :args c::make-c1form* #Y(c::c1labels/flet nil nil (24 45 1 24 45 2 26 13 1 13 0 9 1 19 3 3 19 0 4 12 77 77 77 77 46 5 46 6 46 7 46 8 46 9 10 5 4 45 10 75 45 11 38 118 10 1 4 51 0 10 0 2 40 13 10 0 4 16 12 76 40 5 10 0 5 2 39 8 15 13 13 0 19 2 14 10 0 4 12 13 5 19 2 15 39 10 15 16 10 0 4 12 19 2 14 10 0 4 12 10 5 3 51 5 10 0 4 45 17 14 18 13 0 14 19 14 20 19 4 21 45 22 14 18 13 1 14 23 13 0 19 4 24 45 25 13 0 13 5 19 2 26 13 0 10 3 5 3 12 10 6 3 51 6 43 3 10 1 5 51 1 10 1 40 -120 43 2 13 6 1 27 17 28 39 6 11 29 73 38 4 10 0 73 12 19 1 4 48 29 10 1 16 30 45 10 75 45 11 38 39 10 1 4 51 0 10 0 4 45 25 10 1 5 12 14 31 13 0 14 32 15 33 19 5 34 12 10 5 3 51 5 43 1 10 1 5 51 1 10 1 40 -41 43 2 44 1 13 6 1 35 17 28 39 190 58 60 187 75 45 36 57 37 61 2 2 174 75 51 1 77 13 5 46 38 46 39 75 45 40 75 45 41 57 37 61 2 2 133 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 3 19 1 42 51 2 13 3 19 1 43 51 1 77 13 3 19 1 44 12 46 45 46 46 75 45 47 75 45 48 75 45 49 57 37 61 2 2 63 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 13 4 13 8 19 2 50 51 3 13 4 13 7 19 2 51 51 2 13 4 19 1 52 51 1 10 3 40 7 10 2 40 3 10 1 39 5 11 53 51 12 35 0 0 62 43 1 43 1 43 1 43 2 35 0 0 62 43 1 43 1 43 2 10 1 76 39 5 75 73 36 2 35 0 0 62 43 1 63 10 0 48 29 10 5 5 12 14 53 19 2 54 47 4 55 47 3 56 47 2 57 47 1 58 45 59 13 1 19 1 60 77 13 2 13 3 19 3 61 13 4 13 0 19 2 62 51 9 43 5 44 1 33 63 12 13 2 14 64 33 65 12 19 4 66 51 2 57 37 61 2 2 65 75 45 67 77 13 4 46 68 46 69 57 37 61 2 2 33 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 19 1 52 39 5 11 53 51 3 35 0 0 62 43 2 10 0 43 1 76 39 4 35 0 1 35 0 0 62 10 2 39 29 15 70 14 71 13 4 19 1 72 12 14 73 13 2 13 4 13 6 1 35 17 28 12 19 7 74 38 4 10 4 73 43 5 29) #361# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #362=#A(t (10) (c::child-function-p c::presumed-parent c::fun c::real-parent 0 c::fun-parent eq t #Y(c::child-function-p nil nil (24 45 1 24 45 2 26 58 60 52 75 45 3 57 4 61 2 2 38 13 3 19 1 5 51 1 10 1 76 39 4 35 0 1 13 1 10 4 17 6 39 8 11 7 73 36 2 38 5 10 1 51 3 35 0 0 62 73 43 1 63 29) #362# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #363=#A(t (21) (c::compute-closure-type c::fun c::lexical-closure-p c::fun-referenced-vars si::%dolist-var c::var c::global-var-p c::ref-ref-ccb c::closure t c::fun-referenced-funs c::f c::child-function-p c::fun-closure c::lexical c::fun-ref-ccb c::fun-var c::var-ref plusp #Y(c::compute-closure-type nil nil (24 45 1 26 57 0 60 160 75 45 2 13 2 19 1 3 45 4 75 45 5 38 36 10 1 4 51 0 13 0 19 1 6 40 19 13 0 19 1 7 39 8 1 8 73 36 3 38 5 11 9 51 2 10 1 5 51 1 10 1 40 -38 43 2 13 2 19 1 10 45 4 75 45 11 38 43 10 1 4 51 0 13 4 13 0 19 2 12 76 39 23 13 0 19 1 13 42 8 8 1 8 73 36 3 38 8 42 14 5 11 9 51 2 10 1 5 51 1 10 1 40 -45 43 2 10 0 73 39 36 13 2 19 1 15 40 19 13 2 19 1 16 39 12 13 2 19 1 16 12 19 1 17 16 18 39 6 1 8 73 38 4 1 14 73 43 1 63 29) #363# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #364=#A(t (10) (c::update-fun-closure-type-many c::function-list c::recompute c::finish si::%dolist-var c::f c::update-fun-closure-type t #Y(c::update-fun-closure-type-many nil nil (24 45 1 26 77 77 46 2 46 3 38 44 10 2 45 4 75 45 5 38 25 10 1 4 51 0 13 0 19 1 6 39 8 11 7 51 3 75 51 2 10 1 5 51 1 10 1 40 -27 43 2 14 7 53 0 10 0 39 -46 10 1 73 43 2 29) #364# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #365=#A(t (9) (c::prepend-new c::l1 c::l2 #:loop-list20002 c::f 0 adjoin #Y(c::prepend-new nil nil (24 45 1 24 45 2 26 77 13 1 46 3 46 4 57 5 61 2 2 31 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 3 19 2 6 51 3 35 0 0 62 43 2 10 0 73 29) #365# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 42 12 19 2 43 1 0 73 29) #366=#A(t (44) (c::update-fun-closure-type c::fun c::fun-closure c::old-type c::closure eq c::compute-closure-type c::fun-child-funs c::to-be-updated c::new-type c::fun-global "Function ~A is global but is closed over some variables.~%~{~A ~}" c::fun-name c::var-name c::fun-referenced-vars mapcar c::cmpnote #:g20005 #:g20006 si::structure-set si::%dolist-var c::var c::global-var-p c::var-kind #:g20016 #:g20017 #:g20018 t #:g20019 #:g20020 #:g20021 #:g20022 ffi::object #:g20023 c::var-functions-reading c::var-functions-setting c::prepend-new c::fun-referenced-funs c::f #:g20027 #:g20028 c::update-fun-closure-type-many #Y(c::update-fun-closure-type nil nil (24 45 1 26 57 0 60 343 13 1 19 1 2 45 3 13 0 1 4 17 5 39 5 75 73 36 1 13 2 19 1 6 12 13 2 19 1 7 12 46 8 46 9 13 0 10 2 17 5 39 5 75 73 36 3 13 4 19 1 10 39 25 15 11 13 4 19 1 12 12 33 13 12 13 4 19 1 14 12 19 2 15 12 19 3 16 10 4 45 17 10 1 45 18 13 1 15 1 9 12 13 0 19 4 19 43 1 43 1 13 0 1 4 17 5 39 214 13 4 19 1 14 45 20 75 45 21 38 145 10 1 4 51 0 13 0 19 1 22 40 11 13 0 19 1 23 12 10 2 17 5 76 39 115 10 0 45 24 75 45 25 13 1 15 21 9 3 13 0 19 4 19 43 1 43 1 10 0 45 26 11 27 45 28 13 1 15 21 9 2 13 0 19 4 19 43 1 43 1 10 0 45 29 1 4 45 30 13 1 15 21 9 6 13 0 19 4 19 43 1 43 1 10 0 45 31 1 32 45 33 13 1 15 21 9 10 13 0 19 4 19 43 1 43 1 13 0 19 1 34 12 13 0 19 1 35 12 13 3 19 2 36 12 19 2 36 51 3 10 1 5 51 1 10 1 40 -147 43 2 13 4 19 1 37 45 20 75 45 38 38 34 10 1 4 51 0 10 0 45 39 11 27 45 40 13 1 15 1 9 2 13 0 19 4 19 43 1 43 1 10 1 5 51 1 10 1 40 -36 43 2 13 1 19 1 41 39 6 13 4 19 1 0 11 27 73 43 2 43 1 63 29) #366# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 40 12 19 2 41 1 0 73 29) #367=#A(t (42) (c::c2locals c::c1form c::funs c::body labels c::*env* c::*inline-blocks* c::*env-lvl* c::env-grows si::%dolist-var c::fun c::fun-var c::var c::var-ref plusp c::var-kind (c::lexical c::closure) member #:g20037 c::next-lcl #:g20038 si::structure-set c::maybe-open-inline-block "cl_object " ";" c::wt c::var-ref-ccb c::env-lvl "volatile cl_object env" #:g20040 + " = env" ";" c::bind c::new-local mapc c::make-cclosure c::set-var c::c2expr c::close-inline-blocks #Y(c::c2locals nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 11 5 48 5 8 0 48 6 11 7 48 7 75 45 8 10 3 45 9 75 45 10 38 91 10 1 4 51 0 13 0 19 1 11 45 12 13 0 19 1 13 16 14 39 63 13 0 19 1 15 12 15 16 19 2 17 76 39 37 10 0 45 18 19 0 19 45 20 13 1 15 12 9 10 13 0 19 4 21 43 1 43 1 19 0 22 15 23 13 0 15 24 19 3 25 10 3 76 39 8 13 0 19 1 26 51 3 43 1 10 1 5 51 1 10 1 40 -93 43 2 13 0 19 1 8 39 37 19 0 22 11 7 45 27 15 28 8 1 45 29 14 7 13 0 19 2 30 52 7 12 43 1 15 31 13 0 15 32 19 5 25 43 1 10 3 45 9 75 45 10 38 35 10 1 4 51 0 13 0 19 1 11 45 12 13 0 19 1 13 16 14 39 7 77 13 0 19 2 33 43 1 10 1 5 51 1 10 1 40 -37 43 2 33 34 12 13 3 19 2 35 10 3 45 9 75 45 10 38 41 10 1 4 51 0 13 0 19 1 11 45 12 13 0 19 1 13 16 14 39 13 15 36 10 1 6 2 12 13 0 19 2 37 43 1 10 1 5 51 1 10 1 40 -43 43 2 13 2 19 1 38 19 0 39 44 3 29) #367# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #368=#A(t (11) (c::c1decl-body c::decls c::body c::c1progn c::add-one-declaration :initial-value c::*cmp-env* c::cmp-env-copy reduce #Y(c::c1decl-body nil nil (24 45 1 24 45 2 26 10 1 76 39 8 13 0 19 1 3 38 26 33 4 12 13 1 14 5 14 6 19 1 7 12 19 4 8 48 6 13 0 19 1 3 44 1 29) #368# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #369=#A(t (17) (c::c1locally c::args t c::c1body c::other-decl c::is c::ts c::ss c::body c::cmp-env-copy c::*cmp-env* c::c1declare-specials c::check-vdecl c::c1decl-body c::c1progn #Y(c::c1locally nil nil (24 45 1 26 13 0 14 2 19 2 3 47 4 4 47 3 5 47 2 6 47 1 7 45 8 10 1 40 11 10 2 40 7 10 3 40 3 10 4 39 30 19 0 9 48 10 13 1 19 1 11 77 13 2 13 3 19 3 12 13 4 13 0 19 2 13 44 1 38 6 13 0 19 1 14 43 5 29) #369# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #370=#A(t (10) (c::c1macrolet c::args macrolet c::check-args-number c::cmp-env-copy si::cmp-env-register-macrolet c::*cmp-env* c::c1locally #Y(c::c1macrolet nil nil (24 45 1 26 15 2 13 0 9 1 19 3 3 10 0 4 12 19 0 4 12 19 2 5 48 6 10 0 5 12 19 1 7 44 1 29) #370# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #371=#A(t (17) (c::c1symbol-macrolet c::args symbol-macrolet c::check-args-number c::cmp-env-copy c::*cmp-env* si::%dolist-var c::def c::name symbolp "The symbol-macro definition ~s is illegal." c::cmperr second c::cmp-env-register-symbol-macro c::c1locally #Y(c::c1symbol-macrolet nil nil (24 45 1 26 15 2 13 0 9 1 19 3 3 19 0 4 48 5 10 0 4 45 6 75 45 7 38 53 10 1 4 51 0 10 0 4 45 8 10 1 2 40 12 10 0 16 9 76 40 5 10 1 5 2 39 8 15 10 13 1 19 2 11 13 0 10 1 16 12 12 19 2 13 43 1 10 1 5 51 1 10 1 40 -55 43 2 10 0 5 12 19 1 14 44 1 29) #371# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 47 12 19 2 48 1 0 73 29) #372=#A(t (49) (c::local-function-ref c::fname c::build-object c::cmp-env-search-function c::unw c::clb c::ccb c::fun functionp "The name of a macro ~A was found in special form FUNCTION." c::cmperr #:g20041 #:g20043 c::fun-ref + #:g20042 si::structure-set #:g20044 t #:g20045 c::*current-function* c::caller c::fun-referenced-funs :test eq member #:g20048 #:g20046 #:g20047 #:g20051 #:g20049 c::fun-referencing-funs #:g20050 c::fun-var c::var #:g20052 #:g20053 #:g20054 c::closure #:g20055 #:g20056 #:g20057 #:g20058 #:g20059 #:g20060 c::lexical #:g20061 #Y(c::local-function-ref nil nil (24 45 1 25 40 2 77 46 2 26 57 0 60 344 13 2 19 1 3 47 3 4 47 2 5 47 1 6 45 7 10 0 39 318 10 0 16 8 39 16 10 5 39 8 15 9 13 6 19 2 10 75 73 36 4 10 0 45 11 8 1 45 12 13 1 19 1 13 12 13 0 19 2 14 45 15 13 2 15 7 9 1 13 0 19 4 16 43 3 10 5 39 26 10 0 45 17 11 18 45 19 13 1 15 7 9 2 13 0 19 4 16 43 1 43 1 38 92 11 20 45 21 10 0 39 18 13 1 13 0 19 1 22 12 14 23 33 24 12 19 4 25 76 39 63 10 1 45 26 10 1 45 27 13 1 13 0 19 1 22 3 45 28 13 1 15 7 9 23 13 0 19 4 16 43 3 10 0 45 29 10 2 45 30 13 1 13 0 19 1 31 3 45 32 13 1 15 7 9 24 13 0 19 4 16 43 3 43 1 13 0 19 1 33 45 34 10 2 39 76 10 6 39 47 10 0 45 35 11 18 45 36 13 1 15 34 9 2 13 0 19 4 16 43 1 43 1 10 0 45 37 1 38 45 39 13 1 15 34 9 6 13 0 19 4 16 43 1 43 1 10 1 45 40 11 18 45 41 13 1 15 7 9 2 13 0 19 4 16 43 1 43 1 38 55 10 3 39 51 10 6 39 47 10 0 45 42 11 18 45 43 13 1 15 34 9 3 13 0 19 4 16 43 1 43 1 10 0 45 44 1 45 45 46 13 1 15 34 9 6 13 0 19 4 16 43 1 43 1 43 1 10 0 73 43 4 63 29) #372# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #373=#A(t (15) (c::c2call-local c::c1form c::fun c::args c::c2try-tail-recursive-call c::*temp* c::*inline-blocks* c::fun-name c::inline-args c::c1form-primary-type c::call-loc c::unwind-exit c::close-inline-blocks #Y(c::c2call-local nil nil (24 45 1 24 45 2 24 45 3 26 13 1 13 0 19 2 4 76 73 39 41 9 0 14 5 49 5 49 6 13 1 19 1 7 12 13 1 13 0 19 1 8 12 13 2 19 1 9 12 19 4 10 12 19 1 11 19 0 12 44 2 29) #373# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 28 12 19 2 29 1 0 73 29) #374=#A(t (30) (c::c1apply c::args apply c::check-args-number c::fun c::arguments consp lambda eq t c::optimize-funcall/apply-lambda ext::lambda-block macroexpand-1 function second caadr (lambda ext::lambda-block) member #'apply c::c1funcall c::form c::fname c::get-return-type type #:g20066 #:g20067 c::c1form si::structure-set #Y(c::c1apply nil nil (24 45 1 26 15 2 13 0 9 2 19 3 3 10 0 4 45 4 10 1 5 45 5 10 1 16 6 39 9 10 1 4 12 1 7 17 8 39 14 10 1 5 12 13 0 14 9 19 3 10 38 163 10 1 16 6 39 9 10 1 4 12 1 11 17 8 39 21 13 1 19 1 12 51 1 10 1 5 12 13 0 14 9 19 3 10 38 127 10 1 16 6 39 29 10 1 4 12 1 13 17 8 39 19 10 1 16 14 16 6 39 11 10 1 16 15 12 15 16 19 2 17 39 16 10 1 16 14 12 10 0 7 2 12 19 1 0 38 76 15 18 10 2 7 2 12 19 1 19 45 20 10 2 16 6 39 9 10 2 4 12 1 13 17 8 39 43 10 2 16 14 45 21 13 0 19 1 22 45 23 10 0 39 24 10 2 45 24 10 1 45 25 13 1 15 26 9 1 13 0 19 4 27 43 1 43 1 43 2 10 0 73 43 1 43 2 29) #374# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 42 12 19 3 43 1 0 73 29) #375=#A(t (44) (boole compiler-macro #:g20069 #:g20068 c::form #:g20070 si::dm-too-few-arguments c::op-code c::op1 c::op2 si::dm-too-many-arguments constantp eval 0 progn 15 3 prog1 5 12 lognot 10 1 logand 7 logior 6 logxor 9 logeqv 14 lognand 8 lognor 4 logandc1 2 logandc2 13 logorc1 11 logorc2 #Y(boole nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 4 19 1 6 10 1 4 12 10 1 5 51 1 22 45 8 10 2 76 39 6 13 5 19 1 6 10 2 4 12 10 2 5 51 2 22 45 9 10 3 39 6 13 6 19 1 10 13 2 19 1 11 39 227 10 2 16 12 42 13 13 15 14 13 1 13 0 8 0 6 4 38 208 42 15 13 15 14 13 1 13 0 8 -1 6 4 38 193 42 16 11 15 17 13 1 10 0 6 3 38 180 42 18 11 15 14 13 1 10 0 6 3 38 167 42 19 16 15 17 15 20 10 1 6 2 12 10 0 6 3 38 149 42 21 15 15 14 13 1 15 20 10 0 6 2 6 3 38 132 42 22 11 15 23 13 1 10 0 6 3 38 119 42 24 11 15 25 13 1 10 0 6 3 38 106 42 26 11 15 27 13 1 10 0 6 3 38 93 42 28 11 15 29 13 1 10 0 6 3 38 80 42 30 11 15 31 13 1 10 0 6 3 38 67 42 32 11 15 33 13 1 10 0 6 3 38 54 42 34 11 15 35 13 1 10 0 6 3 38 41 42 36 11 15 37 13 1 10 0 6 3 38 28 42 38 11 15 39 13 1 10 0 6 3 38 15 42 40 11 15 41 13 1 10 0 6 3 38 2 75 73 40 4 10 4 73 29) #375# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #376=#A(t (14) (c::result-type c::x symbolp c::c1expr c::c1form-primary-type constantp type-of consp the eq second t #Y(c::result-type nil nil (24 45 1 26 10 0 16 2 39 12 13 0 19 1 3 12 19 1 4 38 39 13 0 19 1 5 39 7 10 0 16 6 38 26 10 0 16 7 39 9 10 0 4 12 1 8 17 9 39 7 10 0 16 10 38 4 11 11 73 29) #376# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #377=#A(t (20) (c::c1if c::args if c::check-args-number c::c1expr c::test c::c1form-constant-p c::value c::constant-p second third c::true-branch c::false-branch :type c::c1form-type c::values-type-or :args c::make-c1form* #Y(c::c1if nil nil (24 45 1 26 57 0 60 109 15 2 13 1 9 2 9 3 19 4 3 10 1 4 12 19 1 4 45 5 13 0 19 1 6 47 1 7 45 8 10 0 39 17 10 1 39 7 10 4 16 9 38 5 10 4 16 10 36 3 43 2 10 2 16 9 12 19 1 4 45 11 10 3 16 10 12 19 1 4 45 12 15 2 14 13 13 1 19 1 14 12 13 0 19 1 14 12 19 2 15 12 14 16 13 2 13 1 13 0 19 7 17 43 2 43 1 63 29) #377# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #378=#A(t (15) (c::c1not c::args not c::check-args-number c::c1expr c::value c::c1form-constant-p c::constant-p c::fmla-not :type (member t nil) :args c::make-c1form* #Y(c::c1not nil nil (24 45 1 26 57 0 60 59 15 2 13 1 9 1 9 1 19 4 3 10 1 4 12 19 1 4 45 5 13 0 19 1 6 47 1 5 45 7 10 0 39 7 10 1 76 73 36 3 43 2 15 8 14 9 15 10 14 11 13 0 19 5 12 43 1 63 29) #378# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #379=#A(t (17) (c::c1and c::args c::c1t c::c1args* values last nbutlast butlast c::fmla-and :type null c::c1form-primary-type c::type-or :args c::make-c1form* #Y(c::c1and nil nil (24 45 1 26 10 0 76 39 6 19 0 2 38 59 13 0 19 1 3 45 4 13 0 19 1 5 4 45 5 13 1 19 1 6 45 7 10 0 39 28 15 8 14 9 15 10 13 1 19 1 11 12 19 2 12 12 14 13 13 0 13 1 19 6 14 38 4 10 1 73 43 3 29) #379# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #380=#A(t (18) (c::c1or c::args c::c1nil c::c1args* values last butlast c::fmla-or :type c::type-or :key c::c1form-primary-type :initial-value reduce :args c::make-c1form* #Y(c::c1or nil nil (24 45 1 26 10 0 76 39 6 19 0 2 38 69 13 0 19 1 3 45 4 13 0 19 1 5 4 45 5 13 1 19 1 6 45 6 10 0 39 38 15 7 14 8 33 9 12 13 0 14 10 33 11 12 14 12 13 1 19 1 11 12 19 6 13 12 14 14 13 0 13 1 19 6 15 38 4 10 1 73 43 3 29) #380# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 1 0 73 29) #381=#A(t (24) (c::c2if c::c1form c::fmla c::form1 c::form2 c::*destination* c::trash eq c::c1form-name ext::location c::maybe-next-label c::false-label c::*unwind-exit* adjoin c::jump-false c::c2expr* c::c2expr c::maybe-wt-label c::true-label c::jump-true c::next-label c::wt-label #Y(c::c2if nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 14 5 1 6 17 7 39 11 13 0 19 1 8 12 1 9 17 7 39 46 19 0 10 45 11 13 0 14 12 19 2 13 48 12 15 14 10 0 6 2 48 5 13 3 19 1 15 44 1 13 2 19 1 16 13 0 19 1 17 43 1 44 1 38 112 14 5 1 6 17 7 39 11 13 1 19 1 8 12 1 9 17 7 39 46 19 0 10 45 18 13 0 14 12 19 2 13 48 12 15 19 10 0 6 2 48 5 13 3 19 1 15 44 1 13 1 19 1 16 13 0 19 1 17 43 1 44 1 38 47 19 0 20 45 11 13 0 11 12 3 48 12 15 14 10 0 6 2 48 5 13 3 19 1 15 44 1 13 2 19 1 16 13 0 19 1 21 43 1 44 1 13 0 19 1 16 29) #381# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #382=#A(t (18) (c::negate-argument c::inlined-arg c::dest-loc second c::loc c::loc-representation-type c::rep-type c::produce-inline-loc :bool eq ((:bool) (:bool) "(#0)==ECL_NIL" nil t) :object ((:object) (:bool) "(#0)!=ECL_NIL" nil t) ((:bool) (:object) "(#0)?ECL_NIL:ECL_T" nil t) ((:object) (:object) "Null(#0)?ECL_T:ECL_NIL" nil t) apply #Y(c::negate-argument nil nil (24 45 1 24 45 2 26 57 0 60 87 10 2 16 3 45 4 13 0 19 1 5 45 6 33 7 12 10 4 6 1 12 13 3 19 1 5 12 11 8 17 9 39 25 10 0 42 8 6 1 10 73 38 13 42 11 6 1 12 73 38 5 75 73 36 2 38 23 10 0 42 8 6 1 13 73 38 13 42 11 6 1 14 73 38 5 75 73 36 2 12 19 3 15 43 2 63 29) #382# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #383=#A(t (18) (c::c2fmla-not c::c1form c::arg c::*destination* c::dest c::jump-true-destination-p c::jump-false c::c2expr c::jump-false-destination-p c::jump-true c::*temp* c::*inline-blocks* c::emit-inline-form c::negate-argument c::unwind-exit c::close-inline-blocks #Y(c::c2fmla-not nil nil (24 45 1 24 45 2 26 11 3 45 4 13 0 19 1 5 39 19 15 6 10 0 5 7 2 48 3 13 1 19 1 7 44 1 38 55 13 0 19 1 8 39 19 15 9 10 0 5 7 2 48 3 13 1 19 1 7 44 1 38 30 9 0 14 10 49 10 49 11 13 1 77 19 2 12 12 13 0 19 2 13 12 19 1 14 19 0 15 44 2 43 1 29) #383# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #384=#A(t (7) (c::jump-true-destination-p c::dest consp c::jump-true eq #Y(c::jump-true-destination-p nil nil (24 45 1 26 10 0 16 2 73 39 9 10 0 4 12 1 3 17 4 29) #384# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #385=#A(t (7) (c::jump-false-destination-p c::dest consp c::jump-false eq #Y(c::jump-false-destination-p nil nil (24 45 1 26 10 0 16 2 73 39 9 10 0 4 12 1 3 17 4 29) #385# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #386=#A(t (18) (c::c2fmla-and c::c1form butlast last c::*destination* c::jump-false-destination-p c::c2expr* mapc c::c2expr c::next-label c::normal-exit c::*unwind-exit* c::false-label c::jump-false c::wt-label c::unwind-exit #Y(c::c2fmla-and nil nil (24 45 1 24 45 2 24 45 3 26 14 4 19 1 5 39 16 33 6 12 13 1 19 2 7 13 0 19 1 8 38 70 19 0 9 45 10 13 0 11 11 3 48 11 19 0 9 45 12 13 0 11 11 3 48 11 15 13 10 0 6 2 48 4 33 6 12 13 3 19 2 7 44 1 13 2 19 1 8 13 0 19 1 14 43 1 44 1 77 19 1 15 13 0 19 1 14 43 1 44 1 29) #386# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 1 0 73 29) #387=#A(t (25) (c::c2fmla-or c::c1form butlast last c::*destination* c::jump-true-destination-p c::c2expr* mapc c::c2expr c::jump-false-destination-p c::next-label c::true-label c::*unwind-exit* c::jump-true c::wt-label t c::unwind-exit c::common-exit c::normal-exit si::%dolist-var c::f c::value0 c::set-jump-true #Y(c::c2fmla-or nil nil (24 45 1 24 45 2 24 45 3 26 14 4 19 1 5 39 16 33 6 12 13 1 19 2 7 13 0 19 1 8 38 154 14 4 19 1 9 39 52 19 0 10 45 11 13 0 11 12 3 48 12 15 13 10 0 6 2 48 4 33 6 12 13 2 19 2 7 44 1 13 1 19 1 8 13 0 19 1 14 43 1 44 1 14 15 19 1 16 38 96 19 0 10 45 17 13 0 11 12 3 48 12 19 0 10 45 18 13 0 11 12 3 48 12 10 3 45 19 75 45 20 38 29 10 1 4 51 0 1 21 48 4 13 0 19 1 6 44 1 15 21 13 2 19 2 22 10 1 5 51 1 10 1 40 -31 43 2 13 2 19 1 8 13 0 19 1 14 43 1 44 1 15 21 19 1 16 13 0 19 1 14 43 1 44 1 29) #387# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #388=#A(t (27) (c::set-jump-true c::loc c::label c::loc-immediate-value-p c::value constantp c::loc-representation-type :bool eq "if (" ") {" c::wt-nl "if ((" :object c::wt-coerce-loc ")!=ECL_NIL) {" c::wt c::unwind-no-exit #:g20074 c::*opened-c-braces* + c::wt-go c::wt-nl-close-brace " " " }" #Y(c::set-jump-true nil nil (24 45 1 24 45 2 26 13 1 19 1 3 47 1 4 45 5 10 0 76 39 93 13 3 19 1 6 12 11 7 17 8 39 12 15 9 13 3 15 10 19 3 11 38 18 15 12 19 1 11 14 13 13 3 19 2 14 15 15 19 1 16 13 2 19 1 17 39 29 8 1 45 18 14 19 13 0 19 2 20 52 19 43 1 19 0 11 13 2 19 1 21 19 0 22 38 16 15 23 19 1 16 13 2 19 1 21 15 24 19 1 16 38 20 10 1 76 73 40 14 13 2 19 1 17 19 0 11 13 2 19 1 21 43 2 29) #388# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #389=#A(t (27) (c::set-jump-false c::loc c::label c::loc-immediate-value-p c::value constantp c::loc-representation-type :bool eq "if (!(" ")) {" c::wt-nl "if (Null(" :object c::wt-coerce-loc ")) {" c::wt c::unwind-no-exit #:g20078 c::*opened-c-braces* + c::wt-go c::wt-nl-close-brace " " " }" #Y(c::set-jump-false nil nil (24 45 1 24 45 2 26 13 1 19 1 3 47 1 4 45 5 10 0 76 39 93 13 3 19 1 6 12 11 7 17 8 39 12 15 9 13 3 15 10 19 3 11 38 18 15 12 19 1 11 14 13 13 3 19 2 14 15 15 19 1 16 13 2 19 1 17 39 29 8 1 45 18 14 19 13 0 19 2 20 52 19 43 1 19 0 11 13 2 19 1 21 19 0 22 38 16 15 23 19 1 16 13 2 19 1 21 15 24 19 1 16 38 19 10 1 73 40 14 13 2 19 1 17 19 0 11 13 2 19 1 21 43 2 29) #389# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #390=#A(t (6) (c::c1lambda-doc c::form c::c1form-args second #Y(c::c1lambda-doc nil nil (24 45 1 26 13 0 19 1 2 16 3 29) #390# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #391=#A(t (6) (c::c1lambda-body c::form c::c1form-args third #Y(c::c1lambda-body nil nil (24 45 1 26 13 0 19 1 2 16 3 29) #391# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #392=#A(t (5) (c::c1lambda-list c::form c::c1form-args #Y(c::c1lambda-list nil nil (24 45 1 26 13 0 19 1 2 4 73 29) #392# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #393=#A(t (5) (c::fun-needs-narg c::fun c::fun-fixed-narg #Y(c::fun-needs-narg nil nil (24 45 1 26 13 0 19 1 2 76 73 29) #393# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #394=#A(t (13) (c::fun-fixed-narg c::fun c::narg c::fun-closure c::closure eq c::fun-minarg c::fun-maxarg = si::c-arguments-limit <= #Y(c::fun-fixed-narg nil nil (24 45 1 26 75 45 2 13 1 19 1 3 12 1 4 17 5 76 73 39 34 13 1 19 1 6 12 13 1 19 1 7 51 0 12 19 2 8 73 39 14 13 0 14 9 19 2 10 73 39 4 10 0 73 43 1 29) #394# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #395=#A(t (20) (c::add-to-fun-referenced-vars c::fun c::var-list c::fun-referenced-vars c::new-vars c::fun-local-vars c::locals c::change #:loop-list20086 c::v 0 :test eq member t #:g20089 #:g20090 si::structure-set #Y(c::add-to-fun-referenced-vars nil nil (24 45 1 24 45 2 26 58 60 136 13 2 19 1 3 45 4 13 3 19 1 5 45 6 75 45 7 77 13 4 46 8 46 9 57 10 61 2 2 63 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 4 14 11 33 12 12 19 4 13 76 39 14 13 1 13 5 14 11 33 12 12 19 4 13 76 39 12 11 14 51 3 13 1 10 5 3 51 5 35 0 0 10 3 39 29 10 8 45 15 10 6 45 16 13 1 15 1 9 22 13 0 19 4 17 43 1 43 1 11 14 73 36 6 62 73 43 2 43 1 43 1 43 1 63 29) #395# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #396=#A(t (22) (c::add-to-fun-referenced-funs c::fun c::fun-list c::fun-referenced-funs c::new-funs c::change #:loop-list20098 c::f 0 eq :test member c::child-function-p t #:g20101 c::fun-referencing-funs #:g20102 si::structure-set #:g20103 #:g20104 #Y(c::add-to-fun-referenced-funs nil nil (24 45 1 24 45 2 26 58 60 160 13 2 19 1 3 45 4 75 45 5 77 13 3 46 6 46 7 57 8 61 2 2 96 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 7 10 1 17 9 76 39 24 13 1 13 4 14 10 33 9 12 19 4 11 76 39 9 13 7 13 1 19 2 12 76 39 41 11 13 51 3 13 1 10 4 3 51 4 10 1 45 14 13 8 13 2 19 1 15 3 45 16 13 1 15 1 9 24 13 0 19 4 17 43 1 43 1 35 0 0 10 3 39 29 10 7 45 18 10 5 45 19 13 1 15 1 9 23 13 0 19 4 17 43 1 43 1 11 13 73 36 5 62 73 43 2 43 1 43 1 63 29) #396# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 93 12 19 2 94 1 0 73 29) #397=#A(t (95) (c::c1compile-function c::lambda-list-and-body (nil :cb/lb :name :fun) c::make-fun c::fun c::fun-name c::name c::cb c::cb/lb ext::lambda-block lambda #:g20143 #:g20144 si::structure-set #:g20145 #:g20146 #:g20147 c::*current-function* #:g20148 #:g20151 #:g20149 c::fun-child-funs #:g20150 #:g20152 c::cmp-env-mark #:g20153 c::*cmp-env* c::*setjmps* c::setjmps si::process-declarations c::decl si::c-global assoc #:g20154 t #:g20155 c::global si::c-local c::no-entry si::function-block-name c::c1lambda-expr c::lambda-expr c::cfun c::exported c::minarg c::maxarg c::policy-debug-ihs-frame "Ignoring SI::C-LOCAL declaration for~%~4I~A~%because the debug level is large" c::cmpnote eql #:g20157 #:g20158 c::c1form #:g20159 #:g20160 c::exported-fname "LC~D~A" c::next-cfun c::get-proclaimed-narg "~&;;; Function ~A proclaimed (~A,~A)" format call-arguments-limit c::lambda-form-allowed-nargs #:g20165 #:g20166 #:g20167 #:g20168 #:g20169 #:g20170 #:g20171 #:g20172 #:g20173 #:g20174 #:g20175 #:g20176 #:g20177 #:g20178 #:loop-list20179 c::child 0 c::fun-referenced-vars c::add-to-fun-referenced-vars c::fun-referenced-funs c::add-to-fun-referenced-funs #:loop-list20180 c::f c::update-fun-closure-type c::fun-closure "Function ~A is global but is closed over some variables.~%~{~A ~}" c::var-name mapcar c::fun-no-entry c::new-defun #Y(c::c1compile-function nil nil (24 45 1 28 2 22 40 5 19 0 3 12 46 4 22 40 7 13 0 19 1 5 12 46 6 22 40 3 15 7 46 8 10 1 39 11 15 9 13 1 10 3 7 3 38 7 15 10 10 3 7 2 45 10 10 3 45 11 10 3 45 12 13 1 15 4 9 0 13 0 19 4 13 43 1 43 1 10 3 45 14 10 1 45 15 13 1 15 4 9 16 13 0 19 4 13 43 1 43 1 10 3 45 16 11 17 45 18 13 1 15 4 9 20 13 0 19 4 13 43 1 43 1 43 1 11 17 39 32 10 2 45 19 11 17 45 20 13 1 13 0 19 1 21 3 45 22 13 1 15 4 9 25 13 0 19 4 13 43 3 10 2 48 17 10 2 45 23 13 1 19 1 24 45 25 13 1 15 4 9 28 13 0 19 4 13 43 1 43 1 48 26 11 27 45 28 10 4 5 12 19 1 29 45 30 15 31 13 0 19 2 32 39 24 10 4 45 33 11 34 45 35 13 1 15 4 9 8 13 0 19 4 13 43 1 43 1 45 36 15 37 13 1 19 2 32 45 38 13 7 10 5 16 39 12 19 2 40 45 41 75 45 42 75 45 43 75 45 44 75 45 45 10 5 39 4 19 0 46 39 11 75 51 5 15 47 13 10 19 2 48 13 8 11 27 17 49 76 39 24 10 4 45 50 11 34 45 51 13 1 15 52 9 3 13 0 19 4 13 43 1 43 1 10 11 45 53 10 5 45 54 13 1 15 4 9 15 13 0 19 4 13 43 1 43 1 10 6 39 13 13 10 19 1 55 51 3 55 2 1 38 13 15 56 13 10 19 2 57 51 3 75 51 2 10 2 39 39 13 10 19 1 58 51 1 55 0 1 14 34 15 59 13 10 13 1 13 0 19 5 60 10 1 76 39 9 8 0 51 1 11 61 51 0 38 11 13 4 19 1 62 51 1 55 0 1 10 11 45 63 10 4 45 64 13 1 15 4 9 5 13 0 19 4 13 43 1 43 1 10 11 45 65 10 3 45 66 13 1 15 4 9 9 13 0 19 4 13 43 1 43 1 10 11 45 67 75 45 68 13 1 15 4 9 12 13 0 19 4 13 43 1 43 1 10 11 45 69 10 2 45 70 13 1 15 4 9 17 13 0 19 4 13 43 1 43 1 10 11 45 71 10 1 45 72 13 1 15 4 9 18 13 0 19 4 13 43 1 43 1 10 11 45 73 10 11 45 74 13 1 15 4 9 14 13 0 19 4 13 43 1 43 1 10 11 45 75 10 6 45 76 13 1 15 4 9 10 13 0 19 4 13 43 1 43 1 77 13 11 19 1 21 12 46 77 46 78 57 79 61 2 2 44 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 14 13 1 19 1 80 12 19 2 81 13 14 13 1 19 1 82 12 19 2 83 35 0 0 62 43 2 77 13 11 19 1 82 12 46 84 46 85 57 79 61 2 2 33 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 14 13 1 19 1 80 12 19 2 81 35 0 0 62 43 2 13 11 19 1 86 10 6 39 45 13 11 19 1 87 39 27 15 88 13 11 19 1 5 12 33 89 12 13 11 19 1 80 12 19 2 90 12 19 3 48 38 12 13 11 13 11 19 1 91 12 19 2 92 43 9 44 2 10 2 73 29) #397# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #398=#A(t (16) (c::cmp-process-lambda-list list #:g20184 #:g20185 0 error si::temp #Y(nil nil nil (24 45 6 26 10 0 51 2 35 1 0 29) #398# #1# 0) si::*handler-clusters* function si::process-lambda-list c::c "Illegal lambda list ~S" c::cmperr #Y(c::cmp-process-lambda-list nil nil (24 45 1 26 57 2 60 52 75 45 3 57 4 61 1 24 15 5 34 7 3 6 1 12 11 8 3 48 8 13 3 1 9 17 10 36 2 44 1 10 1 45 11 15 12 13 4 19 2 13 43 1 36 2 62 73 43 1 63 29) #398# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 105 12 19 2 106 1 0 73 29) #399=#A(t (107) (c::c1lambda-expr c::lambda-expr c::block-name c::doc c::body c::ss c::is c::ts c::other-decls c::new-variables c::type-checks t c::*permanent-data* c::*cmp-env* c::old-env c::cmp-env-copy "The lambda expression ~s is illegal." lambda c::cmperr c::c1body block c::cmp-process-lambda-list c::aux-vars c::allow-other-keys c::keywords c::key-flag rest c::optionals c::requireds c::specs c::name c::c1make-var c::var #:g20237 #:g20238 rplaca c::push-vars second c::init third c::flag c::var-type c::c1expr :safe "In (LAMBDA ~a...)" c::and-form-type c::default-init #:g20247 #:g20248 #:g20249 #:g20250 #:g20251 #:g20252 cddr cdddr c::key fourth "In (LAMBDA ~a...)" #:g20261 #:g20262 #:g20263 #:g20264 #:g20265 #:g20266 cddddr c::add-one-declaration :initial-value reduce c::declarations c::extract-lambda-type-checks c::type-check-forms nconc c::spec #:loop-list-head20268 #:loop-list-tail20269 0 atom rplacd c::let-vars c::cmp-env-new-variables c::var-name mapcar car set-difference c::already-declared-names c::specials special #:loop-list20271 c::expected-uses #:loop-list-head20272 #:loop-list-tail20273 #72# member c::ignorables ignorable #:loop-list20275 type let* declare c::c1progn si::%dolist-var c::check-vref :local-vars :args c::make-c1form* #Y(c::c1lambda-expr nil nil (24 45 1 25 40 2 77 46 2 26 75 45 3 75 45 4 75 45 5 75 45 6 75 45 7 75 45 8 75 45 9 75 45 10 11 11 48 12 11 13 45 14 19 0 15 48 13 10 10 2 39 12 15 16 15 17 10 10 3 12 19 2 18 10 10 5 12 14 11 19 2 19 51 7 55 6 1 55 4 2 55 5 3 55 3 4 55 8 5 10 9 39 13 15 20 13 9 10 7 3 3 6 1 51 7 10 10 4 12 19 1 21 47 6 22 47 5 23 47 4 24 47 3 25 47 2 26 47 1 27 45 28 10 0 5 51 0 45 29 38 59 10 0 4 45 30 13 0 13 15 13 14 13 13 19 4 31 45 32 13 0 10 11 3 51 11 10 2 45 33 10 1 45 34 13 1 10 0 17 35 10 0 43 1 43 1 13 0 19 1 36 43 2 10 0 5 12 53 0 10 0 2 39 -62 43 1 10 1 5 51 1 45 29 38 174 10 0 4 45 30 13 0 13 15 13 14 13 13 19 4 31 45 32 10 2 16 37 45 38 10 3 16 39 45 40 10 1 39 26 13 2 19 1 41 12 13 1 19 1 42 12 13 1 14 43 15 44 13 21 19 6 45 38 6 13 2 19 1 46 51 1 13 2 10 13 3 51 13 13 2 19 1 36 10 0 39 18 13 0 13 18 13 17 13 16 19 4 31 51 0 12 19 1 36 10 4 45 47 10 3 45 48 13 1 10 0 17 35 10 0 43 1 43 1 10 4 45 49 10 2 45 50 10 1 5 12 10 0 17 35 10 0 43 1 43 1 10 4 45 51 10 1 45 52 10 1 16 53 12 10 0 17 35 10 0 43 1 43 1 43 4 10 0 16 54 12 53 0 10 0 2 39 -177 43 1 10 2 39 18 13 2 13 13 13 12 13 11 19 4 31 51 2 12 19 1 36 10 4 5 51 4 45 29 38 183 10 0 4 45 55 10 1 16 37 45 30 13 0 13 16 13 15 13 14 19 4 31 45 32 10 3 16 39 45 38 10 4 16 56 45 40 10 1 39 26 13 2 19 1 41 12 13 1 19 1 42 12 13 1 14 43 15 57 13 22 19 6 45 38 6 13 2 19 1 46 51 1 13 2 10 14 3 51 14 13 2 19 1 36 10 0 39 18 13 0 13 19 13 18 13 17 19 4 31 51 0 12 19 1 36 10 5 45 58 10 3 45 59 10 1 5 12 10 0 17 35 10 0 43 1 43 1 10 5 45 60 10 2 45 61 10 1 16 53 12 10 0 17 35 10 0 43 1 43 1 10 5 45 62 10 1 45 63 10 1 16 54 12 10 0 17 35 10 0 43 1 43 1 43 5 10 0 16 64 12 53 0 10 0 2 39 -186 43 1 33 65 12 13 10 14 66 14 13 19 4 67 52 13 10 10 45 68 13 17 13 1 13 2 13 5 13 12 13 11 19 6 69 45 10 10 0 4 45 70 58 60 92 10 2 5 12 13 10 19 2 71 45 72 75 45 30 75 45 38 75 6 1 45 73 10 0 45 74 57 75 61 2 2 44 10 5 16 76 39 4 35 0 1 10 5 4 51 4 10 5 16 37 51 3 13 1 13 4 10 3 6 2 6 1 51 1 17 77 10 5 16 53 51 5 35 0 0 10 2 5 73 36 6 62 43 2 43 1 43 1 43 1 63 45 78 14 13 13 11 19 2 79 45 9 33 80 12 13 0 19 2 81 12 33 82 12 13 1 19 2 81 12 19 2 83 45 84 13 19 13 0 19 2 83 45 85 10 0 39 13 15 86 10 0 7 2 12 10 6 3 51 6 43 1 58 60 95 77 77 13 19 46 87 46 88 46 32 75 6 1 45 89 10 0 45 90 57 75 61 2 2 58 10 5 2 39 4 35 0 1 10 5 4 45 91 10 0 4 51 4 10 0 5 51 0 10 0 51 5 43 1 10 5 5 51 5 13 3 13 7 19 2 92 76 39 11 13 1 10 3 6 1 51 1 17 77 35 0 0 10 2 5 73 36 6 62 43 2 43 3 63 45 93 10 0 39 13 15 94 10 0 7 2 12 10 6 3 51 6 43 1 77 77 13 17 46 95 46 96 46 32 57 75 61 2 2 62 10 3 2 39 4 35 0 1 10 3 4 45 91 10 0 4 51 2 10 0 5 51 0 10 0 51 3 43 1 10 3 5 51 3 13 1 13 4 19 2 92 76 39 15 15 96 13 2 10 1 6 3 12 10 9 3 51 9 35 0 0 62 43 3 10 2 40 3 10 5 39 20 15 97 13 2 15 98 10 5 7 2 12 10 20 7 4 6 1 51 20 13 3 13 20 19 2 71 51 20 14 13 19 1 15 48 13 13 20 19 1 99 51 20 44 1 10 1 45 100 75 45 32 38 16 10 1 4 51 0 13 0 19 1 101 10 1 5 51 1 10 1 40 -18 43 2 15 17 14 102 13 1 14 103 13 6 13 7 13 8 13 9 13 10 10 11 6 6 12 13 21 13 20 19 7 104 43 6 43 7 44 2 29) #399# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #400=#A(t (21) (c::lambda-form-allowed-nargs lambda call-arguments-limit c::maxarg c::minarg c::c1form-args #:g20283 #:g20284 si::dm-too-few-arguments c::requireds c::optionals rest c::key-flag c::keywords c::a-o-k si::dm-too-many-arguments length / + #Y(c::lambda-form-allowed-nargs nil nil (24 45 1 26 9 0 14 2 46 3 46 4 13 2 19 1 5 4 45 6 10 0 45 7 10 0 76 39 6 13 1 19 1 8 10 0 4 12 10 0 5 51 0 22 45 9 10 1 76 39 6 13 2 19 1 8 10 1 4 12 10 1 5 51 1 22 45 10 10 2 76 39 6 13 3 19 1 8 10 2 4 12 10 2 5 51 2 22 45 11 10 3 76 39 6 13 4 19 1 8 10 3 4 12 10 3 5 51 3 22 45 12 10 4 76 39 6 13 5 19 1 8 10 4 4 12 10 4 5 51 4 22 45 13 10 5 76 39 6 13 6 19 1 8 10 5 4 12 10 5 5 51 5 22 45 14 10 6 39 6 13 7 19 1 15 10 3 76 39 9 10 2 76 39 4 10 0 76 39 25 10 5 16 16 51 8 13 8 10 4 16 16 12 9 3 19 2 17 12 19 2 18 51 9 43 8 13 0 13 1 72 2 43 2 29) #400# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 174 12 19 2 175 1 0 73 29) #401=#A(t (176) (c::c2lambda-expr c::lambda-list c::body c::cfun c::fname c::use-narg c::required-lcls c::closure-type c::requireds second c::optionals third rest c::rest-loc fifth c::keywords sixth c::allow-other-keys length c::nreq / c::nopt c::nkey c::varargs c::policy-debug-variable-bindings c::policy-debug-ihs-frame c::fname-in-ihs-p c::simple-varargs t c::*permanent-data* c::*unwind-exit* c::*env* c::*inline-blocks* c::last-arg si::%dolist-var c::var c::var-ref-ccb fourth c::*tail-recursion-info* c::policy-check-nargs "if (ecl_unlikely(narg!=" ")) FEwrong_num_arguments_anonym();" c::wt-nl "if (ecl_unlikely(narg<" ")) FEwrong_num_arguments_anonym();" "if (ecl_unlikely(narg>" + ")) FEwrong_num_arguments_anonym();" c::open-inline-block si::c-arguments-limit > - subseq #:loop-list20336 #:loop-list-head20337 #:loop-list-tail20338 0 #:g20339 c::*c1nil* #:g20340 rplacd cddr nconc c::var-name c::next-lcl c::lcl c::*volatile* c::var-rep-type c::rep-type-name " " ";" c::wt #Y(c::wt-decl nil nil (24 45 35 26 13 0 19 1 63 12 19 1 64 45 65 19 0 42 14 66 13 1 19 1 67 12 19 1 68 12 15 69 13 0 15 70 19 5 71 10 0 73 43 1 29) #401# #1# 0) c::local #:g20343 #:g20344 si::structure-set #Y(c::do-decl nil nil (24 45 35 26 13 0 19 1 73 73 39 28 10 0 45 74 13 1 32 3 18 1 45 75 13 1 15 35 9 10 13 0 19 4 76 43 1 43 1 29) #401# #1# 0) #:loop-list20345 c::unboxed #:g20348 #:g20349 c::var-ref < c::opt cdddr c::key cddddr last c::lexical eq "lex~D" c::*level* 1- format "narg" #Y(c::last-variable nil nil (26 10 14 39 10 13 14 19 1 88 4 73 38 25 13 13 1 89 17 90 39 14 77 15 91 11 92 16 93 12 19 3 94 38 4 1 95 73 29) #401# #1# 0) "va_list args; va_start(args," ");" "ecl_va_list args; ecl_va_start(args," ",narg," ");" c::bind mapc c::*ihs-used-p* c::ihs reverse c::build-debug-lexical-env "ecl_ihs_push(cl_env_copy,&ihs," c::add-symbol ",_ecl_debug_env);" c::va-arg c::cl-va-arg c::va-arg-loc c::wt-nl-open-brace "int i = " ";" "if (i >= narg) {" c::*opened-c-braces* 1+ c::bind-init "} else {" "i++;" "}" c::wt-nl-close-brace " = cl_grab_rest_args(args);" "cl_object keyvars[" * "];" "cl_parse_key(args," "," "keys,keyvars" "cl_parse_key(args,0,NULL,NULL" ",(cl_object*)&" ",NULL" ",TRUE);" ",FALSE);" "va_end(args);" "ecl_va_end(args);" (c::keyvars 0) c::i c::keyvars[i] c::all-kwd c::kwd c::flag c::init c::c1form-name ext::location c::c1form-args #:g20362 #:g20363 rplaca #:g20364 #:g20365 "if (Null(" c::wt-loc ")) {" "} else {" #:g20366 #:g20367 "}" #:g20368 #:g20369 "#define " "keys (&" nreverse c::add-keywords ")" c::wt-nl-h c::tail-recursion-mark "TTL:" c::wt-nl1 c::c2expr c::close-inline-blocks #Y(c::c2lambda-expr nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 24 45 6 24 45 7 26 10 6 4 45 8 10 7 16 9 45 10 10 8 16 11 45 12 75 45 13 10 10 16 14 45 15 10 11 16 16 45 17 10 5 16 18 45 19 10 5 16 18 12 9 3 19 2 20 45 21 10 3 16 18 12 9 4 19 2 20 45 22 10 7 40 11 10 6 40 7 10 4 40 3 10 3 45 23 19 0 24 40 8 19 0 25 39 3 10 13 45 26 75 45 27 11 28 48 29 11 30 48 30 11 31 48 31 8 0 48 32 75 45 33 10 16 39 68 58 60 44 10 20 4 45 34 75 45 35 38 22 10 1 4 51 0 13 0 19 1 36 39 5 75 73 36 2 10 1 5 51 1 10 1 40 -24 75 51 0 11 28 43 2 63 39 20 10 19 16 9 76 39 13 10 19 16 11 76 39 6 10 19 16 37 76 39 11 14 38 10 19 4 3 52 38 38 4 75 52 38 19 0 39 39 69 10 15 39 4 10 3 76 39 12 15 40 13 6 15 41 19 3 42 38 46 10 3 39 42 10 12 39 10 15 43 13 6 15 44 19 3 42 10 10 40 7 10 8 40 3 10 7 76 39 16 15 45 13 6 13 5 19 2 46 12 15 47 19 3 42 19 0 48 13 6 14 49 19 2 50 39 137 13 5 13 6 14 49 19 2 51 12 19 2 46 51 5 11 49 51 6 58 60 92 77 13 13 14 49 19 2 52 12 46 53 46 35 75 6 1 45 54 10 0 45 55 57 56 61 2 2 51 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 1 45 57 13 4 14 58 75 6 3 45 59 13 1 10 0 17 60 10 0 43 1 43 1 16 61 51 1 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 12 13 11 19 2 62 51 11 13 12 9 0 14 49 19 3 52 51 12 11 28 51 3 31 2 72 77 77 13 14 46 78 46 35 57 56 61 2 2 56 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 19 1 79 39 28 10 1 45 80 13 2 32 5 18 1 45 81 13 1 15 35 9 10 13 0 19 4 76 43 1 43 1 35 0 0 62 43 2 10 12 39 12 13 12 19 1 82 12 9 1 19 2 83 39 16 75 51 12 10 13 40 7 10 10 40 3 10 9 51 5 10 13 45 84 38 31 10 0 4 12 32 1 18 1 10 0 16 11 39 10 10 0 16 11 12 32 1 18 1 10 0 16 85 12 53 0 10 0 2 39 -34 43 1 10 12 39 9 13 12 32 1 18 1 51 11 10 10 45 86 38 32 10 0 16 9 12 32 1 18 1 10 0 16 37 39 10 10 0 16 37 12 32 1 18 1 10 0 16 87 12 53 0 10 0 2 39 -35 43 1 43 2 10 3 39 66 30 1 96 10 11 40 7 10 9 40 3 10 8 76 39 14 13 7 13 6 19 2 46 12 9 30 19 2 83 51 2 39 15 15 97 32 0 18 0 12 15 98 19 3 42 38 17 15 99 32 0 18 0 12 15 100 13 7 15 101 19 5 42 43 1 33 102 12 13 14 13 12 19 3 103 10 2 39 43 19 0 48 11 28 52 104 15 105 11 30 3 52 30 19 0 24 39 11 10 12 16 106 12 14 28 19 2 107 15 108 13 16 19 1 109 12 15 110 19 3 42 10 11 39 143 10 1 39 5 1 111 38 3 1 112 45 113 19 0 114 15 115 13 7 15 116 19 3 42 10 12 45 84 38 101 15 117 19 1 42 11 118 16 119 48 118 10 0 16 9 12 10 0 4 12 19 2 120 10 0 16 11 39 10 77 10 0 16 11 12 19 2 102 44 1 15 121 19 1 42 11 118 16 119 12 14 30 49 30 49 118 15 122 19 1 42 13 1 10 0 4 12 19 2 102 10 0 16 11 39 11 14 28 10 0 16 11 12 19 2 102 44 2 15 123 19 1 42 10 0 16 85 12 53 0 10 0 2 39 -104 43 1 19 0 124 43 1 10 10 40 7 10 8 40 3 10 7 39 106 10 8 40 3 10 7 76 39 10 13 9 15 125 19 2 42 38 77 10 8 39 34 19 0 114 15 126 9 2 13 4 19 2 127 12 15 128 19 3 42 15 129 13 4 15 130 13 17 15 131 19 5 42 38 6 15 132 19 1 42 10 10 39 10 15 133 13 9 19 2 71 38 6 15 134 19 1 71 10 7 39 6 1 135 73 38 4 1 136 73 12 19 1 71 10 10 39 8 13 9 13 10 19 2 102 10 3 39 17 10 1 39 6 1 137 73 38 4 1 138 73 12 19 1 42 13 8 77 15 139 9 0 46 140 46 141 46 142 46 143 38 252 10 0 4 12 10 1 3 51 1 10 0 4 12 10 0 16 9 12 10 0 16 11 12 10 0 16 37 12 46 144 46 145 46 35 46 86 13 2 19 1 146 12 1 147 17 90 39 8 13 2 19 1 148 4 76 39 32 10 6 45 149 10 8 45 150 10 1 5 12 10 0 17 151 10 0 43 1 43 1 13 6 13 1 19 2 102 38 110 10 6 45 152 13 13 13 8 19 2 46 45 153 10 1 5 12 10 0 17 151 10 0 43 1 43 1 15 154 19 1 42 13 6 19 1 155 15 156 19 1 71 14 30 11 118 16 119 12 49 118 49 30 13 2 13 1 19 2 120 44 2 15 157 19 1 42 11 118 16 119 48 118 10 6 45 158 10 8 45 159 10 1 5 12 10 0 17 151 10 0 43 1 43 1 13 6 13 1 19 2 102 44 1 15 160 19 1 42 10 3 39 35 10 6 45 161 13 13 13 8 19 2 46 45 162 10 1 5 12 10 0 17 151 10 0 43 1 43 1 13 6 13 3 19 2 102 43 4 10 0 16 87 12 10 3 16 119 12 53 3 53 0 10 0 2 39 -255 10 1 39 24 15 163 13 21 15 164 10 1 16 165 12 19 1 166 12 15 167 19 5 168 19 0 124 43 4 11 38 39 13 15 169 11 30 3 52 30 15 170 19 1 171 13 18 19 1 172 19 0 173 44 4 29) #401# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 73 12 19 2 74 1 0 73 29) #402=#A(t (75) (c::optimize-funcall/apply-lambda c::lambda-form c::arguments c::apply-p c::body c::apply-list c::apply-var c::let-vars c::extra-stmts c::all-keys c::cmp-process-lambda-list c::aux-vars c::allow-other-keys c::keywords c::key-flag rest c::optionals c::requireds last gensym butlast copy-list c::scan c::form constantp c::aux-var #:g20417 #:g20418 rplaca si::%dolist-var c::i #:g20423 if pop (si::dm-too-few-arguments nil) "Too few arguments for lambda form ~S" lambda c::cmperr third second c::opt-value c::opt-flag c::opt-var #:g20429 t cdddr list* append list 0 #:g20438 #:g20439 fourth c::key-value c::key-var keyword eq 'si::missing-keyword si::search-keyword setf not 'si::missing-keyword cddddr si::check-keyword quote let* first delete-if-not nreverse declare ignorable si::find-declarations c::decl #Y(c::optimize-funcall/apply-lambda nil nil (24 45 1 24 45 2 24 45 3 26 75 45 4 75 45 5 75 45 6 75 45 7 75 45 8 75 45 9 10 8 4 12 19 1 10 47 6 11 47 5 12 47 4 13 47 3 14 47 2 15 47 1 16 45 17 10 13 39 21 13 14 19 1 18 4 51 11 19 0 19 51 10 13 14 19 1 20 51 14 10 14 16 21 51 14 10 14 45 22 38 61 10 0 4 45 23 13 0 19 1 24 76 39 40 19 0 19 45 25 13 0 10 1 6 2 12 10 12 3 51 12 10 2 45 26 10 1 45 27 13 1 10 0 17 28 10 0 43 1 43 1 43 1 43 1 10 0 5 12 53 0 10 0 2 39 -64 43 1 10 10 39 13 13 10 10 11 6 2 12 10 9 3 51 9 10 0 5 45 29 75 45 30 38 79 10 1 4 51 0 13 0 10 16 39 23 10 16 45 31 10 0 4 12 10 0 5 51 0 10 0 51 17 22 43 1 38 33 10 15 39 18 15 32 13 12 15 33 10 12 6 2 12 1 34 6 4 38 12 15 35 15 36 10 17 3 12 19 2 37 6 2 12 10 11 3 51 11 10 1 5 51 1 10 1 40 -81 43 2 10 1 5 45 22 38 132 10 0 4 12 10 0 16 38 12 10 0 16 39 12 46 40 46 41 46 42 10 18 39 41 13 0 10 18 45 43 10 0 4 12 10 0 5 51 0 10 0 51 19 22 43 1 6 2 12 13 1 1 44 6 2 12 10 13 7 3 51 13 38 59 10 17 39 36 13 0 15 32 13 14 15 33 10 14 6 2 12 10 2 6 4 6 2 12 13 1 10 14 6 2 12 10 13 7 3 51 13 38 20 13 0 10 2 6 2 12 13 1 75 6 2 12 10 13 7 3 51 13 43 3 10 0 16 45 12 53 0 10 0 2 39 -135 43 1 10 3 40 3 10 5 39 11 10 2 76 39 6 19 0 19 51 2 10 2 39 52 13 2 10 14 39 29 10 13 39 17 15 46 13 14 10 10 6 1 12 19 2 47 7 2 38 7 15 48 10 14 7 2 38 10 10 13 39 5 10 10 38 2 75 6 2 12 10 9 3 51 9 57 49 61 2 2 59 10 7 76 39 4 35 0 1 10 7 45 50 10 0 4 12 10 0 5 51 0 10 0 51 8 43 1 10 7 45 51 10 0 4 12 10 0 5 51 0 10 0 51 8 22 43 1 6 2 12 10 10 3 51 10 35 0 0 62 10 4 5 45 22 38 121 10 0 4 12 10 0 16 39 12 10 0 16 38 12 10 0 16 52 73 40 4 19 0 19 12 46 14 46 53 46 54 46 55 13 0 10 12 3 51 12 13 1 15 32 15 56 13 3 1 57 6 3 12 13 2 10 3 6 4 6 2 12 13 3 15 58 13 7 10 0 6 3 6 2 12 10 14 7 3 51 14 10 4 16 52 39 25 15 59 13 3 15 60 15 56 13 3 1 61 6 3 6 2 6 3 12 10 13 3 51 13 43 4 10 0 16 62 12 53 0 10 0 2 39 -124 43 1 10 3 39 4 10 5 76 39 19 15 63 13 2 15 64 10 7 6 2 6 3 12 10 8 3 51 8 15 65 33 66 12 13 9 19 2 67 16 68 12 10 10 73 39 14 15 69 15 70 10 10 6 2 6 2 6 1 73 12 10 15 5 12 19 1 71 47 1 4 45 72 13 0 13 10 13 1 19 3 47 12 43 2 19 2 47 7 3 73 43 7 29) #402# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 31 12 19 2 32 1 0 73 29) #403=#A(t (33) (c::c1let c::args let c::check-args-number #:g20456 c::bindings c::c1locally atom c::invalid-let-bindings let* c::c1let/let* c::temp #:loop-list20457 c::b #:loop-list-head20458 #:loop-list-tail20459 c::real-bindings #:loop-list-head20460 #:loop-list-tail20461 c::temp-names #:loop-list-head20462 #:loop-list-tail20463 c::temp-bindings 0 rplacd "LET" gensym nconc declare ignorable :read-only #Y(c::c1let nil nil (24 45 1 26 15 2 13 0 9 1 19 3 3 10 0 45 4 10 0 4 12 10 0 5 51 0 10 0 51 1 22 43 1 45 5 10 0 76 39 8 13 1 19 1 6 38 243 10 0 16 7 39 10 15 2 13 0 19 2 8 38 228 10 0 5 76 39 12 15 9 13 0 13 1 19 3 10 38 211 58 60 208 75 45 11 77 13 2 46 12 46 13 75 6 1 45 14 10 0 45 15 75 45 16 75 6 1 45 17 10 0 45 18 75 45 19 75 6 1 45 20 10 0 45 21 75 45 22 57 23 61 2 2 105 10 11 2 39 4 35 0 1 10 11 4 51 10 10 11 5 51 11 10 10 16 7 39 18 13 8 10 10 6 1 51 8 17 24 10 9 5 51 7 38 61 13 5 15 25 19 1 26 51 12 6 1 51 5 17 24 10 6 5 51 4 13 2 13 12 10 10 5 3 6 1 51 2 17 24 10 3 5 51 1 13 8 10 10 4 12 10 12 6 2 6 1 51 8 17 24 10 9 5 51 7 35 0 0 15 9 13 1 13 7 19 2 27 12 15 28 15 29 10 4 7 2 12 14 30 10 4 7 2 6 3 12 10 15 7 2 12 19 3 10 36 13 62 73 43 3 43 3 43 3 43 2 43 1 63 43 1 29) #403# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #404=#A(t (12) (c::c1let* c::args let* c::check-args-number #:g20466 c::bindings c::c1locally atom c::invalid-let-bindings c::c1let/let* #Y(c::c1let* nil nil (24 45 1 26 15 2 13 0 9 1 19 3 3 10 0 45 4 10 0 4 12 10 0 5 51 0 10 0 51 1 22 43 1 45 5 10 0 76 39 8 13 1 19 1 6 38 25 10 0 16 7 39 10 15 2 13 0 19 2 8 38 10 15 2 13 0 13 1 19 3 9 43 1 29) #404# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 24 12 19 2 25 1 0 73 29) #405=#A(t (26) (c::c1let/let* c::let/let* c::bindings c::body c::*setjmps* c::setjmps c::cmp-env-copy c::*cmp-env* c::process-let-bindings c::forms c::vars c::c1let-optimize-read-only-vars c::check-vref mapc c::global-var-p some c::sp-change :type c::c1form-type :volatile eql :local-vars :args c::make-c1form* #Y(c::c1let/let* nil nil (24 45 1 24 45 2 24 45 3 26 11 4 45 5 19 0 6 48 7 13 3 13 2 13 1 19 3 8 47 2 3 47 1 9 45 10 13 0 13 1 13 2 19 3 11 51 0 55 1 1 33 12 12 13 0 19 2 13 33 14 12 13 0 19 2 15 45 16 13 7 14 17 13 3 19 1 18 12 14 19 13 4 11 4 17 20 76 12 14 21 13 1 14 22 13 1 13 2 13 3 19 11 23 43 1 43 3 43 1 44 1 29) #405# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #406=#A(t (7) (c::invalid-let-bindings c::let/let* c::bindings "Syntax error in ~A bindings:~%~4I~A" c::cmperr #Y(c::invalid-let-bindings nil nil (24 45 1 24 45 2 26 15 3 13 1 13 0 19 3 4 29) #406# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 48 12 19 2 49 1 0 73 29) #407=#A(t (50) (c::process-let-bindings c::let/let* c::bindings c::body c::c1body c::other-decls c::ignoreds c::types c::specials c::forms c::vars c::form c::name c::b #:g20500 symbolp "LET/LET* binding" c::check-args-number c::c1make-var c::var c::var-type type c::default-init c::trivial-type-p c::c1expr ext::checked-value c::init c::read-only-variable-p c::global-var-p "Found :READ-ONLY declaration for global var ~A" c::cmpwarn #:g20505 c::c1form-primary-type #:g20506 si::structure-set let* eq c::push-vars atom c::invalid-let-bindings nreverse let mapc c::var-name mapcar c::check-vdecl c::c1declare-specials c::c1decl-body #Y(c::process-let-bindings nil nil (24 45 1 24 45 2 24 45 3 26 13 0 77 19 2 4 47 4 5 47 3 6 47 2 7 47 1 8 45 3 77 77 46 9 46 10 13 8 77 77 46 11 46 12 46 13 38 200 10 0 45 14 10 0 4 12 10 0 5 51 0 10 0 51 1 22 43 1 51 2 16 15 39 10 10 2 51 1 75 51 2 38 22 15 16 13 2 9 1 9 2 19 4 17 10 2 4 51 1 10 2 5 51 2 13 1 13 6 13 8 13 7 19 4 18 45 19 13 0 19 1 20 45 21 10 4 76 39 8 13 1 19 1 22 38 30 13 0 19 1 23 39 10 10 4 4 12 19 1 24 38 14 15 25 13 0 10 4 4 6 3 12 19 1 24 45 26 13 4 13 12 19 2 27 39 43 13 2 19 1 28 39 10 15 29 13 4 19 2 30 38 27 10 2 45 31 13 1 19 1 32 45 33 13 1 15 19 9 11 13 0 19 4 34 43 1 43 1 13 2 10 6 3 51 6 13 0 10 7 3 51 7 13 15 1 35 17 36 39 6 13 2 19 1 37 43 3 10 0 16 38 39 -204 10 0 76 76 39 8 13 12 13 11 19 2 39 43 3 10 0 16 40 51 0 10 1 16 40 51 1 13 9 1 41 17 36 39 9 33 37 12 13 0 19 2 42 33 43 12 13 0 19 2 44 12 13 4 13 5 19 3 45 13 3 19 1 46 13 0 13 1 13 6 13 2 19 2 47 12 72 3 43 2 43 5 29) #407# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 30 12 19 2 31 1 0 73 29) #408=#A(t (32) (c::c1let-optimize-read-only-vars c::all-vars c::all-forms c::body c::base c::vars nconc c::forms c::var c::form c::rest-vars c::rest-forms c::read-only-p #:loop-list-head20515 #:loop-list-tail20516 c::used-vars #:loop-list-head20517 #:loop-list-tail20518 c::used-forms 0 atom c::var-set-nodes c::var-functions-reading c::var-functions-setting c::global-var-p c::fix-read-only-variable-type c::c1let-unused-variable-p c::c1let-constant-value-p c::c1let-constant-variable-p rplacd #Y(c::c1let-optimize-read-only-vars nil nil (24 45 1 24 45 2 24 45 3 26 58 60 274 10 1 6 1 45 4 10 4 45 5 13 4 10 3 6 1 12 19 2 6 45 7 75 45 8 75 45 9 75 45 10 75 45 11 75 45 12 75 6 1 45 13 10 0 45 14 75 45 15 75 6 1 45 16 10 0 45 17 75 45 18 57 19 61 2 11 176 10 13 16 20 39 4 35 0 1 10 12 16 20 39 4 35 0 1 10 13 4 51 11 10 12 4 51 10 10 13 5 51 9 10 12 5 51 8 13 11 19 1 21 76 39 23 13 11 19 1 22 76 39 15 13 11 19 1 23 76 39 7 13 11 19 1 24 76 51 7 10 7 39 10 13 11 13 10 13 8 19 3 25 10 7 39 34 13 11 13 10 19 2 26 40 25 13 11 13 10 13 9 13 8 19 4 27 40 12 13 11 13 10 13 9 13 8 19 4 28 76 39 31 13 5 10 11 6 1 51 5 17 29 10 6 5 51 4 13 2 10 10 6 1 51 2 17 29 10 3 5 51 1 10 13 5 51 13 10 13 16 20 39 4 35 0 1 10 12 5 51 12 35 0 0 13 4 13 1 72 2 36 15 62 73 43 3 43 3 43 1 43 1 43 1 43 1 43 1 43 1 43 1 43 1 63 29) #408# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #409=#A(t (17) (c::fix-read-only-variable-type c::var c::form c::rest-forms c::var-type c::var-name :unsafe "In LET body" c::and-form-type c::c1form-primary-type c::form-type #:g20521 #:g20522 si::structure-set c::update-variable-type #Y(c::fix-read-only-variable-type nil nil (24 45 1 24 45 2 24 45 3 26 13 2 19 1 4 12 13 1 13 2 19 1 5 12 14 6 15 7 19 5 8 13 1 19 1 9 45 10 10 3 45 11 10 1 45 12 13 1 15 1 9 11 13 0 19 4 13 43 1 43 1 13 3 13 0 19 2 14 43 1 29) #409# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #410=#A(t (17) (c::c1let-unused-variable-p c::var c::form c::var-ref = c::var-kind (special c::global) member c::form-causes-side-effect c::var-ignorable "Removing unused variable ~A" c::var-name c::cmpdebug c::delete-c1forms t #Y(c::c1let-unused-variable-p nil nil (24 45 1 24 45 2 26 9 0 13 1 19 1 3 12 19 2 4 39 21 13 1 19 1 5 12 15 6 19 2 7 76 39 7 13 0 19 1 8 76 73 39 28 13 1 19 1 9 76 39 12 15 10 13 1 19 1 11 12 19 2 12 13 0 19 1 13 11 14 73 29) #410# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #411=#A(t (17) (c::c1let-constant-value-p c::var c::form c::rest-vars c::rest-forms c::c1form-name ext::location eq c::c1form-args c::loc-in-c1form-movable-p "Replacing variable ~A by its value ~A" c::var-name c::cmpdebug c::nsubst-var t #Y(c::c1let-constant-value-p nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 2 19 1 5 12 1 6 17 7 39 11 13 2 19 1 8 4 12 19 1 9 73 39 24 15 10 13 3 19 1 11 12 13 2 19 3 12 13 3 13 2 19 2 13 11 14 73 29) #411# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #412=#A(t (19) (c::c1let-constant-variable-p c::var c::form c::rest-vars c::rest-forms c::c1form-name eq c::c1form-args c::other-var c::global-var-p member c::var-changed-in-form-list "Replacing variable ~A by its value ~A" c::var-name c::cmpdebug c::nsubst-var t #Y(c::c1let-constant-variable-p nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 2 19 1 5 12 1 1 17 6 73 39 61 13 2 19 1 7 4 45 8 13 0 19 1 9 40 17 13 0 13 2 19 2 10 40 8 13 0 13 1 19 2 11 76 73 39 24 15 12 13 4 19 1 13 12 13 3 19 3 14 13 4 13 3 19 2 15 11 16 73 43 1 29) #412# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #413=#A(t (19) (c::c2let-replaceable-var-ref-p c::var c::form c::rest-forms c::c1form-name eq c::var-set-nodes c::local c::c1form-args c::var1 c::unboxed c::var-changed-in-form-list "Replacing variable ~a by its value" c::var-name c::cmpdebug c::nsubst-var t #Y(c::c2let-replaceable-var-ref-p nil nil (24 45 1 24 45 2 24 45 3 26 13 1 19 1 4 12 1 1 17 5 39 14 13 2 19 1 6 76 39 6 13 2 19 1 7 73 39 65 13 1 19 1 8 4 45 9 13 0 19 1 7 39 24 13 3 19 1 10 12 13 0 19 1 10 17 5 39 9 13 0 13 1 19 2 11 76 73 39 22 15 12 13 3 19 1 13 12 19 2 14 13 3 13 2 19 2 15 11 16 73 43 1 29) #413# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #414=#A(t (20) (c::c1let-can-move-variable-value-p c::var c::form c::rest-vars c::rest-forms c::var-ref = c::form-causes-side-effect c::v c::var-referenced-in-form #Y(nil nil nil (24 45 8 26 13 0 13 3 19 2 9 29) #414# #1# 0) notany c::replaceable "Replacing variable ~A by its value ~A" c::var-name c::cmpdebug c::nsubst-var t #Y(c::c1let-can-move-variable-value-p nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 9 1 13 3 19 1 5 12 19 2 6 39 26 13 2 19 1 7 76 39 18 34 10 12 13 1 19 2 11 39 8 13 3 13 0 19 2 12 73 39 24 15 13 13 3 19 1 14 12 13 2 19 3 15 13 3 13 2 19 2 16 11 17 73 29) #414# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #415=#A(t (11) (c::read-only-variable-p c::v c::other-decls si::%dolist-var c::i :read-only eq member t #Y(c::read-only-variable-p nil nil (24 45 1 24 45 2 26 58 60 58 10 1 45 3 75 45 4 38 37 10 1 4 51 0 10 0 4 12 11 5 17 6 39 10 13 4 10 0 5 12 19 2 7 39 6 11 8 73 36 2 10 1 5 51 1 10 1 40 -39 75 51 0 75 73 43 2 63 29) #415# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #416=#A(t (12) (c::env-grows c::possibily c::*env* plusp c::*unwind-exit* si::%dolist-var ext::exit return c::bds-bind t #Y(c::env-grows nil nil (24 45 1 26 10 0 73 39 60 11 2 16 3 73 39 53 58 60 50 11 4 45 5 75 45 6 38 32 10 1 4 51 0 10 0 42 7 7 75 73 36 2 38 11 42 8 3 38 6 11 9 73 36 2 10 1 5 51 1 10 1 40 -34 75 73 43 2 63 29) #416# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #417=#A(t (18) (c::replaceable c::var c::form c::c1form-name eq c::c1form-args t c::c1form-side-effects #Y(c::abort-on-side-effects nil nil (24 45 2 26 13 0 19 1 3 12 1 1 17 4 39 21 13 4 13 0 19 1 5 4 17 4 73 39 6 11 6 73 36 2 38 13 13 0 19 1 7 73 39 5 75 73 36 2 29) #417# #1# 0) c::traverse-c1form-tree :format-control "In REPLACEABLE, variable ~A not found. Form:~%~A" :format-arguments c::var-name c::*current-form* c::baboon #Y(c::replaceable nil nil (24 45 1 24 45 2 26 57 0 60 35 31 1 8 13 2 32 0 12 19 2 9 14 10 15 11 14 12 13 3 19 1 13 12 11 14 6 2 12 19 4 15 43 1 63 29) #417# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 68 12 19 2 69 1 0 73 29) #418=#A(t (70) (c::c2let* c::c1form c::vars c::forms c::body c::c1form-volatile* c::*volatile* c::*unwind-exit* c::*env* c::*env-lvl* c::*inline-blocks* #:loop-list20538 c::var append c::rest-forms c::form #:loop-list-head20539 #:loop-list-tail20540 c::used-vars #:loop-list-head20541 #:loop-list-tail20542 c::used-forms 0 atom c::c2let-replaceable-var-ref-p rplacd #:loop-list20547 c::kind c::local c::maybe-open-inline-block c::var-name c::next-lcl c::bind c::rep-type-name " " ";" c::wt-nl c::var-ref-ccb some c::env-lvl "cl_object env" #:g20549 + " = env" ";" #:loop-list20550 #:loop-list20551 c::var-kind c::lexical c::closure special c::global c::c1form-name ext::location c::c1form-args c::bind-init c::*destination* c::c2expr* c::policy-debug-variable-bindings c::wt-nl-open-brace c::build-debug-lexical-env c::env c::ihs-env c::c2expr c::wt-nl-close-brace c::pop-debug-lexical-env :line c::close-inline-blocks #Y(c::c2let* nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 3 19 1 5 48 6 11 7 48 7 11 8 48 8 11 9 48 9 8 0 48 10 77 13 2 46 11 46 12 13 3 10 2 6 1 12 19 2 13 45 14 75 45 15 75 6 1 45 16 10 0 45 17 75 45 18 75 6 1 45 19 10 0 45 20 75 45 21 57 22 61 2 20 101 10 10 2 39 4 35 0 1 10 10 4 51 9 10 10 5 51 10 10 8 16 23 39 4 35 0 1 10 8 4 51 7 13 9 13 7 13 8 19 3 24 76 39 31 13 5 10 9 6 1 51 5 17 25 10 6 5 51 4 13 2 10 7 6 1 51 2 17 25 10 3 5 51 1 10 10 2 39 4 35 0 1 10 10 4 51 9 10 10 5 51 10 10 8 5 51 8 35 0 0 10 4 51 13 10 1 51 12 62 43 3 43 3 43 1 43 1 43 2 77 13 2 46 26 46 12 75 45 27 57 22 61 2 2 68 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 13 2 19 1 28 51 1 10 1 39 36 19 0 29 13 2 19 1 30 12 19 1 31 12 13 2 19 2 32 14 6 13 1 19 1 33 12 15 34 13 2 15 35 19 5 36 35 0 0 62 43 1 43 2 33 37 12 13 2 19 2 38 39 39 19 0 29 11 9 45 39 14 6 15 40 8 1 45 41 14 9 13 0 19 2 42 52 9 12 43 1 15 43 13 0 15 44 19 6 36 43 1 77 13 1 46 45 46 15 77 13 4 46 46 46 12 57 22 61 2 2 116 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 19 1 47 41 48 10 41 49 7 41 50 4 42 51 49 13 3 19 1 52 42 53 15 13 3 19 1 54 4 12 13 1 19 2 32 38 25 42 12 15 13 3 19 1 54 4 12 13 1 19 2 32 38 8 13 3 13 1 19 2 55 38 12 10 1 48 56 13 3 19 1 57 44 1 35 0 0 62 43 2 43 2 19 0 58 39 47 11 7 48 7 19 0 59 13 2 19 1 60 45 61 10 0 39 8 15 62 11 7 3 52 7 13 1 19 1 63 19 0 64 10 0 39 4 19 0 65 43 1 44 1 38 6 13 0 19 1 63 14 66 19 1 67 44 5 29) #418# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 24 12 19 2 25 1 0 73 29) #419=#A(t (26) (c::discarded c::var c::form c::body last c::x c::c1form-args c::args c::c1form-name progn let let* flet labels block catch #Y(c::last-form nil nil (24 45 5 26 13 0 19 1 6 45 7 13 1 19 1 8 42 9 16 10 0 4 12 19 1 4 4 12 32 2 18 1 38 47 41 10 16 41 11 13 41 12 10 41 13 7 41 14 4 42 15 14 13 0 19 1 4 4 12 32 2 18 1 38 16 42 1 10 13 1 19 1 6 4 73 38 4 10 1 73 29) #419# #1# 0) c::form-causes-side-effect c::var-ref < = eq c::trash c::*destination* #Y(c::discarded nil nil (24 45 1 24 45 2 24 45 3 26 75 45 4 31 1 16 13 3 19 1 17 76 73 39 48 13 4 19 1 18 12 9 1 19 2 19 73 40 34 13 4 19 1 18 12 9 1 19 2 20 73 39 20 13 4 13 2 32 0 18 1 17 21 73 39 7 15 22 11 23 17 21 43 1 29) #419# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #420=#A(t (23) (c::nsubst-var c::var c::form c::var-set-nodes :format-control "Cannot replace a variable that is to be changed" c::baboon c::var-functions-reading "Cannot replace a variable that forms part of a closure" c::var-read-forms si::%dolist-var c::where c::c1form-name eql c::c1form-args "VAR-READ-NODES are only C1FORMS of type VAR" c::delete-from-read-nodes c::c1form-replace-with #:g20555 #:g20556 si::structure-set #Y(c::nsubst-var nil nil (24 45 1 24 45 2 26 13 1 19 1 3 39 8 14 4 15 5 19 2 6 13 1 19 1 7 39 8 14 4 15 8 19 2 6 13 1 19 1 9 45 10 75 45 11 38 58 10 1 4 51 0 13 0 19 1 12 12 1 1 17 13 39 12 13 0 19 1 14 4 12 10 3 17 13 76 39 8 14 4 15 15 19 2 6 13 3 13 0 19 2 16 13 0 13 2 19 2 17 10 1 5 51 1 10 1 40 -60 43 2 10 1 45 18 8 0 45 19 13 1 15 1 9 13 13 0 19 4 20 43 1 43 1 29) #420# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #421=#A(t (16) (c::member-var c::var list c::var-kind c::kind (special c::global) member :test c::v1 c::v2 (special c::global) c::var-name eql #Y(nil nil nil (24 45 8 24 45 9 26 13 0 19 1 3 12 15 10 19 2 6 73 39 14 13 1 19 1 11 12 13 0 19 1 11 17 12 29) #421# #1# 0) #Y(c::member-var nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 4 13 0 15 5 19 2 6 39 15 13 2 13 1 14 7 34 13 12 19 4 6 38 8 13 2 13 1 19 2 6 43 1 29) #421# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #422=#A(t (7) (c::tmp-destination c::loc values c::trash return #Y(c::tmp-destination nil nil (24 45 1 26 10 0 42 2 6 1 2 73 38 12 42 3 6 1 3 73 38 4 1 4 73 29) #422# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #423=#A(t (8) (c::precise-loc-type c::loc c::new-type c::loc-type subtypep the #Y(c::precise-loc-type nil nil (24 45 1 24 45 2 26 13 1 19 1 3 12 13 0 19 2 4 39 6 10 1 73 38 10 15 5 13 0 10 1 6 3 73 29) #423# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #424=#A(t (21) (c::loc-in-c1form-movable-p c::loc (t nil) member t ext::fixnump stringp c::vv-p (c::value0 values c::va-arg c::cl-va-arg) atom :format-control "Unknown location ~A found in C1FORM" :format-arguments c::baboon the eq third (c::vv c::vv-temp c::fixnum-value c::character-value c::double-float-value c::single-float-value c::long-float-value c::keyvars) "Unknown location ~A found in C1FORM" #Y(c::loc-in-c1form-movable-p nil nil (24 45 1 26 13 0 15 2 19 2 3 39 6 11 4 73 38 122 10 0 16 5 39 6 11 4 73 38 111 10 0 16 6 39 6 11 4 73 38 100 13 0 19 1 7 39 6 11 4 73 38 88 13 0 15 8 19 2 3 39 5 75 73 38 75 10 0 16 9 39 17 14 10 15 11 14 12 10 0 6 1 12 19 4 13 38 53 10 0 4 12 1 14 17 15 39 11 10 0 16 16 12 19 1 0 38 33 10 0 4 51 0 12 15 17 19 2 3 39 6 11 4 73 38 15 14 10 15 18 14 12 10 0 6 1 12 19 4 13 29) #424# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #425=#A(t (12) (c::uses-values c::loc consp (c::call c::call-normal c::call-indirect) :test eq member ffi::c-inline sixth values #Y(c::uses-values nil nil (24 45 1 26 10 0 16 2 73 39 38 10 0 4 12 15 3 14 4 33 5 12 19 4 6 73 40 21 10 0 4 12 1 7 17 5 73 39 10 10 0 16 8 12 1 9 17 5 29) #425# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #426=#A(t (18) (c::loc-immediate-value-p c::loc t eq ext::fixnump c::vv-p c::vv-value c::value atom the third (c::fixnum-value c::long-float-value c::double-float-value c::single-float-value) member second c::character-value code-char #Y(c::loc-immediate-value-p nil nil (24 45 1 26 13 0 11 2 17 3 39 9 14 2 14 2 72 2 38 151 13 0 75 17 3 39 8 14 2 77 72 2 38 137 10 0 16 4 39 9 14 2 13 0 72 2 38 123 13 0 19 1 5 39 35 13 0 19 1 6 45 7 10 0 76 40 5 10 0 16 4 39 7 77 77 72 2 38 7 14 2 13 0 72 2 43 1 38 82 10 0 16 8 39 7 77 77 72 2 38 70 10 0 4 12 1 9 17 3 39 11 10 0 16 10 12 19 1 0 38 50 10 0 4 12 15 11 19 2 12 39 12 14 2 10 0 16 13 12 72 2 38 28 10 0 4 12 1 14 17 3 39 14 14 2 10 0 16 13 16 15 12 72 2 38 5 77 77 72 2 29) #426# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #427=#A(t (5) (c::loc-immediate-value c::loc c::loc-immediate-value-p #Y(c::loc-immediate-value nil nil (24 45 1 26 9 1 13 0 19 1 2 74 73 29) #427# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #428=#A(t (9) (c::unknown-location c::where c::loc :format-control "Unknown location found in ~A~%~S" :format-arguments c::baboon #Y(c::unknown-location nil nil (24 45 1 24 45 2 26 14 3 15 4 14 5 13 1 10 0 6 2 12 19 4 6 29) #428# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #429=#A(t (20) (c::wt-loc c::loc consp c::*wt-loc-dispatch-table* gethash c::fd apply c::unknown-location symbolp :not-found c::txt eq c::wt stringp c::var-p c::wt-var c::vv-p c::wt-vv #Y(c::wt-loc nil nil (24 45 1 26 10 0 16 2 39 38 10 0 4 12 14 3 19 2 4 45 5 10 0 39 12 13 0 10 1 5 12 19 2 6 38 8 15 0 13 1 19 2 7 43 1 38 90 10 0 16 8 39 36 13 0 14 3 14 9 19 3 4 45 10 13 0 11 9 17 11 39 8 15 0 13 1 19 2 7 13 0 19 1 12 43 1 38 49 10 0 16 13 39 8 13 0 19 1 12 38 36 13 0 19 1 14 39 8 13 0 19 1 15 38 22 13 0 19 1 16 39 8 13 0 19 1 17 38 8 15 0 13 0 19 2 7 29) #429# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #430=#A(t (6) (c::last-call-p c::*exit* (return c::return-fixnum c::return-character c::return-single-float c::return-double-float c::return-long-float c::return-object) member #Y(c::last-call-p nil nil (26 14 1 15 2 19 2 3 29) #430# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #431=#A(t (8) (c::wt-lcl c::lcl numberp c::baboon "v" c::wt #Y(c::wt-lcl nil nil (24 45 1 26 10 0 16 2 76 39 4 19 0 3 15 4 13 0 19 2 5 29) #431# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #432=#A(t (10) (c::wt-lcl-loc c::lcl type c::name numberp c::baboon "v" c::wt #Y(c::wt-lcl-loc nil nil (24 45 1 25 40 2 77 46 2 25 40 2 77 46 3 26 10 2 16 4 76 39 4 19 0 5 15 6 13 2 13 0 19 3 7 29) #432# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #433=#A(t (6) (c::wt-temp c::temp "T" c::wt #Y(c::wt-temp nil nil (24 45 1 26 15 2 13 0 19 2 3 29) #433# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #434=#A(t (6) (c::wt-number c::value c::vv c::wt #Y(c::wt-number nil nil (24 45 1 25 40 2 77 46 2 26 13 1 19 1 3 29) #434# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #435=#A(t (6) (c::wt-character c::value c::vv c::wt #Y(c::wt-character nil nil (24 45 1 25 40 2 77 46 2 26 13 1 19 1 3 29) #435# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #436=#A(t (7) (c::wt-value c::i "cl_env_copy->values[" "]" c::wt #Y(c::wt-value nil nil (24 45 1 26 15 2 13 0 15 3 19 3 4 29) #436# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #437=#A(t (7) (c::wt-keyvars c::i "keyvars[" "]" c::wt #Y(c::wt-keyvars nil nil (24 45 1 26 15 2 13 0 15 3 19 3 4 29) #437# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #438=#A(t (6) (c::wt-the type c::loc c::wt-loc #Y(c::wt-the nil nil (24 45 1 24 45 2 26 13 0 19 1 3 29) #438# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #439=#A(t (15) (c::loc-refers-to-special c::loc c::var-p c::var-kind (special c::global) member atom the eq third c::bind t ffi::c-inline #Y(c::loc-refers-to-special nil nil (24 45 1 26 13 0 19 1 2 39 14 13 0 19 1 3 12 15 4 19 2 5 38 63 10 0 16 6 39 5 75 73 38 53 10 0 4 12 1 7 17 8 39 11 10 0 16 9 12 19 1 0 38 33 10 0 4 51 0 12 1 10 17 8 39 6 11 11 73 38 16 13 0 1 12 17 8 39 6 11 11 73 38 3 75 73 29) #439# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #440=#A(t (5) (c::values-loc c::n c::value #Y(c::values-loc nil nil (24 45 1 26 15 2 10 0 6 2 73 29) #440# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #441=#A(t (7) (c::set-unknown-loc c::loc c::set-loc c::*destination* c::unknown-location #Y(c::set-unknown-loc nil nil (24 45 1 26 15 2 14 3 19 2 4 29) #441# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 24 12 19 2 25 1 0 73 29) #442=#A(t (26) (c::set-loc c::loc c::fd c::*destination* c::destination eq symbolp c::*set-loc-dispatch-table* c::set-unknown-loc gethash c::var-p c::set-var c::vv-p c::set-vv atom c::unknown-location apply c::wt-nl c::wt-loc " = " c::wt c::loc-representation-type c::wt-coerce-loc ";" #Y(c::set-loc nil nil (24 45 1 26 75 45 2 11 3 45 4 13 0 10 2 17 5 73 40 130 10 0 16 6 39 18 13 0 14 7 15 8 19 3 9 12 13 2 20 1 23 38 107 13 0 19 1 10 39 10 13 2 13 0 19 2 11 38 91 13 0 19 1 12 39 10 13 2 13 0 19 2 13 38 75 10 0 16 14 39 10 15 0 13 0 19 2 15 38 60 10 0 4 12 14 7 19 2 9 45 2 10 0 39 14 13 0 13 3 10 1 5 12 19 3 16 38 30 19 0 17 13 1 19 1 18 15 19 19 1 20 14 3 19 1 21 12 13 3 19 2 22 15 23 19 1 20 43 1 43 1 29) #442# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #443=#A(t (8) (c::set-the-loc c::loc type c::orig-loc c::*destination* c::set-loc #Y(c::set-the-loc nil nil (24 45 1 24 45 2 24 45 3 26 10 0 48 4 13 2 19 1 5 44 1 29) #443# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #444=#A(t (16) (c::set-values-loc c::loc values eq c::uses-values "cl_env_copy->values[0] = " c::wt-nl :object c::wt-coerce-loc ";" c::wt "cl_env_copy->values[0] = " ";" "cl_env_copy->nvalues = 1;" #Y(c::set-values-loc nil nil (24 45 1 26 13 0 1 2 17 3 73 40 49 13 0 19 1 4 39 20 15 5 19 1 6 14 7 13 0 19 2 8 15 9 19 1 10 38 23 15 11 19 1 6 14 7 13 0 19 2 8 15 12 19 1 10 15 13 19 1 6 29) #444# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #445=#A(t (10) (c::set-value0-loc c::loc "value0 = " c::wt-nl :object c::wt-coerce-loc ";" c::wt #Y(c::set-value0-loc nil nil (24 45 1 26 15 2 19 1 3 14 4 13 0 19 2 5 15 6 19 1 7 29) #445# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #446=#A(t (19) (c::set-return-loc c::loc values eq c::uses-values "value0 = " c::wt-nl :object c::wt-coerce-loc ";" c::wt c::value0 "cl_env_copy->nvalues = 1;" return "value0 = " ";" "cl_env_copy->nvalues = 1;" #Y(c::set-return-loc nil nil (24 45 1 26 13 0 1 2 17 3 40 6 13 0 19 1 4 39 20 15 5 19 1 6 14 7 13 0 19 2 8 15 9 19 1 10 38 47 13 0 1 11 17 3 39 8 15 12 19 1 6 38 32 13 0 1 13 17 3 73 40 23 15 14 19 1 6 14 7 13 0 19 2 8 15 15 19 1 10 15 16 19 1 6 29) #446# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #447=#A(t (22) (c::loc-with-side-effects-p c::loc c::name c::var-p c::global-var-p c::policy-global-var-checking atom (c::call c::call-normal c::call-indirect) :test eq member t the third fdefinition c::policy-global-function-checking ffi::c-inline sixth values fifth #Y(c::loc-with-side-effects-p nil nil (24 45 1 26 75 45 2 13 1 19 1 3 39 14 13 1 19 1 4 73 39 4 19 0 5 38 90 10 1 16 6 39 5 75 73 38 80 10 1 4 51 0 12 15 7 14 8 33 9 12 19 4 10 39 6 11 11 73 38 57 13 0 1 12 17 9 39 11 10 1 16 13 12 19 1 0 38 39 13 0 1 14 17 9 39 6 19 0 15 38 26 13 0 1 16 17 9 73 39 17 10 1 16 17 12 1 18 17 9 73 40 5 10 1 16 19 29) #447# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #448=#A(t (8) (c::set-trash-loc c::loc c::loc-with-side-effects-p ";" c::wt-nl t #Y(c::set-trash-loc nil nil (24 45 1 26 13 0 19 1 2 73 39 11 13 0 15 3 19 2 4 11 5 73 29) #448# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 46 12 19 2 47 1 0 73 29) #449=#A(t (48) (c::expand-mapcar c::whole length < program-error "Too few arguments to function ~A in form: ~A" c::firt si::signal-simple-error c::which funcall eq consp function second cddr c::args c::iterators c::for-statements :in c::in-or-on :collect c::do-or-collect c::list-1-form c::finally-form mapcar maplist :on mapc :do mapl mapcan nconc mapcon gensym c::var c::with = c::finally return reverse #:loop-list20576 c::arg 0 :for loop append #Y(c::expand-mapcar nil nil (24 45 1 26 57 0 60 322 10 1 16 2 12 9 3 19 2 3 39 18 33 4 12 77 15 5 13 1 19 1 6 12 13 1 19 5 7 10 1 4 45 8 13 0 1 9 17 10 39 40 10 2 5 51 2 10 2 4 51 0 10 0 16 11 39 24 10 0 4 12 1 12 17 10 39 9 10 0 16 13 51 0 38 6 10 2 73 36 1 10 2 16 13 45 12 10 3 16 14 45 15 75 45 16 75 45 17 11 18 45 19 11 20 45 21 75 45 22 75 45 23 10 8 42 24 3 38 52 42 25 7 11 26 51 3 38 43 42 27 7 11 28 51 2 38 34 42 29 11 11 26 51 3 11 28 51 2 38 21 42 30 7 1 31 51 2 38 12 42 32 9 11 26 51 3 1 31 51 2 13 2 11 28 17 10 39 42 19 0 33 45 34 15 35 13 0 15 36 10 7 4 6 4 51 2 13 0 10 7 5 7 2 51 7 15 37 15 38 10 0 6 2 6 2 51 1 43 1 77 10 6 16 39 12 46 40 46 41 57 42 61 2 2 50 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 19 0 33 45 34 13 0 10 9 3 51 9 14 43 13 0 13 7 13 2 10 8 7 5 51 8 43 1 35 0 0 62 43 2 15 44 13 1 13 4 13 2 15 9 13 7 10 5 7 3 12 10 0 7 3 12 19 3 45 7 2 73 43 8 43 1 63 29) #449# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 8 12 19 3 9 1 0 73 29) #450=#A(t (10) (mapcar compiler-macro #:g20582 #:g20581 c::whole #:g20583 c::r c::expand-mapcar #Y(mapcar nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 13 2 19 1 7 29) #450# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 8 12 19 3 9 1 0 73 29) #451=#A(t (10) (mapc compiler-macro #:g20585 #:g20584 c::whole #:g20586 c::r c::expand-mapcar #Y(mapc nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 13 2 19 1 7 29) #451# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 8 12 19 3 9 1 0 73 29) #452=#A(t (10) (mapcan compiler-macro #:g20588 #:g20587 c::whole #:g20589 c::r c::expand-mapcar #Y(mapcan nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 13 2 19 1 7 29) #452# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 8 12 19 3 9 1 0 73 29) #453=#A(t (10) (maplist compiler-macro #:g20591 #:g20590 c::whole #:g20592 c::r c::expand-mapcar #Y(maplist nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 13 2 19 1 7 29) #453# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 8 12 19 3 9 1 0 73 29) #454=#A(t (10) (mapl compiler-macro #:g20594 #:g20593 c::whole #:g20595 c::r c::expand-mapcar #Y(mapl nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 13 2 19 1 7 29) #454# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 8 12 19 3 9 1 0 73 29) #455=#A(t (10) (mapcon compiler-macro #:g20597 #:g20596 c::whole #:g20598 c::r c::expand-mapcar #Y(mapcon nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 13 2 19 1 7 29) #455# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+ecl-stack-frame-variable+ "_ecl_inner_frame" si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+ecl-local-stack-frame-variable+ "__frame" si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+ecl-local-stack-variable+ "__frame_sp" si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #456=#A(t (15) (c::c1with-stack c::forms #:g20600 c::var let (c::innermost-stack-frame) c::c1expr c::body c::with-stack :type c::c1form-type :args c::make-c1form* #Y(c::c1with-stack nil nil (24 45 1 26 10 0 45 2 10 0 4 12 10 0 5 51 0 10 0 51 1 22 43 1 45 3 15 4 13 0 1 5 6 2 6 1 12 10 1 7 3 12 19 1 6 45 7 15 8 14 9 13 0 19 1 10 12 14 11 13 0 19 5 12 43 2 29) #456# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #457=#A(t (21) (c::c2with-stack c::c1form c::body c::*destination* c::tmp-destination c::new-destination c::*temp* c::wt-nl-open-brace "struct ecl_stack_frame _ecl_inner_frame_aux;" c::wt-nl c::*volatile* "cl_object _ecl_inner_frame = ecl_stack_frame_open(cl_env_copy,(cl_object)&_ecl_inner_frame_aux,0);" c::stack c::+ecl-stack-frame-variable+ c::*unwind-exit* c::c2expr* "ecl_stack_frame_close(_ecl_inner_frame);" c::wt-nl-close-brace c::unwind-exit #Y(c::c2with-stack nil nil (24 45 1 24 45 2 26 14 3 19 1 4 45 5 11 6 48 6 19 0 7 15 8 19 1 9 14 10 15 11 19 2 9 10 0 48 3 15 12 11 13 6 2 12 11 14 7 2 48 14 13 1 19 1 15 44 2 15 16 19 1 9 19 0 17 13 0 19 1 18 43 1 44 1 29) #457# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #458=#A(t (8) (c::c1innermost-stack-frame c::args ffi::c-inline :object c::+ecl-stack-frame-variable+ (:one-liner t :side-effects nil) #Y(c::c1innermost-stack-frame nil nil (24 45 1 26 15 2 77 77 14 3 14 4 1 5 7 6 73 29) #458# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #459=#A(t (7) (c::c1stack-push c::args progn ffi::c-inline ((t t) :void "ecl_stack_frame_push(#0,#1)" :one-liner t :side-effects t) #Y(c::c1stack-push nil nil (24 45 1 26 15 2 15 3 13 0 1 4 7 3 12 8 1 6 3 73 29) #459# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #460=#A(t (16) (c::c1stack-push-values c::args #:g20603 #:g20604 c::form c::frame-var c::stack-push-values :type (values) :args c::c1expr ffi::c-inline ((t) :void "ecl_stack_frame_push_values(#0)" :one-liner t :side-effects t) c::make-c1form* #Y(c::c1stack-push-values nil nil (24 45 1 26 10 0 45 2 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 10 0 45 3 10 0 4 12 10 0 5 51 0 10 0 51 1 43 1 46 4 46 5 15 6 14 7 15 8 14 9 13 1 19 1 10 12 15 11 10 0 6 1 12 1 12 7 3 12 19 1 10 12 19 6 13 43 2 29) #460# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #461=#A(t (10) (c::c2stack-push-values c::c1form c::form c::push-statement values c::*destination* c::c2expr* c::c2expr #Y(c::c2stack-push-values nil nil (24 45 1 24 45 2 24 45 3 26 1 4 48 5 13 1 19 1 6 44 1 13 0 19 1 7 29) #461# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #462=#A(t (6) (c::c1stack-pop c::args ffi::c-inline ((t) (values &rest t) "cl_env_copy->values[0]=ecl_stack_frame_pop_values(#0);" :one-liner nil :side-effects t) #Y(c::c1stack-pop nil nil (24 45 1 26 15 2 13 0 1 3 7 3 73 29) #462# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #463=#A(t (6) (c::c1apply-from-stack-frame c::args ffi::c-inline ((t t) (values &rest t) "cl_env_copy->values[0]=ecl_apply_from_stack_frame(#0,#1);" :one-liner nil :side-effects t) #Y(c::c1apply-from-stack-frame nil nil (24 45 1 26 15 2 13 0 1 3 7 3 73 29) #463# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 15 28 1 31 12 19 2 27 1 28 73 29) #464=#A(t (32) (c::c1multiple-value-call c::args c::forms multiple-value-call c::check-args-number c::c1funcall length = second consp values eq gensym c::frame function c::with-stack let* #:loop-list20608 c::i #:loop-list-head20609 #:loop-list-tail20610 0 c::stack-push-values rplacd si::apply-from-stack-frame append #Y(c::c1multiple-value-call nil nil (24 45 1 26 75 45 2 15 3 13 1 9 1 19 3 4 10 1 5 2 39 8 13 1 19 1 5 38 174 10 1 16 6 12 9 2 19 2 7 39 18 10 1 16 8 51 0 16 9 39 8 15 10 10 0 4 17 11 39 16 10 1 4 12 10 0 5 7 2 12 19 1 5 38 128 19 0 12 12 19 0 12 12 46 13 46 14 15 15 13 1 15 16 13 0 10 3 4 6 2 6 1 12 58 60 75 77 10 4 5 12 46 17 46 18 75 6 1 45 19 10 0 45 20 57 21 61 2 2 38 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 15 22 13 7 10 3 6 3 6 1 51 1 17 23 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 12 15 24 13 1 10 0 6 3 6 1 12 19 2 25 7 3 6 3 73 43 2 29) #464# #1# 0) si::fset c::c1multiple-value-prog1 multiple-value-prog1 c::stack-pop #Y(c::c1multiple-value-prog1 nil nil (24 45 1 26 15 29 13 0 9 1 19 3 4 19 0 12 45 13 15 15 13 0 15 22 13 0 10 1 4 6 3 12 10 1 5 12 15 30 10 0 6 2 6 1 12 19 2 25 7 4 73 43 1 29) #464# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #465=#A(t (8) (c::c1values c::args values :args c::c1args* c::make-c1form* #Y(c::c1values nil nil (24 45 1 26 15 2 14 3 13 0 19 1 4 12 19 3 5 29) #465# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 45 12 19 2 46 1 0 73 29) #466=#A(t (47) (c::c2values c::c1form c::forms c::*destination* c::return-object eq c::*current-form* consp defun "Trying to return multiple values. ~
              ~%;But ~a was proclaimed to have single value.~
              ~%;Only first one will be assured." second c::cmpwarn c::trash c::c2expr* mapc c::value0 c::unwind-exit return "value0 = ECL_NIL;" c::wt-nl "cl_env_copy->nvalues = 0;" values "cl_env_copy->values[0] = ECL_NIL;" "cl_env_copy->nvalues = 0;" c::form (return values) member c::c1form-single-valued-p c::c2expr length c::nv c::*inline-blocks* c::*temp* c::inline-args c::coerce-locs nreverse "cl_env_copy->nvalues = " ";" 1- c::i c::vl "cl_env_copy->values[" "] = " ";" c::close-inline-blocks #Y(c::c2values nil nil (24 45 1 24 45 2 26 14 3 1 4 17 5 39 19 10 0 5 39 14 11 6 16 7 39 8 15 8 11 6 4 17 5 39 11 15 9 11 6 16 10 12 19 2 11 14 3 1 12 17 5 39 16 33 13 12 13 0 19 2 14 15 15 19 1 16 38 215 10 0 2 39 57 14 3 1 17 17 5 39 18 15 18 19 1 19 15 20 19 1 19 15 17 19 1 16 38 30 14 3 1 21 17 5 39 18 15 22 19 1 19 15 23 19 1 19 15 21 19 1 16 38 5 77 19 1 16 38 154 10 0 5 2 39 50 10 0 4 45 24 14 3 15 25 19 2 26 76 40 6 13 0 19 1 27 39 8 13 0 19 1 28 38 17 1 15 48 3 13 0 19 1 13 44 1 15 15 19 1 16 43 1 38 99 10 0 16 29 45 30 8 0 48 31 11 32 48 32 13 1 19 1 33 12 19 1 34 16 35 45 2 15 36 13 1 15 37 19 3 19 13 0 10 0 16 29 16 38 12 46 39 46 40 38 29 15 41 13 1 15 42 10 0 4 12 15 43 19 5 19 10 0 5 12 10 1 16 38 12 53 1 53 0 10 0 76 39 -32 43 2 15 21 19 1 16 19 0 44 43 2 44 2 29) #466# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 39 12 19 2 40 1 0 73 29) #467=#A(t (41) (c::c1multiple-value-setq c::args c::vars c::temp-vars c::late-bindings multiple-value-setq c::check-args-number reverse si::%dolist-var c::var symbolp "The variable ~s is not a symbol." c::cmperr c::chk-symbol-macrolet c::var-or-form t type constantp "The constant ~s is being assigned a value." c::policy-type-assertions c::variable-type-in-env c::trivial-type-p gensym c::new-var setf ext::checked-value second c::value let* values length = setq c::c1expr c::c1vref mapcar :args c::make-c1form* c::add-to-set-nodes-of-var-list #Y(c::c1multiple-value-setq nil nil (24 45 1 26 75 45 2 75 45 3 75 45 4 15 5 13 3 9 2 9 2 19 4 6 10 3 4 16 7 45 8 75 45 9 38 130 10 1 4 51 0 10 0 16 10 76 39 8 15 11 13 0 19 2 12 13 0 19 1 13 45 14 11 15 45 16 10 1 16 10 39 43 13 1 19 1 17 39 8 15 18 13 1 19 2 12 19 0 19 76 40 12 13 1 19 1 20 51 0 12 19 1 21 39 10 13 1 10 6 3 51 6 11 15 76 39 42 19 0 22 45 23 13 0 10 7 3 51 7 13 0 10 6 3 51 6 15 24 13 2 15 25 13 1 10 0 6 3 6 3 12 10 5 3 51 5 43 1 43 2 10 1 5 51 1 10 1 40 -132 43 2 10 3 16 26 45 27 10 2 39 21 15 28 13 2 15 5 13 3 10 0 6 3 12 10 1 7 4 73 38 74 10 3 2 39 10 15 29 10 0 6 2 73 38 60 10 3 16 30 12 9 1 19 2 31 39 14 15 32 10 3 4 12 10 0 6 3 73 38 35 13 0 19 1 33 51 0 33 34 12 13 3 19 2 35 51 3 13 3 15 5 14 36 13 3 13 0 19 4 37 12 19 2 38 43 1 29) #467# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #468=#A(t (13) (c::bind-or-set c::loc c::v c::use-bind c::set-var c::var-ref plusp c::var-kind (special c::global) member c::bind #Y(c::bind-or-set nil nil (24 45 1 24 45 2 24 45 3 26 10 0 76 39 10 13 2 13 1 19 2 4 38 31 13 1 19 1 5 16 6 40 12 13 1 19 1 7 12 15 8 19 2 9 73 39 8 13 2 13 1 19 2 10 29) #468# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #469=#A(t (7) (c::values-loc-or-value0 c::i plusp c::values-loc c::value0 #Y(c::values-loc-or-value0 nil nil (24 45 1 26 10 0 16 2 39 8 13 0 19 1 3 38 4 1 4 73 29) #469# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 44 12 19 2 45 1 0 73 29) #470=#A(t (46) (c::do-m-v-setq c::vars c::form c::use-bind c::min-values c::max-values length = c::*destination* c::c2expr* c::c1form-values-number return max si::%dotimes-var c::i #:g20633 c::values-loc-or-value0 c::loc c::v c::bind-or-set 1+ < c::useful-var-p some c::*lcl* :type :int c::make-lcl-var c::nr c::tmp c::wt-nl-open-brace "const int " " = cl_env_copy->nvalues;" c::wt-nl "cl_object " ";" #:loop-list20634 0 " = (" "<=" ")? ECL_NIL : " ";" c::wt-nl-close-brace c::value0 #Y(c::do-m-v-setq nil nil (24 45 1 24 45 2 24 45 3 26 75 45 4 75 45 5 57 0 60 307 10 5 16 6 12 9 1 19 2 7 39 18 10 5 4 48 8 13 4 19 1 9 11 8 73 36 0 44 1 13 4 19 1 10 47 1 5 45 4 1 11 48 8 13 6 19 1 9 44 1 9 1 13 0 19 2 12 51 0 10 0 45 13 8 0 45 14 38 51 10 9 39 41 10 9 45 15 10 0 4 12 10 0 5 51 0 10 0 51 10 43 1 13 0 19 1 16 12 46 17 46 18 13 1 13 0 13 9 19 3 19 43 2 10 0 16 20 51 0 13 0 13 1 19 2 21 40 -58 43 2 33 22 12 13 7 19 2 23 39 161 11 24 48 24 14 25 14 26 19 2 27 45 28 19 0 27 45 29 19 0 30 15 31 13 1 15 32 19 3 33 15 34 13 0 15 35 19 3 33 77 13 9 46 36 46 18 10 4 45 14 75 45 17 57 37 61 2 20 88 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 2 19 1 16 51 1 13 3 19 1 22 39 29 13 5 15 38 13 6 15 39 13 2 15 40 13 1 15 41 19 8 33 13 5 13 3 13 12 19 3 19 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 2 16 20 51 2 35 0 0 62 43 1 43 1 43 2 19 0 42 43 2 44 1 1 43 73 43 2 63 29) #470# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #471=#A(t (8) (c::c2multiple-value-setq c::c1form c::vars c::form c::do-m-v-setq c::unwind-exit #Y(c::c2multiple-value-setq nil nil (24 45 1 24 45 2 24 45 3 26 13 1 13 0 77 19 3 4 12 19 1 5 29) #471# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 39 12 19 2 40 1 0 73 29) #472=#A(t (41) (c::c1multiple-value-bind c::args multiple-value-bind c::check-args-number c::cmp-env-copy c::*cmp-env* #:g20635 c::variables #:g20636 c::init-form length = let* c::c1body c::other-decls c::is c::ts c::ss c::body c::c1declare-specials #:loop-list20637 c::name #:loop-list-head20638 #:loop-list-tail20639 0 c::c1make-var rplacd c::vars c::c1expr c::push-vars mapc c::check-vdecl c::c1decl-body c::check-vref :type c::c1form-type :local-vars :args c::make-c1form* #Y(c::c1multiple-value-bind nil nil (24 45 1 26 57 0 60 270 15 2 13 1 9 2 19 3 3 19 0 4 48 5 10 1 45 6 10 0 4 12 10 0 5 51 0 10 0 51 2 22 43 1 45 7 10 2 45 8 10 0 4 12 10 0 5 51 0 10 0 51 3 22 43 1 45 9 10 1 16 10 12 9 1 19 2 11 39 21 15 12 10 1 4 12 10 0 6 2 6 1 12 10 3 7 3 73 36 2 13 3 77 19 2 13 47 4 14 47 3 15 47 2 16 47 1 17 45 18 13 1 19 1 19 58 60 75 77 13 7 46 20 46 21 75 6 1 45 22 10 0 45 23 57 24 61 2 2 41 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 13 3 13 7 13 9 13 8 19 4 25 6 1 51 1 17 26 35 0 0 10 2 5 73 36 5 62 43 2 43 2 63 45 27 13 6 19 1 28 51 6 33 29 12 13 0 19 2 30 13 7 13 3 13 4 19 3 31 13 5 13 1 19 2 32 51 1 33 33 12 13 0 19 2 30 15 2 14 34 13 1 19 1 35 12 14 36 13 0 14 37 13 0 13 6 13 1 19 9 38 43 1 43 5 43 2 44 1 63 29) #472# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 45 12 19 2 46 1 0 73 29) #473=#A(t (47) (c::c2multiple-value-bind c::c1form c::vars c::init-form c::body c::*unwind-exit* c::*env-lvl* c::*env* c::*lcl* labels c::env-grows :type :int c::make-lcl-var c::nr c::*inline-blocks* c::min-values c::max-values c::c1form-values-number si::%dolist-var c::var c::local c::kind c::useful-var-p c::maybe-open-inline-block c::next-lcl c::bind c::*volatile* c::rep-type-name " " ";" c::wt-nl c::var-name c::wt-comment c::var-ref-ccb c::env-lvl "volatile cl_object env" #:g20643 + " = env" ";" t c::do-m-v-setq c::c2expr c::close-inline-blocks #Y(c::c2multiple-value-bind nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 11 5 48 5 11 6 48 6 11 7 48 7 11 8 48 8 75 45 9 75 45 10 14 11 14 12 19 2 13 45 14 8 0 48 15 75 45 16 75 45 17 13 6 19 1 18 51 1 55 0 1 10 7 45 19 75 45 20 38 83 10 1 4 51 0 13 0 19 1 21 45 22 10 0 39 48 13 1 19 1 23 39 39 19 0 24 19 0 25 12 13 1 19 2 26 14 27 13 0 19 1 28 12 15 29 13 1 15 30 19 5 31 13 1 19 1 32 12 19 1 33 38 13 10 6 76 39 8 13 1 19 1 34 51 6 43 1 10 1 5 51 1 10 1 40 -85 43 2 13 3 19 1 10 51 3 39 37 11 6 45 35 19 0 24 15 36 8 1 45 37 14 6 13 0 19 2 38 52 6 12 43 1 15 39 13 0 15 40 19 5 31 43 1 13 7 13 6 14 41 19 3 42 13 5 19 1 43 19 0 44 43 5 44 5 29) #473# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #474=#A(t (9) (c::c1quote c::args quote c::check-args-number :always t c::c1constant-value #Y(c::c1quote nil nil (24 45 1 26 15 2 13 0 9 1 9 1 19 4 3 10 0 4 12 14 4 14 5 19 3 6 29) #474# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #475=#A(t (7) (c::c1declare c::args "The declaration ~s was found in a bad place." declare c::cmperr #Y(c::c1declare nil nil (24 45 1 26 15 2 15 3 10 0 3 12 19 2 4 29) #475# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #476=#A(t (13) (c::c1the c::args the c::check-args-number type c::policy-the-is-checked consp values eq c::c1checked-value c::c1truly-the #Y(c::c1the nil nil (24 45 1 26 15 2 13 0 9 2 9 2 19 4 3 10 0 4 45 4 19 0 5 39 16 10 0 16 6 39 9 10 0 4 12 1 7 17 8 76 39 8 13 1 19 1 9 38 6 13 1 19 1 10 43 1 29) #476# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #477=#A(t (21) (c::c1truly-the c::args ext::truly-the c::check-args-number second c::c1expr c::form c::the-type type c::c1form-type c::values-type-and c::values-type-primary-type #:g20648 #:g20649 c::c1form si::structure-set "Type mismatch was found in ~s." the c::cmpwarn #Y(c::c1truly-the nil nil (24 45 1 26 15 2 13 0 9 2 9 2 19 4 3 10 0 16 4 12 19 1 5 45 6 10 1 4 45 7 75 45 8 13 1 13 2 19 1 9 12 19 2 10 51 0 13 0 19 1 11 39 26 10 2 45 12 10 1 45 13 13 1 15 14 9 1 13 0 19 4 15 43 1 43 1 38 12 15 16 15 17 10 3 3 12 19 2 18 10 2 73 43 3 29) #477# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #478=#A(t (21) (c::c1compiler-let c::args c::symbols values ext::compiler-let c::too-few-args si::%dolist-var c::spec consp symbolp cddr "The variable binding ~s is illegal." c::cmperr second eval "The variable binding ~s is illegal." nreverse c::c1progn c::make-c1form #Y(c::c1compiler-let nil nil (24 45 1 26 75 45 2 75 45 3 10 2 2 39 10 15 4 9 1 9 0 19 3 5 10 2 4 45 6 75 45 7 38 106 10 1 4 51 0 10 0 16 8 39 62 10 0 4 16 9 39 12 10 0 5 2 40 6 10 0 16 10 2 76 39 8 15 11 13 0 19 2 12 10 0 4 12 10 3 3 51 3 10 0 5 2 39 5 75 73 38 7 10 0 16 13 16 14 12 10 2 3 51 2 38 29 10 0 16 9 39 16 13 0 10 3 3 51 3 77 10 2 3 51 2 38 8 15 15 13 0 19 2 12 10 1 5 51 1 10 1 40 -108 43 2 10 1 16 16 51 1 10 0 16 16 51 0 13 1 10 0 67 10 2 5 12 19 1 17 68 51 2 15 4 13 2 13 1 13 0 13 2 19 5 18 29) #478# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #479=#A(t (8) (c::c2compiler-let c::c1form c::symbols values c::body c::c2expr #Y(c::c2compiler-let nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 2 10 1 67 13 0 19 1 5 68 29) #479# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 36 12 19 2 37 1 0 73 29) #480=#A(t (38) (c::c1function c::args c::fd function c::check-args-number c::fun si::valid-function-name-p t c::local-function-ref c::funob c::fun-var c::var :args c::make-c1form* c::add-to-read-nodes :type :sp-change symbolp c::no-sp-change si::get-sysprop c::global consp (lambda ext::lambda-block) member "The lambda expression ~s is illegal." c::cmperr c::body c::name lambda eq gensym second cddr flet c::c1expr "The function ~s is illegal." #Y(c::c1function nil nil (24 45 1 26 75 45 2 15 3 13 1 9 1 9 1 19 4 4 10 1 4 45 5 10 0 16 6 39 76 13 0 14 7 19 2 8 45 9 10 0 39 27 13 0 19 1 10 45 11 13 0 15 11 14 12 13 0 19 3 13 12 19 2 14 43 1 38 33 15 3 14 15 15 3 14 16 10 1 16 17 39 7 13 1 1 18 17 19 76 12 14 12 15 20 77 13 1 19 9 13 43 1 38 105 10 0 16 21 39 10 10 0 4 12 15 22 19 2 23 39 81 10 0 5 2 39 8 15 24 13 0 19 2 25 77 77 46 26 46 27 10 2 4 12 1 28 17 29 39 13 19 0 30 51 0 10 2 5 51 1 38 13 10 2 16 31 51 0 10 2 16 32 51 1 15 33 13 0 10 1 7 2 6 1 12 15 3 10 0 6 2 6 3 12 19 1 34 43 2 38 8 15 35 13 0 19 2 25 43 1 29) #480# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #481=#A(t (14) (c::c2function c::c1form c::kind c::funob c::fun c::global fdefinition c::unwind-exit c::closure c::baboon c::new-local c::make-cclosure #Y(c::c2function nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 10 2 42 5 13 15 6 10 0 6 2 12 19 1 7 38 26 42 8 21 19 0 9 13 0 19 1 10 15 11 10 0 6 2 12 19 1 7 38 3 75 73 29) #481# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 37 12 19 2 38 1 0 73 29) #482=#A(t (39) (c::new-local c::fun c::fun-closure c::closure #:g20691 #:g20692 si::structure-set #:g20693 c::*env* #:g20694 c::lexical c::fun-parent c::parent #:g20695 c::*lex* plusp c::*level* 1+ #:g20696 #:g20697 #:g20698 #:g20699 #:g20700 #:g20701 #:g20702 c::previous eq "Sharing code for closure" c::cmpnote "Sharing code for local function ~A" c::fun-name #:g20703 c::fun-cfun #:g20704 #:g20705 #:g20706 c::*local-funs* #Y(c::new-local nil nil (24 45 1 26 13 0 19 1 2 42 3 49 10 0 45 4 8 0 45 5 13 1 15 1 9 6 13 0 19 4 6 43 1 43 1 10 0 45 7 11 8 45 9 13 1 15 1 9 7 13 0 19 4 6 43 1 43 1 38 119 42 10 70 13 0 19 1 11 45 12 10 1 45 13 11 14 16 15 39 7 11 16 16 17 38 3 11 16 45 18 13 1 15 1 9 6 13 0 19 4 6 43 1 43 1 10 1 45 19 8 0 45 20 13 1 15 1 9 7 13 0 19 4 6 43 1 43 1 43 1 38 47 10 0 45 21 8 0 45 22 13 1 15 1 9 7 13 0 19 4 6 43 1 43 1 10 0 45 23 8 0 45 24 13 1 15 1 9 6 13 0 19 4 6 43 1 43 1 75 45 25 10 0 39 84 13 1 19 1 2 12 1 3 17 26 39 8 15 27 19 1 28 38 12 15 29 13 1 19 1 30 12 19 2 28 10 1 45 31 13 1 19 1 32 45 33 13 1 15 1 9 5 13 0 19 4 6 43 1 43 1 10 1 45 34 75 45 35 13 1 15 1 9 15 13 0 19 4 6 43 1 43 1 10 0 73 38 9 13 1 11 36 3 52 36 73 43 1 29) #482# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 34 12 19 2 35 1 0 73 29) #483=#A(t (36) (c::wt-fdefinition c::fun-name si::function-block-name c::name symbol-package package c::safe-compile "CL" find-package eq "CLOS" "SI" fboundp fdefinition functionp c::safe c::add-symbol c::vv "(" "->symbol.gfdef)" c::wt "ecl_fdefinition(" ")" c::*setf-definitions* assoc c::set-loc c::data-empty-loc c::setf-vv c::name-vv "ECL_CONS_CAR(" second ")" "ecl_fdefinition(" ")" #Y(c::wt-fdefinition nil nil (24 45 1 26 10 0 16 2 45 3 10 0 16 4 45 5 19 0 6 76 40 43 13 0 1 7 16 8 17 9 40 19 13 0 1 10 16 8 17 9 40 9 13 0 1 11 16 8 17 9 39 13 10 2 16 12 39 7 10 2 16 13 16 14 45 15 13 2 10 3 17 9 39 36 13 2 19 1 16 45 17 10 1 39 12 15 18 13 0 15 19 19 3 20 38 10 15 21 13 0 15 22 19 3 20 43 1 38 84 10 0 39 62 13 2 14 23 19 2 24 45 25 10 0 76 39 32 19 0 26 45 27 13 4 19 1 16 45 28 13 5 13 1 10 0 6 3 51 2 13 2 11 23 3 52 23 43 2 15 29 10 0 16 30 12 15 31 19 3 20 43 1 38 19 13 3 19 1 16 45 17 15 32 13 0 15 33 19 3 20 43 1 43 3 29) #483# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #484=#A(t (14) (c::environment-accessor c::fun c::*env-lvl* c::env-var-name c::env-var c::fun-env c::expected-env-size c::*env* < "ecl_nthcdr(~D,~A)" - format #Y(c::environment-accessor nil nil (24 45 1 26 14 2 19 1 3 45 4 13 1 19 1 5 45 6 13 0 14 7 19 2 8 39 19 77 15 9 14 7 13 0 19 2 10 12 13 1 19 4 11 38 4 10 1 73 43 2 29) #484# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #485=#A(t (23) (c::wt-make-closure c::fun c::fun-cfun c::cfun c::fun-closure c::closure c::narg eq "ecl_make_cclosure_va((cl_objectfn)" "," c::environment-accessor ",Cblock)" c::wt c::lexical c::baboon c::fun-fixed-narg "ecl_make_cfun((cl_objectfn_fixed)" ",ECL_NIL,Cblock," ")" "ecl_make_cfun_va((cl_objectfn)" ",ECL_NIL,Cblock)" #Y(c::wt-make-closure nil nil (24 45 1 26 13 0 19 1 2 45 3 13 1 19 1 4 45 5 75 45 6 13 1 1 5 17 7 39 20 15 8 13 2 15 9 13 3 19 1 10 12 15 11 19 5 12 38 47 13 1 1 13 17 7 39 6 19 0 14 38 34 13 3 19 1 15 51 0 39 16 15 16 13 2 15 17 13 0 15 18 19 5 12 38 10 15 19 13 2 15 20 19 3 12 43 2 29) #485# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 60 52 0 1 0 73 29) #A(t (3) (c::*reg-amount* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 28 12 19 2 29 1 0 73 29) #486=#A(t (30) (c::add-loop-registers tagbody c::form c::c1form-p c::c1form-args si::%dolist-var c::v consp c::var-p #:g20720 most-positive-fixnum #:g20721 c::var si::structure-set #Y(c::add-reg1 nil nil (24 45 2 26 13 0 19 1 3 39 39 13 0 19 1 4 45 5 75 45 6 38 17 10 1 4 51 0 13 0 32 4 18 1 10 1 5 51 1 10 1 40 -19 75 73 43 2 38 73 10 0 16 7 39 36 10 0 45 5 75 45 6 38 17 10 1 4 51 0 13 0 32 4 18 1 10 1 5 51 1 10 1 40 -19 75 73 43 2 38 32 13 0 19 1 8 73 39 24 10 0 45 9 11 10 45 11 13 1 15 12 9 1 13 0 19 4 13 43 1 43 1 29) #486# #1# 0) c::clause c::tag-name c::c1form-name go eq atom #Y(c::jumps-to-p nil nil (24 45 15 24 45 16 26 13 1 19 1 3 39 31 13 1 19 1 17 12 1 18 17 19 73 39 16 13 1 19 1 4 4 12 19 1 16 12 10 0 17 19 38 34 10 1 16 20 39 5 75 73 38 24 10 1 4 12 13 0 32 2 18 2 73 40 11 10 1 5 12 13 0 32 2 18 2 29) #486# #1# 0) first c::end c::tag-p c::name c::w c::ww #Y(c::add-loop-registers nil nil (24 45 1 26 31 2 14 21 13 2 77 77 46 22 46 23 46 6 38 72 10 0 4 12 19 1 24 39 57 10 2 76 39 5 10 0 51 2 10 0 5 12 10 0 4 12 19 1 16 12 46 25 46 26 38 23 10 0 4 12 13 1 32 5 18 2 39 5 10 0 51 3 10 0 5 12 53 0 10 0 76 39 -26 43 2 10 0 5 12 53 0 10 0 76 39 -75 10 2 45 27 38 15 10 0 4 12 32 5 18 1 10 0 5 12 53 0 13 0 10 2 17 19 39 -21 10 0 4 12 32 5 18 1 43 1 43 3 43 2 29) #486# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 54 12 19 2 55 1 0 73 29) #487=#A(t (56) (c::c1tagbody c::orig-body c::cmp-env-copy c::*cmp-env* :name tagbody :kind c::make-var c::tag-var c::tag-index c::body #:loop-list20722 c::x #:loop-list-head20723 #:loop-list-tail20724 0 consp :var :index c::make-tag c::tag c::tag-name c::cmp-env-register-tag #:g20726 + rplacd #:loop-list20727 c::form c::output c::tag-body c::tagbody-beginnnig c::this-tag c::tag-p (nil) nreconc c::c1progn (nil) #:loop-list20738 c::tag-ref plusp last c::c1expr nconc c::var-ref zerop progn :args delete-if c::make-c1form* c::var-ref-ccb #:g20745 c::*setjmps* c::add-loop-registers :local-vars #Y(c::c1tagbody nil nil (24 45 1 26 19 0 2 48 3 14 4 15 5 14 6 77 19 4 7 45 8 8 0 45 9 75 45 10 57 0 60 437 58 60 121 77 13 5 46 11 46 12 75 6 1 45 13 10 0 45 14 57 15 61 2 2 87 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 10 3 16 16 39 5 10 3 38 48 14 4 13 3 14 17 13 9 14 18 13 8 19 6 19 45 20 13 0 19 1 21 12 13 0 19 2 22 8 1 45 23 13 10 13 0 19 2 24 51 10 43 1 10 0 43 1 6 1 51 1 17 25 35 0 0 10 2 5 73 36 5 62 43 2 43 2 63 51 1 77 13 1 46 26 46 27 75 45 28 75 45 29 14 4 15 30 14 6 77 19 4 7 45 31 57 15 61 2 2 68 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 13 4 19 1 32 39 33 10 2 39 20 13 2 1 33 17 34 12 19 1 35 12 10 3 3 51 3 75 51 2 13 4 10 3 3 51 3 38 8 13 4 10 2 3 51 2 35 0 0 10 2 39 17 13 2 1 36 17 34 12 19 1 35 12 10 3 3 38 3 10 3 51 7 62 43 1 43 1 43 1 43 2 77 13 1 46 37 46 27 75 45 28 57 15 61 2 2 46 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 13 2 19 1 32 76 40 8 13 2 19 1 38 16 39 39 8 13 2 10 1 3 51 1 35 0 0 10 1 51 5 62 43 1 43 2 10 1 76 39 7 77 19 1 35 36 0 13 1 19 1 40 4 12 19 1 32 39 15 13 1 77 19 1 41 6 1 12 19 2 42 51 1 13 3 19 1 43 16 44 39 19 15 45 14 46 33 32 12 13 1 19 2 47 12 19 3 48 36 0 13 3 19 1 49 39 16 8 1 45 50 14 51 13 0 19 2 24 52 51 43 1 13 1 19 1 52 15 5 14 53 10 3 6 1 12 14 46 13 3 13 1 19 6 48 63 44 1 29) #487# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 61 12 19 2 62 1 0 73 29) #488=#A(t (63) (c::c2tagbody c::c1form c::tag-loc c::body c::var-kind si::%dolist-var c::x c::tag-p c::tag-ref plusp #:g20770 c::next-label* #:g20771 c::tag si::structure-set #:g20772 c::*unwind-exit* #:g20773 c::c2tagbody-body c::frame c::*env* c::*env-lvl* c::*lex* c::*lcl* c::var-ref-ccb c::env-grows c::*inline-blocks* c::env-lvl c::maybe-open-inline-block "volatile cl_object env" #:g20775 + " = env" ";" c::wt-nl :object eq #:g20776 c::next-lcl #:g20777 c::var "cl_object " ";" t "ECL_NEW_FRAME_ID(cl_env_copy)" c::bind "if (ecl_frs_push(cl_env_copy," ")) {" #:g20782 c::next-label #:g20783 #:g20784 #:g20785 "if (cl_env_copy->values[0]==ecl_make_fixnum(" c::tag-index "))" c::tag-label c::wt-go "ecl_internal_error(\"GO found an inexistent tag\");" "}" c::close-inline-blocks #Y(c::c2tagbody nil nil (24 45 1 24 45 2 24 45 3 26 13 1 19 1 4 76 39 99 10 0 45 5 75 45 6 38 74 10 1 4 51 0 13 0 19 1 7 39 8 13 0 19 1 8 16 9 39 48 10 0 45 10 19 0 11 45 12 13 1 15 13 9 5 13 0 19 4 14 43 1 43 1 10 0 45 15 11 16 45 17 13 1 15 13 9 6 13 0 19 4 14 43 1 43 1 10 1 5 51 1 10 1 40 -76 75 51 0 13 2 19 1 18 43 2 38 287 15 19 11 16 3 12 14 20 14 21 14 22 14 23 9 0 13 1 19 1 24 12 19 1 25 12 46 25 49 26 49 23 49 22 49 21 49 20 49 16 10 0 39 37 11 21 45 27 19 0 28 15 29 8 1 45 30 14 21 13 0 19 2 31 52 21 12 43 1 15 32 13 0 15 33 19 5 34 43 1 14 35 13 2 19 1 4 17 36 39 41 10 2 45 37 19 0 38 45 39 13 1 15 40 9 10 13 0 19 4 14 43 1 43 1 19 0 28 15 41 13 2 15 42 19 3 34 11 43 51 0 15 44 13 2 19 2 45 15 46 13 2 15 47 19 3 34 10 1 45 5 75 45 13 38 96 10 1 4 51 0 13 0 19 1 7 39 8 13 0 19 1 8 16 9 39 70 10 0 45 48 19 0 49 45 50 13 1 15 13 9 5 13 0 19 4 14 43 1 43 1 10 0 45 51 11 16 45 52 13 1 15 13 9 6 13 0 19 4 14 43 1 43 1 15 53 13 0 19 1 54 12 15 55 19 3 34 13 0 19 1 56 12 19 1 57 10 1 5 51 1 10 1 40 -98 43 2 13 2 19 1 24 39 6 15 58 19 1 34 15 59 19 1 34 13 1 19 1 18 19 0 60 43 1 44 6 29) #488# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #489=#A(t (17) (c::c2tagbody-body c::body c::l c::this-form c::tag-p c::tag-label c::wt-label c::c2expr second c::next-form c::next-label c::*exit* c::*unwind-exit* c::trash c::*destination* #Y(c::c2tagbody-body nil nil (24 45 1 26 10 0 45 2 38 103 10 0 4 45 3 13 0 19 1 4 39 12 13 0 19 1 5 12 19 1 6 38 72 10 1 5 2 39 8 13 0 19 1 7 38 59 10 1 16 8 45 9 13 0 19 1 4 39 8 13 0 19 1 5 38 4 19 0 10 48 11 14 11 11 12 3 48 12 1 13 48 14 13 1 19 1 7 13 0 19 1 4 76 39 6 14 11 19 1 6 43 1 44 3 43 1 10 0 5 12 53 0 10 0 76 39 -106 75 73 43 1 29) #489# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 45 12 19 2 46 1 0 73 29) #490=#A(t (47) (c::c1go c::args go c::check-args-number c::name symbolp integerp "The tag name ~s is not a symbol nor an integer." c::cmperr c::cmp-env-search-tag c::unw c::clb c::ccb c::tag "Undefined tag ~A" c::tag-var c::var #:g20803 t #:g20804 si::structure-set #:g20805 #:g20806 #:g20807 c::closure #:g20808 #:g20809 #:g20810 #:g20811 #:g20812 #:g20813 c::lexical #:g20814 c::var-kind #:g20815 :object #:g20816 #:g20817 #:g20819 c::tag-ref + #:g20818 :args c::make-c1form* c::add-to-read-nodes #Y(c::c1go nil nil (24 45 1 26 15 2 13 0 9 1 9 1 19 4 3 10 0 4 45 4 10 0 16 5 40 5 10 0 16 6 76 39 8 15 7 13 0 19 2 8 13 0 19 1 9 47 3 10 47 2 11 47 1 12 45 13 10 0 76 39 8 15 14 13 4 19 2 8 13 0 19 1 15 45 16 10 2 39 72 10 1 45 17 11 18 45 19 13 1 15 13 9 2 13 0 19 4 20 43 1 43 1 10 0 45 21 11 18 45 22 13 1 15 16 9 2 13 0 19 4 20 43 1 43 1 10 0 45 23 1 24 45 25 13 1 15 16 9 6 13 0 19 4 20 43 1 43 1 38 111 10 3 39 72 10 1 45 26 11 18 45 27 13 1 15 13 9 3 13 0 19 4 20 43 1 43 1 10 0 45 28 11 18 45 29 13 1 15 16 9 3 13 0 19 4 20 43 1 43 1 10 0 45 30 1 31 45 32 13 1 15 16 9 6 13 0 19 4 20 43 1 43 1 38 36 10 4 39 32 13 0 19 1 33 76 39 24 10 0 45 34 11 35 45 36 13 1 15 16 9 6 13 0 19 4 20 43 1 43 1 10 1 45 37 8 1 45 38 13 1 19 1 39 12 13 0 19 2 40 45 41 13 2 15 13 9 1 13 0 19 4 20 43 3 13 0 15 2 14 42 13 1 10 2 73 40 9 10 3 73 40 4 10 4 73 12 19 4 43 12 19 2 44 43 1 43 4 43 1 29) #490# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #491=#A(t (17) (c::c2go c::c1form c::tag c::nonlocal c::tag-var c::var "cl_go(" ",ecl_make_fixnum(" c::tag-index "));" c::wt-nl c::tag-unwind-exit c::unwind-no-exit-until c::tag-label c::wt-go #Y(c::c2go nil nil (24 45 1 24 45 2 24 45 3 26 10 0 39 29 13 1 19 1 4 45 5 15 6 13 0 15 7 13 2 19 1 8 12 15 9 19 5 10 43 1 38 22 13 1 19 1 11 12 19 1 12 19 0 10 13 1 19 1 13 12 19 1 14 29) #491# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #492=#A(t (10) (c::t1expr c::form c::*current-toplevel-form* c::*cmp-env* c::cmp-env-copy c::cmp-env-root c::t1expr* c::*top-level-forms* #Y(c::t1expr nil nil (24 45 1 26 75 48 2 11 3 39 8 14 3 19 1 4 38 4 19 0 5 48 3 13 0 19 1 6 12 11 7 3 52 7 73 44 2 29) #492# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 1 3 52 0 1 0 73 29) #A(t (4) (c::*toplevel-forms-to-print* si::*make-special boundp (defun defmacro defvar defparameter defclass defmethod defgeneric))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 29 12 19 2 30 1 0 73 29) #493=#A(t (31) (c::t1expr* c::form c::*current-toplevel-form* c::*current-form* t c::*first-error* c::*setjmps* consp c::fd c::args c::fun c::*toplevel-forms-to-print* member c::print-current-form c::t1ordinary symbolp "~s is illegal function." c::cmperr quote eq c::*t1-dispatch-table* gethash c::*c1-dispatch-table* compiler-macro-function c::inline-possible c::success c::cmp-expand-macro macroexpand c::cmp-macro-function #Y(c::t1expr* nil nil (24 45 1 26 13 0 11 2 7 2 48 2 10 0 48 3 11 4 48 5 8 0 48 6 10 0 16 7 73 39 194 10 0 4 12 10 0 5 12 77 46 8 46 9 46 10 13 0 14 11 19 2 12 39 4 19 0 13 10 0 16 7 39 8 13 3 19 1 14 38 152 10 0 16 15 76 39 10 15 16 13 0 19 2 17 38 136 13 0 1 18 17 19 39 7 77 19 1 14 38 122 13 0 14 20 19 2 21 51 2 39 10 13 2 13 1 20 1 23 38 102 13 0 14 22 19 2 21 39 8 13 3 19 1 14 38 86 13 0 19 1 23 51 2 39 27 13 0 19 1 24 39 20 75 45 25 13 3 13 4 19 2 26 51 3 55 0 1 10 0 43 1 39 15 15 27 11 2 3 52 2 13 2 19 1 0 38 35 13 0 19 1 28 51 2 39 21 15 27 11 2 3 52 2 13 2 13 3 19 2 26 12 19 1 0 38 6 13 3 19 1 14 43 3 44 4 29) #493# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #494=#A(t (9) (c::t1/c1expr c::form c::*compile-toplevel* c::c1expr atom c::t1ordinary c::t1expr* #Y(c::t1/c1expr nil nil (24 45 1 26 11 2 76 39 8 13 0 19 1 3 38 19 10 0 16 4 39 8 13 0 19 1 5 38 6 13 0 19 1 6 29) #494# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #495=#A(t (21) (c::t2expr c::form c::c1form-name c::*t2-dispatch-table* gethash c::def c::c1form-file c::c1form-file-position c::c1form-form c::c1form-env c::*cmp-env* c::*current-form* c::*current-toplevel-form* c::*compile-file-position* *compile-file-truename* c::c1form-args apply "Unhandled T2FORM found at the toplevel:~%~4I~A" c::cmperr #Y(c::t2expr nil nil (24 45 1 26 10 0 73 39 84 13 0 19 1 2 12 14 3 19 2 4 45 5 10 0 39 58 13 1 19 1 6 12 13 1 19 1 7 12 13 1 19 1 8 12 13 1 19 1 8 12 13 1 19 1 9 12 49 10 49 11 49 12 49 13 49 14 13 0 13 1 13 1 19 1 15 12 19 3 16 44 5 38 8 15 17 13 1 19 2 18 43 1 29) #495# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 4 75 52 0 1 0 73 29) #A(t (3) (c::*emitted-local-funs* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #496=#A(t (10) (c::emit-local-funs c::*compile-toplevel* c::*compile-time-too* c::*local-funs* c::lfs c::*emitted-local-funs* eq c::t3local-fun #Y(c::emit-local-funs nil nil (26 77 77 49 1 49 2 38 36 11 3 45 4 38 7 10 0 5 12 53 0 10 0 5 12 11 5 17 6 39 -15 10 0 52 5 10 0 4 12 19 1 7 43 1 14 5 11 3 17 6 39 -42 75 73 44 2 29) #496# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 153 12 19 2 154 1 0 73 29) #497=#A(t (155) (c::ctop-write c::name c::h-pathname c::data-pathname c::def c::top-output-string " volatile " c::*volatile* c::*top-level-forms* nreverse "#include \"" c::brief-namestring "\"" c::wt-nl "#ifdef ECL_DYNAMIC_VV" c::wt-nl-h "static cl_object *VV;" "#else" "static cl_object VV[VM];" "#endif" c::*compiler-output2* c::output-clines "#ifdef __cplusplus" "extern \"C\" {" "#endif" c::*opened-c-braces* c::*aux-closure* c::*compiler-output1* c::c-output-file make-string-output-stream c::*emitted-local-funs* make-hash-table c::*compiler-declared-globals* "#include \"" "\"" "#ifdef __cplusplus" "extern \"C\"" "#endif" "ECL_DLLEXPORT void " "(cl_object flag)" c::wt-nl-open-brace "const cl_env_ptr cl_env_copy = ecl_process_env();" "cl_object value0;" "cl_object *VVtemp;" "if (flag != OBJNULL){" "Cblock = flag;" "#ifndef ECL_DYNAMIC_VV" "flag->cblock.data = VV;" "#endif" c::*self-destructing-fasl* "flag->cblock.self_destruct=1;" "flag->cblock.data_size = VM;" "flag->cblock.temp_data_size = VMtemp;" c::*compile-in-constants* si::*compiler-constants* "flag->cblock.data_text = compiler_data_text;" "flag->cblock.data_text_size = compiler_data_text_size;" "flag->cblock.cfuns_size = compiler_cfuns_size;" "flag->cblock.cfuns = compiler_cfuns;" ext::*source-location* "flag->cblock.source = make_constant_base_string(\"" namestring "\");" "return;}" "#ifdef ECL_DYNAMIC_VV" "VV = Cblock->cblock.data;" "#endif" "Cblock->cblock.data_text = \"" c::init-name-tag "\";" "VVtemp = Cblock->cblock.temp_data;" "ECL_DEFINE_SETF_FUNCTIONS" c::*do-type-propagation* c::p1propagate c::*compiler-phase* si::%dolist-var c::form c::*local-funs* c::fun c::fun-lambda c::t2 c::*make-forms* reverse nconc #:loop-list20830 0 c::emit-toplevel-form c::wt-nl-close-many-braces get-output-stream-string "static cl_object Cblock;" c::data-size c::num-objects zerop "#undef ECL_DYNAMIC_VV" "#define compiler_data_text \"\"" "#define compiler_data_text_size 0" "#define VM 0" "#define VMtemp 0" "#define VV NULL" "#define VM " c::data-permanent-storage-size "#define VMtemp " c::data-temporary-storage-size c::*linking-calls* c::l fourth c::c-name fifth c::var-name "static cl_object " "(cl_narg, ...);" "static cl_object (*" ")(cl_narg, ...)=" ";" c::*global-entries* c::x c::wt-global-entry apply third c::lisp-name "static cl_object " "(cl_narg narg, ...)" "{TRAMPOLINK(narg," ",&" ",Cblock);}" "#define ECL_DEFINE_SETF_FUNCTIONS " c::*setf-definitions* #:loop-list20831 c::name-vv c::setf-vv #72# #\\ #\Newline "=ecl_setf_definition(" ",ECL_T);" c::wt-h "#ifdef __cplusplus" "}" "#endif" c::*static-constants* listp "/*" " * Statically defined constants" " */" #:loop-list20833 c::builder c::value terpri c::output-cfuns c::t3 c::*callbacks* "#include <ecl/internal.h>" c::t3-defcallback #Y(c::ctop-write nil nil (24 45 1 24 45 2 24 45 3 26 75 45 4 75 45 5 1 6 48 7 11 8 16 9 52 8 15 10 13 3 19 1 11 12 15 12 19 3 13 15 14 19 1 15 15 16 19 1 15 15 17 19 1 15 15 18 19 1 15 15 19 19 1 15 14 20 19 1 21 15 22 19 1 15 15 23 19 1 15 15 24 19 1 15 8 0 48 25 75 48 26 11 27 45 28 19 0 29 48 27 75 48 30 19 0 31 48 32 15 33 13 3 19 1 11 12 15 34 19 3 13 15 35 19 1 13 15 36 19 1 13 15 37 19 1 13 15 38 13 5 15 39 19 3 13 19 0 40 15 41 19 1 13 15 42 19 1 13 15 43 19 1 13 15 44 19 1 13 15 45 19 1 13 15 46 19 1 13 15 47 19 1 13 15 48 19 1 13 11 49 39 6 15 50 19 1 13 15 51 19 1 13 15 52 19 1 13 11 53 40 3 11 54 39 11 15 55 19 1 13 15 56 19 1 13 15 57 19 1 13 15 58 19 1 13 11 59 39 14 15 60 11 59 4 16 61 12 15 62 19 3 13 15 63 19 1 13 15 64 19 1 13 15 65 19 1 13 15 66 19 1 13 15 67 13 5 19 1 68 12 15 69 19 3 13 15 70 19 1 13 15 71 19 1 13 11 72 39 75 1 73 52 74 11 8 45 75 75 45 76 38 21 10 1 4 51 0 10 0 39 7 13 0 77 19 2 73 10 1 5 51 1 10 1 40 -23 43 2 11 77 45 75 75 45 78 38 21 10 1 4 51 0 13 0 19 1 79 12 77 19 2 73 10 1 5 51 1 10 1 40 -23 43 2 1 80 52 74 77 11 81 16 82 12 14 8 19 2 83 12 46 84 46 76 57 85 61 2 2 29 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 3 19 2 86 35 0 0 62 43 2 9 0 19 1 87 11 27 16 88 51 1 43 1 44 5 15 89 19 1 15 19 0 90 45 91 10 0 16 92 39 33 15 93 19 1 15 15 94 19 1 15 15 95 19 1 15 15 96 19 1 15 15 97 19 1 15 15 98 19 1 15 38 19 15 99 19 0 100 12 19 2 15 15 101 19 0 102 12 19 2 15 43 1 11 103 45 75 75 45 104 38 47 10 1 4 51 0 10 0 16 105 45 106 10 1 16 107 45 108 15 109 13 1 15 110 19 3 15 15 111 13 0 15 112 13 1 15 113 19 5 15 43 2 10 1 5 51 1 10 1 40 -49 43 2 11 114 45 75 75 45 115 38 18 10 1 4 51 0 15 116 13 0 19 2 117 10 1 5 51 1 10 1 40 -20 43 2 11 103 45 75 75 45 104 38 50 10 1 4 51 0 10 0 16 107 45 108 10 1 16 105 45 106 10 2 16 118 45 119 15 120 13 1 15 121 15 122 13 0 15 123 13 2 15 124 19 8 13 43 3 10 1 5 51 1 10 1 40 -52 43 2 15 125 19 1 15 77 77 77 14 126 46 127 46 128 46 129 46 1 57 85 61 2 2 64 10 4 2 39 4 35 0 1 10 4 4 45 130 10 0 4 51 2 10 0 5 51 0 10 0 4 51 3 10 0 5 51 0 10 0 4 51 4 43 1 10 4 5 51 4 15 131 15 132 13 2 15 133 13 3 15 134 19 6 135 35 0 0 62 43 4 15 136 19 1 15 15 137 19 1 15 15 138 19 1 15 11 139 16 140 39 7 11 139 16 9 52 139 39 105 15 141 19 1 15 15 142 19 1 15 15 143 19 1 15 77 77 77 11 139 16 82 12 46 144 46 145 46 1 46 146 57 85 61 2 2 65 10 4 2 39 4 35 0 1 10 4 4 45 130 10 0 4 51 2 10 0 5 51 0 10 0 4 51 3 10 0 5 51 0 10 0 4 51 4 43 1 10 4 5 51 4 14 20 19 1 147 13 3 13 2 13 1 14 20 20 3 23 35 0 0 62 43 4 14 20 19 1 148 1 149 52 74 11 150 39 39 15 151 19 1 15 11 150 45 75 75 45 115 38 19 10 1 4 51 0 33 152 12 13 0 19 2 117 10 1 5 51 1 10 1 40 -21 43 2 13 0 19 1 13 44 1 29) #497# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 28 12 19 2 29 1 0 73 29) #498=#A(t (30) (c::emit-toplevel-form c::form c::c-output-file c::c1form-file c::c1form-file-position c::*compile-file-position* *compile-file-truename* c::*compile-to-linking-call* c::*temp* c::*level* c::*env* c::*lex* c::*lcl* c::*max-temp* c::*max-env* c::*max-lex* c::*ihs-used-p* make-string-output-stream c::*compiler-output1* c::t2expr get-output-stream-string c::body plusp c::wt-nl-open-brace c::wt-function-locals write-sequence c::wt-nl-close-brace c::emit-local-funs #Y(c::emit-toplevel-form nil nil (24 45 1 24 45 2 26 77 9 0 9 0 9 0 9 0 9 0 9 0 9 0 9 0 77 10 1 73 39 6 13 1 19 1 3 12 10 1 73 39 6 13 1 19 1 4 12 49 5 49 6 49 7 49 8 49 9 49 10 49 11 49 12 49 13 49 14 49 15 49 16 19 0 17 48 18 13 1 19 1 19 11 18 16 20 44 1 45 21 11 15 16 22 40 15 11 13 16 22 40 9 11 14 16 22 40 3 11 16 39 19 19 0 23 19 0 24 13 0 14 18 19 2 25 19 0 26 38 8 13 0 14 18 19 2 25 43 1 10 0 48 18 19 0 27 44 1 44 12 29) #498# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 1 0 73 29) #499=#A(t (25) (c::c1eval-when c::args eval-when c::check-args-number c::execute-flag c::compile-flag c::load-flag si::%dolist-var c::situation load :load-toplevel t compile :compile-toplevel eval :execute c::*compile-toplevel* c::*compile-time-too* "The EVAL-WHEN situation ~s is illegal." c::cmperr c::c1progn progn c::cmp-eval #Y(c::c1eval-when nil nil (24 45 1 26 15 2 13 0 9 1 19 3 3 77 77 77 46 4 46 5 46 6 10 3 4 45 7 75 45 8 38 70 10 1 4 51 0 10 0 41 9 4 42 10 7 11 11 51 2 38 46 41 12 4 42 13 7 11 11 51 3 38 34 41 14 4 42 15 21 11 16 39 11 11 17 40 3 10 3 51 3 38 5 11 11 51 4 38 8 15 18 13 0 19 2 19 10 1 5 51 1 10 1 40 -72 43 2 11 16 76 39 16 10 2 73 39 5 10 3 5 73 12 19 1 20 38 44 10 0 39 16 10 1 48 17 10 3 5 12 19 1 20 44 1 38 25 10 1 39 17 15 21 10 3 5 3 12 19 1 22 77 19 1 20 38 5 77 19 1 20 43 3 29) #499# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #500=#A(t (8) (c::t2compiler-let c::c1form c::symbols values c::body c::c2expr #Y(c::t2compiler-let nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 2 10 1 67 13 0 19 1 5 68 29) #500# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #501=#A(t (7) (c::t2progn c::c1form c::args c::t2expr mapc #Y(c::t2progn nil nil (24 45 1 24 45 2 26 33 3 12 13 0 19 2 4 29) #501# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #502=#A(t (11) (c::exported-fname c::name c::cname symbolp c::lfun si::get-sysprop t "L~D~A" c::next-cfun #Y(c::exported-fname nil nil (24 45 1 26 75 45 2 10 1 16 3 39 9 13 1 1 4 17 5 51 0 39 9 13 0 14 6 72 2 38 12 15 7 13 1 19 2 8 12 77 72 2 43 1 29) #502# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #503=#A(t (6) (c::new-defun c::new c::no-entry c::*global-funs* #Y(c::new-defun nil nil (24 45 1 25 40 2 77 46 2 26 13 1 11 3 3 52 3 73 29) #503# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #504=#A(t (11) (c::print-function c::x t "~%<a FUN: ~A, CLOSURE: ~A, LEVEL: ~A, ENV: ~A>" c::fun-name c::fun-closure c::fun-level c::fun-env format #Y(c::print-function nil nil (24 45 1 26 14 2 15 3 13 0 19 1 4 12 13 0 19 1 5 12 13 0 19 1 6 12 13 0 19 1 7 12 19 6 8 29) #504# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 14 10 9 1 19 4 11 1 0 73 29) #505=#A(t (12) (c::and! #:g20839 #:g20838 #:g20840 c::body let c::l list ((pprint (list* 'c::l? c::l)) (every #'identity c::l)) #Y(c::and! nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 45 4 15 5 15 6 15 7 10 0 7 2 6 2 6 1 12 1 8 7 3 73 29) #505# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 35 12 19 2 36 1 0 73 29) #506=#A(t (37) (c::wt-function-locals c::closure-type c::*max-temp* plusp "cl_object " c::wt-nl si::%dotimes-var c::i "T" c::wt 1+ = ", " < ";" c::*ihs-used-p* "struct ecl_ihs_frame ihs;" "const cl_object _ecl_debug_env = ECL_NIL;" c::*max-lex* "volatile cl_object lex" c::*level* "[" "];" c::*max-env* c::closure eq "cl_object " c::*volatile* "env0;" c::*aux-closure* "volatile struct ecl_cclosure aux_closure;" "cl_object " "CLV" ", " ";" #Y(c::wt-function-locals nil nil (25 40 2 77 46 1 26 11 2 16 3 39 63 15 4 19 1 5 11 2 45 6 8 0 45 7 38 32 15 8 13 0 19 2 9 10 0 16 10 12 14 2 19 2 11 76 39 6 15 12 19 1 9 10 0 16 10 51 0 13 0 13 1 19 2 13 40 -39 43 2 15 14 19 1 9 11 15 39 11 15 16 19 1 5 15 17 19 1 5 11 18 16 3 39 14 15 19 14 20 15 21 14 18 15 22 19 5 5 11 23 16 3 73 39 92 13 0 1 24 17 25 76 39 10 15 26 14 27 15 28 19 3 5 11 29 39 6 15 30 19 1 5 15 31 14 27 19 2 5 11 23 45 6 8 0 45 7 38 32 15 32 13 0 19 2 9 10 0 16 10 12 14 23 19 2 11 76 39 6 15 33 19 1 9 10 0 16 10 51 0 13 0 13 1 19 2 13 40 -39 43 2 15 34 19 1 5 29) #506# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 62 12 19 2 63 1 0 73 29) #507=#A(t (64) (c::wt-global-entry c::fname c::cfun c::arg-types c::return-type symbolp c::no-global-entry si::get-sysprop "global entry for the function ~a" c::wt-comment-nl "static cl_object L" "(cl_narg narg" c::wt-nl "static cl_object L" "(cl_narg" c::wt-nl-h c::*lcl* 1+ c::lcl c::vl ", cl_object " c::wt1 c::wt-lcl ", cl_object" c::wt-h ")" ");" c::wt-h1 c::wt-nl-open-brace c::compiler-check-args "_ecl_check_narg(" length ");" "cl_env_copy->nvalues = 1;" "return " fixnum "ecl_make_fixnum" character "CODE_CHAR" double-float "ecl_make_double_float" single-float "ecl_make_single_float" long-float "ecl_make_long_float" "" "(LI" "(" c::n c::types "fix" "ecl_char_code" "df" "sf" "ecl_long_float" "" "(" c::wt ")" "," "));" c::wt-nl-close-many-braces #Y(c::wt-global-entry nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 57 0 60 299 10 4 16 5 39 7 13 4 1 6 17 7 39 5 75 73 36 0 15 8 13 4 19 2 9 15 10 13 3 15 11 19 3 12 15 13 13 3 15 14 19 3 15 13 2 11 16 16 17 12 46 18 46 19 38 29 15 20 19 1 21 13 1 19 1 22 15 23 19 1 24 10 0 5 12 10 1 16 17 12 53 1 53 0 10 0 2 39 -32 15 25 19 1 21 43 2 15 26 19 1 27 19 0 28 19 0 29 39 13 15 30 10 2 16 31 12 15 32 19 3 12 15 33 19 1 12 15 34 10 1 42 35 6 1 36 73 38 36 42 37 6 1 38 73 38 28 42 39 6 1 40 73 38 20 42 41 6 1 42 73 38 12 42 43 6 1 44 73 38 4 1 45 73 12 15 46 13 3 15 47 19 5 12 13 2 9 1 46 48 46 49 38 88 10 0 4 42 35 6 1 50 73 38 36 42 37 6 1 51 73 38 28 42 39 6 1 52 73 38 20 42 41 6 1 53 73 38 12 42 43 6 1 54 73 38 4 1 55 73 12 15 56 19 2 57 13 1 19 1 22 15 58 19 1 57 10 0 5 2 76 39 6 15 59 19 1 57 10 0 5 12 10 1 16 17 12 53 1 53 0 10 0 2 39 -91 43 2 15 60 19 1 57 9 0 19 1 61 63 29) #507# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #508=#A(t (13) (c::rep-type type fixnum "cl_fixnum " character "unsigned char " single-float "float " double-float "double " "cl_object " #Y(c::rep-type nil nil (24 45 1 26 10 0 42 2 6 1 3 73 38 28 42 4 6 1 5 73 38 20 42 6 6 1 7 73 38 12 42 8 6 1 9 73 38 4 1 10 73 29) #508# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #509=#A(t (12) (c::t1ordinary c::form c::*compile-time-too* c::cmp-eval c::*compile-toplevel* c::ordinary :args c::c1expr c::make-c1form* c::add-load-time-values #Y(c::t1ordinary nil nil (24 45 1 26 11 2 39 6 13 0 19 1 3 77 77 49 2 49 4 15 5 14 6 13 0 19 1 7 12 19 3 8 12 19 1 9 44 2 29) #509# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #510=#A(t (7) (c::p1ordinary c::c1form c::assumptions c::form c::p1propagate #Y(c::p1ordinary nil nil (24 45 1 24 45 2 24 45 3 26 13 0 13 1 19 2 4 29) #510# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #511=#A(t (12) (c::t2ordinary c::c1form c::form c::next-label c::*exit* c::*unwind-exit* c::trash c::*destination* c::c2expr c::wt-label #Y(c::t2ordinary nil nil (24 45 1 24 45 2 26 19 0 3 48 4 11 4 6 1 48 5 1 6 48 7 13 0 19 1 8 14 4 19 1 9 44 3 29) #511# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #512=#A(t (14) (c::add-load-time-values c::form c::*load-time-values* consp nreverse c::*make-forms* append c::previous progn :args nconc c::make-c1form* #Y(c::add-load-time-values nil nil (24 45 1 26 11 2 16 3 73 39 5 11 2 16 4 12 11 5 16 4 12 19 2 6 45 7 10 0 39 27 75 52 2 75 52 5 15 8 14 9 13 0 10 1 6 1 12 19 2 10 12 19 3 11 51 1 43 1 10 0 73 29) #512# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #513=#A(t (23) (c::t1defmacro c::args load-time-value c::check-args-number #:g20849 #:g20850 si::dm-too-few-arguments c::name c::lambda-list c::body si::expand-defmacro c::doc-string pprint function c::*cmp-env* c::cmp-eval c::fn c::cmp-env-register-global-macro defmacro macroexpand c::t1expr* #Y(c::t1defmacro nil nil (24 45 1 26 15 2 13 0 9 2 19 3 3 10 0 45 4 10 0 45 5 10 0 76 39 6 13 1 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 2 19 1 6 10 1 4 12 10 1 5 51 1 22 45 8 10 2 45 9 13 2 13 1 13 0 19 3 10 47 2 11 47 1 12 45 13 13 0 14 14 19 2 15 45 16 13 6 13 0 19 2 17 43 1 15 18 10 8 7 2 12 19 1 19 12 19 1 20 43 3 43 5 29) #513# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #514=#A(t (23) (c::c1load-time-value c::args load-time-value c::check-args-number c::loc c::form c::*load-time-values* listp c::cmp-eval :always t c::c1constant-value (or list symbol) typep c::data-empty-loc :args c::c1expr c::make-c1form* c::add-object ext::location :type #Y(c::c1load-time-value nil nil (24 45 1 26 57 0 60 109 15 2 13 1 9 1 9 2 19 4 3 10 1 4 12 77 46 4 46 5 11 6 16 7 76 39 18 13 0 19 1 8 12 14 9 14 10 19 3 11 36 2 38 49 13 0 15 12 19 2 13 39 29 19 0 14 51 1 15 2 14 15 13 1 13 0 19 1 16 12 19 4 17 12 11 6 3 52 6 38 12 13 0 19 1 8 12 19 1 18 51 1 15 19 14 20 14 10 14 15 13 1 19 5 17 43 2 63 29) #514# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #515=#A(t (12) (c::t2load-time-value c::c1form c::vv-loc c::form c::next-label c::*exit* c::*unwind-exit* c::*destination* c::c2expr c::wt-label #Y(c::t2load-time-value nil nil (24 45 1 24 45 2 24 45 3 26 19 0 4 48 5 11 5 6 1 48 6 10 1 48 7 13 0 19 1 8 14 5 19 1 9 44 3 29) #515# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #516=#A(t (12) (c::t2make-form c::c1form c::vv-loc c::form c::next-label c::*exit* c::*unwind-exit* c::*destination* c::c2expr c::wt-label #Y(c::t2make-form nil nil (24 45 1 24 45 2 24 45 3 26 19 0 4 48 5 11 5 6 1 48 6 10 1 48 7 13 0 19 1 8 14 5 19 1 9 44 3 29) #516# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #517=#A(t (13) (c::t2init-form c::c1form c::vv-loc c::form c::next-label c::*exit* c::*unwind-exit* c::trash c::*destination* c::c2expr c::wt-label #Y(c::t2init-form nil nil (24 45 1 24 45 2 24 45 3 26 19 0 4 48 5 11 5 6 1 48 6 1 7 48 8 13 0 19 1 9 14 5 19 1 10 44 3 29) #517# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #518=#A(t (20) (c::parse-cvspecs c::x c::cvspecs si::%dolist-var c::cvs symbolp :object symbol-name string-downcase stringp consp (ffi::object char ffi::int float ffi::double) member c::name "The C variable name ~s is illegal." c::cmperr "The C variable specification ~s is illegal." nreverse #Y(c::parse-cvspecs nil nil (24 45 1 26 75 45 2 10 1 45 3 75 45 4 38 154 10 1 4 51 0 10 0 16 5 39 21 14 6 10 0 16 7 12 19 1 8 6 2 12 10 2 3 51 2 38 118 10 0 16 9 39 15 14 6 10 0 6 2 12 10 2 3 51 2 38 98 10 0 16 10 39 10 10 0 4 12 15 11 19 2 12 39 74 10 0 5 45 3 75 45 13 38 56 10 1 4 51 0 10 2 4 12 10 0 16 5 39 11 10 0 16 7 12 19 1 8 38 18 10 0 16 9 39 5 10 0 38 8 15 14 13 0 19 2 15 6 2 12 10 4 3 51 4 10 1 5 51 1 10 1 40 -58 43 2 38 8 15 16 13 0 19 2 15 10 1 5 51 1 10 1 40 -156 75 51 0 10 2 16 17 43 2 29) #518# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #519=#A(t (6) (c::locative-type-from-var-kind c::kind ((:object . "_ecl_object_loc") (:fixnum . "_ecl_fixnum_loc") (:char . "_ecl_base_char_loc") (:float . "_ecl_float_loc") (:double . "_ecl_double_loc") ((special c::global c::closure c::lexical))) assoc #Y(c::locative-type-from-var-kind nil nil (24 45 1 26 13 0 15 2 19 2 3 5 73 29) #519# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 52 12 19 2 53 1 0 73 29) #520=#A(t (54) (c::build-debug-lexical-env c::var-locations first c::filtered-locations c::filtered-codes #:loop-list20878 c::var c::name c::code c::loc 0 "KEYWORD" find-package *package* "\"~S\"" c::var-name format c::var-kind c::locative-type-from-var-kind c::var-loc consp c::lcl eq t c::*ihs-used-p* "static const struct ecl_var_debug_info _ecl_descriptors[]={" c::wt-nl #:loop-list20884 c::i #:loop-not-first-time #72# 1+ zerop "{" ",{" "," "}" "};" c::wt "const cl_index _ecl_debug_info_raw[]={" "(cl_index)(ECL_NIL)," "(cl_index)(_ecl_debug_env)," "(cl_index)(_ecl_descriptors)" #:loop-list20885 ",(cl_index)(&" ")" "};" "ecl_def_ct_vector(_ecl_debug_env,ecl_aet_index,_ecl_debug_info_raw," length + ",,);" "ihs.lex_env = _ecl_debug_env;" #Y(c::build-debug-lexical-env nil nil (24 45 1 25 40 2 77 46 2 26 75 45 3 75 45 4 77 13 3 46 5 46 6 75 45 7 75 45 8 75 45 9 57 10 61 2 2 100 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 1 11 16 12 48 13 77 15 14 13 4 19 1 15 12 19 3 16 44 1 51 3 13 4 19 1 17 12 19 1 18 51 2 13 4 19 1 19 51 1 10 2 39 15 10 1 16 20 39 9 10 1 4 12 1 21 17 22 39 19 13 3 10 2 3 12 10 6 3 51 6 13 1 10 7 3 51 7 35 0 0 62 43 1 43 1 43 1 43 2 10 0 39 226 11 23 52 24 15 25 19 1 26 77 77 13 0 46 27 46 8 46 7 8 0 45 28 75 45 29 57 10 61 2 2 80 10 5 2 39 4 35 0 1 10 5 4 45 30 10 0 4 51 4 10 0 5 51 0 10 0 51 5 43 1 10 5 5 51 5 10 1 39 9 10 2 16 31 51 2 38 5 11 23 51 1 10 2 16 32 39 6 1 33 73 38 4 1 34 73 12 13 3 15 35 13 4 15 36 19 5 26 35 0 0 62 43 1 43 1 43 3 15 37 19 1 38 15 39 19 1 26 10 2 39 6 1 40 73 38 4 1 41 73 12 15 42 19 2 26 77 13 1 46 43 46 19 57 10 61 2 2 31 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 15 44 13 1 15 45 19 3 38 35 0 0 62 43 2 15 46 19 1 38 15 47 9 2 10 1 16 48 12 19 2 49 12 15 50 19 3 26 10 2 76 39 6 15 51 19 1 26 10 0 73 43 2 29) #520# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #521=#A(t (5) (c::pop-debug-lexical-env "ihs.lex_env = _ecl_debug_env;" c::wt-nl #Y(c::pop-debug-lexical-env nil nil (26 15 1 19 1 2 29) #521# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 50 12 19 2 51 1 0 73 29) #522=#A(t (52) (c::t3local-fun c::fun c::print-emitting c::fun-lambda c::lambda-expr c::c1form-env c::*cmp-env* c::*lcl* c::*temp* c::*max-temp* c::*last-label* c::*lex* c::*max-lex* c::fun-env c::*env* c::*max-env* c::*env-lvl* c::*aux-closure* c::fun-lexical-levels c::*level* return c::*exit* (return) c::*unwind-exit* c::*destination* c::*ihs-used-p* c::*opened-c-braces* c::*tail-recursion-info* c::c1form-volatile* c::*volatile* c::t3local-fun-declaration c::wt-nl-open-brace c::t3local-fun-body c::body c::fun-closure c::wt-function-locals "const cl_env_ptr cl_env_copy = ecl_process_env();" c::wt-nl c::closure eq "cl_object " "env0 = cl_env_copy->function->cclosure.env;" c::wt "cl_object value0;" c::policy-check-stack-overflow "ecl_cs_check(cl_env_copy,value0);" c::t3local-fun-closure-scan c::*compiler-output1* write-sequence c::wt-nl-close-many-braces #Y(c::t3local-fun nil nil (24 45 1 26 13 0 19 1 2 13 0 19 1 3 45 4 13 0 19 1 5 48 6 8 0 48 7 8 0 48 8 8 0 48 9 8 0 48 10 8 0 48 11 8 0 48 12 13 1 19 1 13 48 14 11 14 48 15 8 0 48 16 75 48 17 13 1 19 1 18 48 19 1 20 48 21 1 22 48 23 1 20 48 24 75 48 25 8 0 48 26 10 1 48 27 13 0 19 1 28 48 29 13 1 19 1 30 73 39 94 19 0 31 13 1 19 1 32 45 33 13 2 19 1 34 12 19 1 35 15 36 19 1 37 13 2 19 1 34 12 1 38 17 39 39 10 15 40 14 29 15 41 19 3 42 14 29 15 43 19 2 37 19 0 44 39 6 15 45 19 1 37 13 2 19 1 34 12 1 38 17 39 39 6 13 2 19 1 46 13 0 14 47 19 2 48 9 0 19 1 49 43 1 43 1 44 19 29) #522# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 1 0 73 29) #523=#A(t (24) (c::t3local-fun-body c::fun :element-type base-char :adjustable t :fill-pointer make-array string si::make-string-output-stream-from-string c::*compiler-output1* #:g20887 c::fun-lambda c::lambda-expr c::c1form-args nth c::fun-cfun c::fun-name c::fun-needs-narg c::fun-required-lcls c::fun-closure c::c2lambda-expr #Y(c::t3local-fun-body nil nil (24 45 1 26 9 2048 14 2 15 3 14 4 14 5 14 6 9 0 19 7 7 45 8 10 0 16 9 48 10 75 45 11 13 2 19 1 12 45 13 13 0 19 1 14 4 12 9 2 13 0 19 1 14 17 15 12 13 3 19 1 16 12 13 3 19 1 17 12 13 3 19 1 18 12 13 3 19 1 19 12 13 3 19 1 20 12 19 7 21 43 1 43 1 44 1 10 0 73 43 1 29) #523# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 78 12 19 2 79 1 0 73 29) #524=#A(t (80) (c::t3local-fun-declaration c::fun c::fun-global "function definition for ~a" c::fun-closure c::closure eq "closure ~a" "local function ~a" c::fun-name c::fun-description c::wt-comment-nl c::fun-shares-with "... shares definition with ~a" "" c::comma c::fun-lambda c::lambda-expr c::c1form-volatile* c::volatile c::c1form-args c::lambda-list c::v c::var-name c::next-lcl #Y(nil nil nil (24 45 22 26 13 0 19 1 23 12 19 1 24 29) #524# #1# 0) mapcar c::requireds c::fun-needs-narg c::narg c::c1form-env c::cmp-env "optimize speed ~D, debug ~D, space ~D, safety ~D " speed c::cmp-env-optimization debug space safety c::fun-cfun c::cfun c::fun-exported "ECL_DLLEXPORT cl_object " "(" c::wt-nl-h "cl_object " "(" c::wt-nl "static cl_object " "(" "static cl_object " "(" "cl_narg" c::wt-h "cl_narg narg" c::wt ", " c::fun-lexical-levels si::%dotimes-var c::n "volatile cl_object  *" "volatile cl_object *lex" ", " 1+ < #:g20895 #:g20896 si::structure-set #:loop-list20891 c::lcl 0 "cl_object " "cl_object " ", " ", ..." ", ..." ");" ")" t #Y(c::t3local-fun-declaration nil nil (24 45 1 26 57 0 60 413 13 1 19 1 2 39 6 1 3 73 38 21 13 1 19 1 4 12 1 5 17 6 39 6 1 7 73 38 4 1 8 73 12 13 1 19 1 9 73 40 12 13 1 19 1 10 73 40 4 1 5 73 12 19 2 11 13 1 19 1 12 39 20 15 13 13 1 19 1 12 12 19 1 9 12 19 2 11 75 73 36 0 1 14 45 15 13 2 19 1 16 45 17 13 0 19 1 18 45 19 13 1 19 1 20 4 45 21 34 25 12 10 0 4 12 19 2 26 45 27 13 6 19 1 28 45 29 13 4 19 1 30 45 31 15 32 15 33 13 0 19 2 34 12 15 35 13 0 19 2 34 12 15 36 13 0 19 2 34 12 15 37 13 0 19 2 34 12 19 5 11 43 1 13 7 19 1 38 45 39 13 8 19 1 40 39 21 15 41 13 0 15 42 19 3 43 15 44 13 0 15 45 19 3 46 38 19 15 47 13 0 15 48 19 3 43 15 49 13 0 15 50 19 3 46 43 1 10 0 39 19 13 3 15 51 19 2 52 13 3 15 53 19 2 54 1 55 51 5 13 7 19 1 56 45 57 8 0 45 58 38 27 13 7 15 59 19 2 52 13 7 15 60 13 0 19 3 54 1 61 51 7 10 0 16 62 51 0 13 0 13 1 19 2 63 40 -34 43 2 77 10 7 45 64 10 2 45 65 13 1 15 1 9 29 13 0 19 4 66 12 43 1 43 1 46 67 46 68 57 69 61 2 2 46 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 8 15 70 13 6 19 3 52 13 8 15 71 13 6 13 1 19 4 54 1 72 51 8 35 0 0 62 43 2 10 0 39 11 15 73 19 1 52 15 74 19 1 54 15 75 19 1 52 15 76 19 1 54 43 6 11 77 73 63 29) #524# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #525=#A(t (20) (c::fun-closure-variables c::fun c::x c::ref-ref-ccb c::var-kind special eq c::fun-lambda c::var-referenced-in-form c::var-changed-in-form c::var-loc ffi::object #Y(nil nil nil (24 45 2 26 13 0 19 1 3 76 73 40 53 13 0 19 1 4 12 1 5 17 6 73 40 40 13 0 13 1 19 1 7 12 19 2 8 76 39 13 13 0 13 1 19 1 7 12 19 2 9 76 73 40 11 13 0 19 1 10 12 1 11 17 6 29) #525# #1# 0) c::fun-referenced-vars remove-if > :key sort #Y(c::fun-closure-variables nil nil (24 45 1 26 34 12 12 13 0 19 1 13 12 19 2 14 12 33 15 12 14 16 33 10 12 19 4 17 29) #525# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #526=#A(t (8) (c::fun-lexical-levels c::fun c::fun-closure c::lexical eq c::fun-level #Y(c::fun-lexical-levels nil nil (24 45 1 26 13 0 19 1 2 12 1 3 17 4 39 8 13 0 19 1 5 38 4 8 0 73 29) #526# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 1 0 73 29) #527=#A(t (28) (c::t3local-fun-closure-scan c::fun c::fun-closure-variables c::clv-used "/* Scanning closure data ... */" c::wt-nl c::fun-env 1- t first c::bs c::n "CLV" " = env0;" c::wt " = _ecl_cdr(CLV" 1+ ");" c::var-loc = c::var-name c::wt-comment #:g20905 minusp c::wt-nl-open-brace " /* ... closure scanning finished */" #Y(c::t3local-fun-closure-scan nil nil (24 45 1 26 13 0 19 1 2 45 3 15 4 19 1 5 13 1 19 1 6 16 7 12 13 0 14 8 46 9 46 10 46 11 38 85 15 12 13 0 19 2 5 10 2 39 11 15 13 19 1 14 75 51 2 38 13 15 15 10 0 16 16 12 15 17 19 3 14 13 0 10 1 4 12 19 1 18 12 19 2 19 39 30 10 3 4 12 19 1 20 12 19 1 21 10 3 45 22 10 0 4 10 0 5 51 0 10 0 51 4 43 1 10 0 16 7 12 53 0 10 0 16 23 40 4 10 1 76 39 -94 43 3 19 0 24 15 25 19 1 14 43 1 29) #527# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 45 12 19 2 32 1 0 73 29) #528=#A(t (46) (c::c1fset c::args #:g20906 #:g20907 si::dm-too-few-arguments c::fname c::def si::macro pprint si::dm-too-many-arguments c::c1expr c::fun-form c::c1form-name c::locals eq c::c1form-args c::function-list #:g20908 c::fun-object second c::form nth labels c::global-var-p c::fun-referenced-vars every c::var c::fun-var c::fun-no-entry "Declaration C-LOCAL used in macro ~a" c::fun-name c::cmperr si::fset :args c::make-c1form* boolean typep (or integer null) consp quote :permanent t :duplicate c::add-object c::c1call-global #Y(c::c1fset nil nil (24 45 1 26 57 0 60 364 10 1 45 2 10 0 45 3 10 0 76 39 6 13 1 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 2 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 39 13 10 2 4 12 10 2 5 51 2 22 38 2 75 45 7 10 3 39 13 10 3 4 12 10 3 5 51 3 22 38 2 75 45 8 10 4 39 6 13 5 19 1 9 13 2 19 1 10 45 11 13 0 19 1 12 12 1 13 17 14 39 225 13 0 19 1 15 4 45 16 10 0 45 17 10 0 4 12 10 0 5 51 0 10 0 51 1 22 43 1 45 18 13 2 19 1 15 16 19 45 20 9 2 13 3 19 1 15 17 21 45 22 10 3 76 39 41 33 23 12 13 2 19 1 24 12 19 2 25 39 27 13 1 19 1 12 12 1 26 17 14 39 15 13 1 19 1 15 4 12 13 2 19 1 27 17 14 39 126 13 2 19 1 28 39 31 10 6 39 12 15 29 13 2 19 1 30 12 19 2 31 15 32 14 33 13 2 77 77 77 77 19 7 34 36 11 13 6 15 35 19 2 36 39 24 13 5 15 37 19 2 36 39 15 10 8 16 38 39 9 10 8 4 12 1 39 17 14 39 55 15 32 14 33 13 2 10 8 16 19 12 14 40 14 41 14 42 14 41 19 5 43 12 13 6 13 5 13 8 19 1 10 12 13 4 13 6 19 1 10 12 13 5 19 1 10 6 4 12 19 7 34 36 11 43 4 43 1 15 32 13 3 13 2 13 1 10 0 6 4 12 19 2 44 43 6 63 29) #528# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #529=#A(t (12) (c::p1fset c::c1form c::assumptions c::fun c::fname si::macro pprint c::c1forms c::fun-lambda c::p1propagate #Y(c::p1fset nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 24 45 6 24 45 7 26 13 4 19 1 8 12 13 5 19 2 9 29) #529# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 31 12 19 2 19 1 0 73 29) #530=#A(t (32) (c::c2fset c::c1form c::fun c::fname si::macro pprint c::c1forms c::fun-no-entry "(void)0; /* No entry created for " "~A" c::fun-name format " */" c::wt-nl c::new-local c::fun-closure c::*destination* c::trash eq si::fset c::c2call-global c::data-empty-loc c::loc c::*inline-blocks* c::*global-cfuns-array* "ecl_cmp_defmacro(" "ecl_cmp_defun(" ");" c::loc-immediate-value c::wt-comment c::close-inline-blocks #Y(c::c2fset nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 24 45 6 26 57 0 60 131 13 5 19 1 7 39 30 15 8 77 15 9 13 5 19 1 10 12 19 3 11 12 15 12 19 3 13 13 5 19 1 14 75 73 36 0 13 5 19 1 15 76 39 7 14 16 1 17 17 18 76 39 12 13 6 15 19 13 1 19 3 20 36 0 9 0 19 0 21 12 46 22 49 23 13 0 13 5 10 6 6 3 12 11 24 3 52 24 13 6 19 1 14 10 4 39 6 1 25 73 38 4 1 26 73 12 13 0 15 27 19 3 13 13 5 19 1 28 12 19 1 29 19 0 30 43 1 44 1 63 29) #530# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 35 12 19 2 36 1 0 73 29) #531=#A(t (37) (c::output-cfuns stream c::*global-cfuns-array* length c::n-cfuns "/*" c::wt-nl-h " * Exported Lisp functions" " */" "#define compiler_cfuns_size " zerop "#define compiler_cfuns NULL" "~%static const struct ecl_cfun compiler_cfuns[] = {~
~%~t/*t,m,narg,padding,name,block,entry*/" format nreverse #:loop-list20911 c::fun c::fname-loc c::loc 0 #72# c::fun-cfun c::cfun c::fun-minarg c::minarg c::fun-maxarg c::maxarg = si::c-arguments-limit <= c::narg "~%{0,0,~D,0,ecl_make_fixnum(~D),ecl_make_fixnum(~D),(cl_objectfn)~A,ECL_NIL,ecl_make_fixnum(~D)}," c::vv-location c::fun-file-position "~%};" #Y(c::output-cfuns nil nil (24 45 1 26 11 2 16 3 45 4 15 5 19 1 6 15 7 19 1 6 15 8 19 1 6 15 9 13 0 19 2 6 10 0 16 10 39 8 15 11 19 1 6 38 166 13 1 15 12 19 2 13 77 77 77 11 2 16 14 12 46 15 46 16 46 17 46 18 57 19 61 2 2 127 10 4 2 39 4 35 0 1 10 4 4 45 20 10 0 4 51 2 10 0 5 51 0 10 0 4 51 3 10 0 5 51 0 10 0 4 51 4 43 1 10 4 5 51 4 13 3 19 1 21 45 22 13 4 19 1 23 45 24 13 5 19 1 25 45 26 13 1 13 0 19 2 27 39 8 13 0 14 28 19 2 29 39 5 10 0 38 3 8 -1 45 30 13 10 15 31 13 0 13 5 19 1 32 12 13 6 19 1 32 12 13 3 13 7 19 1 33 12 19 7 13 43 4 35 0 0 62 43 4 13 1 15 34 19 2 13 43 1 29) #531# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #532=#A(t (17) (c::make-var c::args c::%make-var apply c::var c::var-kind (special c::global) member c::*current-function* #:g20917 #:g20915 c::fun-local-vars #:g20916 c::fun si::structure-set #Y(c::make-var nil nil (27 45 1 33 2 12 13 0 19 2 3 45 4 13 0 19 1 5 12 15 6 19 2 7 76 39 36 11 8 39 32 10 0 45 9 11 8 45 10 13 1 13 0 19 1 11 3 45 12 13 1 15 13 9 21 13 0 19 4 14 43 3 10 0 73 43 1 29) #532# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #533=#A(t (10) (c::var-referenced-in-form-list c::var c::form-list #:loop-list20920 c::f #:loop-it-20921 0 c::var-referenced-in-form #Y(c::var-referenced-in-form-list nil nil (24 45 1 24 45 2 26 58 60 61 77 13 1 46 3 46 4 75 45 5 57 6 61 2 2 38 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 13 6 13 2 19 2 7 51 1 39 6 10 1 73 36 4 35 0 0 62 73 43 1 43 2 63 29) #533# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #534=#A(t (10) (c::var-changed-in-form-list c::var c::form-list #:loop-list20924 c::f #:loop-it-20925 0 c::var-changed-in-form #Y(c::var-changed-in-form-list nil nil (24 45 1 24 45 2 26 58 60 61 77 13 1 46 3 46 4 75 45 5 57 6 61 2 2 38 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 13 6 13 2 19 2 7 51 1 39 6 10 1 73 36 4 35 0 0 62 73 43 1 43 2 63 29) #534# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #535=#A(t (8) (c::var-referenced-in-form c::var c::form c::var-read-nodes c::find-form-in-node-list c::var-functions-reading #Y(c::var-referenced-in-form nil nil (24 45 1 24 45 2 26 13 0 13 1 19 1 3 12 19 2 4 73 40 6 13 1 19 1 5 29) #535# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #536=#A(t (14) (c::var-changed-in-form c::var c::form c::var-set-nodes c::find-form-in-node-list c::var-kind c::kind special eq c::global c::c1form-sp-change c::var-functions-setting #Y(c::var-changed-in-form nil nil (24 45 1 24 45 2 26 13 0 13 1 19 1 3 12 19 2 4 73 40 38 13 1 19 1 5 45 6 13 0 1 7 17 8 40 7 13 0 1 9 17 8 39 8 13 1 19 1 10 38 6 13 2 19 1 11 43 1 29) #536# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 24 12 19 2 25 1 0 73 29) #537=#A(t (26) (c::update-variable-type c::var c::orig-type c::var-set-nodes c::var-type c::type-and type "Variable assigned a value incompatible with its type declaration.~%Variable: ~A~%Expected type: ~A~%Value type: ~A" c::var-name c::cmpwarn c::var-read-forms #:loop-list20926 c::form 0 c::c1form-name eq c::c1form-args #:g20931 c::c1form-primary-type #:g20932 c::c1form si::structure-set #:g20933 #:g20934 #Y(c::update-variable-type nil nil (24 45 1 24 45 2 26 57 0 60 175 13 2 19 1 3 39 5 75 73 36 0 13 2 19 1 4 12 13 1 19 2 5 45 6 10 0 76 39 22 15 7 13 3 19 1 8 12 13 3 19 1 4 12 13 2 19 4 9 38 122 77 13 3 19 1 10 12 46 11 46 12 57 13 61 2 2 78 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 19 1 14 12 1 1 17 15 39 11 13 6 13 1 19 1 16 4 17 15 39 33 10 1 45 17 13 4 13 2 19 1 18 12 19 2 5 45 19 13 1 15 20 9 1 13 0 19 4 21 43 1 43 1 35 0 0 10 6 45 22 10 4 45 23 13 1 15 1 9 11 13 0 19 4 21 43 1 43 1 62 73 43 2 43 1 63 29) #537# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #538=#A(t (7) (c::var-read-forms c::var first c::var-read-nodes mapcar #Y(c::var-read-forms nil nil (24 45 1 26 33 2 12 13 0 19 1 3 12 19 2 4 29) #538# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #539=#A(t (18) (c::assert-var-ref-value c::var c::var-ref c::ref most-positive-fixnum / > c::var-read-nodes length c::var-set-nodes + = :format-control "Number of references in VAR ~A unequal to references list" :format-arguments c::baboon #Y(c::assert-var-ref-value nil nil (24 45 1 26 13 0 19 1 2 45 3 13 0 14 4 9 2 19 2 5 12 19 2 6 40 30 13 1 19 1 2 12 13 1 19 1 7 16 8 12 13 1 19 1 9 16 8 12 19 2 10 12 19 2 11 43 1 76 73 39 15 14 12 15 13 14 14 10 0 6 1 12 19 4 15 29) #539# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #540=#A(t (13) (c::assert-var-not-ignored c::var c::var-ignorable c::x minusp "Variable ~A, declared as IGNORE, found in a lisp form." c::var-name c::cmpwarn-style #:g20937 #:g20938 si::structure-set #Y(c::assert-var-not-ignored nil nil (24 45 1 26 13 0 19 1 2 45 3 10 0 39 5 10 0 16 4 43 1 73 39 34 15 5 13 0 19 1 6 12 19 2 7 10 0 45 8 75 45 9 13 1 15 1 9 13 13 0 19 4 10 43 1 43 1 29) #540# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #541=#A(t (15) (c::delete-from-read-nodes c::var c::form c::assert-var-ref-value #:g20943 c::var-ref 1- #:g20944 si::structure-set #:g20945 c::var-read-nodes c::delete-form-from-node-list #:g20946 #Y(c::delete-from-read-nodes nil nil (24 45 1 24 45 2 26 13 1 19 1 3 10 1 45 4 13 2 19 1 5 16 6 45 7 13 1 15 1 9 1 13 0 19 4 8 43 1 43 1 10 1 45 9 13 1 13 2 19 1 10 12 19 2 11 45 12 13 1 15 1 9 4 13 0 19 4 8 43 1 43 1 29) #541# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 27 12 19 2 28 1 0 73 29) #542=#A(t (29) (c::add-to-read-nodes c::var c::form c::assert-var-ref-value c::assert-var-not-ignored #:g20957 c::var-ref 1+ #:g20958 si::structure-set #:g20959 c::var-read-nodes c::add-form-to-node-list #:g20960 c::*current-function* c::var-function eq #:g20963 #:g20961 c::var-functions-reading adjoin #:g20962 #:g20966 #:g20964 c::fun-referenced-vars #:g20965 c::fun #Y(c::add-to-read-nodes nil nil (24 45 1 24 45 2 26 13 1 19 1 3 13 1 19 1 4 10 1 45 5 13 2 19 1 6 16 7 45 8 13 1 15 1 9 1 13 0 19 4 9 43 1 43 1 10 1 45 10 13 1 13 2 19 1 11 12 19 2 12 45 13 13 1 15 1 9 4 13 0 19 4 9 43 1 43 1 11 14 39 81 14 14 13 1 19 1 15 17 16 76 39 69 11 14 45 17 10 2 45 18 13 1 13 0 19 1 19 12 19 2 20 45 21 13 1 15 1 9 9 13 0 19 4 9 43 3 10 1 45 22 11 14 45 23 13 1 13 0 19 1 24 12 19 2 20 45 25 13 1 15 26 9 22 13 0 19 4 9 43 3 10 0 73 29) #542# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 27 12 19 2 28 1 0 73 29) #543=#A(t (29) (c::add-to-set-nodes c::var c::form c::assert-var-ref-value c::assert-var-not-ignored #:g20977 c::var-ref 1+ #:g20978 si::structure-set #:g20979 c::var-set-nodes c::add-form-to-node-list #:g20980 c::*current-function* c::var-function eq #:g20983 #:g20981 c::var-functions-setting adjoin #:g20982 #:g20986 #:g20984 c::fun-referenced-vars #:g20985 c::fun #Y(c::add-to-set-nodes nil nil (24 45 1 24 45 2 26 13 1 19 1 3 13 1 19 1 4 10 1 45 5 13 2 19 1 6 16 7 45 8 13 1 15 1 9 1 13 0 19 4 9 43 1 43 1 10 1 45 10 13 1 13 2 19 1 11 12 19 2 12 45 13 13 1 15 1 9 5 13 0 19 4 9 43 1 43 1 11 14 39 81 14 14 13 1 19 1 15 17 16 76 39 69 11 14 45 17 10 2 45 18 13 1 13 0 19 1 19 12 19 2 20 45 21 13 1 15 1 9 8 13 0 19 4 9 43 3 10 1 45 22 11 14 45 23 13 1 13 0 19 1 24 12 19 2 20 45 25 13 1 15 26 9 22 13 0 19 4 9 43 3 10 0 73 29) #543# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #544=#A(t (8) (c::add-to-set-nodes-of-var-list c::var-list c::form si::%dolist-var c::v c::add-to-set-nodes #Y(c::add-to-set-nodes-of-var-list nil nil (24 45 1 24 45 2 26 10 1 45 3 75 45 4 38 18 10 1 4 51 0 13 0 13 2 19 2 5 10 1 5 51 1 10 1 40 -20 43 2 10 0 73 29) #544# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #545=#A(t (6) (c::check-global c::name c::*global-vars* member #Y(c::check-global nil nil (24 45 1 26 13 0 14 2 19 2 3 29) #545# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #546=#A(t (12) (c::special-variable-p c::name si::specialp c::check-global c::*cmp-env-root* c::cmp-env-search-var c::v c::var-kind special eq #Y(c::special-variable-p nil nil (24 45 1 26 10 0 16 2 73 40 35 13 0 19 1 3 73 40 27 13 0 14 4 19 2 5 45 6 10 0 73 39 11 13 0 19 1 7 12 1 8 17 9 43 1 29) #546# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #547=#A(t (9) (c::local-variable-p c::name c::*cmp-env* c::env c::cmp-env-search-var c::record c::var-p #Y(c::local-variable-p nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 13 0 19 2 4 45 5 10 0 73 39 6 13 0 19 1 6 43 1 29) #547# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #548=#A(t (9) (c::symbol-macro-p c::name c::*cmp-env* c::env c::cmp-env-search-var c::record c::var-p #Y(c::symbol-macro-p nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 13 0 19 2 4 45 5 10 0 73 39 8 13 0 19 1 6 76 73 43 1 29) #548# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #549=#A(t (16) (c::variable-type-in-env c::name c::*cmp-env* c::env c::cmp-env-search-var c::unw c::clb c::ccb c::var c::var-p c::var-type c::cmp-type si::get-sysprop t #Y(c::variable-type-in-env nil nil (24 45 1 25 40 3 14 2 46 3 26 13 1 19 1 4 47 3 5 47 2 6 47 1 7 45 8 13 0 19 1 9 39 8 13 0 19 1 10 38 13 13 5 1 11 17 12 73 40 4 11 13 73 43 4 29) #549# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #550=#A(t (10) (c::chk-symbol-macrolet c::form 0 symbolp c::*cmp-env* macroexpand-1 c::new-form eq #Y(c::chk-symbol-macrolet nil nil (24 45 1 26 58 60 52 57 2 61 1 1 10 2 16 3 76 39 6 10 2 73 36 1 13 2 14 4 19 2 5 45 6 13 0 10 3 17 7 39 6 10 3 73 36 2 10 0 51 3 43 1 35 0 0 62 73 63 29) #550# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 29 12 19 2 30 1 0 73 29) #551=#A(t (31) (c::c1make-var c::name c::specials c::ignores c::types symbolp "The variable ~s is not a symbol." c::cmperr constantp "The constant ~s is being bound." assoc type ignorable t member c::special-variable-p c::cmp-type si::get-sysprop :kind special :type c::c1make-global-variable :name :loc ffi::object c::lexical :ignorable :ref c::make-var #Y(c::c1make-var nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 10 3 16 5 76 39 8 15 6 13 3 19 2 7 13 3 19 1 8 39 8 15 9 13 3 19 2 7 13 3 13 1 19 2 10 5 12 77 46 11 46 12 13 5 13 2 19 2 10 51 1 39 6 10 1 5 38 3 1 13 51 1 13 5 13 4 19 2 14 40 6 13 5 19 1 15 39 33 10 1 76 39 13 13 5 1 16 17 17 40 3 1 13 51 1 13 5 14 18 15 19 14 20 13 1 19 5 21 38 28 14 22 13 5 14 20 13 1 14 23 15 24 14 18 15 25 14 26 13 0 14 27 9 0 19 12 28 43 2 29) #551# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #552=#A(t (21) (c::check-vref c::var c::var-kind c::lexical eq c::var-ref zerop c::var-ignorable "The variable ~s is not used." c::var-name c::cmpwarn-style c::var-ref-clb #:g20995 plusp c::var-type c::lisp-type->rep-type :object #:g20996 si::structure-set #Y(c::check-vref nil nil (24 45 1 26 13 0 19 1 2 12 1 3 17 4 73 39 81 13 0 19 1 5 16 6 39 7 13 0 19 1 7 76 39 12 15 8 13 0 19 1 9 12 19 2 10 13 0 19 1 11 76 73 39 44 10 0 45 12 13 1 19 1 5 16 13 39 12 13 1 19 1 14 12 19 1 15 38 3 11 16 45 17 13 1 15 1 9 6 13 0 19 4 18 43 1 43 1 29) #552# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #553=#A(t (12) (c::c1var c::name c::c1vref c::var :type c::var-type :args c::make-c1form* c::output c::add-to-read-nodes #Y(c::c1var nil nil (24 45 1 26 13 0 19 1 2 45 3 15 3 14 4 13 0 19 1 5 12 14 6 13 0 19 5 7 45 8 13 1 13 0 19 2 9 10 0 73 43 2 29) #553# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #554=#A(t (14) (c::make-lcl-var (nil :type :rep-type) c::rep-type t type c::lisp-type->rep-type :object :kind :type :loc c::next-lcl c::make-var #Y(c::make-lcl-var nil nil (28 1 22 40 2 77 46 2 22 40 3 15 3 46 4 10 1 76 39 16 10 0 39 8 13 0 19 1 5 38 3 11 6 51 1 10 0 76 39 5 1 3 51 0 14 7 13 1 14 8 13 0 14 9 19 0 10 12 19 6 11 29) #554# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #555=#A(t (12) (c::make-temp-var t type :kind :object :type :loc c::temp c::next-temp c::make-var #Y(c::make-temp-var nil nil (25 40 3 15 1 46 2 26 14 3 14 4 14 5 13 0 14 6 15 7 19 0 8 6 2 12 19 6 9 29) #555# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 35 12 19 2 36 1 0 73 29) #556=#A(t (37) (c::c1vref c::name c::cmp-env-search-var c::unw c::clb c::ccb c::var :warn t :type c::cmp-type si::get-sysprop c::c1make-global-variable c::var-p c::baboon c::assert-var-ref-value c::assert-var-not-ignored c::var-kind c::lexical eq #:g21009 #:g21010 si::structure-set #:g21011 #:g21012 #:g21013 c::closure #:g21014 #:g21015 ffi::object #:g21016 #:g21017 #:g21018 #:g21019 #:g21020 #Y(c::c1vref nil nil (24 45 1 26 13 0 19 1 2 47 3 3 47 2 4 47 1 5 45 6 10 0 76 39 27 13 4 14 7 14 8 14 9 13 4 1 10 17 11 73 40 4 11 8 73 12 19 5 12 38 186 13 0 19 1 13 76 39 6 19 0 14 38 173 13 0 19 1 15 13 0 19 1 16 13 0 19 1 17 12 1 18 17 19 39 148 10 1 39 94 10 0 45 20 75 45 21 13 1 15 6 9 3 13 0 19 4 22 43 1 43 1 10 0 45 23 11 8 45 24 13 1 15 6 9 2 13 0 19 4 22 43 1 43 1 10 0 45 25 1 26 45 27 13 1 15 6 9 6 13 0 19 4 22 43 1 43 1 10 0 45 28 1 29 45 30 13 1 15 6 9 10 13 0 19 4 22 43 1 43 1 38 51 10 2 39 47 10 0 45 31 11 8 45 32 13 1 15 6 9 3 13 0 19 4 22 43 1 43 1 10 0 45 33 1 29 45 34 13 1 15 6 9 10 13 0 19 4 22 43 1 43 1 10 0 73 43 4 29) #556# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #557=#A(t (11) (c::push-vars c::v #:g21023 c::*cmp-env* length #:g21024 c::var si::structure-set c::cmp-env-register-var #Y(c::push-vars nil nil (24 45 1 26 10 0 45 2 11 3 4 16 4 45 5 13 1 15 6 9 12 13 0 19 4 7 43 1 43 1 13 0 19 1 8 29) #557# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #558=#A(t (7) (c::unboxed c::var c::var-rep-type :object eq #Y(c::unboxed nil nil (24 45 1 26 13 0 19 1 2 12 11 3 17 4 76 73 29) #558# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #559=#A(t (7) (c::local c::var c::var-kind (c::lexical c::closure special c::global) member #Y(c::local nil nil (24 45 1 26 13 0 19 1 2 12 15 3 19 2 4 76 73 39 6 13 0 19 1 2 29) #559# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #560=#A(t (9) (c::global-var-p c::var c::var-kind c::kind c::global eq special #Y(c::global-var-p nil nil (24 45 1 26 13 0 19 1 2 45 3 13 0 1 4 17 5 73 40 7 13 0 1 6 17 5 43 1 29) #560# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #561=#A(t (7) (c::useful-var-p c::var c::var-ref plusp c::global-var-p #Y(c::useful-var-p nil nil (24 45 1 26 13 0 19 1 2 16 3 73 40 6 13 0 19 1 4 29) #561# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #562=#A(t (8) (c::c2var/location c::c1form c::loc c::c1form-primary-type c::precise-loc-type c::unwind-exit #Y(c::c2var/location nil nil (24 45 1 24 45 2 26 13 0 13 1 19 1 3 12 19 2 4 12 19 1 5 29) #562# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #563=#A(t (18) (c::wt-var c::var c::var-loc c::var-kind c::closure c::wt-env c::lexical c::wt-lex special c::global c::safe-compile "ecl_symbol_value(" ")" c::wt "ECL_SYM_VAL(cl_env_copy," ")" #Y(c::wt-var nil nil (24 45 1 26 13 0 19 1 2 45 2 13 1 19 1 3 42 4 8 13 0 19 1 5 38 49 42 6 8 13 0 19 1 7 38 39 41 8 4 42 9 28 19 0 10 39 12 15 11 13 0 15 12 19 3 13 38 10 15 14 13 0 15 15 19 3 13 38 6 13 0 19 1 13 43 1 29) #563# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #564=#A(t (10) (c::var-rep-type c::var c::var-kind c::lexical c::closure special c::global :object #Y(c::var-rep-type nil nil (24 45 1 26 13 0 19 1 2 41 3 10 41 4 7 41 5 4 42 6 6 11 7 73 38 6 13 0 19 1 2 29) #564# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 27 12 19 2 28 1 0 73 29) #565=#A(t (29) (c::set-var c::loc c::var c::var-loc c::var-p c::baboon c::var-kind c::closure c::wt-nl c::wt-env " = " c::wt c::var-rep-type c::wt-coerce-loc #\; c::lexical c::wt-lex " = " special c::global c::safe-compile "cl_set(" "," "ECL_SETQ(cl_env_copy," "," ");" " = " #Y(c::set-var nil nil (24 45 1 24 45 2 26 13 0 19 1 3 45 3 13 1 19 1 4 76 39 4 19 0 5 13 1 19 1 6 42 7 32 19 0 8 13 0 19 1 9 15 10 19 1 11 13 1 19 1 12 12 13 2 19 2 13 15 14 19 1 11 38 107 42 15 32 19 0 8 13 0 19 1 16 15 17 19 1 11 13 1 19 1 12 12 13 2 19 2 13 15 14 19 1 11 38 73 41 18 4 42 19 44 19 0 20 39 12 15 21 13 0 15 22 19 3 8 38 10 15 23 13 0 15 24 19 3 8 13 1 19 1 12 12 13 2 19 2 13 15 25 19 1 11 38 24 13 0 15 26 19 2 8 13 1 19 1 12 12 13 2 19 2 13 15 14 19 1 11 29) #565# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #566=#A(t (10) (c::wt-lex c::lex consp "lex" "[" "]" c::wt c::wt-lcl #Y(c::wt-lex nil nil (24 45 1 26 10 0 16 2 39 20 15 3 10 0 4 12 15 4 10 0 5 12 15 5 19 5 6 38 6 13 0 19 1 7 29) #566# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #567=#A(t (7) (c::wt-env c::clv "ECL_CONS_CAR(CLV" ")" c::wt #Y(c::wt-env nil nil (24 45 1 26 15 2 13 0 15 3 19 3 4 29) #567# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 1 0 73 29) #568=#A(t (24) (c::c1make-global-variable c::name (nil :warn :kind :type) c::cmp-type si::get-sysprop t type c::global c::kind warn :name :kind :type :loc c::add-symbol c::make-var c::var constantp c::special-variable-p c::*undefined-vars* member c::undefined-variable #Y(c::c1make-global-variable nil nil (24 45 1 28 2 22 40 14 13 0 1 3 17 4 73 40 4 11 5 73 12 46 6 22 40 3 15 7 46 8 22 40 2 77 46 9 14 10 13 3 14 11 13 1 14 12 13 2 14 13 13 3 19 1 14 12 19 8 15 45 16 10 1 39 37 13 4 19 1 17 40 15 13 4 19 1 18 40 8 13 4 14 19 19 2 20 76 39 13 13 4 19 1 21 13 4 11 19 3 52 19 10 0 73 43 1 29) #568# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #569=#A(t (6) (c::c1declare-specials c::globals c::cmp-env-declare-special mapc #Y(c::c1declare-specials nil nil (24 45 1 26 33 2 12 13 0 19 2 3 29) #569# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #570=#A(t (6) (si::register-global c::name c::*global-vars* adjoin #Y(si::register-global nil nil (24 45 1 26 13 0 14 2 19 2 3 52 2 0 29) #570# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #571=#A(t (22) (c::c1setq c::args length c::l oddp "SETQ requires an even number of arguments." c::cmperr zerop c::c1nil = second c::c1setq1 #:loop-list-head21033 #:loop-list-tail21034 0 setq #:g21035 #:g21036 rplacd c::c1progn #Y(c::c1setq nil nil (24 45 1 26 10 0 16 2 45 3 10 0 16 4 39 6 15 5 19 1 6 10 0 16 7 39 6 19 0 8 38 119 13 0 9 2 19 2 9 39 15 10 1 4 12 10 1 16 10 12 19 2 11 38 96 58 60 89 75 6 1 45 12 10 0 45 13 57 14 61 2 2 63 10 5 76 39 4 35 0 1 13 1 15 15 10 5 45 16 10 0 4 12 10 0 5 51 0 10 0 51 6 43 1 10 5 45 17 10 0 4 12 10 0 5 51 0 10 0 51 6 22 43 1 6 3 6 1 51 1 17 18 35 0 0 10 2 5 73 36 3 62 73 43 2 63 12 19 1 19 43 1 29) #571# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 1 0 73 29) #572=#A(t (24) (c::c1setq1 c::name c::form symbolp "The variable ~s is not a symbol." c::cmperr constantp "The constant ~s is being assigned a value." c::chk-symbol-macrolet c::c1vref c::var-type type c::trivial-type-p ext::checked-value c::c1expr setq :type c::c1form-type :args c::make-c1form* c::add-to-set-nodes setf #Y(c::c1setq1 nil nil (24 45 1 24 45 2 26 10 1 16 3 76 39 8 15 4 13 1 19 2 5 13 1 19 1 6 39 8 15 7 13 1 19 2 5 13 1 19 1 8 51 1 10 1 16 3 39 71 13 1 19 1 9 45 1 13 0 19 1 10 45 11 13 0 19 1 12 39 6 10 2 73 38 10 15 13 13 0 10 2 6 3 73 12 19 1 14 45 2 13 2 15 15 14 16 13 0 19 1 17 12 14 18 13 2 13 0 19 6 19 12 19 2 20 43 3 38 10 15 21 13 1 10 0 6 3 73 29) #572# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #573=#A(t (14) (c::c2setq c::c1form c::vref c::form c::*destination* c::c2expr* c::c1form-name ext::location eq c::c1form-args c::c2var/location c::unwind-exit #Y(c::c2setq nil nil (24 45 1 24 45 2 24 45 3 26 10 1 48 4 13 0 19 1 5 44 1 13 0 19 1 6 12 1 7 17 8 39 15 13 0 13 0 19 1 9 4 12 19 2 10 38 6 13 1 19 1 11 29) #573# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #574=#A(t (17) (c::c1progv c::args progv c::check-args-number c::c1expr second cddr c::c1progn c::forms values c::symbols :type c::c1form-type :args c::make-c1form* #Y(c::c1progv nil nil (24 45 1 26 15 2 13 0 9 2 19 3 3 10 0 4 12 19 1 4 12 10 0 16 5 12 19 1 4 12 10 0 16 6 12 19 1 7 12 46 8 46 9 46 10 15 2 14 11 13 2 19 1 12 12 14 13 13 0 13 1 13 2 19 7 14 43 3 29) #574# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #575=#A(t (27) (c::c2progv c::c1form c::symbols values c::body c::*lcl* c::next-lcl c::lcl c::make-lcl-var c::sym-loc c::val-loc c::*unwind-exit* c::wt-nl-open-brace "cl_object " ", " "; cl_index " ";" c::wt-nl c::*destination* c::c2expr* " = ecl_progv(cl_env_copy, " ", " ");" c::c2expr c::wt-nl-close-brace #Y(c::c2progv nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 11 5 48 5 19 0 6 45 7 19 0 8 45 9 19 0 8 45 10 13 2 11 11 3 48 11 19 0 12 15 13 13 1 15 14 13 0 15 15 13 2 15 16 19 7 17 10 1 48 18 13 5 19 1 19 44 1 10 0 48 18 13 4 19 1 19 44 1 13 2 15 20 13 1 15 21 13 0 15 22 19 6 17 13 3 19 1 23 19 0 24 43 3 44 2 29) #575# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 38 12 19 2 39 1 0 73 29) #576=#A(t (40) (c::c1psetq c::old-args c::args c::use-psetf c::l #:g21039 c::var symbolp "The variable ~s is not a symbol." c::cmperr "No form was given for the value of ~s." c::chk-symbol-macrolet #:g21040 nconc constantp "The constant ~s is being assigned a value." t psetf c::forms c::vrefs #:g21045 c::c1vref c::vref c::var-type type #:g21046 c::form c::trivial-type-p ext::checked-value c::c1expr psetq :type (member nil) :args reverse nreverse c::make-c1form* c::add-to-set-nodes-of-var-list #Y(c::c1psetq nil nil (24 45 1 26 75 45 2 75 45 3 57 0 60 278 10 3 45 4 38 116 10 0 45 5 10 0 4 12 10 0 5 51 0 10 0 51 1 22 43 1 45 6 10 0 16 7 76 39 8 15 8 13 0 19 2 9 10 1 2 39 8 15 10 13 0 19 2 9 13 0 19 1 11 51 0 13 4 13 0 10 1 45 12 10 0 4 12 10 0 5 51 0 10 0 51 2 22 43 1 6 2 12 19 2 13 51 4 10 0 16 7 39 17 13 0 19 1 14 39 8 15 15 13 0 19 2 9 38 5 11 16 51 3 43 1 10 0 2 39 -119 43 1 10 1 39 10 15 17 10 2 7 2 73 36 0 77 77 46 18 46 19 38 94 10 4 45 20 10 0 4 12 10 0 5 51 0 10 0 51 5 43 1 19 1 21 45 22 13 0 19 1 23 45 24 10 6 45 25 10 0 4 12 10 0 5 51 0 10 0 51 7 22 43 1 45 26 13 2 10 3 3 51 3 13 1 19 1 27 39 6 10 0 73 38 10 15 28 13 1 10 0 6 3 73 12 19 1 29 12 10 4 3 51 4 43 3 10 4 2 39 -97 13 0 15 30 14 31 15 32 14 33 10 0 16 34 12 10 1 16 35 12 19 6 36 12 19 2 37 43 2 63 29) #576# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 35 12 19 2 36 1 0 73 29) #577=#A(t (37) (c::c2psetq c::c1form c::vrefs c::forms c::*lcl* c::saves c::*opened-c-braces* c::braces c::form c::var c::var-changed-in-form-list c::var-referenced-in-form-list c::c1form-name ext::location c::c1form-args c::local c::var-rep-type c::rep-type c::rep-type-name :rep-type c::make-lcl-var c::temp c::wt-nl-open-brace c::*volatile* " " ";" c::wt-nl c::*destination* c::c2expr* c::make-temp-var si::%dolist-var c::save c::set-var c::wt-nl-close-many-braces c::unwind-exit #Y(c::c2psetq nil nil (24 45 1 24 45 2 24 45 3 26 11 4 48 4 75 45 5 11 6 45 7 13 3 13 2 77 77 46 8 46 9 46 3 46 2 38 178 10 0 4 51 2 10 1 4 51 3 13 2 10 1 5 12 19 2 10 40 10 13 2 10 1 5 12 19 2 11 39 123 13 3 19 1 12 42 13 18 13 2 13 3 19 1 14 4 3 12 10 5 3 51 5 38 96 13 2 19 1 15 39 66 13 2 19 1 16 45 17 13 0 19 1 18 45 18 14 19 13 1 19 2 20 45 21 19 0 22 14 23 13 1 15 24 13 0 15 25 19 5 26 10 0 48 27 13 6 19 1 28 44 1 13 5 10 0 3 12 10 8 3 51 8 43 3 38 24 19 0 29 48 27 13 3 19 1 28 13 2 11 27 3 12 10 5 3 51 5 44 1 38 12 10 2 48 27 13 3 19 1 28 44 1 10 0 5 12 10 1 5 12 53 1 53 0 10 0 76 39 -181 43 4 10 1 45 30 75 45 31 38 22 10 1 4 51 0 10 0 5 12 10 0 4 12 19 2 32 10 1 5 51 1 10 1 40 -24 43 2 13 0 19 1 33 77 19 1 34 44 1 29) #577# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #578=#A(t (5) (c::data-permanent-storage-size c::*permanent-objects* length #Y(c::data-permanent-storage-size nil nil (26 11 1 16 2 29) #578# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #579=#A(t (5) (c::data-temporary-storage-size c::*temporary-objects* length #Y(c::data-temporary-storage-size nil nil (26 11 1 16 2 29) #579# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #580=#A(t (6) (c::data-size c::data-permanent-storage-size c::data-temporary-storage-size + #Y(c::data-size nil nil (26 19 0 1 12 19 0 2 12 19 2 3 29) #580# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #581=#A(t (18) (c::data-init c::filename probe-file :direction :input open c::s read c::*permanent-objects* c::*temporary-objects* close :abort t :adjustable :fill-pointer make-array #Y(c::data-init nil nil (25 40 2 77 46 1 26 10 0 39 5 10 0 16 2 39 59 13 0 14 3 14 4 19 3 5 45 6 64 28 13 0 19 1 7 52 8 13 0 19 1 7 52 9 73 69 10 0 39 6 13 0 19 1 10 70 65 10 0 39 10 13 0 14 11 14 12 19 3 10 66 43 1 38 32 9 128 14 13 14 12 14 14 9 0 19 5 15 52 8 9 128 14 13 14 12 14 14 9 0 19 5 15 52 9 73 29) #581# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 28 12 19 2 29 1 0 73 29) #582=#A(t (30) (c::data-get-all-objects c::*permanent-objects* c::*temporary-objects* #:loop-list21079 array #:loop-list-head21080 #:loop-list-tail21081 0 #:g21087 #:loop-across-list21084 #:loop-across-index-21083 #:loop-across-vector-21082 rest c::vv-record ffi::object #:loop-list-head21085 #:loop-list-tail21086 length >= aref #72# 1+ c::*load-objects* gethash c::vv-used-p rplacd #:g21088 last #Y(c::data-get-all-objects nil nil (26 58 60 238 77 14 1 11 2 6 2 12 46 3 46 4 75 6 1 45 5 10 0 45 6 57 7 61 2 2 198 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 1 45 8 58 60 145 77 77 77 13 5 9 0 9 0 46 9 46 10 46 11 46 12 46 13 46 14 75 6 1 45 15 10 0 45 16 57 7 61 2 8 97 10 6 16 17 51 8 13 7 13 8 19 2 18 39 4 35 0 1 13 6 13 7 19 2 19 45 20 10 0 4 51 4 10 0 5 51 0 10 0 4 51 5 10 0 5 51 0 10 0 51 6 43 1 10 7 16 21 51 7 13 1 13 3 14 22 19 2 23 39 5 8 0 38 14 13 4 19 1 24 39 5 10 3 38 3 8 0 6 1 51 1 17 25 35 0 0 10 2 5 73 36 9 62 43 2 43 6 63 45 26 13 1 10 0 17 25 10 0 43 1 43 1 39 10 10 1 5 12 19 1 27 51 1 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 29) #582# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #583=#A(t (22) (c::data-dump-array si::*compiler-constants* vector c::data-get-all-objects concatenate "" c::data-size plusp c::*wt-string-size* c::*wt-data-column* c::data si::+ecl-syntax-progv-list+ #:%progv-list prin1-to-string c::data-string length c::l 1- subseq "" #Y(c::data-dump-array nil nil (26 11 1 39 17 15 2 19 0 3 12 19 2 4 52 1 1 5 73 38 70 19 0 6 16 7 39 60 8 0 48 8 8 80 45 9 19 0 3 45 10 11 11 45 12 10 0 4 12 10 0 5 67 13 1 19 1 13 68 43 1 45 14 10 0 16 15 45 16 13 1 9 1 10 0 16 17 12 19 3 18 43 4 44 1 38 4 1 19 73 29) #583# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 29 12 19 2 30 1 0 73 29) #584=#A(t (31) (c::data-c-dump c::filename :direction :output :if-does-not-exist :create :if-exists :supersede :external-format :default open stream c::data-dump-array string c::*compile-in-constants* length plusp c::*wt-data-column* c::*wt-string-size* "static const char compiler_data_text[] = " princ c::wt-filtered-data #\; "~%#define compiler_data_text_size ~D~%" format "#define compiler_data_text NULL
#define compiler_data_text_size 0" close :abort t #Y(c::data-c-dump nil nil (24 45 1 26 13 0 14 2 14 3 14 4 14 5 14 6 14 7 14 8 14 9 19 9 10 45 11 64 83 19 0 12 45 13 11 14 39 7 10 0 16 15 16 16 39 45 9 0 9 80 46 17 49 18 15 19 13 2 19 2 20 13 1 13 2 19 2 21 15 22 13 2 19 2 20 13 2 15 23 14 18 19 3 24 43 1 44 1 38 8 15 25 13 1 19 2 20 43 1 69 10 0 39 6 13 0 19 1 26 70 65 10 0 39 10 13 0 14 27 14 28 19 3 26 66 43 1 29) #584# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #585=#A(t (8) (c::data-binary-dump c::filename string c::*compile-in-constants* c::data-dump-array si::add-cdata #Y(c::data-binary-dump nil nil (24 45 1 25 40 2 77 46 2 26 11 3 76 73 39 12 13 1 10 0 40 4 19 0 4 17 5 29) #585# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 2 12 19 2 3 1 0 73 29) #586=#A(t (4) (c::wt-data-begin stream #Y(c::wt-data-begin nil nil (24 45 1 26 75 73 29) #586# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #587=#A(t (9) (c::wt-data-end stream #\; princ "~%#define compiler_data_text_size ~D~%" c::*wt-string-size* format #Y(c::wt-data-end nil nil (24 45 1 26 15 2 13 0 19 2 3 13 0 15 4 14 5 19 3 6 8 0 52 5 73 29) #587# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #588=#A(t (7) (c::data-empty-loc :duplicate t :permanent c::add-object #Y(c::data-empty-loc nil nil (26 9 0 14 1 14 2 14 3 14 2 19 5 4 29) #588# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #589=#A(t (21) (c::add-load-form ffi::object ext::location c::*cmp-env* clos::need-to-make-load-form-p c::*compiler-phase* c::t1 eq "Unable to internalize complex object ~A in ~a phase" c::cmperr make-load-form c::init-form c::make-form c::*load-objects* si::hash-set :args c::c1expr c::make-c1form* c::*make-forms* #Y(c::add-load-form nil nil (24 45 1 24 45 2 26 13 1 14 3 19 2 4 73 39 94 14 5 1 6 17 7 76 39 12 15 8 13 1 14 5 19 3 9 38 74 13 1 19 1 10 47 1 11 45 12 13 3 14 13 13 2 19 3 14 10 0 39 22 15 12 14 15 13 2 13 0 19 1 16 12 19 4 17 12 11 18 3 52 18 10 1 73 39 23 15 11 14 15 13 2 13 1 19 1 16 12 19 4 17 12 11 18 3 52 18 73 43 2 29) #589# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 33 12 19 2 34 1 0 73 29) #590=#A(t (35) (c::add-object ffi::object (nil :permanent :duplicate) c::duplicate symbolp c::*permanent-data* c::permanent si::*compiler-constants* eq equal c::test c::*permanent-objects* c::*temporary-objects* array :test :key first find c::x length c::next-ndx c::forced c::found c::add-static-constant :location :used-p :permanent-p :value c::make-vv vector-push-extend second si::mangle-name c::add-load-form #Y(c::add-object nil nil (24 45 1 28 2 22 40 2 77 46 3 22 40 12 10 1 16 4 73 40 4 11 5 73 12 46 6 11 7 39 5 1 8 38 3 1 9 45 10 10 1 39 5 11 11 38 3 11 12 45 13 10 2 76 39 17 13 4 14 11 14 14 13 1 14 15 33 16 12 19 6 17 40 17 13 4 13 0 14 14 13 1 14 15 33 16 12 19 6 17 45 18 10 1 16 19 45 20 10 5 45 21 75 45 22 13 8 19 1 23 73 40 137 10 3 39 3 10 7 39 41 14 24 13 2 14 25 13 1 14 26 13 6 14 27 13 8 19 8 28 51 3 13 8 13 3 10 2 6 3 12 13 4 19 2 29 10 3 73 38 89 10 3 39 7 10 3 16 30 38 79 10 7 76 39 17 10 8 16 4 39 11 13 8 19 1 31 51 0 55 3 1 39 6 10 3 73 38 51 14 24 13 2 14 25 13 1 14 26 13 6 14 27 13 8 19 8 28 51 3 13 8 13 3 10 2 6 3 12 13 4 19 2 29 11 7 76 39 8 13 8 13 3 19 2 32 10 3 73 43 6 29) #590# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #591=#A(t (8) (c::add-symbol symbol :duplicate :permanent t c::add-object #Y(c::add-symbol nil nil (24 45 1 26 13 0 14 2 77 14 3 14 4 19 5 5 29) #591# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #592=#A(t (20) (c::add-keywords c::keywords c::*permanent-objects* :test c::k c::record eq #Y(nil nil nil (24 45 4 24 45 5 26 13 1 10 0 4 17 6 29) #592# #1# 0) search c::x elt second #:g21104 :duplicate t :permanent c::add-object si::%dolist-var #Y(c::add-keywords nil nil (24 45 1 26 13 0 14 2 14 3 34 7 12 19 4 8 45 9 10 0 39 11 14 2 10 0 17 10 16 11 38 72 10 1 45 12 10 0 4 12 10 0 5 51 0 10 0 51 2 43 1 14 13 14 14 14 15 14 14 19 5 16 12 10 1 45 17 75 45 4 38 24 10 1 4 51 0 13 0 14 13 14 14 14 15 14 14 19 5 16 10 1 5 51 1 10 1 40 -26 43 2 22 73 43 1 29) #592# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #593=#A(t (13) (c::static-base-string-builder c::name c::value stream "ecl_def_ct_base_string(~A," format :one-liner t c::wt-filtered-data ",~D,static,const);" length #Y(c::static-base-string-builder nil nil (24 45 1 24 45 2 24 45 3 26 13 0 15 4 13 2 19 3 5 13 1 13 0 14 6 14 7 19 4 8 13 0 15 9 10 1 16 10 12 19 3 5 29) #593# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #594=#A(t (12) (c::static-single-float-builder c::name c::value stream single-float *read-default-float-format* t *print-readably* "ecl_def_ct_single_float(~A,~S,static,const);" format #Y(c::static-single-float-builder nil nil (24 45 1 24 45 2 24 45 3 26 1 4 48 5 11 6 48 7 13 0 15 8 13 2 13 1 13 0 19 5 9 44 2 29) #594# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #595=#A(t (12) (c::static-double-float-builder c::name c::value stream double-float *read-default-float-format* t *print-readably* "ecl_def_ct_double_float(~A,~S,static,const);" format #Y(c::static-double-float-builder nil nil (24 45 1 24 45 2 24 45 3 26 1 4 48 5 11 6 48 7 13 0 15 8 13 2 13 1 13 0 19 5 9 44 2 29) #595# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #596=#A(t (12) (c::static-long-float-builder c::name c::value stream long-float *read-default-float-format* t *print-readably* "ecl_def_ct_long_float(~A,~SL,static,const);" format #Y(c::static-long-float-builder nil nil (24 45 1 24 45 2 24 45 3 26 1 4 48 5 11 6 48 7 13 0 15 8 13 2 13 1 13 0 19 5 9 44 2 29) #596# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #597=#A(t (14) (c::static-rational-builder c::name c::value stream double-float *read-default-float-format* t *print-readably* "ecl_def_ct_ratio(~A,ecl_make_fixnum(~D),ecl_make_fixnum(~D),static,const);" numerator denominator format #Y(c::static-rational-builder nil nil (24 45 1 24 45 2 24 45 3 26 1 4 48 5 11 6 48 7 13 0 15 8 13 2 10 1 16 9 12 10 1 16 10 12 19 5 11 44 2 29) #597# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #598=#A(t (7) (c::static-constant-delegate c::name c::value stream c::static-constant-expression #Y(c::static-constant-delegate nil nil (24 45 1 24 45 2 24 45 3 26 13 1 19 1 4 12 13 2 13 1 13 0 20 3 23 29) #598# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #599=#A(t (22) (c::static-complex-builder c::name c::value stream double-float *read-default-float-format* t *print-readably* string "_real" concatenate c::name-real "_imag" c::name-imag realpart c::static-constant-delegate terpri imagpart "ecl_def_ct_complex(~A,&~A_data,&~A_data,static,const);" format #Y(c::static-complex-builder nil nil (24 45 1 24 45 2 24 45 3 26 1 4 48 5 11 6 48 7 15 8 13 2 15 9 19 3 10 45 11 15 8 13 3 15 12 19 3 10 45 13 13 1 10 3 16 14 12 13 2 19 3 15 13 2 19 1 16 13 0 10 3 16 17 12 13 2 19 3 15 13 2 19 1 16 13 2 15 18 13 4 13 1 13 0 19 5 19 43 2 44 2 29) #599# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #600=#A(t (8) (c::static-constant-builder format c::value c::name stream #Y(nil nil nil (24 45 3 24 45 4 26 13 0 13 3 13 1 13 2 19 4 1 29) #600# #1# 0) #Y(c::static-constant-builder nil nil (24 45 1 24 45 2 26 34 5 73 29) #600# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 1 0 73 29) #601=#A(t (24) (c::static-constant-expression ffi::object #:g21106 base-string typep c::static-base-string-builder ratio numerator denominator c::static-rational-builder single-float ext::float-nan-p ext::float-infinity-p c::static-single-float-builder double-float c::static-double-float-builder long-float c::static-long-float-builder complex realpart imagpart c::static-complex-builder #Y(c::static-constant-expression nil nil (24 45 1 26 10 0 45 2 13 0 15 3 19 2 4 39 6 33 5 73 38 165 13 0 15 6 19 2 4 39 28 10 1 16 7 12 19 1 0 73 39 15 10 1 16 8 12 19 1 0 73 39 4 33 9 73 38 129 13 0 15 10 19 2 4 39 22 10 1 16 11 76 73 39 12 10 1 16 12 76 73 39 4 33 13 73 38 99 13 0 15 14 19 2 4 39 22 10 1 16 11 76 73 39 12 10 1 16 12 76 73 39 4 33 15 73 38 69 13 0 15 16 19 2 4 39 22 10 1 16 11 76 73 39 12 10 1 16 12 76 73 39 4 33 17 73 38 39 13 0 15 18 19 2 4 39 28 10 1 16 19 12 19 1 0 73 39 15 10 1 16 20 12 19 1 0 73 39 4 33 21 73 38 3 75 73 43 1 29) #601# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 1 0 73 29) #602=#A(t (24) (c::add-static-constant ffi::object si::*compiler-constants* c::*use-static-constants-p* c::*static-constants* listp :key first :test equal find c::record second c::static-constant-expression c::builder "_ecl_static_~D" length format c::c-name :location :value c::make-vv #Y(c::add-static-constant nil nil (24 45 1 26 11 2 40 11 11 3 76 40 6 11 4 16 5 76 76 73 39 86 13 0 14 4 14 6 33 7 12 14 8 33 9 12 19 6 10 45 11 10 0 39 7 10 0 16 12 38 55 13 1 19 1 13 45 14 10 0 73 39 41 77 15 15 11 4 16 16 12 19 3 17 45 18 13 3 13 0 10 1 6 3 12 11 4 3 52 4 14 19 13 0 14 20 13 3 19 4 21 43 1 43 1 43 1 29) #602# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #603=#A(t (11) (c::wt-vv-index c::index c::permanent-p numberp c::wt "VV[" "]" "VVtemp[" "]" #Y(c::wt-vv-index nil nil (24 45 1 24 45 2 26 10 1 16 3 76 39 8 13 1 19 1 4 38 25 10 0 39 12 15 5 13 1 15 6 19 3 4 38 10 15 7 13 1 15 8 19 3 4 29) #603# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #604=#A(t (13) (c::set-vv-index c::loc c::index c::permanent-p c::wt-nl c::wt-vv-index "= " c::wt :object c::wt-coerce-loc ";" #Y(c::set-vv-index nil nil (24 45 1 24 45 2 24 45 3 26 19 0 4 13 1 13 0 19 2 5 15 6 19 1 7 14 8 13 2 19 2 9 15 10 19 1 7 29) #604# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #605=#A(t (12) (c::wt-vv c::vv-loc #:g21111 t #:g21112 c::vv si::structure-set c::vv-location c::vv-permanent-p c::wt-vv-index #Y(c::wt-vv nil nil (24 45 1 26 10 0 45 2 11 3 45 4 13 1 15 5 9 1 13 0 19 4 6 43 1 43 1 13 0 19 1 7 12 13 0 19 1 8 12 19 2 9 29) #605# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #606=#A(t (13) (c::set-vv c::loc c::vv-loc #:g21115 t #:g21116 c::vv si::structure-set c::vv-location c::vv-permanent-p c::set-vv-index #Y(c::set-vv nil nil (24 45 1 24 45 2 26 10 0 45 3 11 4 45 5 13 1 15 6 9 1 13 0 19 4 7 43 1 43 1 13 1 13 0 19 1 8 12 13 0 19 1 9 12 19 3 10 29) #606# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #607=#A(t (9) (c::vv-type c::loc c::vv-value c::value ext::fixnump type-of t #Y(c::vv-type nil nil (24 45 1 26 13 0 19 1 2 45 3 10 0 39 6 10 0 16 4 76 39 7 10 0 16 5 38 4 11 6 73 43 1 29) #607# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+all-integer-rep-type-pairs+ ((:byte . -8) (:unsigned-byte . 8) (:unsigned-short . 16) (:short . -16) (:unsigned-int . 32) (:int . 32) (:unsigned-long . 64) (:long . 64) (:unsigned-long-long . 64) (:long-long . 64) (:cl-index . 64) (:fixnum . -64) (:uint8-t . 8) (:int8-t . -8) (:uint16-t . 16) (:int16-t . -16) (:uint32-t . 32) (:int32-t . -32) (:uint64-t . 64) (:int64-t . -64)) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 33 1 12 14 2 19 2 3 17 4 1 0 73 29) #A(t (5) (c::+all-integer-rep-types+ car c::+all-integer-rep-type-pairs+ mapcar si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 15 2 19 2 3 17 4 1 0 73 29) #A(t (5) (c::+all-number-rep-types+ c::+all-integer-rep-types+ (:float :double :long-double) append si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+representation-types+ (:byte #608=((signed-byte 8) "int8_t" "ecl_make_int8_t" "ecl_to_int8_t" "ecl_fixnum") :unsigned-byte #609=((unsigned-byte 8) "uint8_t" "ecl_make_uint8_t" "ecl_to_uint8_t" "ecl_fixnum") :fixnum (fixnum "cl_fixnum" "ecl_make_fixnum" "ecl_to_fixnum" "ecl_fixnum") :int ((integer -2147483648 2147483647) "int" "ecl_make_int" "ecl_to_int" "ecl_to_int") :unsigned-int ((integer 0 4294967295) "unsigned int" "ecl_make_uint" "ecl_to_uint" "ecl_to_uint") :long ((integer -9223372036854775808 9223372036854775807) "long" "ecl_make_long" "ecl_to_long" "ecl_to_long") :unsigned-long ((integer 0 18446744073709551615) "unsigned long" "ecl_make_ulong" "ecl_to_ulong" "ecl_fixnum") :cl-index ((integer 0 2305843009213693951) "cl_index" "ecl_make_unsigned_integer" "ecl_to_cl_index" "ecl_fixnum") :long-long ((signed-byte 64) "ecl_long_long_t" "ecl_make_long_long" "ecl_to_long_long" "ecl_to_long_long") :unsigned-long-long ((unsigned-byte 64) "ecl_ulong_long_t" "ecl_make_ulong_long" "ecl_to_ulong_long" "ecl_to_ulong_long") :float (single-float "float" "ecl_make_single_float" "ecl_to_float" "ecl_single_float") :double (double-float "double" "ecl_make_double_float" "ecl_to_double" "ecl_double_float") :long-double (long-float "long double" "ecl_make_long_float" "ecl_to_long_double" "ecl_long_float") :unsigned-char (base-char "unsigned char" "CODE_CHAR" "ecl_base_char_code" "CHAR_CODE") :char (base-char "char" "CODE_CHAR" "ecl_base_char_code" "CHAR_CODE") :wchar (character "ecl_character" "CODE_CHAR" "ecl_char_code" "CHAR_CODE") :object (t "cl_object") :bool (t "bool" "ecl_make_bool" "ecl_to_bool" "ecl_to_bool") :void (nil "void") :pointer-void (si::foreign-data "void*" "ecl_make_pointer" "ecl_to_pointer" "ecl_to_pointer") :cstring (string "char*" "ecl_cstring_to_base_string_or_nil") :char* (string "char*") :int8-t #608# :uint8-t #609# :int16-t ((unsigned-byte 16) "ecl_int16_t" "ecl_make_int16_t" "ecl_to_int16_t" "ecl_fixnum") :uint16-t ((signed-byte 16) "ecl_uint16_t" "ecl_make_uint16_t" "ecl_to_uint16_t" "ecl_fixnum" "ecl_fixnum") :int32-t ((unsigned-byte 32) "ecl_int32_t" "ecl_make_int32_t" "ecl_to_int32_t" "ecl_fixnum") :uint32-t ((signed-byte 32) "ecl_uint32_t" "ecl_make_uint32_t" "ecl_to_uint32_t" "ecl_fixnum") :int64-t ((signed-byte 64) "ecl_int64_t" "ecl_make_int64_t" "ecl_to_int64_t" "ecl_to_int64_t") :uint64-t ((signed-byte 64) "ecl_uint64_t" "ecl_make_uint64_t" "ecl_to_uint64_t" "ecl_to_uint64_t") :short ((integer -32768 32767) "short" "ecl_make_short" "ecl_to_short" "ecl_fixnum") :unsigned-short ((integer 0 65535) "unsigned short" "ecl_make_ushort" "ecl_to_ushort" "ecl_fixnum")) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 58 60 83 14 2 9 128 14 3 15 4 19 4 5 45 6 11 7 45 8 75 45 9 75 45 10 57 11 61 2 2 39 10 3 4 51 2 10 3 16 12 51 1 13 2 13 4 13 1 19 3 13 10 3 16 14 51 3 10 3 16 15 39 4 35 0 1 35 0 0 10 4 73 36 5 62 43 1 43 1 43 1 43 1 63 52 0 1 0 73 29) #A(t (16) (c::+representation-type-hash+ si::*make-special :size :test eq make-hash-table c::table c::+representation-types+ c::record c::rep-type c::information 0 second si::hash-set cddr atom)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #610=#A(t (6) (c::c-number-rep-type-p c::rep-type c::+all-number-rep-types+ member #Y(c::c-number-rep-type-p nil nil (24 45 1 26 13 0 14 2 19 2 3 29) #610# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #611=#A(t (6) (c::c-integer-rep-type-p c::rep-type c::+all-integer-rep-types+ member #Y(c::c-integer-rep-type-p nil nil (24 45 1 26 13 0 14 2 19 2 3 29) #611# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #612=#A(t (7) (c::c-integer-rep-type-bits c::rep-type c::+all-integer-rep-type-pairs+ assoc abs #Y(c::c-integer-rep-type-bits nil nil (24 45 1 26 13 0 14 2 19 2 3 5 16 4 29) #612# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #613=#A(t (6) (c::c-number-type-p type c::lisp-type->rep-type c::c-number-rep-type-p #Y(c::c-number-type-p nil nil (24 45 1 26 13 0 19 1 2 12 19 1 3 29) #613# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #614=#A(t (6) (c::c-integer-type-p type c::lisp-type->rep-type c::c-integer-rep-type-p #Y(c::c-integer-type-p nil nil (24 45 1 26 13 0 19 1 2 12 19 1 3 29) #614# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #615=#A(t (6) (c::c-integer-type-bits type c::lisp-type->rep-type c::c-number-rep-type-bits #Y(c::c-integer-type-bits nil nil (24 45 1 26 13 0 19 1 2 12 19 1 3 29) #615# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #616=#A(t (6) (c::rep-type-record c::rep-type c::+representation-type-hash+ gethash #Y(c::rep-type-record nil nil (24 45 1 26 13 0 14 2 19 2 3 29) #616# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #617=#A(t (12) (c::rep-type->lisp-type c::rep-type c::rep-type-record c::output :void eq "Representation type ~S cannot be coerced to lisp" c::cmperr c::lisp-type-p "Unknown representation type ~S" #Y(c::rep-type->lisp-type nil nil (24 45 1 26 13 0 19 1 2 45 3 10 0 39 28 13 1 11 4 17 5 39 5 75 73 38 14 10 0 4 73 40 8 15 6 13 1 19 2 7 38 20 13 1 19 1 8 39 6 10 1 73 38 8 15 9 13 1 19 2 7 43 1 29) #617# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #618=#A(t (11) (c::lisp-type->rep-type type :object c::rep-type-record c::+representation-types+ c::l second subtypep cddr #Y(c::lisp-type->rep-type nil nil (24 45 1 26 57 0 60 66 10 1 76 39 6 11 2 73 38 55 13 1 19 1 3 39 6 10 1 73 38 43 11 4 45 5 38 27 13 2 10 0 16 6 4 12 19 2 7 39 7 10 0 4 73 36 1 10 0 16 8 12 53 0 10 0 2 39 -30 11 2 73 43 1 63 29) #618# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #619=#A(t (8) (c::rep-type-name type c::rep-type-record second "Not a valid C type name ~S" c::cmperr #Y(c::rep-type-name nil nil (24 45 1 26 13 0 19 1 2 16 3 73 40 8 15 4 13 0 19 2 5 29) #619# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #620=#A(t (6) (c::lisp-type-p type t subtypep #Y(c::lisp-type-p nil nil (24 45 1 26 13 0 15 2 19 2 3 29) #620# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #621=#A(t (16) (c::wt-to-object-conversion c::loc-rep-type c::loc consp (c::single-float-value c::double-float-value c::long-float-value) member third c::wt c::rep-type-record c::x "Cannot coerce C variable of type ~A to lisp object" c::cmperr "(" ")" #Y(c::wt-to-object-conversion nil nil (24 45 1 24 45 2 26 57 0 60 65 10 1 16 3 39 10 10 1 4 12 15 4 19 2 5 39 13 10 1 16 6 12 19 1 7 75 73 36 0 13 2 19 1 8 16 6 45 9 10 0 76 39 8 15 10 13 3 19 2 11 13 0 15 12 13 2 15 13 19 4 7 43 1 63 29) #621# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #622=#A(t (18) (c::wt-from-object-conversion c::dest-type c::loc-type c::rep-type c::loc c::rep-type-record cdddr c::x "Cannot coerce lisp object to C type ~A" c::cmperr c::policy-assume-no-errors subtypep second "(" ")" c::wt #Y(c::wt-from-object-conversion nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 1 19 1 5 16 6 45 7 10 0 76 39 8 15 8 13 2 19 2 9 19 0 10 40 8 13 3 13 4 19 2 11 39 7 10 0 16 12 38 5 10 0 4 73 12 15 13 13 1 15 14 19 4 15 43 1 29) #622# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #623=#A(t (10) (c::loc-movable-p c::loc atom t c::call c::call-local ffi::c-inline fifth #Y(c::loc-movable-p nil nil (24 45 1 26 10 0 16 2 39 6 11 3 73 38 28 10 0 4 41 4 4 42 5 5 75 73 38 15 42 6 9 10 0 16 7 76 73 38 4 11 3 73 29) #623# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 35 12 19 2 36 1 0 73 29) #624=#A(t (37) (c::loc-type c::loc eq null c::var-p c::var-type c::vv-p c::vv-type ext::fixnump fixnum atom t c::fixnum-value c::character-value second code-char type-of c::double-float-value double-float c::single-float-value single-float c::long-float-value long-float ffi::c-inline type consp values c::lisp-type-p c::rep-type->lisp-type c::bind c::lcl third the c::call-normal fourth #Y(c::loc-type nil nil (24 45 1 26 13 0 75 17 2 39 6 1 3 73 38 200 13 0 19 1 4 39 8 13 0 19 1 5 38 186 13 0 19 1 6 39 8 13 0 19 1 7 38 172 10 0 16 8 39 6 1 9 73 38 161 10 0 16 10 39 6 1 11 73 38 150 10 0 4 42 12 6 1 9 73 38 139 42 13 11 10 0 16 14 16 15 16 16 38 126 42 17 6 1 18 73 38 118 42 19 6 1 20 73 38 110 42 21 6 1 22 73 38 102 42 23 50 10 0 16 14 4 45 24 10 0 16 25 39 9 10 0 4 12 1 26 17 2 39 6 11 11 73 38 18 13 0 19 1 27 39 6 10 0 73 38 6 13 0 19 1 28 43 1 38 50 42 29 11 10 0 16 14 12 19 1 5 38 37 42 30 13 10 0 16 31 73 40 4 11 11 73 38 22 42 32 7 10 0 16 14 38 13 42 33 7 10 0 16 34 38 4 11 11 73 29) #624# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 40 12 19 2 41 1 0 73 29) #625=#A(t (42) (c::loc-representation-type c::loc (nil t) member :object c::var-p c::var-rep-type c::vv-p ext::fixnump :fixnum c::trash eq :void atom c::fixnum-value c::character-value second <= :unsigned-char :wchar c::double-float-value :double c::single-float-value :float c::long-float-value :long-double ffi::c-inline type consp values c::lisp-type-p c::lisp-type->rep-type c::bind c::lcl third t c::jump-true c::jump-false :bool the #Y(c::loc-representation-type nil nil (24 45 1 26 13 0 15 2 19 2 3 39 6 11 4 73 38 233 13 0 19 1 5 39 8 13 0 19 1 6 38 219 13 0 19 1 7 39 6 11 4 73 38 207 10 0 16 8 39 6 11 9 73 38 196 13 0 1 10 17 11 39 6 11 12 73 38 183 10 0 16 13 39 6 11 4 73 38 172 10 0 4 42 14 6 11 9 73 38 161 42 15 23 10 0 16 16 12 9 255 19 2 17 39 6 11 18 73 38 4 11 19 73 38 136 42 20 6 11 21 73 38 128 42 22 6 11 23 73 38 120 42 24 6 11 25 73 38 112 42 26 50 10 0 16 16 4 45 27 10 0 16 28 39 9 10 0 4 12 1 29 17 11 39 6 11 4 73 38 18 13 0 19 1 30 39 8 13 0 19 1 31 38 4 10 0 73 43 1 38 60 42 32 11 10 0 16 16 12 19 1 6 38 47 42 33 17 10 0 16 34 73 40 4 11 35 73 12 19 1 31 38 28 41 36 4 42 37 6 11 38 73 38 17 42 39 11 10 0 16 34 12 19 1 0 38 4 11 4 73 29) #625# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 71 12 19 2 72 1 0 73 29) #626=#A(t (73) (c::wt-coerce-loc c::dest-rep-type c::loc c::lisp-type->rep-type c::rep-type->lisp-type c::dest-type c::loc-type c::loc-representation-type c::loc-rep-type "Unable to coerce lisp object from type (~S,~S)~%~
			to C/C++ type (~S,~S)" c::cmpwarn #Y(c::coercion-error nil nil (26 15 9 13 3 13 2 13 4 13 7 19 5 10 29) #626# #1# 0) c::a-lisp-type and subtypep #Y(c::ensure-valid-object-type nil nil (24 45 12 26 15 13 13 4 10 0 6 3 12 77 19 2 14 73 39 5 32 2 18 0 29) #626# #1# 0) eq c::wt :byte :unsigned-byte :unsigned-short :short :unsigned-int :int :unsigned-long :long :unsigned-long-long :long-long :cl-index :fixnum :uint8-t :int8-t :uint16-t :int16-t :uint32-t :int32-t :uint64-t :int64-t :float :double :long-double "(" c::rep-type-name ")(" ")" :object c::wt-from-object-conversion :char :unsigned-char :wchar "(" ")(" ")" "(" ")(" ")" float :bool "1" "(" ")!=ECL_NIL" c::wt-to-object-conversion :pointer-void :cstring "(char *)(" ")" :char* "ecl_base_string_pointer_safe(" ")" "(char *)(" ")" #Y(c::wt-coerce-loc nil nil (24 45 1 24 45 2 26 57 0 60 635 13 2 19 1 3 51 2 13 2 19 1 4 45 5 13 2 19 1 6 45 6 13 3 19 1 7 45 8 31 2 11 15 13 7 10 2 17 16 39 10 13 6 19 1 17 75 73 36 5 10 7 41 18 58 41 19 55 41 20 52 41 21 49 41 22 46 41 23 43 41 24 40 41 25 37 41 26 34 41 27 31 41 28 28 41 29 25 41 30 22 41 31 19 41 32 16 41 33 13 41 34 10 41 35 7 41 36 4 42 37 119 10 2 41 18 67 41 19 64 41 20 61 41 21 58 41 22 55 41 23 52 41 24 49 41 25 46 41 26 43 41 27 40 41 28 37 41 29 34 41 30 31 41 31 28 41 32 25 41 33 22 41 34 19 41 35 16 41 36 13 41 37 10 41 38 7 41 39 4 42 40 20 15 41 13 7 19 1 42 12 15 43 13 6 15 44 19 5 17 38 27 42 45 20 13 4 32 0 18 1 13 4 13 3 13 7 13 6 19 4 46 38 5 32 1 18 0 38 401 41 47 7 41 48 4 42 49 59 10 2 41 47 7 41 48 4 42 49 20 15 50 13 7 19 1 42 12 15 51 13 6 15 52 19 5 17 38 27 42 45 20 13 4 32 0 18 1 13 4 13 3 13 7 13 6 19 4 46 38 5 32 1 18 0 38 334 41 38 7 41 39 4 42 40 119 10 2 41 18 67 41 19 64 41 20 61 41 21 58 41 22 55 41 23 52 41 24 49 41 25 46 41 26 43 41 27 40 41 28 37 41 29 34 41 30 31 41 31 28 41 32 25 41 33 22 41 34 19 41 35 16 41 36 13 41 37 10 41 38 7 41 39 4 42 40 20 15 53 13 7 19 1 42 12 15 54 13 6 15 55 19 5 17 38 27 42 45 20 15 56 32 0 18 1 13 4 13 3 13 7 13 6 19 4 46 38 5 32 1 18 0 38 207 42 57 99 10 2 41 18 67 41 19 64 41 20 61 41 21 58 41 22 55 41 23 52 41 24 49 41 25 46 41 26 43 41 27 40 41 28 37 41 29 34 41 30 31 41 31 28 41 32 25 41 33 22 41 34 19 41 35 16 41 36 13 41 37 10 41 38 7 41 39 4 42 40 8 15 58 19 1 17 38 19 42 45 12 15 59 13 6 15 60 19 3 17 38 5 32 1 18 0 38 106 42 45 10 13 2 13 6 19 2 61 38 94 42 62 39 10 2 42 45 14 13 4 13 3 13 7 13 6 19 4 46 38 19 42 63 12 15 64 13 6 15 65 19 3 17 38 5 32 1 18 0 38 53 42 63 7 32 1 18 0 38 44 42 66 37 10 2 42 45 12 15 67 13 6 15 68 19 3 17 38 19 42 62 12 15 69 13 6 15 70 19 3 17 38 5 32 1 18 0 38 5 32 1 18 0 43 2 43 3 63 29) #626# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #627=#A(t (12) (c::c1clines c::args stringp every "The argument to CLINES, ~s, is not a list of strings." c::cmperr c::*clines-string-list* copy-list nconc (progn) #Y(c::c1clines nil nil (24 45 1 26 33 2 12 13 0 19 2 3 76 39 8 15 4 13 0 19 2 5 14 6 10 0 16 7 12 19 2 8 52 6 1 9 73 29) #627# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 32 12 19 2 33 1 0 73 29) #628=#A(t (34) (c::output-clines c::output-stream c::s make-string-input-stream stream c::c 0 read-char #\@ eq #:g21145 #:g21146 serious-condition si::temp #Y(nil nil nil (24 45 13 26 10 0 51 2 35 1 0 29) #628# #1# 0) si::*handler-clusters* read "Unable to parse FFI:CLINES string~& ~S" c::cmperr ffi::object c::*compiler-output1* :permanent t c::add-object c::wt write-char #Y(c::parse-one-string nil nil (24 45 2 24 45 1 26 13 1 9 0 77 19 3 3 45 4 75 45 5 57 6 61 2 2 114 13 2 77 77 19 3 7 51 1 10 1 76 39 4 35 0 1 13 1 1 8 17 9 39 79 57 10 60 50 75 45 11 57 6 61 1 23 15 12 34 14 3 6 1 12 11 15 3 48 15 13 5 19 1 16 36 2 44 1 10 1 45 5 15 17 13 8 19 2 18 43 1 36 2 62 43 1 63 45 19 10 4 48 20 13 0 14 21 14 22 19 3 23 12 19 1 24 44 1 43 1 38 8 13 1 13 3 19 2 25 35 0 0 62 73 43 1 43 1 29) #628# #1# 0) c::*clines-string-list* #:loop-list21148 terpri find write-string #Y(c::output-clines nil nil (24 45 1 26 30 1 26 77 14 27 46 28 46 2 57 6 61 2 2 53 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 4 19 1 29 15 8 13 1 19 2 30 39 11 13 1 13 4 32 3 18 2 38 8 13 1 13 4 19 2 31 35 0 0 62 43 2 13 1 19 1 29 75 52 27 73 43 1 29) #628# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 67 12 19 2 68 1 0 73 29) #629=#A(t (69) (c::c1c-inline c::args #:g21150 #:g21151 si::dm-too-few-arguments c::arguments c::arg-types c::output-type c::c-expression rest :side-effects si::search-keyword #:g21152 si::missing-keyword eq t c::side-effects :one-liner #:g21153 c::one-liner c::output-rep-type (:one-liner :side-effects) si::check-keyword length = "In a C-INLINE form the number of declare arguments and the number of supplied ones do not match:~%~S" ffi::c-inline c::cmperr :cstring position c::ndx gensym c::var copy-list elt c::value si::elt-set :char* ffi::with-cstring c::c1expr type c::lisp-type-p c::lisp-type->rep-type c::rep-type->lisp-type #Y(c::produce-type-pair nil nil (24 45 40 26 13 0 19 1 41 39 12 13 0 13 0 19 1 42 3 73 38 11 13 0 19 1 43 12 10 0 3 73 29) #629# #1# 0) :void (values &rest t) equal ((values &rest t)) consp values eql mapcar c::x cdr car c::processed-arguments listp stringp "C-INLINE: syntax error in ~S" c::processed-arg-types #:g21172 #:g21174 :type :args nreverse c::make-c1form* #Y(c::c1c-inline nil nil (24 45 1 26 57 0 60 538 10 1 45 2 10 0 45 3 10 0 76 39 6 13 1 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 2 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 76 39 6 13 3 19 1 4 10 2 4 12 10 2 5 51 2 22 45 7 10 3 76 39 6 13 4 19 1 4 10 3 4 12 10 3 5 51 3 22 45 8 10 4 45 9 13 5 15 10 19 2 11 45 12 13 0 1 13 17 14 39 5 11 15 38 3 10 0 45 16 13 7 15 17 19 2 11 45 18 13 0 1 13 17 14 39 4 75 38 3 10 0 45 19 75 45 20 13 10 15 21 19 2 22 10 9 16 23 12 10 8 16 23 12 19 2 24 76 39 13 15 25 15 26 10 13 7 2 12 19 2 27 14 28 13 8 19 2 29 45 30 10 0 39 71 19 0 31 45 32 10 11 16 33 45 5 13 0 10 2 17 34 45 35 13 1 13 3 13 2 19 3 36 13 12 13 3 14 37 19 3 36 15 38 13 2 10 0 6 2 12 15 26 13 1 13 12 13 11 13 10 10 9 7 6 6 3 12 19 1 39 36 16 43 3 43 1 30 1 44 13 8 1 45 17 14 39 9 75 51 1 75 51 8 38 93 13 8 1 46 17 47 39 7 1 48 51 1 38 79 10 8 16 49 39 9 10 8 4 12 1 50 17 51 39 41 32 0 12 10 8 5 12 19 2 52 45 53 33 54 12 13 0 19 2 52 51 2 15 50 33 55 12 13 0 19 2 52 7 2 51 9 43 1 38 23 13 8 32 0 18 1 45 53 10 0 4 51 9 10 0 5 6 1 51 2 43 1 43 1 75 45 56 10 10 16 57 39 11 10 9 16 57 39 5 10 7 16 58 76 39 13 15 59 15 26 10 14 7 2 12 19 2 27 77 77 46 60 46 56 38 61 10 11 45 61 10 0 4 12 10 0 5 51 0 10 0 51 12 22 43 1 73 40 4 1 15 73 12 10 1 3 51 1 10 12 45 62 10 0 4 12 10 0 5 51 0 10 0 51 13 43 1 19 1 39 12 10 0 3 51 0 10 12 2 39 4 10 11 2 39 -69 15 26 14 63 13 10 14 10 13 6 14 64 10 0 16 65 12 10 1 16 65 12 13 3 13 9 13 6 13 4 19 12 66 43 2 43 1 43 12 63 29) #629# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 58 12 19 2 59 1 0 73 29) #630=#A(t (60) (c::produce-inline-loc c::inlined-arguments c::arg-types c::output-rep-type c::c-expression c::side-effects c::one-liner c::args-to-be-saved c::coerced-arguments length > char #\@ eq c::ndx c::c #\; 1+ subseq alphanumericp char-code #\0 - >= c::coerce-locs c::wt-nl t c::wt-c-inline-loc ";" c::wt "Ignoring form ~S" c::cmpnote ffi::c-inline ((values &rest t)) equalp values ((values &rest t)) type :rep-type c::make-lcl-var c::var c::rep-type-name " " ";" #Y(c::make-output-var nil nil (24 45 37 26 14 38 13 0 19 2 39 45 40 13 1 19 1 41 12 15 42 13 0 15 43 19 4 25 10 0 73 43 1 29) #630# #1# 0) c::open-inline-block mapcar c::output-vars = #:loop-list21179 c::v c::i 0 c::value c::*destination* c::set-loc "cl_env_copy->nvalues=" ";" #Y(c::produce-inline-loc nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 24 45 6 26 57 0 60 396 75 45 7 75 45 8 10 5 16 9 12 9 1 19 2 10 39 12 13 5 8 0 17 11 12 1 12 17 13 39 99 58 60 96 8 1 45 14 38 75 13 7 10 0 17 11 45 15 13 0 1 16 17 13 39 17 13 8 10 1 16 17 12 19 2 18 51 8 75 73 36 2 10 0 16 19 76 39 8 75 51 4 75 73 36 2 10 0 16 20 12 1 21 16 20 12 19 2 22 12 10 4 3 51 4 43 1 10 0 16 17 12 53 0 13 0 10 7 16 9 12 19 2 23 39 -85 43 1 63 13 8 13 7 13 1 19 3 24 51 0 10 6 76 39 42 10 4 39 27 19 0 25 13 6 13 5 13 0 14 26 77 19 5 27 10 3 39 6 15 28 19 1 29 38 8 15 30 13 5 19 2 31 75 73 36 2 10 3 39 29 15 32 13 6 13 5 13 0 13 4 13 6 1 33 17 34 39 5 1 35 38 2 75 6 6 73 36 2 13 6 1 36 17 34 39 19 13 6 13 5 13 0 13 4 15 35 19 5 27 1 35 73 36 2 30 1 44 19 0 45 32 0 12 13 7 19 2 46 45 47 13 8 13 7 13 2 13 6 13 0 19 5 27 10 0 16 9 12 9 1 19 2 48 39 7 10 0 4 73 38 98 77 13 0 46 49 46 50 8 0 45 51 57 52 61 2 20 61 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 15 53 10 1 6 2 48 54 13 2 19 1 55 44 1 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 10 1 16 17 51 1 35 0 0 62 43 1 43 2 15 56 10 0 16 9 12 15 57 19 3 29 1 35 73 43 1 43 1 43 2 63 29) #630# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #631=#A(t (13) (c::c2c-inline c::c1form c::arguments rest c::*temp* c::*inline-blocks* c::produce-inline-loc c::inline-args apply c::unwind-exit c::close-inline-blocks #Y(c::c2c-inline nil nil (24 45 1 24 45 2 27 45 3 9 0 14 4 49 4 49 5 33 6 12 13 1 19 1 7 12 13 0 19 3 8 12 19 1 9 19 0 10 44 2 29) #631# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 36 12 19 2 37 1 0 73 29) #632=#A(t (38) (c::coerce-locs c::inlined-args c::types c::args-to-be-saved c::l c::item c::i c::block-opened #:g21189 :object type c::lisp-type->rep-type c::rep-type c::lisp-type second c::loc c::loc-movable-p member :rep-type c::make-lcl-var c::lcl c::wt-nl c::open-inline-block c::rep-type-name " " "= " c::wt c::wt-coerce-loc ";" c::loc-representation-type equal c::coerce-loc #:g21190 #:g21191 rplaca 1+ #Y(c::coerce-locs nil nil (24 45 1 25 40 2 77 46 2 25 40 2 77 46 3 26 10 2 45 4 10 0 4 45 5 8 0 45 6 75 45 7 38 181 10 5 39 23 10 5 45 8 10 0 4 12 10 0 5 51 0 10 0 51 6 22 43 1 38 3 11 9 45 10 13 0 19 1 11 45 12 10 4 4 45 13 10 5 16 14 45 15 13 0 19 1 16 76 39 8 13 5 13 8 19 2 17 39 56 14 18 13 2 19 2 19 45 20 19 0 21 10 5 76 39 4 19 0 22 13 3 19 1 23 12 15 24 13 0 15 25 19 4 26 13 3 13 1 19 2 27 15 28 19 1 26 10 0 51 1 43 1 38 23 13 2 13 0 19 1 29 17 30 76 39 11 15 31 13 2 10 0 6 3 51 0 10 7 45 32 10 1 45 33 13 1 10 0 17 34 10 0 43 1 43 1 43 4 10 3 5 51 3 10 3 4 51 2 10 1 16 35 51 1 10 3 2 39 -184 10 6 73 43 4 29) #632# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 43 12 19 2 44 1 0 73 29) #633=#A(t (45) (c::wt-c-inline-loc c::output-rep-type c::c-expression c::coerced-arguments c::side-effects c::output-vars make-string-input-stream c::s values eq c::wt-nl read-char c::c #\@ read ffi::object consp return equal "User @(RETURN ...) in a C-INLINE form with no output values" c::cmperr second length c::l c::ndx < nth c::wt "Used @(RETURN ~D) in a C-INLINE form with ~D output values" quote :permanent t c::add-object #\# c::k peek-char c::next-char digit-char-p c::index alphanumericp "C-INLINE: Variable code exceeds number of arguments" c::*compiler-output1* write-char #Y(c::wt-c-inline-loc nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 13 3 9 0 77 19 3 6 45 7 10 1 39 8 13 1 1 8 17 9 76 39 4 19 0 10 13 0 77 77 19 3 11 45 12 38 255 10 0 42 13 132 13 1 19 1 14 45 15 10 0 16 16 39 9 10 0 4 12 1 17 17 18 39 70 13 3 1 8 17 9 39 8 15 19 19 1 20 38 53 10 0 16 21 73 40 4 8 0 73 12 10 3 16 22 12 46 23 46 24 13 0 13 1 19 2 25 39 13 13 0 10 5 17 26 12 19 1 27 38 10 15 28 13 0 13 1 19 3 20 43 2 38 36 10 0 16 16 39 9 10 0 4 12 1 29 17 9 39 7 10 0 16 21 51 0 13 0 14 30 14 31 19 3 32 12 19 1 27 43 1 38 109 42 33 99 13 1 19 1 11 45 34 77 13 2 77 77 19 4 35 45 36 13 1 9 36 19 2 37 45 38 13 2 1 33 17 9 39 8 15 33 19 1 27 38 54 10 0 76 40 9 10 1 39 5 10 1 16 39 39 10 15 33 13 2 19 2 27 38 30 13 0 10 7 16 22 12 19 2 25 39 13 13 0 10 7 17 26 12 19 1 27 38 6 15 40 19 1 20 43 3 38 8 13 0 14 41 19 2 42 13 1 77 77 19 3 11 12 53 0 10 0 76 39 -258 75 73 43 1 43 1 29) #633# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #634=#A(t (21) (c::c-inline-safe-string c::constant-string string #:loop-across-list21199 #:loop-across-index-21198 #:loop-across-vector-21197 c::c #:loop-list-head21200 #:loop-list-tail21201 0 length >= aref 1+ (#\# #\@) member rplacd concatenate c::c-filtered-string #Y(c::c-inline-safe-string nil nil (24 45 1 26 15 2 58 60 109 77 13 1 9 0 9 0 46 3 46 4 46 5 46 6 75 6 1 45 7 10 0 45 8 57 9 61 2 8 66 10 4 16 10 51 6 13 5 13 6 19 2 11 39 4 35 0 1 13 4 13 5 19 2 12 51 3 10 5 16 13 51 5 13 3 15 14 19 2 15 39 11 13 1 10 3 6 1 51 1 17 16 13 1 10 3 6 1 51 1 17 16 35 0 0 10 2 5 73 36 7 62 73 43 2 43 4 63 12 19 2 17 12 19 1 18 29) #634# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 41 12 19 2 42 1 0 73 29) #635=#A(t (43) (c::c1-defcallback c::args #:g21211 #:g21212 si::dm-too-few-arguments c::name c::return-type c::arg-list c::body "ecl_callback_~d" c::*callbacks* length format consp second :cdecl c::call-type c::c-name c::arg-variables c::arg-type-constants c::arg-types si::%dolist-var c::i "Syntax error in CALLBACK form: C type is missing in argument ~A " c::cmperr type si::foreign-elt-type-p c::foreign-elt-type-code c::add-object reverse progn defun si::put-sysprop quote :callback list ffi::c-inline :object "ecl_make_foreign_data(@':pointer-void,0,~a)" (:one-liner t) c::c1expr #Y(c::c1-defcallback nil nil (24 45 1 26 10 0 45 2 10 0 45 3 10 0 76 39 6 13 1 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 2 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 76 39 6 13 3 19 1 4 10 2 4 12 10 2 5 51 2 22 45 7 10 3 45 8 77 77 77 77 15 9 11 10 16 11 12 19 3 12 12 10 3 16 13 39 7 10 3 4 73 38 4 10 3 73 12 10 3 16 13 39 7 10 3 16 14 38 4 11 15 73 12 46 16 46 5 46 17 46 18 46 19 46 20 10 7 45 21 75 45 22 38 76 10 1 4 51 0 10 0 16 13 76 39 8 15 23 13 0 19 2 24 10 0 4 12 10 4 3 51 4 10 0 16 14 45 25 10 1 16 14 12 10 3 3 51 3 10 0 16 26 39 8 13 0 19 1 27 38 6 13 0 19 1 28 12 10 4 3 51 4 43 1 10 1 5 51 1 10 1 40 -78 43 2 13 4 13 3 13 4 19 1 28 12 13 8 10 0 16 29 12 10 1 16 29 12 10 5 6 7 12 11 10 3 52 10 15 30 15 31 13 4 10 2 16 29 12 10 6 7 4 12 15 32 15 33 10 4 6 2 12 14 34 15 35 15 36 77 77 14 37 77 15 38 13 3 19 3 12 12 1 39 7 6 6 2 6 4 6 3 12 19 1 40 43 6 43 6 29) #635# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+foreign-elt-type-codes+ ((:char . "ECL_FFI_CHAR") (:unsigned-char . "ECL_FFI_UNSIGNED_CHAR") (:byte . "ECL_FFI_BYTE") (:unsigned-byte . "ECL_FFI_UNSIGNED_BYTE") (:short . "ECL_FFI_SHORT") (:unsigned-short . "ECL_FFI_UNSIGNED_SHORT") (:int . "ECL_FFI_INT") (:unsigned-int . "ECL_FFI_UNSIGNED_INT") (:long . "ECL_FFI_LONG") (:unsigned-long . "ECL_FFI_UNSIGNED_LONG") (:int16-t . "ECL_FFI_INT16_T") (:uint16-t . "ECL_FFI_UINT16_T") (:int32-t . "ECL_FFI_INT32_T") (:uint32-t . "ECL_FFI_UINT32_T") (:int64-t . "ECL_FFI_INT64_T") (:uint64-t . "ECL_FFI_UINT64_T") (:long-long . "ECL_FFI_LONG_LONG") (:unsigned-long-long . "ECL_FFI_UNSIGNED_LONG_LONG") (:pointer-void . "ECL_FFI_POINTER_VOID") (:cstring . "ECL_FFI_CSTRING") (:object . "ECL_FFI_OBJECT") (:float . "ECL_FFI_FLOAT") (:double . "ECL_FFI_DOUBLE") (:void . "ECL_FFI_VOID")) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #636=#A(t (9) (c::foreign-elt-type-code type c::+foreign-elt-type-codes+ assoc c::x "~a is not a valid elementary FFI type" c::cmperr #Y(c::foreign-elt-type-code nil nil (24 45 1 26 13 0 14 2 19 2 3 45 4 10 0 76 39 8 15 5 13 1 19 2 6 10 0 5 73 43 1 29) #636# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 76 12 19 2 77 1 0 73 29) #637=#A(t (78) (c::t3-defcallback c::lisp-name c::c-name c::c-name-constant c::return-type c::arg-types c::arg-type-constants c::call-type t c::return-p (nil :void) member si::foreign-elt-type-p consp (* array) :pointer-void "DEFCALLBACK does not support complex return types such as ~A" c::cmperr ffi::%convert-to-arg-type c::rep-type-name :cdecl "" :stdcall "__stdcall " "DEFCALLBACK does not support ~A as calling convention" c::fmod c::return-type-name "static " " " "(" c::wt-nl-h "static " " " "(" c::wt-nl1 #:loop-list21229 type c::n "" c::comma 0 " var" c::wt-h " var" c::wt "," 1+ ")" ");" c::wt-nl-open-brace " output;" c::wt-nl "const cl_env_ptr cl_env_copy = ecl_process_env();" "cl_object aux;" "ECL_BUILD_STACK_FRAME(cl_env_copy, frame, helper)" #:loop-list21233 c::ct #:loop-list21232 stringp "ecl_stack_frame_push(frame,ecl_foreign_data_ref_elt(&var" "," "));" "ecl_stack_frame_push(frame,ecl_make_foreign_data(&var" "," "," ffi::size-of-foreign-type "));" "aux = ecl_apply_from_stack_frame(frame," "ecl_fdefinition(" "));" "ecl_stack_frame_close(frame);" "ecl_foreign_data_set_elt(&output," c::foreign-elt-type-code ",aux);" "return output;" c::wt-nl-close-brace #Y(c::t3-defcallback nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 24 45 6 24 45 7 26 11 8 45 9 13 4 15 10 19 2 11 39 6 75 51 0 38 37 10 4 16 12 40 31 10 4 16 13 39 10 10 4 4 12 15 14 19 2 11 39 7 11 15 51 4 38 8 15 16 13 4 19 2 17 13 4 19 1 18 12 19 1 19 12 10 1 42 20 6 1 21 73 38 16 42 22 6 1 23 73 38 8 15 24 13 1 19 2 17 12 46 25 46 26 15 27 13 0 15 28 13 1 13 8 15 29 19 6 30 15 31 13 0 15 32 13 1 13 8 15 33 19 6 34 9 0 77 13 5 46 35 46 36 46 37 1 38 45 39 57 40 61 2 15 85 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 13 3 19 1 18 12 19 1 19 12 15 41 13 2 19 4 42 13 1 13 3 19 1 18 12 19 1 19 12 15 43 13 2 19 4 44 1 45 51 1 10 4 2 39 4 35 0 1 10 2 16 46 12 10 4 4 51 3 22 51 2 35 0 0 62 43 1 43 3 15 47 19 1 44 15 48 19 1 42 19 0 49 10 2 39 8 13 0 15 50 19 2 51 15 52 19 1 51 15 53 19 1 51 15 54 19 1 51 9 0 77 13 5 77 13 4 46 55 46 56 46 57 46 36 46 37 57 40 61 2 27 114 10 3 2 40 4 10 5 2 39 4 35 0 1 10 3 4 12 10 5 4 51 4 22 51 2 10 3 5 51 3 10 5 5 51 5 10 4 16 58 39 16 15 59 13 1 15 60 13 4 15 61 19 5 51 38 22 15 62 13 1 15 63 13 4 15 64 13 2 19 1 65 12 15 66 19 7 51 10 3 2 40 4 10 5 2 39 4 35 0 1 10 1 16 46 12 10 3 4 12 10 5 4 51 4 22 51 2 22 51 1 35 0 0 62 43 5 15 67 15 68 13 7 15 69 19 4 51 15 70 19 1 51 10 2 39 19 15 71 13 6 19 1 72 12 15 73 19 3 51 15 74 19 1 51 19 0 75 43 2 29) #637# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 75 52 0 1 0 73 29) #A(t (2) (c::+optimizable-constants+ si::*make-special)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 42 12 19 2 43 1 0 73 29) #638=#A(t (44) (c::c1constant-value c::val (nil :only-small-values :always) c::always c::only-small-values c::+optimizable-constants+ assoc c::x "#include <float.h>" c::*clines-string-list* adjoin listp c::c1expr eq c::c1nil t c::c1t ext::fixnump ext::location :type fixnum :args c::fixnum-value c::make-c1form* characterp character c::character-value char-code double-float typep ext::float-nan-p "Cannot externalize value ~A" c::cmperr c::double-float-value c::add-object single-float "Cannot externalize value ~A" c::single-float-value long-float "Cannot externalize value ~A" c::long-float-value c::object-type #Y(c::c1constant-value nil nil (24 45 1 28 2 22 40 2 77 46 3 22 40 2 77 46 4 13 2 14 5 19 2 6 45 7 10 0 39 30 15 8 14 9 19 2 10 52 9 10 0 5 51 0 10 0 16 11 39 8 13 0 19 1 12 38 3 10 0 43 1 73 40 273 13 2 75 17 13 39 6 19 0 14 38 261 13 2 11 15 17 13 39 6 19 0 16 38 248 10 2 16 17 39 21 15 18 14 19 15 20 14 21 15 22 10 2 6 2 12 19 5 23 38 222 10 2 16 24 39 23 15 18 14 19 15 25 14 21 15 26 10 2 16 27 6 2 12 19 5 23 38 194 13 2 15 28 19 2 29 39 44 10 2 16 30 39 4 10 0 76 39 8 15 31 13 2 19 2 32 15 18 14 19 15 28 14 21 15 33 13 2 13 2 19 1 34 6 3 12 19 5 23 38 142 13 2 15 35 19 2 29 39 44 10 2 16 30 39 4 10 0 76 39 8 15 36 13 2 19 2 32 15 18 14 19 15 35 14 21 15 37 13 2 13 2 19 1 34 6 3 12 19 5 23 38 90 13 2 15 38 19 2 29 39 44 10 2 16 30 39 4 10 0 76 39 8 15 39 13 2 19 2 32 15 18 14 19 15 38 14 21 15 40 13 2 13 2 19 1 34 6 3 12 19 5 23 38 38 10 0 39 5 75 73 38 30 10 1 39 24 15 18 14 19 13 2 19 1 41 12 14 21 13 2 19 1 34 12 19 5 23 38 3 75 73 29) #638# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 60 16 61 78 59 15 59 75 3 78 55 15 55 1 62 17 63 1 65 16 61 78 64 15 64 75 3 78 54 15 54 1 66 17 63 1 68 16 61 78 67 15 67 75 3 78 53 15 53 1 69 17 63 1 71 16 61 78 70 15 70 75 3 78 52 15 52 1 72 17 63 1 74 16 61 78 73 15 73 75 3 78 51 15 51 1 75 17 63 1 28 12 15 29 15 30 15 31 15 32 15 33 15 34 15 35 15 36 15 37 15 38 15 39 15 40 15 41 15 42 15 43 15 44 15 45 15 46 15 47 15 48 15 49 15 50 15 51 15 52 15 53 15 54 15 55 1 56 7 28 16 57 12 19 2 58 29) #639=#A(t (76) (c::record c::name second c::c-value symbolp symbol-value c::value type-of c::lisp-type->rep-type type ffi::c-inline (:one-liner t :side-effects nil) floatp single-float c::single-float-value double-float c::double-float-value long-float c::long-float-value c::loc-type :location :value c::make-vv ext::location :type :args c::make-c1form* c::+optimizable-constants+ #Y(nil nil nil (24 45 0 26 10 0 4 45 1 10 1 16 2 45 3 10 1 16 4 39 37 10 1 16 5 45 6 10 0 16 7 12 19 1 8 45 9 13 1 15 10 77 77 13 0 13 2 1 11 7 6 3 73 43 2 38 114 10 1 16 12 39 78 10 1 45 6 10 0 16 7 45 9 10 0 42 13 5 1 14 38 16 42 15 5 1 16 38 9 42 17 5 1 18 38 2 75 45 19 14 20 13 3 14 21 13 2 19 4 22 45 23 13 3 15 23 14 24 13 2 14 25 13 1 13 3 10 0 6 3 12 19 5 26 3 73 43 4 38 31 13 1 15 23 14 24 10 1 16 7 12 14 25 14 20 13 0 14 21 13 1 19 4 22 12 19 5 26 3 73 12 11 27 3 52 27 73 43 2 29) #639# #1# 0) (most-positive-short-float "FLT_MAX") (most-positive-single-float "FLT_MAX") (most-negative-short-float "-FLT_MAX") (most-negative-single-float "-FLT_MAX") (least-positive-short-float "FLT_MIN") (least-positive-single-float "FLT_MIN") (least-positive-normalized-short-float "FLT_MIN") (least-positive-normalized-single-float " FLT_MIN") (least-negative-short-float "-FLT_MIN") (least-negative-single-float "-FLT_MIN") (least-negative-normalized-short-float "-FLT_MIN") (least-negative-normalized-single-float "-FLT_MIN") (most-positive-double-float "DBL_MAX") (most-negative-double-float "-DBL_MAX") (least-positive-double-float "DBL_MIN") (least-positive-normalized-double-float "DBL_MIN") (least-negative-double-float "-DBL_MIN") (least-negative-normalized-double-float "-DBL_MIN") (#157# "cl_core.singlefloat_zero") (#156# "cl_core.doublefloat_zero") (-0.0 "cl_core.singlefloat_minus_zero") (-0.0d0 "cl_core.doublefloat_minus_zero") 0 0 0 0 0 ((most-positive-long-float "LDBL_MAX") (most-negative-long-float "-LDBL_MAX") (least-positive-long-float "LDBL_MIN") (least-positive-normalized-long-float " LDBL_MIN") (least-negative-long-float "-LDBL_MIN") (least-negative-normalized-long-float "-LDBL_MIN") (#155# "cl_core.longfloat_zero") (-0.0l0 "cl_core.longfloat_minus_zero")) reverse mapc 0 "MP" find-package ("cl_core.mp_package") rplacd 0 "CLOS" ("cl_core.clos_package") 0 "KEYWORD" ("cl_core.keyword_package") 0 "COMMON-LISP-USER" ("cl_core.user_package") 0 "CL" ("cl_core.lisp_package"))) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #640=#A(t (23) (c::simplify-arithmetic c::operator c::args c::whole numberp every apply length c::l > second cddr = * eq + c::simple-program-error :format-error "Wrong number of arguments for operator ~a in ~a" :format-arguments error #Y(c::simplify-arithmetic nil nil (24 45 1 24 45 2 24 45 3 26 33 4 12 13 1 19 2 5 39 10 13 2 13 1 19 2 6 38 171 10 1 16 7 45 8 13 0 9 2 19 2 9 39 34 13 3 13 3 10 2 4 12 10 2 16 10 6 2 12 77 19 3 0 12 10 2 16 11 7 2 12 77 19 3 0 38 121 13 0 9 2 19 2 12 39 15 10 1 73 40 8 13 3 10 2 7 2 73 38 98 13 0 9 1 19 2 12 39 37 13 3 1 13 17 14 40 7 13 3 1 15 17 14 39 7 10 2 4 73 38 13 10 1 73 40 8 13 3 10 2 7 2 73 38 53 13 3 1 13 17 14 39 6 8 1 73 38 40 13 3 1 15 17 14 39 6 8 0 73 38 27 15 16 14 17 15 18 14 19 13 3 10 1 40 7 13 3 10 2 7 2 6 2 12 19 5 20 43 1 29) #640# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 8 12 19 3 9 1 0 73 29) #641=#A(t (10) (* compiler-macro #:g21240 #:g21239 c::all #:g21241 c::args c::simplify-arithmetic #Y(* nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 15 0 13 0 13 2 19 3 7 29) #641# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 8 12 19 3 9 1 0 73 29) #642=#A(t (10) (+ compiler-macro #:g21243 #:g21242 c::all #:g21244 c::args c::simplify-arithmetic #Y(+ nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 15 0 13 0 13 2 19 3 7 29) #642# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 8 12 19 3 9 1 0 73 29) #643=#A(t (10) (/ compiler-macro #:g21246 #:g21245 c::all #:g21247 c::args c::simplify-arithmetic #Y(/ nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 15 0 13 0 13 2 19 3 7 29) #643# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 8 12 19 3 9 1 0 73 29) #644=#A(t (10) (- compiler-macro #:g21249 #:g21248 c::all #:g21250 c::args c::simplify-arithmetic #Y(- nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 15 0 13 0 13 2 19 3 7 29) #644# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 1 0 73 29) #645=#A(t (24) (c::maximum-number-type c::t1 c::t2 (nil :integer-result :only-real) c::only-real c::integer-result real number (fixnum integer rational single-float double-float long-float float real number) (fixnum integer rational single-float double-float long-float float real) c::types-list c::default c::output c::t2-eq c::t1-eq si::%dolist-var c::i c::type>= equalp fixnum eq integer #Y(c::maximum-number-type nil nil (24 45 1 24 45 2 28 3 22 40 2 77 46 4 22 40 2 77 46 5 77 77 77 10 1 39 6 1 6 73 38 4 1 7 73 12 10 1 39 6 1 8 73 38 4 1 9 73 12 46 10 46 11 46 12 46 13 46 14 10 4 45 15 75 45 16 38 67 10 1 4 51 0 10 2 76 39 8 13 0 13 10 19 2 17 39 21 13 10 10 9 17 18 39 5 10 0 51 3 10 0 51 2 10 0 51 4 10 3 76 39 8 13 0 13 9 19 2 17 39 9 10 0 51 3 10 0 51 4 10 1 5 51 1 10 1 40 -69 43 2 10 0 39 7 10 1 39 3 10 2 76 39 5 10 3 51 2 10 5 39 15 13 2 1 19 17 20 40 7 13 2 1 21 17 20 39 5 10 5 51 2 13 2 10 0 39 6 10 8 73 38 4 10 3 73 12 10 1 39 6 10 7 73 38 4 10 3 73 12 72 3 43 5 29) #645# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 3 12 19 2 4 1 0 73 29) #646=#A(t (5) (c::ensure-number-type c::general-type c::maximum-number-type #Y(c::ensure-number-type nil nil (24 45 1 26 13 0 13 0 19 2 2 29) #646# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #647=#A(t (6) (c::ensure-nonrational-type c::general-type single-float c::maximum-number-type #Y(c::ensure-nonrational-type nil nil (24 45 1 26 13 0 15 2 19 2 3 29) #647# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #648=#A(t (8) (c::ensure-real-type c::general-type integer :only-real t c::maximum-number-type #Y(c::ensure-real-type nil nil (24 45 1 26 13 0 15 2 14 3 14 4 19 4 5 29) #648# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #649=#A(t (16) (c::arithmetic-propagator c::op1-type c::others c::integer-result c::ensure-number-type c::result-type c::arg-types #:loop-list21277 c::x c::op2-type 0 :integer-result c::maximum-number-type nreverse #Y(c::arithmetic-propagator nil nil (24 45 1 24 45 2 24 45 3 26 13 2 19 1 4 47 1 1 45 5 58 60 94 10 2 6 1 45 6 77 13 5 46 7 46 8 75 45 9 57 10 61 2 2 52 10 3 2 39 4 35 0 1 10 3 4 51 2 10 3 5 51 3 10 2 51 1 13 6 13 1 14 11 13 8 19 4 12 51 6 55 7 1 55 1 2 13 1 10 4 3 51 4 35 0 0 10 4 16 13 12 13 6 72 2 36 5 62 73 43 1 43 2 43 1 63 43 2 29) #649# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 7 12 19 3 8 29) #650=#A(t (9) (* c::*p0-dispatch-table* c::fname c::op1 c::others integer c::arithmetic-propagator #Y(nil nil nil (24 45 2 24 45 3 27 45 4 13 1 13 0 15 5 19 3 6 29) #650# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 19 2 2 29) #A(t (3) (* (+ -) c::copy-type-propagator)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 7 12 19 3 8 29) #651=#A(t (9) (/ c::*p0-dispatch-table* c::fname c::op1 c::others rational c::arithmetic-propagator #Y(nil nil nil (24 45 2 24 45 3 27 45 4 13 1 13 0 15 5 19 3 6 29) #651# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #652=#A(t (17) (c::inline-binop c::expected-type c::arg1 c::arg2 c::integer-result-type c::consing c::non-consing c::policy-assume-right-type c::c-number-type-p c::inlined-arg-type c::lisp-type->rep-type t c::produce-inline-loc (:object :object) (:object) #Y(c::inline-binop nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 24 45 6 26 19 0 7 39 28 13 5 19 1 8 39 21 13 4 19 1 9 12 19 1 8 39 10 13 3 19 1 9 12 19 1 8 39 48 13 4 10 3 6 2 12 13 4 19 1 9 12 19 1 10 12 13 3 19 1 9 12 19 1 10 6 2 12 13 5 19 1 10 6 1 12 13 0 77 14 11 19 6 12 38 20 13 4 10 3 6 2 12 15 13 15 14 13 1 77 14 11 19 6 12 29) #652# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #653=#A(t (15) (c::inline-arith-unop c::expected-type c::arg1 c::consing c::non-consing c::policy-assume-right-type c::c-number-type-p c::inlined-arg-type c::lisp-type->rep-type t c::produce-inline-loc (:object :object) (:object) #Y(c::inline-arith-unop nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 19 0 5 39 17 13 3 19 1 6 39 10 13 2 19 1 7 12 19 1 6 39 36 10 2 6 1 12 13 2 19 1 7 12 19 1 8 6 1 12 13 3 19 1 8 6 1 12 13 0 77 14 9 19 6 10 38 18 10 2 6 1 12 15 11 15 12 13 1 77 14 9 19 6 10 29) #653# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 17 12 19 3 18 29) #654=#A(t (19) (+ c::*cinline-dispatch-table* c::return-type c::arguments c::arg1 c::arg2 (c::fixnum-value 0) #:g21289 c::inlined-arg-loc c::result 0 #:g21290 integer "ecl_plus(#0,#1)" "(#0)+(#1)" c::inline-binop c::save-inline-loc #Y(nil nil nil (24 45 2 27 45 3 75 45 4 75 45 5 58 60 128 10 3 76 39 6 1 6 73 36 0 10 3 45 7 10 0 4 12 10 0 5 51 0 10 0 51 4 22 43 1 51 2 10 3 76 39 8 13 2 19 1 8 36 0 58 60 80 75 45 5 75 45 9 57 10 61 2 2 61 10 7 45 11 10 0 4 12 10 0 5 51 0 10 0 51 8 22 43 1 51 2 13 8 13 6 13 2 15 12 15 13 15 14 19 6 15 51 1 10 7 39 10 13 1 19 1 16 51 6 38 6 10 1 73 36 3 35 0 0 62 73 43 1 43 1 63 63 29) #654# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 17 12 19 3 18 29) #655=#A(t (19) (- c::*cinline-dispatch-table* c::return-type c::arg1 c::arguments c::arg2 "ecl_negate(#0)" "-(#0)" c::inline-arith-unop c::result 0 #:g21295 integer "ecl_minus(#0,#1)" "(#0)-(#1)" c::inline-binop c::save-inline-loc #Y(nil nil nil (24 45 2 24 45 3 27 45 4 75 45 5 58 60 102 10 2 76 39 14 13 4 13 3 15 6 15 7 19 4 8 36 0 58 60 80 75 45 5 75 45 9 57 10 61 2 2 61 10 6 45 11 10 0 4 12 10 0 5 51 0 10 0 51 7 22 43 1 51 2 13 8 13 7 13 2 15 12 15 13 15 14 19 6 15 51 1 10 6 39 10 13 1 19 1 16 51 7 38 6 10 1 73 36 3 35 0 0 62 73 43 1 43 1 63 63 29) #655# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 17 12 19 3 18 29) #656=#A(t (19) (* c::*cinline-dispatch-table* c::return-type c::arguments c::arg1 c::arg2 (c::fixnum-value 1) #:g21301 c::inlined-arg-loc c::result 0 #:g21302 integer "ecl_times(#0,#1)" "(#0)*(#1)" c::inline-binop c::save-inline-loc #Y(nil nil nil (24 45 2 27 45 3 75 45 4 75 45 5 58 60 128 10 3 76 39 6 1 6 73 36 0 10 3 45 7 10 0 4 12 10 0 5 51 0 10 0 51 4 22 43 1 51 2 10 3 76 39 8 13 2 19 1 8 36 0 58 60 80 75 45 5 75 45 9 57 10 61 2 2 61 10 7 45 11 10 0 4 12 10 0 5 51 0 10 0 51 8 22 43 1 51 2 13 8 13 6 13 2 15 12 15 13 15 14 19 6 15 51 1 10 7 39 10 13 1 19 1 16 51 6 38 6 10 1 73 36 3 35 0 0 62 73 43 1 43 1 63 63 29) #656# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 17 12 19 3 18 29) #657=#A(t (19) (/ c::*cinline-dispatch-table* c::return-type c::arg1 c::arguments c::arg2 "ecl_divide(ecl_make_fixnum(1),(#0))" "1/(#0)" c::inline-arith-unop c::result 0 #:g21307 rational "ecl_divide(#0,#1)" "(#0)/(#1)" c::inline-binop c::save-inline-loc #Y(nil nil nil (24 45 2 24 45 3 27 45 4 75 45 5 58 60 102 10 2 76 39 14 13 4 13 3 15 6 15 7 19 4 8 36 0 58 60 80 75 45 5 75 45 9 57 10 61 2 2 61 10 6 45 11 10 0 4 12 10 0 5 51 0 10 0 51 7 22 43 1 51 2 13 8 13 7 13 2 15 12 15 13 15 14 19 6 15 51 1 10 6 39 10 13 1 19 1 16 51 7 38 6 10 1 73 36 3 35 0 0 62 73 43 1 43 1 63 63 29) #657# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 7 12 19 3 8 29) #658=#A(t (9) (cos c::*p0-dispatch-table* c::fname c::op1-type #:g21309 c::ensure-nonrational-type c::output-type #Y(nil nil nil (24 45 2 24 45 3 27 45 4 13 1 19 1 5 47 1 3 45 6 10 1 6 1 12 13 0 72 2 43 2 29) #658# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 19 2 2 29) #A(t (3) (cos (sin tan cosh sinh tanh exp) c::copy-type-propagator)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 8 12 19 3 9 29) #659=#A(t (10) (acos c::*p0-dispatch-table* c::fname c::op1-type #:g21313 c::ensure-nonrational-type c::output-type number #Y(nil nil nil (24 45 2 24 45 3 27 45 4 13 1 19 1 5 47 1 3 45 6 10 1 6 1 12 15 7 72 2 43 2 29) #659# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 15 12 19 3 16 29) #660=#A(t (17) (atan c::*p0-dispatch-table* c::fname c::op1-type t c::op2-p c::op2-type #:g21317 c::ensure-nonrational-type c::t1 c::float-t1 :only-real c::maximum-number-type c::t2 c::result #Y(nil nil nil (24 45 2 24 45 3 25 40 4 14 4 75 45 5 46 6 27 45 7 13 3 19 1 8 47 1 9 45 10 10 4 39 35 13 1 13 3 14 11 14 4 19 4 12 47 2 13 47 1 9 45 14 13 1 10 2 6 2 12 13 0 72 2 43 3 38 10 10 1 6 1 12 13 1 72 2 43 2 29) #660# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 16 12 19 3 17 29) #661=#A(t (18) (expt c::*p0-dispatch-table* c::fname c::base c::exponent #:g21321 c::ensure-real-type integer eql fixnum subtypep (real 0 *) c::type>= c::ensure-nonrational-type c::maximum-number-type number #Y(nil nil nil (24 45 2 24 45 3 24 45 4 27 45 5 13 1 19 1 6 45 4 13 3 10 0 6 2 12 13 0 1 7 17 8 39 20 13 3 15 9 19 2 10 39 6 1 7 73 38 4 10 3 73 38 31 15 11 13 3 19 2 12 39 19 13 0 19 1 13 45 4 13 0 13 4 19 2 14 43 1 38 4 1 15 73 12 72 2 43 1 29) #661# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 9 12 19 3 10 29) #662=#A(t (11) (abs c::*p0-dispatch-table* c::fname c::arg #:g21325 c::ensure-number-type c::output ((fixnum integer 0 2305843009213693951) (integer integer 0 *) (rational rational 0 *) (short-float short-float 0 *) (single-float single-float 0 *) (double-float double-float 0 *) (long-float long-float 0 *) (real real 0 *) (number real 0 *)) assoc #Y(nil nil nil (24 45 2 24 45 3 27 45 4 13 1 19 1 5 47 1 3 45 6 10 1 6 1 12 13 0 15 7 19 2 8 5 73 40 4 10 0 73 12 72 2 43 2 29) #662# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 10 12 19 3 11 29) #663=#A(t (12) (sqrt c::*p0-dispatch-table* c::fname c::arg #:g21329 c::ensure-nonrational-type c::output (real 0 *) c::type>= number #Y(nil nil nil (24 45 2 24 45 3 27 45 4 13 1 19 1 5 47 1 3 45 6 10 1 6 1 12 15 7 13 1 19 2 8 39 6 10 0 73 38 4 1 9 73 12 72 2 43 2 29) #663# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 11 12 19 3 12 29) #664=#A(t (13) (isqrt c::*p0-dispatch-table* c::fname c::arg #:g21333 (integer 0 2305843009213693951) c::type>= ((integer 0 2305843009213693951)) (integer 0 2305843009213693951) ((integer 0 *)) (integer 0 *) #Y(nil nil nil (24 45 2 24 45 3 27 45 4 15 5 13 1 19 2 6 39 9 15 7 15 8 72 2 38 7 15 9 15 10 72 2 29) #664# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #665=#A(t (19) (c::encode-number-in-name number zerop "0" minusp - "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" c::code length c::base c::output c::digit floor char nreverse base-string coerce #Y(c::encode-number-in-name nil nil (24 45 1 26 10 0 16 2 39 6 1 3 73 38 79 10 0 16 4 39 12 13 0 19 1 5 12 19 1 0 38 62 1 6 45 7 10 0 16 8 45 9 75 45 10 8 0 45 11 38 25 13 4 13 2 19 2 12 51 4 55 0 1 13 3 10 0 17 13 12 10 1 3 51 1 10 4 16 2 39 -29 10 1 16 14 12 15 15 19 2 16 43 4 29) #665# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 1 0 73 29) #666=#A(t (28) (c::unique-init-name c::file pathname c::path sxhash ash pathname-directory cddr pathname-name logxor c::path-hash get-universal-time c::seconds * get-internal-real-time internal-time-units-per-second floor mod + c::ms base-string "_ecl" c::encode-number-in-name "_" concatenate c::tag #Y(c::unique-init-name nil nil (24 45 1 26 10 0 16 2 45 3 10 0 16 4 12 8 8 17 5 12 13 0 19 1 6 16 7 16 4 12 8 16 17 5 12 13 0 19 1 8 16 4 12 19 3 9 45 10 19 0 11 45 12 13 0 9 1000 19 2 13 12 9 1000 19 0 14 12 19 2 13 12 14 15 19 2 16 12 8 1000 17 17 12 19 2 18 45 19 15 20 15 21 13 2 19 1 22 12 15 23 13 0 19 1 22 12 19 5 24 45 25 10 0 73 43 5 29) #666# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #667=#A(t (9) (c::init-name-tag c::init-name base-string "@EcLtAg" ":" "@" concatenate #Y(c::init-name-tag nil nil (24 45 1 26 15 2 15 3 15 4 13 0 15 5 19 5 6 29) #667# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #668=#A(t (17) (c::search-tag stream c::tag c::eof list ":" concatenate c::key string read-byte c::c #:g21343 char-code = t #Y(c::search-tag nil nil (24 45 1 24 45 2 26 58 60 98 75 45 3 15 4 13 2 15 5 19 3 6 45 7 10 0 45 8 38 70 13 5 77 77 19 3 9 45 10 10 0 76 39 7 75 73 36 4 38 48 13 0 10 1 45 11 10 0 4 12 10 0 5 51 0 10 0 51 2 22 43 1 16 12 12 19 2 13 76 39 7 10 2 51 1 38 11 10 1 76 39 6 11 14 73 36 4 43 1 75 39 -71 75 73 43 3 63 29) #668# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #669=#A(t (15) (c::read-name stream string t c::c #:loop-list-head21348 #:loop-list-tail21349 0 read-byte = code-char rplacd concatenate #Y(c::read-name nil nil (24 45 1 26 15 2 58 60 72 11 3 45 4 75 6 1 45 5 10 0 45 6 57 7 61 2 2 40 13 5 77 77 19 3 8 51 3 76 40 8 13 3 9 64 19 2 9 39 4 35 0 1 13 1 10 3 16 10 6 1 51 1 17 11 35 0 0 10 2 5 73 36 4 62 73 43 2 43 1 63 12 19 2 12 29) #669# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 33 12 19 2 34 1 0 73 29) #670=#A(t (35) (c::find-init-name c::file (nil :tag) "@EcLtAg" c::tag :pnacl *features* member "PNACL_DIS" ext::getenv "please set the PNACL_DIS environment variable to your toolchain's pnacl-dis location" error c::pnacl-dis translate-logical-pathname namestring :wait :input :output :stream :error ext::run-program stream "Unable to disasemble file ~a" c::search-tag c::read-name c::name :direction :element-type (unsigned-byte 8) open close :abort t #Y(c::find-init-name nil nil (24 45 1 28 2 22 40 3 15 3 46 4 14 5 14 6 19 2 7 39 83 1 8 16 9 40 6 15 10 19 1 11 45 12 13 0 13 2 19 1 13 16 14 6 1 12 14 15 77 14 16 77 14 17 14 18 14 19 14 17 19 10 20 45 21 10 0 76 39 8 15 22 13 3 19 2 11 13 0 13 2 19 2 23 73 39 13 13 0 19 1 24 45 25 10 0 73 43 1 43 2 38 68 13 1 14 26 14 16 14 27 15 28 19 5 29 45 21 64 35 13 0 13 1 19 2 23 73 39 13 13 0 19 1 24 45 25 10 0 73 43 1 69 10 0 39 6 13 0 19 1 30 70 65 10 0 39 10 13 0 14 31 14 32 19 3 30 66 43 1 29) #670# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #671=#A(t (9) (c::remove-prefix c::prefix c::name search equal length subseq #Y(c::remove-prefix nil nil (24 45 1 24 45 2 26 9 0 13 1 13 0 19 2 3 17 4 39 14 13 0 10 1 16 5 12 77 19 3 6 38 4 10 0 73 29) #671# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #672=#A(t (13) (c::guess-init-name pathname c::kind :object eq probe-file c::find-init-name "Cannot find out entry point for binary file ~A" error :kind c::compute-init-name #Y(c::guess-init-name nil nil (24 45 1 24 45 2 26 13 0 11 3 17 4 39 24 10 1 16 5 39 6 13 1 19 1 6 73 40 8 15 7 13 1 19 2 8 38 10 13 1 14 9 13 0 19 3 10 29) #672# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 32 12 19 2 33 1 0 73 29) #673=#A(t (34) (c::compute-init-name pathname (nil :prefix :kind) c::guess-kind c::kind c::prefix translate-logical-pathname pathname-name c::filename :object :c c::unique-init-name :fasl :fas "CODE" :kind :prefix c::init-function-name :static-library :lib c::+static-library-prefix+ c::remove-prefix :shared-library :dll c::+shared-library-prefix+ :program string "init_" "ECL_PROGRAM" concatenate "C::BUILDER cannot accept files of kind ~s" error #Y(c::compute-init-name nil nil (24 45 1 28 2 22 40 7 13 0 19 1 3 12 46 4 22 40 2 77 46 5 13 2 19 1 6 12 19 1 7 45 8 10 2 41 9 4 42 10 8 13 3 19 1 11 38 104 41 12 4 42 13 16 15 14 14 15 14 13 14 16 13 1 19 5 17 38 83 41 18 4 42 19 22 14 20 13 0 19 2 21 12 14 15 14 19 14 16 13 1 19 5 17 38 56 41 22 4 42 23 22 14 24 13 0 19 2 21 12 14 15 14 23 14 16 13 1 19 5 17 38 29 42 25 19 15 26 10 1 73 40 4 1 27 73 12 15 28 19 3 29 38 8 15 30 13 2 19 2 31 43 1 29) #673# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #674=#A(t (9) (c::compute-main-name pathname c::args c::compute-init-name :prefix "main_" apply #Y(c::compute-main-name nil nil (24 45 1 27 45 2 33 3 12 13 1 14 4 15 5 13 0 19 5 6 29) #674# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 43 12 19 2 44 1 0 73 29) #675=#A(t (45) (c::init-function-name c::s (nil :prefix :kind) :object c::kind c::prefix c::c #\a char>= #\z char<= char-upcase #\A #\Z #\- eq #\_ #\* #\x #\? digit-char-p #\p #Y(c::translate-char nil nil (24 45 6 26 13 0 15 7 19 2 8 39 8 13 0 15 9 19 2 10 39 7 10 0 16 11 38 86 13 0 15 12 19 2 8 39 8 13 0 15 13 19 2 10 39 6 10 0 73 38 63 13 0 1 14 17 15 40 7 13 0 1 16 17 15 39 6 1 16 73 38 42 13 0 1 17 17 15 39 6 1 18 73 38 29 13 0 1 19 17 15 39 6 1 7 73 38 16 13 0 19 1 20 39 6 10 0 73 38 4 1 21 73 29) #675# #1# 0) "" :program "exe_" :fasl :fas "fas_" :library :static-library :lib "lib_" :shared-library :dll "dll_" "Not a valid argument to INIT-FUNCTION-NAME: kind = ~S" error #Y(c::disambiguation nil nil (24 45 6 26 10 2 42 3 6 1 23 73 38 52 42 24 6 1 25 73 38 44 41 26 4 42 27 6 1 28 73 38 33 41 29 7 41 30 4 42 31 6 1 32 73 38 19 41 33 4 42 34 6 1 35 73 38 8 15 36 13 2 19 2 37 29) #675# #1# 0) string map "init_" concatenate #Y(c::init-function-name nil nil (24 45 1 28 2 22 40 3 14 3 46 4 22 40 2 77 46 5 30 2 22 38 15 39 32 1 12 10 4 16 39 12 19 3 40 51 4 15 39 10 2 73 40 4 1 41 73 12 13 3 32 0 18 1 12 15 39 32 1 12 10 4 16 39 12 19 3 40 12 19 4 42 43 2 29) #675# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #676=#A(t (18) (c::expand-in-interval-p c::var c::interval c::forms #:g21355 #:g21356 * c::lower-limit c::upper-limit si::dm-too-many-arguments eq consp > >= < <= #Y(c::expand-in-interval-p nil nil (24 45 1 24 45 2 26 75 45 3 10 1 45 4 10 0 45 5 10 0 39 13 10 0 4 12 10 0 5 51 0 22 38 3 1 6 45 7 10 1 39 13 10 1 4 12 10 1 5 51 1 22 38 3 1 6 45 8 10 2 39 6 13 3 19 1 9 13 1 1 6 17 10 76 39 34 10 1 16 11 39 13 15 12 13 6 10 1 4 6 3 73 38 10 15 13 13 6 10 1 6 3 73 12 10 4 3 51 4 13 0 1 6 17 10 76 39 34 10 0 16 11 39 13 15 14 13 6 10 0 4 6 3 73 38 10 15 15 13 6 10 0 6 3 73 12 10 4 3 51 4 43 4 10 0 73 43 1 29) #676# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 70 12 19 2 71 1 0 73 29) #677=#A(t (72) (c::expand-typep c::form ffi::object type c::env c::orig-type c::aux function first rest constantp c::cmp-eval t c::known-type-p symbolp c::cmp-env-search-var c::var-type subtypep eq "TYPEP form contains an empty type ~S and cannot be optimized" c::cmpwarn si::type-predicate si::get-sysprop si::+known-typep-predicates+ #:loop-list21376 c::function-name c::a-type 0 #72# si::type= ((single-float . c::single-float-p) (short-float . c::short-float-p) (double-float . c::double-float-p) (long-float . c::long-float-p)) assoc atom si::deftype-definition quote c::policy-inline-type-checks consp cons find-class si::of-class-p not typep (or and) member gensym c::var let declare :read-only #:loop-list21381 #:loop-list-head21382 #:loop-list-tail21383 rplacd (integer rational float real single-float double-float long-float) c::var2 c::var1 integer fixnum coerce and locally (declare (optimize (speed 3) (safety 0) (space 0))) setf ext::truly-the c::expand-in-interval-p satisfies list-length = second apply #Y(c::expand-typep nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 10 1 45 5 75 45 6 75 45 7 75 45 8 75 45 9 75 45 7 13 7 19 1 10 39 12 13 7 19 1 11 51 7 39 3 11 12 76 39 6 10 9 73 38 727 13 7 19 1 13 76 39 6 10 9 73 38 714 10 8 16 14 39 23 13 8 13 6 19 2 15 51 4 39 12 13 4 19 1 16 12 13 7 19 2 17 39 6 11 12 73 38 679 15 12 13 7 19 2 17 39 6 11 12 73 38 665 13 7 75 17 18 39 5 75 73 38 654 13 7 77 19 2 17 39 13 15 19 13 7 19 2 20 10 9 73 38 634 13 7 1 21 17 22 51 0 39 10 13 0 10 8 6 2 73 38 615 58 60 76 77 77 14 23 46 24 46 25 46 26 57 27 61 2 2 56 10 3 4 45 28 10 0 4 51 2 10 0 5 51 0 10 0 51 3 43 1 10 3 5 51 3 13 12 13 1 19 2 29 39 10 13 2 10 13 6 2 73 36 4 10 3 2 39 4 35 0 1 35 0 0 62 43 3 63 73 40 534 13 7 15 30 19 2 31 51 0 39 12 10 0 5 12 10 8 6 2 73 38 512 10 7 16 32 39 9 13 7 1 33 17 22 51 0 39 22 13 9 13 8 15 34 13 0 20 0 23 6 2 12 13 6 19 4 0 38 475 19 0 35 76 39 6 10 9 73 38 464 10 7 16 36 39 7 13 2 1 37 17 18 39 6 10 9 73 38 445 10 7 16 14 39 9 13 7 77 19 2 38 51 4 39 16 15 39 13 8 15 34 10 7 6 2 6 3 73 38 414 10 7 16 32 39 6 10 9 73 38 403 10 7 5 51 1 10 7 4 51 2 13 2 1 40 17 18 39 21 15 40 15 41 13 8 15 34 10 1 4 6 2 6 3 6 2 73 38 365 13 2 15 42 19 2 43 39 117 19 0 44 45 45 15 46 13 0 10 9 6 2 6 1 12 15 47 14 48 10 0 6 2 6 2 12 13 3 58 60 76 77 13 3 46 49 46 3 75 6 1 45 50 10 0 45 51 57 27 61 2 2 42 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 15 41 13 6 15 34 10 3 6 2 6 3 6 1 51 1 17 52 35 0 0 10 2 5 73 36 5 62 43 2 43 2 63 7 2 6 4 73 43 1 38 240 13 2 1 43 17 18 39 16 15 43 13 8 15 34 10 1 6 2 6 3 73 38 217 13 2 15 53 19 2 43 39 133 19 0 44 12 19 0 44 12 46 54 46 55 13 4 1 56 17 18 39 8 13 9 15 57 19 2 17 39 5 1 57 51 4 15 46 13 0 10 10 6 2 12 13 1 9 0 13 4 19 2 58 6 2 6 2 12 15 47 14 48 10 0 6 2 12 15 3 13 4 10 1 6 3 6 3 12 15 59 15 41 13 0 15 34 10 4 6 2 6 3 12 15 60 15 61 15 62 13 1 15 63 13 4 10 0 6 3 6 3 12 15 59 13 1 13 3 19 2 64 7 2 6 4 6 3 6 4 73 43 2 38 76 13 2 1 65 17 18 39 21 10 7 16 66 12 9 2 19 2 67 39 9 10 7 16 68 51 0 16 14 39 10 13 0 10 8 6 2 73 38 37 13 2 1 33 17 22 51 0 39 24 13 9 13 8 15 34 13 0 13 1 19 2 69 6 2 12 13 6 19 4 0 38 4 10 9 73 43 6 29) #677# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 12 12 19 3 13 1 0 73 29) #678=#A(t (14) (typep compiler-macro #:g21387 c::env c::form #:g21388 si::dm-too-few-arguments ffi::object type c::e si::dm-too-many-arguments c::expand-typep #Y(typep nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 4 19 1 6 10 1 4 12 10 1 5 51 1 22 45 8 10 2 39 13 10 2 4 12 10 2 5 51 2 22 38 2 75 45 9 10 3 39 6 13 6 19 1 10 13 4 13 2 13 1 13 5 19 4 11 29) #678# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 30 12 19 3 31 1 0 73 29) #679=#A(t (32) (dolist compiler-macro #:g21389 c::env #:g21390 si::dm-too-few-arguments #:g21391 #:g21392 c::var c::expression c::output-form c::body si::dm-too-many-arguments si::process-declarations c::declarations gensym c::list-var c::policy-assume-no-errors ext::truly-the cons c::typed-var block let* si::while let first declare tagbody setq rest #Y(dolist nil nil (24 45 2 24 45 3 26 10 1 5 45 4 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 0 45 7 10 0 76 39 6 13 4 19 1 5 10 0 4 12 10 0 5 51 0 22 45 8 10 1 76 39 6 13 5 19 1 5 10 1 4 12 10 1 5 51 1 22 45 9 10 2 39 13 10 2 4 12 10 2 5 51 2 22 38 2 75 45 10 10 5 45 11 10 4 39 6 13 8 19 1 12 13 0 77 19 2 13 47 1 11 45 14 19 0 15 45 16 13 10 19 1 17 39 5 10 0 38 9 15 18 15 19 10 0 6 3 45 20 15 21 77 15 22 13 1 10 6 6 2 6 1 12 15 23 13 1 15 24 13 7 15 25 10 0 6 2 6 2 6 1 12 15 26 10 2 7 2 12 15 27 10 3 7 2 6 4 12 15 28 13 1 15 29 10 0 6 2 6 3 6 4 12 10 5 39 22 15 24 13 7 75 6 2 6 1 12 15 26 10 2 7 2 12 10 5 6 4 6 4 6 3 73 43 2 43 2 29) #679# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 2 52 0 1 0 73 29) #A(t (3) (c::+coercion-table+ si::*make-special ((integer let ((c::y c::x)) (check-type c::y integer) c::y) (float float c::x) (short-float float c::x #157#) (single-float float c::x #157#) (double-float float c::x #156#) (long-float float c::x #155#) (base-char character c::x) (character character c::x) (function si::coerce-to-function c::x)))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 67 12 19 2 68 1 0 73 29) #680=#A(t (69) (c::expand-coerce c::form c::value type c::env c::orig-type first rest constantp c::cmp-eval t subtypep "Cannot COERCE an expression to an empty type." c::cmperror c::policy-inline-type-checks c::+coercion-table+ #:loop-list21402 c::template c::a-type 0 #72# eq c::x subst complex let c::y ((declare (:read-only c::y)) (complex (realpart c::y) (imagpart c::y))) atom si::deftype-definition si::get-sysprop quote consp cons #:loop-list21403 si::type= sequence si::closest-sequence-type length c::elt-type list si::coerce-to-list si::coerce-to-vector simple-array and #:loop-list21406 c::i #:loop-list-head21407 #:loop-list-tail21408 setf coerce rplacd (c::x) append = (declare (:read-only c::y)) (realpart c::y) (imagpart c::y) (integer rational float real single-float double-float long-float) member c::unchecked c::policy-assume-no-errors declare unless c::expand-in-interval-p si::do-check-type (nil "coerced value") #Y(c::expand-coerce nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 10 1 45 5 75 45 6 75 45 7 13 4 19 1 8 39 8 13 4 19 1 9 51 4 76 39 6 10 6 73 38 672 15 10 13 4 19 2 11 39 6 10 5 73 38 658 13 4 77 19 2 11 39 8 15 12 19 1 13 38 643 19 0 14 76 39 6 10 6 73 38 632 58 60 77 77 77 14 15 46 16 46 17 46 18 57 19 61 2 2 57 10 3 2 39 4 35 0 1 10 3 4 45 20 10 0 4 51 2 10 0 5 51 0 10 0 51 3 43 1 10 3 5 51 3 13 9 10 1 17 21 39 12 13 10 15 22 13 2 19 3 23 36 4 35 0 0 62 43 3 63 73 40 550 13 4 1 24 17 21 39 19 15 25 15 26 10 5 6 2 6 1 12 1 27 7 3 73 38 524 10 4 16 28 39 9 13 4 1 29 17 30 51 1 39 22 13 6 13 5 15 31 13 1 20 0 23 6 2 12 13 3 19 4 0 38 487 10 4 16 32 39 9 10 4 4 12 1 33 17 21 39 6 10 6 73 38 466 58 60 78 77 77 14 15 46 34 46 17 46 18 57 19 61 2 2 58 10 3 2 39 4 35 0 1 10 3 4 45 20 10 0 4 51 2 10 0 5 51 0 10 0 51 3 43 1 10 3 5 51 3 13 9 13 1 19 2 35 39 12 13 10 15 22 13 2 19 3 23 36 4 35 0 0 62 43 3 63 73 40 383 13 4 15 36 19 2 11 39 64 13 4 19 1 37 47 1 38 45 39 13 0 1 40 17 21 39 10 15 41 10 7 6 2 73 38 33 15 42 13 7 15 31 10 0 6 2 12 15 31 10 1 6 2 12 13 6 15 43 19 2 11 39 3 11 10 6 5 73 43 2 38 311 10 4 16 28 39 6 10 6 73 38 300 10 4 5 51 0 10 4 4 51 1 13 1 1 44 17 21 39 108 15 25 15 22 10 5 6 2 6 1 12 58 60 83 77 13 1 46 45 46 46 75 6 1 45 47 10 0 45 48 57 19 61 2 2 48 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 15 49 15 22 15 50 15 22 15 31 10 3 6 2 6 3 6 3 6 1 51 1 17 51 35 0 0 10 2 5 73 36 5 62 73 43 2 43 2 63 12 15 52 19 2 53 7 3 73 38 175 13 1 1 24 17 21 39 11 10 0 16 38 12 9 1 19 2 54 39 50 15 25 15 26 10 5 6 2 6 1 12 15 55 15 24 15 50 15 56 15 31 10 0 4 6 2 6 3 12 15 50 15 57 15 31 10 0 4 6 2 6 3 6 3 6 4 73 38 106 13 1 15 58 19 2 59 39 94 13 6 13 5 15 31 10 1 6 2 12 13 3 19 4 0 45 60 19 0 61 39 6 10 0 73 38 62 15 25 15 22 10 0 6 2 6 1 12 15 62 13 2 1 22 6 2 6 2 12 15 63 15 44 15 22 10 5 5 12 19 2 64 7 2 12 15 65 15 22 15 31 10 5 6 2 12 1 66 7 4 6 3 12 1 22 6 5 73 43 1 38 4 10 6 73 43 3 29) #680# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 11 12 19 3 12 1 0 73 29) #681=#A(t (13) (coerce compiler-macro #:g21409 c::env c::form #:g21410 si::dm-too-few-arguments c::value type si::dm-too-many-arguments c::expand-coerce #Y(coerce nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 4 19 1 6 10 1 4 12 10 1 5 51 1 22 45 8 10 2 39 6 13 5 19 1 9 13 3 13 1 13 0 13 4 19 4 10 29) #681# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 35 12 19 3 36 1 0 73 29) #682=#A(t (37) (float compiler-macro #:g21411 c::env c::form #:g21412 si::dm-too-few-arguments c::value si::dm-too-many-arguments c::policy-inline-type-checks c::constant-value-p c::constant-p floatp gentemp c::aux type-of c::lisp-type->rep-type c::c-type let (declare (:read-only c::value)) ext::compiler-typecase t ffi::c-inline (c::value) (:object) #:g21414 :double "ecl_to_double(#0)" :float "ecl_to_float(#0)" :long-double "ecl_to_long_double(#0)" (:double :float :long-double) si::ecase-error (:one-liner t :side-effects nil) #Y(float nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 39 13 10 1 4 12 10 1 5 51 1 22 38 2 75 45 0 10 2 39 6 13 5 19 1 8 10 0 39 136 13 4 19 1 9 39 129 13 0 13 4 19 2 10 47 1 0 45 11 10 0 39 5 10 1 16 12 39 105 19 0 13 45 14 10 2 16 15 45 0 13 0 19 1 16 45 17 15 18 15 7 10 6 6 2 6 1 12 15 19 15 20 15 7 13 1 1 7 6 2 12 15 21 15 22 15 23 15 24 13 0 10 0 45 25 10 0 42 26 6 1 27 73 38 24 42 28 6 1 29 73 38 16 42 30 6 1 31 73 38 8 13 0 15 32 19 2 33 12 43 1 1 34 7 6 6 2 6 4 6 4 43 3 43 2 73 40 4 10 3 73 29) #682# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 26 12 19 3 27 1 0 73 29) #683=#A(t (28) (ldb compiler-macro #:g21416 #:g21415 c::whole #:g21417 c::args most-positive-fixnum integer-length c::pos c::size c::len c::arg1 consp byte eq second integerp third + <= c::result-type fixnum subtypep ext::truly-the c::ldb1 #Y(ldb nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 10 0 4 12 11 7 16 8 12 77 77 46 9 46 10 46 11 46 12 10 0 16 13 39 59 15 14 10 0 4 17 15 39 50 10 0 16 16 51 2 16 17 39 40 10 0 16 18 51 3 16 17 39 30 13 2 13 3 19 2 19 12 13 1 19 2 20 39 15 10 4 16 16 12 19 1 21 12 15 22 19 2 23 39 22 15 24 15 22 15 25 13 2 13 3 10 4 16 16 6 4 6 3 73 38 4 10 6 73 43 4 29) #683# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 13 12 19 3 14 1 0 73 29) #684=#A(t (15) (ash compiler-macro #:g21419 #:g21418 c::whole #:g21420 si::dm-too-few-arguments c::argument c::shift si::dm-too-many-arguments c::policy-assume-right-type integerp zerop #Y(ash nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 4 19 1 6 10 1 4 12 10 1 5 51 1 22 45 8 10 2 39 6 13 5 19 1 9 19 0 10 39 5 10 0 16 11 39 23 10 0 16 12 39 6 10 1 73 38 10 15 8 13 1 10 0 6 3 73 38 4 10 3 73 29) #684# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 29 12 19 3 30 29) #685=#A(t (31) (c::shift c::*cinline-dispatch-table* c::return-type c::argument c::orig-shift c::inlined-arg-type c::arg-type c::lisp-type->rep-type c::arg-c-type c::return-c-type c::inlined-arg-loc c::loc-immediate-value c::c-integer-rep-type-p (:object :fixnum) (:object) "ecl_ash(#0,#1)" t c::produce-inline-loc c::c-integer-rep-type-bits c::arg-bits c::return-bits plusp < c::max-type minusp "((#0) >> (~D))" "((#0) << (~D))" abs format #Y(nil nil nil (24 45 2 24 45 3 24 45 4 26 13 1 19 1 5 45 6 13 0 19 1 7 45 8 13 4 19 1 7 45 9 13 3 19 1 10 12 19 1 11 45 0 13 2 19 1 12 76 40 7 13 1 19 1 12 76 39 22 13 5 10 4 6 2 12 15 13 15 14 15 15 77 14 16 19 6 17 38 86 13 2 19 1 18 45 19 13 2 19 1 18 45 20 10 2 16 21 39 8 13 1 13 0 19 2 22 39 5 10 3 38 3 10 4 45 23 10 8 6 1 12 10 0 6 1 12 10 9 6 1 12 77 10 3 16 24 39 6 1 25 73 38 4 1 26 73 12 10 3 16 27 12 19 3 28 12 77 14 16 19 6 17 43 3 43 4 29) #685# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 14 12 19 3 15 29) #686=#A(t (16) (logand c::*p0-dispatch-table* c::fname c::args ((unsigned-byte 8) fixnum) si::%dolist-var c::int-type #:loop-list21427 c::value 0 subtypep t integer fixnum #Y(nil nil nil (24 45 2 27 45 3 13 0 10 0 39 105 58 60 100 1 4 45 5 75 45 6 38 78 10 1 4 51 0 58 60 58 77 13 4 46 7 46 8 57 9 61 2 2 36 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 4 19 2 10 76 39 5 75 73 36 3 35 0 0 11 11 73 36 3 62 43 2 63 39 6 10 0 73 36 2 10 1 5 51 1 10 1 40 -80 75 51 0 1 12 73 43 2 63 38 4 1 13 73 12 72 2 29) #686# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #687=#A(t (12) (c::clos-compiler-macro-expand c::fname c::args si::valid-function-name-p fboundp fdefinition function generic-function typep c::generic-function-macro-expand #Y(c::clos-compiler-macro-expand nil nil (24 45 1 24 45 2 26 10 1 16 3 39 5 10 1 16 4 73 39 31 10 1 16 5 45 6 13 0 15 7 19 2 8 73 39 13 13 0 13 2 10 1 7 2 12 19 2 9 43 1 29) #687# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 77 15 1 15 2 1 9 12 14 7 19 6 10 29) #688=#A(t (11) (c::generic-function-macro-expand (standard-generic-function t) (c::g c::whole) c::g c::whole c::optimizable-slot-accessor c::output t c::success #Y(nil nil nil (24 45 3 24 45 4 26 13 1 13 0 19 2 5 45 6 10 0 39 3 11 7 45 8 13 1 13 0 72 2 43 2 29) #688# #1# 0) clos::install-method)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #689=#A(t (27) (c::optimizable-slot-reader method c::whole clos::standard-reader-method typep clos::method-specializers class clos::class-sealedp clos::accessor-method-slot-definition c::slotd clos::slot-definition-location ext::location gentemp ffi::object "Inlining read access to slot ~a from class ~a" clos::slot-definition-name class-name c::cmpnote let second c::optional-type-check quote locally (declare (optimize speed (safety 0))) si::instance-ref #Y(c::optimizable-slot-reader nil nil (24 45 1 24 45 2 26 13 1 15 3 19 2 4 73 39 102 13 1 19 1 5 4 45 6 13 0 19 1 7 73 39 84 13 2 19 1 8 45 9 13 0 19 1 10 45 11 19 0 12 45 13 15 14 13 2 19 1 15 12 13 3 19 1 16 12 19 3 17 15 18 13 0 10 4 16 19 6 2 6 1 12 15 20 13 0 15 21 10 3 6 2 6 3 12 15 22 15 23 15 24 13 0 10 1 6 3 6 3 6 4 73 43 1 43 2 43 1 29) #689# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 27 12 19 2 28 1 0 73 29) #690=#A(t (29) (c::optimizable-slot-writer method c::whole clos::standard-writer-method typep clos::method-specializers second class clos::class-sealedp clos::accessor-method-slot-definition c::slotd clos::slot-definition-location ext::location gentemp ffi::object c::value "Inlining write access to slot ~a from class ~a" clos::slot-definition-name class-name c::cmpnote let third c::optional-type-check quote locally (declare (optimize speed (safety 0))) si::instance-set #Y(c::optimizable-slot-writer nil nil (24 45 1 24 45 2 26 13 1 15 3 19 2 4 73 39 119 13 1 19 1 5 16 6 45 7 13 0 19 1 8 73 39 100 13 2 19 1 9 45 10 13 0 19 1 11 45 12 19 0 13 45 14 19 0 13 45 15 15 16 13 3 19 1 17 12 13 4 19 1 18 12 19 3 19 15 20 13 0 10 5 16 6 6 2 12 13 1 10 5 16 21 6 2 6 2 12 15 22 13 1 15 23 10 4 6 2 6 3 12 15 24 15 25 15 26 13 1 13 2 10 0 6 4 6 3 6 4 73 43 2 43 2 43 1 29) #690# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #691=#A(t (11) (c::optimizable-slot-accessor c::g c::whole c::policy-inline-slot-access clos::generic-function-methods c::methods c::principal c::optimizable-slot-reader c::optimizable-slot-writer #Y(c::optimizable-slot-accessor nil nil (24 45 1 24 45 2 26 19 0 3 73 39 46 13 1 19 1 4 45 5 10 0 73 39 32 10 0 5 76 73 39 25 10 0 4 45 6 13 0 13 2 19 2 7 73 40 8 13 0 13 2 19 2 8 43 1 43 1 29) #691# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #692=#A(t (13) (c::constant-expression-p c::form constantp consp every c::head (if or and null not progn) member c::pure si::get-sysprop c::inline-possible #Y(c::constant-expression-p nil nil (24 45 1 26 13 0 19 1 2 73 40 52 10 0 16 3 73 39 45 33 0 12 10 0 5 12 19 2 4 73 39 32 10 0 4 45 5 13 0 15 6 19 2 7 73 40 15 13 0 1 8 17 9 73 39 6 13 0 19 1 10 43 1 29) #692# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #693=#A(t (15) (c::extract-constant-value c::form c::failure c::constant-expression-p #:g21431 #:g21432 0 error si::temp #Y(nil nil nil (24 45 8 26 10 0 51 2 35 1 0 29) #693# #1# 0) si::*handler-clusters* c::cmp-eval c::c #Y(c::extract-constant-value nil nil (24 45 1 25 40 2 77 46 2 26 13 1 19 1 3 39 53 57 4 60 47 75 45 5 57 6 61 1 23 15 7 34 9 3 6 1 12 11 10 3 48 10 13 4 19 1 11 36 2 44 1 10 1 45 12 10 4 73 43 1 36 2 62 73 43 1 63 38 4 10 0 73 29) #693# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #694=#A(t (16) (c::constant-value-p c::form c::env c::constant-expression-p #:g21437 #:g21438 0 error si::temp #Y(nil nil nil (24 45 8 26 10 0 51 2 35 1 0 29) #694# #1# 0) si::*handler-clusters* t c::cmp-eval c::c #Y(c::constant-value-p nil nil (24 45 1 25 40 2 77 46 2 26 13 1 19 1 3 39 60 57 4 60 54 75 45 5 57 6 61 1 28 15 7 34 9 3 6 1 12 11 10 3 48 10 14 11 13 4 19 1 12 12 72 2 36 2 44 1 10 1 45 13 77 13 5 72 2 43 1 36 2 62 73 43 1 63 38 6 77 13 1 72 2 29) #694# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #695=#A(t (20) (c::expand-simple-optimizer values c::arg-types c::inline-form c::env ffi::c-inline c::policy-assume-right-type #:loop-list21444 c::v #:loop-list21445 c::value-and-type #:loop-list-head21446 #:loop-list-tail21447 0 consp ext::checked-value second rplacd #Y(c::expand-simple-optimizer nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 15 5 13 0 19 1 6 39 6 10 3 73 38 116 58 60 113 77 13 4 46 7 46 8 77 13 5 46 9 46 10 75 6 1 45 11 10 0 45 12 57 13 61 2 2 69 10 6 2 39 4 35 0 1 10 6 4 51 5 10 6 5 51 6 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 10 3 16 14 39 14 15 15 10 3 16 16 12 10 5 6 3 38 3 10 5 6 1 51 1 17 17 35 0 0 10 2 5 73 36 7 62 73 43 2 43 2 43 2 63 12 10 1 7 3 73 29) #695# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #696=#A(t (17) (c::simple-optimizer-function c::name c::args c::inline-form compiler-macro symbolp every c::whole c::env c::policy-inline-accessors ffi::c-inline #Y(nil nil nil (24 45 7 24 45 8 26 13 0 19 1 9 39 14 15 10 10 1 5 12 10 2 7 3 73 38 4 10 1 73 29) #696# #1# 0) c::expand-simple-optimizer #Y(nil nil nil (24 45 7 24 45 8 26 13 0 19 1 9 39 16 10 1 5 12 13 3 13 2 13 0 19 4 12 38 4 10 1 73 29) #696# #1# 0) si::put-sysprop #Y(c::simple-optimizer-function nil nil (24 45 1 24 45 2 24 45 3 26 13 2 15 4 33 5 12 13 1 19 2 6 39 6 34 11 73 38 4 34 13 73 12 19 3 14 29) #696# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 14 10 9 2 19 4 11 1 0 73 29) #697=#A(t (12) (c::cons-car #:g21449 #:g21448 #:g21450 si::dm-too-few-arguments c::x si::dm-too-many-arguments ffi::c-inline ((:object) :object "ECL_CONS_CAR(#0)" :one-liner t :side-effects nil) #Y(c::cons-car nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 39 6 13 3 19 1 6 15 7 10 0 6 1 12 1 8 7 3 73 29) #697# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 14 10 9 2 19 4 11 1 0 73 29) #698=#A(t (12) (c::cons-cdr #:g21452 #:g21451 #:g21453 si::dm-too-few-arguments c::x si::dm-too-many-arguments ffi::c-inline ((:object) :object "ECL_CONS_CDR(#0)" :one-liner t :side-effects nil) #Y(c::cons-cdr nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 39 6 13 3 19 1 6 15 7 10 0 6 1 12 1 8 7 3 73 29) #698# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 24 12 19 3 25 1 0 73 29) #699=#A(t (26) (cons compiler-macro #:g21455 #:g21454 c::whole #:g21456 c::args c::x last c::tem consp caar eq cdar length eql butlast append #Y(c::cons-to-lista nil nil (24 45 7 26 13 0 19 1 8 45 9 10 0 16 10 39 30 10 0 4 16 10 39 23 10 0 16 11 12 1 0 17 12 39 12 10 0 16 13 16 14 12 8 2 17 15 39 22 13 1 19 1 16 12 10 0 16 13 12 19 2 17 12 32 2 18 1 38 4 10 1 73 43 1 29) #699# #1# 0) c::temp (nil) equal list list* #Y(cons nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 31 1 18 75 45 19 10 2 16 14 12 8 2 17 15 39 14 13 2 13 2 32 1 18 1 51 0 17 12 76 39 31 15 20 13 0 19 1 8 17 21 39 12 15 22 13 0 19 1 16 3 73 38 7 15 23 10 0 3 73 38 4 10 4 73 43 1 43 1 29) #699# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 14 11 9 3 19 4 12 1 0 73 29) #700=#A(t (13) (c::define-simple-optimizer #:g21458 #:g21457 #:g21459 si::dm-too-few-arguments c::name c::args c::inline-form c::simple-optimizer-function quote #Y(c::define-simple-optimizer nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 45 7 15 8 15 9 10 2 6 2 12 15 9 10 1 6 2 12 15 9 10 0 6 2 6 4 73 29) #700# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (rplaca ((c::c cons) c::value) ((:object :object) :object "@0;(ECL_CONS_CAR(#0)=#1,#0)" :one-liner t) c::simple-optimizer-function)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (rplacd ((c::c cons) c::value) ((:object :object) :object "@0;(ECL_CONS_CDR(#0)=#1,#0)" :one-liner t) c::simple-optimizer-function)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 20 12 19 3 21 1 0 73 29) #701=#A(t (22) (nth compiler-macro #:g21461 #:g21460 c::whole #:g21462 c::args 0 car 1 cadr 2 caddr 3 cadddr 4 cddddr 5 6 7 #Y(nth nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 10 0 4 42 7 10 15 8 10 0 5 3 73 38 104 42 9 10 15 10 10 0 5 3 73 38 92 42 11 10 15 12 10 0 5 3 73 38 80 42 13 10 15 14 10 0 5 3 73 38 68 42 15 14 15 8 15 16 10 0 5 3 6 2 73 38 52 42 17 14 15 10 15 16 10 0 5 3 6 2 73 38 36 42 18 14 15 12 15 16 10 0 5 3 6 2 73 38 20 42 19 14 15 14 15 16 10 0 5 3 6 2 73 38 4 10 2 73 29) #701# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 20 12 19 3 21 1 0 73 29) #702=#A(t (22) (nthcdr compiler-macro #:g21464 #:g21463 c::whole #:g21465 c::args 0 second 1 cdr 2 cddr 3 cdddr 4 cddddr 5 6 7 #Y(nthcdr nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 10 0 4 42 7 7 10 0 16 8 38 100 42 9 10 15 10 10 0 5 3 73 38 88 42 11 10 15 12 10 0 5 3 73 38 76 42 13 10 15 14 10 0 5 3 73 38 64 42 15 10 15 16 10 0 5 3 73 38 52 42 17 14 15 10 15 16 10 0 5 3 6 2 73 38 36 42 18 14 15 12 15 16 10 0 5 3 6 2 73 38 20 42 19 14 15 14 15 16 10 0 5 3 6 2 73 38 4 10 2 73 29) #702# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 9 12 19 3 10 15 11 15 1 1 15 12 19 3 10 15 16 15 1 1 20 12 19 3 10 15 21 15 1 1 25 12 19 3 10 15 26 15 1 1 30 12 19 3 10 15 31 15 1 1 35 12 19 3 10 15 36 15 1 1 40 12 19 3 10 15 41 15 1 1 45 12 19 3 10 15 46 15 1 1 50 12 19 3 10 15 51 15 1 1 55 12 19 3 10 1 51 73 29) #703=#A(t (56) (first compiler-macro #:g21470 #:g21469 #:g21471 si::dm-too-few-arguments c::x si::dm-too-many-arguments nth #Y(first nil nil (24 45 2 24 45 3 26 10 1 5 45 4 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 6 13 3 19 1 7 15 8 9 0 10 0 6 3 73 29) #703# #1# 0) si::put-sysprop second #:g21473 #:g21472 #:g21474 #Y(second nil nil (24 45 12 24 45 13 26 10 1 5 45 14 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 6 13 3 19 1 7 15 8 9 1 10 0 6 3 73 29) #703# #1# 0) third #:g21476 #:g21475 #:g21477 #Y(third nil nil (24 45 17 24 45 18 26 10 1 5 45 19 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 6 13 3 19 1 7 15 8 9 2 10 0 6 3 73 29) #703# #1# 0) fourth #:g21479 #:g21478 #:g21480 #Y(fourth nil nil (24 45 22 24 45 23 26 10 1 5 45 24 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 6 13 3 19 1 7 15 8 9 3 10 0 6 3 73 29) #703# #1# 0) fifth #:g21482 #:g21481 #:g21483 #Y(fifth nil nil (24 45 27 24 45 28 26 10 1 5 45 29 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 6 13 3 19 1 7 15 8 9 4 10 0 6 3 73 29) #703# #1# 0) sixth #:g21485 #:g21484 #:g21486 #Y(sixth nil nil (24 45 32 24 45 33 26 10 1 5 45 34 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 6 13 3 19 1 7 15 8 9 5 10 0 6 3 73 29) #703# #1# 0) seventh #:g21488 #:g21487 #:g21489 #Y(seventh nil nil (24 45 37 24 45 38 26 10 1 5 45 39 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 6 13 3 19 1 7 15 8 9 6 10 0 6 3 73 29) #703# #1# 0) eighth #:g21491 #:g21490 #:g21492 #Y(eighth nil nil (24 45 42 24 45 43 26 10 1 5 45 44 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 6 13 3 19 1 7 15 8 9 7 10 0 6 3 73 29) #703# #1# 0) ninth #:g21494 #:g21493 #:g21495 #Y(ninth nil nil (24 45 47 24 45 48 26 10 1 5 45 49 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 6 13 3 19 1 7 15 8 9 8 10 0 6 3 73 29) #703# #1# 0) tenth #:g21497 #:g21496 #:g21498 #Y(tenth nil nil (24 45 52 24 45 53 26 10 1 5 45 54 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 6 13 3 19 1 7 15 8 9 9 10 0 6 3 73 29) #703# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 9 12 19 3 10 1 0 73 29) #704=#A(t (11) (rest compiler-macro #:g21500 #:g21499 #:g21501 si::dm-too-few-arguments c::x si::dm-too-many-arguments cdr #Y(rest nil nil (24 45 2 24 45 3 26 10 1 5 45 4 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 6 13 3 19 1 7 15 8 10 0 6 2 73 29) #704# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 31 12 19 3 32 1 0 73 29) #705=#A(t (33) (pop compiler-macro #:g21502 c::env c::whole #:g21503 si::dm-too-few-arguments c::place si::dm-too-many-arguments c::policy-inline-accessors get-setf-expansion c::access-form c::store-form c::stores c::vals c::vars c::store-var gensym c::saved-place let* list append mapcar declare :read-only c::optional-type-check when let c::cons-cdr setq c::cons-car #Y(pop nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 39 6 13 4 19 1 8 19 0 9 39 143 13 0 13 3 19 2 10 47 4 11 47 3 12 47 2 13 47 1 14 45 15 10 2 4 45 16 19 0 17 45 18 15 19 33 20 12 13 2 10 0 6 1 12 19 2 21 12 13 3 10 6 6 1 12 19 2 21 12 19 3 22 12 15 23 14 24 10 2 7 2 6 2 12 15 25 13 0 1 20 6 3 12 15 26 13 0 15 27 13 1 15 28 10 0 6 2 6 2 6 1 12 15 23 14 24 10 1 6 2 6 2 12 13 5 15 29 13 0 15 30 10 0 6 2 6 3 6 5 6 3 12 10 0 6 6 73 43 2 43 5 38 4 10 2 73 29) #705# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #706=#A(t (18) (c::printer-default-stream stream c::env constantp c::cmp-eval c::value nil *standard-output* t *terminal-io* streamp "Found~%~A~%as expression for a stream, but it cannot be externalized." "Found~%~A~%where a stream was expected." c::cmpwarn ffi::c-inline ((:object) :object "_ecl_stream_or_default_output(#0)" :one-liner t) #Y(c::printer-default-stream nil nil (24 45 1 24 45 2 26 13 1 13 0 19 2 3 39 55 13 1 13 0 19 2 4 45 5 10 0 42 6 6 1 7 73 38 32 42 8 6 1 9 73 38 24 10 0 16 10 39 6 1 11 73 38 4 1 12 73 12 13 2 19 2 13 10 2 73 43 1 38 13 15 14 10 1 6 1 12 1 15 7 3 73 29) #706# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 37 12 19 3 38 1 0 73 29) #707=#A(t (39) (princ compiler-macro #:g21504 c::env #:g21505 si::dm-too-few-arguments c::expression stream si::dm-too-many-arguments constantp c::cmp-eval c::value #\Newline eql terpri characterp ffi::c-inline ((:wchar :object) :wchar "ecl_princ_char(#0,#1)" :one-liner t) stringp length = aref ((:wchar :object) :wchar "ecl_princ_char(#0,#1)" :one-liner t) base-string typep < progn (:object) :void string "ecl_princ_str(" c::c-inline-safe-string ",#0)" concatenate (:one-liner t) ((:object :object) :object "ecl_princ(#0,#1)" :one-liner t) ((:object :object) :object "ecl_princ(#0,#1)" :one-liner t) #Y(princ nil nil (24 45 2 24 45 3 26 10 1 5 45 4 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 13 10 1 4 12 10 1 5 51 1 22 38 2 75 45 7 10 2 39 6 13 4 19 1 8 13 1 13 3 19 2 9 39 169 13 1 13 3 19 2 10 45 11 13 0 1 12 17 13 39 10 15 14 10 1 6 2 73 38 139 10 0 16 15 39 17 15 16 13 0 10 1 6 2 12 1 17 7 3 73 38 117 10 0 16 18 39 11 10 0 16 19 12 9 1 19 2 20 39 23 15 16 13 0 9 0 19 2 21 12 10 1 6 2 12 1 22 7 3 73 38 77 13 0 15 23 19 2 24 39 11 10 0 16 19 12 9 80 19 2 25 39 42 15 26 15 16 10 1 6 1 12 15 27 14 28 15 29 15 30 13 0 19 1 31 12 15 32 19 4 33 12 1 34 7 6 12 10 0 6 3 73 38 15 15 16 13 2 10 1 6 2 12 1 35 7 3 73 43 1 38 15 15 16 13 1 10 0 6 2 12 1 36 7 3 73 29) #707# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 9 12 19 3 10 1 0 73 29) #708=#A(t (11) (terpri compiler-macro #:g21506 c::env #:g21507 stream si::dm-too-many-arguments ffi::c-inline ((:object) :object "ecl_terpri(#0)" :one-liner t) #Y(terpri nil nil (24 45 2 24 45 3 26 10 1 5 45 4 10 0 39 13 10 0 4 12 10 0 5 51 0 22 38 2 75 45 5 10 1 39 6 13 3 19 1 6 15 7 10 0 6 1 12 1 8 7 3 73 29) #708# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 11 12 19 3 12 1 0 73 29) #709=#A(t (13) (print compiler-macro #:g21508 c::env #:g21509 si::dm-too-few-arguments c::value stream si::dm-too-many-arguments ffi::c-inline ((:object :object) :object "ecl_print(#0,#1)" :one-liner t) #Y(print nil nil (24 45 2 24 45 3 26 10 1 5 45 4 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 13 10 1 4 12 10 1 5 51 1 22 38 2 75 45 7 10 2 39 6 13 4 19 1 8 15 9 13 1 10 0 6 2 12 1 10 7 3 73 29) #709# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 11 12 19 3 12 1 0 73 29) #710=#A(t (13) (prin1 compiler-macro #:g21510 c::env #:g21511 si::dm-too-few-arguments c::value stream si::dm-too-many-arguments ffi::c-inline ((:object :object) :object "ecl_prin1(#0,#1)" :one-liner t) #Y(prin1 nil nil (24 45 2 24 45 3 26 10 1 5 45 4 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 1 39 13 10 1 4 12 10 1 5 51 1 22 38 2 75 45 7 10 2 39 6 13 4 19 1 8 15 9 13 1 10 0 6 2 12 1 10 7 3 73 29) #710# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #711=#A(t (7) (c::constant-function-expression c::form consp (quote function lambda) member #Y(c::constant-function-expression nil nil (24 45 1 26 10 0 16 2 73 39 10 10 0 4 12 15 3 19 2 4 29) #711# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #712=#A(t (22) (c::seq-opt-test-function c::test-flag c::test :test #'eql :test-not eq c::init function c::v1 c::v2 not #Y(nil nil nil (24 45 9 24 45 10 26 15 11 13 2 13 1 13 0 20 2 23 6 2 73 29) #712# #1# 0) c::constant-function-expression funcall #Y(nil nil nil (24 45 9 24 45 10 26 15 14 13 2 13 1 10 0 6 4 73 29) #712# #1# 0) "TEST-FUNCTION" gensym c::test-function #Y(nil nil nil (24 45 9 24 45 10 26 15 14 13 2 13 1 10 0 6 4 73 29) #712# #1# 0) #Y(c::seq-opt-test-function nil nil (24 45 1 24 45 2 26 10 1 76 39 14 14 3 15 4 19 2 0 12 77 72 2 38 70 13 1 11 5 17 6 39 24 14 3 13 0 19 2 0 47 1 7 45 8 34 12 12 13 1 72 2 43 2 38 39 13 0 19 1 13 39 9 34 15 12 77 72 2 38 24 15 16 19 1 17 45 18 34 19 12 13 0 10 1 6 2 6 1 12 72 2 43 1 29) #712# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #713=#A(t (15) (c::seq-opt-key-function c::key identity c::constant-function-expression elt funcall #Y(nil nil nil (24 45 4 26 15 5 13 1 10 0 6 3 73 29) #713# #1# 0) "KEY-FUNCTION" gensym c::key-function #Y(nil nil nil (24 45 4 26 15 5 13 1 10 0 6 3 73 29) #713# #1# 0) or #'identity #Y(c::seq-opt-key-function nil nil (24 45 1 26 10 0 76 39 9 33 2 12 77 72 2 38 45 13 0 19 1 3 39 9 34 6 12 77 72 2 38 30 15 7 19 1 8 45 9 34 10 12 13 0 15 11 13 1 1 12 6 3 6 2 6 1 12 72 2 43 1 29) #713# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 43 12 19 2 44 1 0 73 29) #714=#A(t (45) (c::seq-opt-parse-args function c::args (nil :start-end) t c::start-end c::key-flag c::key c::init 'eql c::test c::test-flag c::start c::end keyword 0 atom :allow-other-keys eq #:g21526 keywordp :key #:g21529 :test :test-not #:g21532 "Cannot specify :TEST and :TEST-NOT arguments to ~A" c::cmpwarn :start "Unexpected keyword argument ~A in a call to function ~A" #:g21534 :end "Unexpected keyword argument ~A in a call to function ~A" #:g21536 :from-end #:g21537 c::seq-opt-key-function c::key-init c::key-function c::seq-opt-test-function c::test-init c::test-function nconc #Y(c::seq-opt-parse-args nil nil (24 45 1 24 45 2 28 3 22 40 3 14 4 46 5 58 60 418 75 45 6 75 45 7 75 45 8 1 9 45 10 75 45 11 8 0 45 12 75 45 13 75 45 14 57 15 61 2 2 319 10 11 76 39 4 35 0 1 10 11 16 16 40 40 10 11 5 76 40 34 13 1 11 17 17 18 40 26 10 11 45 19 10 0 4 12 10 0 5 51 0 10 0 51 12 22 43 1 51 1 16 20 76 39 7 75 73 36 9 38 255 13 1 11 21 17 18 39 34 10 8 76 39 27 10 11 45 22 10 0 4 12 10 0 5 51 0 10 0 51 12 22 43 1 51 7 11 4 51 8 38 214 13 1 11 23 17 18 40 7 13 1 11 24 17 18 39 56 10 4 76 39 29 10 11 45 25 10 0 4 12 10 0 5 51 0 10 0 51 12 22 43 1 51 5 10 1 51 4 38 21 13 4 10 1 17 18 76 39 12 15 26 13 12 19 2 27 75 73 36 9 38 143 13 1 11 28 17 18 39 43 10 10 76 39 14 15 29 13 1 13 12 19 3 27 75 73 36 9 10 11 45 30 10 0 4 12 10 0 5 51 0 10 0 51 12 22 43 1 51 3 38 93 13 1 11 31 17 18 39 43 10 10 76 39 14 15 32 13 1 13 12 19 3 27 75 73 36 9 10 11 45 33 10 0 4 12 10 0 5 51 0 10 0 51 12 22 43 1 51 2 38 43 13 1 11 34 17 18 39 31 10 11 45 35 10 0 4 12 10 0 5 51 0 10 0 51 12 22 43 1 76 76 39 5 75 73 36 9 38 5 75 73 36 9 35 0 0 13 7 19 1 36 47 1 37 45 38 13 6 13 7 19 2 39 47 1 40 45 41 13 2 13 0 13 3 13 1 19 2 42 12 13 12 13 8 13 9 72 6 36 13 43 2 43 2 62 73 43 1 43 1 43 1 43 1 43 1 43 1 43 1 43 1 63 29) #714# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 53 12 14 54 9 2 19 4 55 1 0 73 29) #715=#A(t (56) (c::do-in-seq #:g21539 #:g21538 #:g21540 si::dm-too-few-arguments #:g21541 #:g21542 c::%elt sequence :start si::search-keyword #:g21543 si::missing-keyword eq c::start :end #:g21544 c::end :output #:g21545 c::output c::body (:output :end :start) si::check-keyword "%START" gensym c::%start "%ITERATOR" c::%iterator "%COUNTER" c::%counter "%SEQUENCE" c::%sequence - or most-positive-fixnum c::counter and plusp c::test let* si::make-seq-iterator declare :read-only ignorable fixnum loop unless return let si::seq-iterator-ref setf si::seq-iterator-next #Y(c::do-in-seq nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 5 19 1 4 10 1 4 12 10 1 5 51 1 22 45 8 13 2 15 9 19 2 10 45 11 13 0 1 12 17 13 39 5 8 0 38 3 10 0 45 14 13 4 15 15 19 2 10 45 16 13 0 1 12 17 13 39 4 75 38 3 10 0 45 17 13 6 15 18 19 2 10 45 19 13 0 1 12 17 13 39 4 75 38 3 10 0 45 20 10 10 45 21 13 9 15 22 19 2 23 15 24 19 1 25 45 26 15 27 19 1 25 45 28 15 29 19 1 25 45 30 15 31 19 1 25 45 32 10 7 39 18 15 33 15 34 13 7 1 35 6 3 12 10 3 6 3 38 3 8 0 45 36 10 8 39 15 15 37 13 3 15 38 10 2 6 2 6 3 38 3 10 3 45 39 15 40 13 2 10 13 6 2 12 13 5 10 11 6 2 12 13 4 15 41 13 2 10 5 6 3 6 2 12 13 3 10 1 6 2 6 4 12 15 42 14 43 13 2 13 5 10 3 6 4 12 15 44 10 3 6 2 12 15 45 10 3 6 2 6 4 12 15 46 15 47 13 0 15 48 10 7 6 2 6 3 12 15 49 13 14 15 50 13 2 10 4 6 3 6 2 6 1 12 10 6 7 3 12 15 51 13 4 15 52 13 2 10 4 6 3 6 3 6 4 6 4 73 43 2 43 4 29) #715# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 14 20 9 2 19 4 21 1 0 73 29) #716=#A(t (22) (c::do-in-list #:g21547 #:g21546 #:g21548 si::dm-too-few-arguments #:g21549 #:g21550 c::%elt c::%sublist list c::output c::body do* c::cons-cdr null let* c::optional-type-check cons c::cons-car #Y(c::do-in-list nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 0 45 6 10 0 76 39 6 13 4 19 1 4 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 5 19 1 4 10 1 4 12 10 1 5 51 1 22 45 8 10 2 76 39 6 13 6 19 1 4 10 2 4 12 10 2 5 51 2 22 45 9 10 3 45 10 10 6 45 11 15 12 13 3 13 2 15 13 10 3 6 2 6 3 6 1 12 15 14 10 3 6 2 12 10 1 7 2 12 15 15 13 3 15 16 13 3 1 17 6 3 6 2 12 13 4 15 18 10 3 6 2 6 2 6 2 12 10 0 7 3 6 4 73 29) #716# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 51 12 19 2 52 1 0 73 29) #717=#A(t (53) (c::expand-member c::value list c::sequence-args member :start-end c::seq-opt-parse-args c::test c::test-flag c::key-flag c::init c::test-function c::key-function c::constant-function-expression c::constant-expression-p c::cmp-eval length <= #718="%VALUE" gensym c::%value let or c::l elt #:loop-list-head21552 #:loop-list-tail21553 0 atom and quote rplacd consp symbol :test eq ('eq #'eq) equal ffi::c-inline ((:object :object) :object "si_memq(#0,#1)" :one-liner t :side-effects nil) ('eql #'eql) ((:object :object) :object "ecl_memql(#0,#1)" :one-liner t :side-effects nil) ('equal #'equal) ((:object :object) :object "ecl_member(#0,#1)" :one-liner t :side-effects nil) #719="%SUBLIST" c::%sublist #720="%ELT" c::%elt c::do-in-list when return #Y(c::expand-member nil nil (24 45 1 24 45 2 27 45 3 57 0 60 407 15 4 13 1 14 5 77 19 4 6 47 5 7 47 4 8 47 3 9 47 2 10 47 1 11 45 12 10 0 76 39 5 75 73 36 6 10 3 76 39 284 10 5 76 40 6 13 5 19 1 13 39 6 13 8 19 1 14 39 162 13 8 19 1 15 51 8 16 16 12 9 4 19 2 17 39 124 15 18 19 1 19 45 20 15 21 13 0 10 10 6 2 6 1 12 15 22 58 60 92 10 10 45 23 75 45 24 75 6 1 45 25 10 0 45 26 57 27 61 2 2 56 10 4 16 28 39 4 35 0 1 10 4 4 51 3 13 1 15 29 13 8 13 6 15 30 10 3 6 2 12 20 2 23 12 15 30 10 4 6 2 6 3 6 1 51 1 17 31 10 4 5 51 4 35 0 0 10 2 5 73 36 5 62 43 2 43 1 43 1 63 7 2 6 3 73 43 1 36 6 10 8 16 32 40 6 13 8 19 1 33 39 9 15 30 10 8 6 2 51 8 10 4 76 40 7 13 4 11 34 17 35 39 91 13 5 15 36 14 34 33 37 12 19 4 4 39 17 15 38 13 9 10 8 6 2 12 1 39 7 3 73 36 6 13 5 15 40 14 34 33 37 12 19 4 4 39 17 15 38 13 9 10 8 6 2 12 1 41 7 3 73 36 6 13 5 15 42 14 34 33 37 12 19 4 4 39 17 15 38 13 9 10 8 6 2 12 1 43 7 3 73 36 6 15 18 19 1 19 45 20 15 44 19 1 19 45 45 15 46 19 1 19 45 47 15 21 13 2 10 12 6 2 12 10 5 7 2 12 15 48 13 0 13 1 10 11 6 3 12 15 49 13 4 13 2 13 3 13 0 20 1 23 12 20 2 23 12 15 50 10 1 6 2 6 3 6 3 6 3 73 43 3 43 6 63 29) #717# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 13 12 19 3 14 1 0 73 29) #721=#A(t (15) (member compiler-macro #:g21556 #:g21555 c::whole #:g21557 si::dm-too-few-arguments c::value list c::sequence-args c::policy-inline-sequence-functions c::expand-member apply #Y(member nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 4 19 1 6 10 1 4 12 10 1 5 51 1 22 45 8 10 2 45 9 19 0 10 39 19 33 11 12 10 4 5 12 19 2 12 73 40 4 10 4 73 38 4 10 4 73 29) #721# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 42 12 19 2 43 1 0 73 29) #722=#A(t (44) (c::expand-assoc c::value list c::sequence-args assoc :start-end c::seq-opt-parse-args c::test c::test-flag c::key-flag c::init c::test-function c::key-function :test eq ('eq #'eq) equal member ffi::c-inline ((:object :object) :object "ecl_assq(#0,#1)" :one-liner t :side-effects nil) ('eql #'eql) ((:object :object) :object "ecl_assql(#0,#1)" :one-liner t :side-effects nil) ('equal #'equal) ((:object :object) :object "ecl_assoc(#0,#1)" :one-liner t :side-effects nil) ('equalp #'equalp) ((:object :object) :object "ecl_assqlp(#0,#1)" :one-liner t :side-effects nil) #718# gensym c::%value #719# c::%sublist #720# c::%elt "%CAR" c::%car let c::do-in-list when c::cons-car c::optional-type-check cons return #Y(c::expand-assoc nil nil (24 45 1 24 45 2 27 45 3 57 0 60 289 15 4 13 1 14 5 77 19 4 6 47 5 7 47 4 8 47 3 9 47 2 10 47 1 11 45 12 10 3 76 39 134 10 4 76 40 7 13 4 11 13 17 14 39 121 13 5 15 15 14 13 33 16 12 19 4 17 39 17 15 18 13 9 10 8 6 2 12 1 19 7 3 73 36 6 13 5 15 20 14 13 33 16 12 19 4 17 39 17 15 18 13 9 10 8 6 2 12 1 21 7 3 73 36 6 13 5 15 22 14 13 33 16 12 19 4 17 39 17 15 18 13 9 10 8 6 2 12 1 23 7 3 73 36 6 13 5 15 24 14 13 33 16 12 19 4 17 39 17 15 18 13 9 10 8 6 2 12 1 25 7 3 73 36 6 10 1 73 39 116 15 26 19 1 27 45 28 15 29 19 1 27 45 30 15 31 19 1 27 45 32 15 33 19 1 27 45 34 15 35 13 3 10 13 6 2 12 10 6 7 2 12 15 36 13 1 13 2 10 12 6 3 12 15 37 13 1 15 35 13 0 15 38 15 39 13 1 1 40 6 3 6 2 6 2 6 1 12 15 37 13 5 13 3 13 4 13 0 20 1 23 12 20 2 23 12 15 41 10 1 6 2 6 3 6 3 6 3 6 3 6 3 73 43 4 43 6 63 29) #722# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 13 12 19 3 14 1 0 73 29) #723=#A(t (15) (assoc compiler-macro #:g21559 #:g21558 c::whole #:g21560 si::dm-too-few-arguments c::value list c::sequence-args c::policy-inline-sequence-functions c::expand-assoc apply #Y(assoc nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 4 19 1 6 10 1 4 12 10 1 5 51 1 22 45 8 10 2 45 9 19 0 10 39 19 33 11 12 10 4 5 12 19 2 12 73 40 4 10 4 73 38 4 10 4 73 29) #723# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 1 0 73 29) #724=#A(t (25) (c::expand-find c::value sequence c::sequence-args find c::seq-opt-parse-args c::end c::start c::test c::test-flag c::key-flag c::init c::test-function c::key-function #718# gensym c::%value #720# c::%elt let c::do-in-seq when return #Y(c::expand-find nil nil (24 45 1 24 45 2 27 45 3 15 4 13 0 19 2 5 47 7 6 47 6 7 47 5 8 47 4 9 47 3 10 47 2 11 47 1 12 45 13 10 1 73 39 71 15 14 19 1 15 45 16 15 17 19 1 15 45 18 15 19 13 1 10 12 6 2 12 10 4 7 2 12 15 20 13 0 10 11 6 2 12 15 21 13 3 13 1 13 2 13 0 20 1 23 12 20 2 23 12 15 22 10 0 6 2 6 3 6 3 6 3 73 43 2 43 8 29) #724# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 13 12 19 3 14 1 0 73 29) #725=#A(t (15) (find compiler-macro #:g21562 #:g21561 c::whole #:g21563 si::dm-too-few-arguments c::value sequence c::sequence-args c::policy-inline-sequence-functions c::expand-find apply #Y(find nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 4 19 1 6 10 1 4 12 10 1 5 51 1 22 45 8 10 2 45 9 19 0 10 39 19 33 11 12 10 4 5 12 19 2 12 73 40 4 10 4 73 38 4 10 4 73 29) #725# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 30 12 19 3 31 1 0 73 29) #726=#A(t (32) (dotimes compiler-macro #:g21565 #:g21564 #:g21566 si::dm-too-few-arguments #:g21567 #:g21568 variable c::limit c::output c::body si::process-declarations c::declarations "%LIMIT" gensym c::%limit block let declare :read-only ext::compiler-typecase fixnum si::while < c::reckless setq 1+ append t #Y(dotimes nil nil (24 45 2 24 45 3 26 10 1 5 45 4 10 0 76 39 6 13 2 19 1 5 10 0 4 12 10 0 5 51 0 22 45 6 10 0 45 7 10 0 76 39 6 13 4 19 1 5 10 0 4 12 10 0 5 51 0 22 45 8 10 1 76 39 6 13 5 19 1 5 10 1 4 12 10 1 5 51 1 22 45 9 10 2 45 10 10 5 45 11 13 0 77 19 2 12 47 1 11 45 13 15 14 19 1 15 45 16 15 17 77 15 18 13 0 10 5 6 2 6 1 12 15 19 14 20 10 0 6 2 6 2 12 15 21 13 0 15 22 15 18 13 6 8 0 6 2 6 1 12 15 19 15 22 10 6 6 2 12 10 1 7 3 12 15 23 15 24 13 6 10 0 6 3 12 13 2 15 25 15 26 13 6 15 27 10 6 6 2 6 3 6 2 6 1 12 19 2 28 7 3 12 10 4 7 5 6 2 12 15 29 15 18 13 6 8 0 6 2 6 1 12 15 19 10 1 7 2 12 15 23 15 24 13 6 10 0 6 3 12 13 2 15 26 13 6 15 27 10 6 6 2 6 3 6 1 12 19 2 28 7 3 12 10 4 7 5 6 2 6 4 6 4 6 3 73 43 1 43 2 29) #726# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (75 73 29) #A(t (0) ()) #1# 0) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 1 0 73 29) #727=#A(t (28) (c::p1propagate c::form c::assumptions null c::c1form-p c::c1form-env c::*cmp-env* c::c1form-name c::name c::*p1-dispatch-table* gethash c::propagator c::c1form-args apply c::new-type :format-control "Non-empty assumptions found in P1PROPAGATE" c::baboon #:g21572 c::c1form-type c::values-type-and #:g21573 c::c1form si::structure-set "Refusing to propagate ~A" c::cmpnote #Y(c::p1propagate nil nil (24 45 1 24 45 2 26 57 0 60 142 10 2 76 39 9 15 3 13 1 72 2 36 0 13 2 19 1 4 39 104 13 2 19 1 5 48 6 13 2 19 1 7 45 8 13 0 14 9 19 2 10 45 11 10 0 39 73 13 0 13 4 13 3 13 4 19 1 12 12 19 4 13 47 1 2 45 14 10 1 39 8 14 15 15 16 19 2 17 10 6 45 18 13 7 19 1 19 12 13 1 19 2 20 45 21 13 1 15 22 9 1 13 0 19 4 23 12 43 1 43 1 13 1 72 2 36 4 43 2 43 2 44 1 15 24 13 2 19 2 25 13 2 19 1 19 12 13 1 72 2 63 29) #727# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #728=#A(t (7) (c::p1trivial c::form c::assumptions rest c::c1form-type #Y(c::p1trivial nil nil (24 45 1 24 45 2 27 45 3 13 2 19 1 4 12 13 1 72 2 29) #728# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #729=#A(t (15) (c::p1var c::form c::assumptions c::var assoc :format-control "Non empty assumptions found in P1VAR" c::baboon c::record c::var-type c::c1form-primary-type c::type-and type #Y(c::p1var nil nil (24 45 1 24 45 2 24 45 3 26 13 0 13 1 19 2 4 39 8 14 5 15 6 19 2 7 45 8 10 0 39 6 10 0 5 38 6 13 1 19 1 9 45 9 13 0 13 4 19 1 10 12 19 2 11 45 12 13 0 13 4 72 2 43 3 29) #729# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #730=#A(t (17) (c::p1values c::form c::assumptions values #:loop-list21578 c::v #:loop-list-head21579 #:loop-list-tail21580 c::all-values 0 c::p1propagate c::new-assumptions type c::values-type-primary-type rplacd #Y(c::p1values nil nil (24 45 1 24 45 2 24 45 3 26 58 60 103 77 13 1 46 4 46 5 75 6 1 45 6 10 0 45 7 75 45 8 57 9 61 2 2 58 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 13 2 13 4 13 8 19 2 10 47 1 11 45 12 10 1 51 10 13 0 19 1 13 43 2 6 1 51 2 17 14 10 3 5 51 1 35 0 0 15 3 10 1 7 2 12 13 8 72 2 36 6 62 73 43 3 43 2 63 29) #730# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #731=#A(t (11) (c::p1propagate-list list c::assumptions t c::final-type #:loop-list21583 c::f 0 c::p1propagate #Y(c::p1propagate-list nil nil (24 45 1 24 45 2 26 58 60 66 11 3 45 4 77 13 3 46 5 46 6 57 7 61 2 2 34 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 5 19 2 8 51 3 55 5 1 35 0 0 13 3 13 5 72 2 36 4 62 73 43 2 43 1 63 29) #731# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #732=#A(t (10) (c::p1merge-branches c::root c::chains null every :format-control "P1MERGE-BRANCHES got a non-empty list of assumptions" c::baboon #Y(c::p1merge-branches nil nil (24 45 1 24 45 2 26 10 1 76 39 9 33 3 12 13 0 19 2 4 76 73 39 8 14 5 15 6 19 2 7 29) #732# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #733=#A(t (9) (c::revise-var-type variable c::assumptions c::where-to-stop :format-control "REVISE-VAR-TYPE got a non-empty list of assumptions" c::baboon #Y(c::revise-var-type nil nil (24 45 1 24 45 2 24 45 3 26 10 1 76 39 4 10 0 76 76 73 39 8 14 4 15 5 19 2 6 29) #733# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #734=#A(t (14) (c::p1block c::c1form c::assumptions c::blk c::body #:g21586 #:g21587 si::structure-set c::p1propagate c::normal-type c::blk-type c::values-type-or #Y(c::p1block nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 10 1 45 5 75 45 6 13 1 15 3 9 8 13 0 19 4 7 43 1 43 1 13 0 13 2 19 2 8 47 1 2 45 9 13 3 19 1 10 45 10 10 0 39 10 13 0 13 1 19 2 11 38 4 10 1 73 12 13 2 72 2 43 1 43 2 29) #734# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #735=#A(t (16) (c::p1return-from c::c1form c::assumptions c::blk c::return-type c::value c::variable-or-nil c::p1propagate c::values-type c::blk-type #:g21590 c::values-type-or #:g21591 si::structure-set #Y(c::p1return-from nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 24 45 6 26 13 1 13 4 19 2 7 45 8 13 4 19 1 9 45 9 10 5 45 10 10 1 39 10 13 1 13 2 19 2 11 38 3 10 2 45 12 13 1 15 3 9 8 13 0 19 4 13 43 1 43 1 13 1 13 6 72 2 43 2 29) #735# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 19 2 14 1 0 73 29) #736=#A(t (15) (c::p1call-global c::c1form c::assumptions c::fname c::args #:loop-list21594 c::v 0 c::p1propagate c::local-ass c::arg-type c::propagate-types type #Y(c::p1call-global nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 58 60 77 77 13 1 46 5 46 6 57 7 61 2 2 40 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 6 19 2 8 47 1 9 45 10 10 1 51 8 43 2 35 0 0 13 5 13 4 19 2 11 45 12 13 0 13 7 72 2 36 4 43 1 62 73 43 2 63 29) #736# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #737=#A(t (14) (c::p1call-local c::c1form c::assumptions c::fun c::args #:loop-list21598 c::v 0 c::p1propagate c::local-ass c::arg-type c::fun-return-type #Y(c::p1call-local nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 58 60 70 77 13 1 46 5 46 6 57 7 61 2 2 40 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 6 19 2 8 47 1 9 45 10 10 1 51 8 43 2 35 0 0 13 5 19 1 11 12 13 6 72 2 36 3 62 73 43 2 63 29) #737# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #738=#A(t (10) (c::p1catch c::c1form c::assumptions c::tag c::body c::p1propagate c::tag-type t #Y(c::p1catch nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 1 13 2 19 2 5 47 1 2 45 6 13 2 13 1 19 2 5 43 2 14 7 13 2 72 2 29) #738# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #739=#A(t (11) (c::p1throw c::c1form c::assumptions c::catch-value c::output-value c::p1propagate c::new-assumptions type t #Y(c::p1throw nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 1 13 2 19 2 5 47 1 6 45 7 13 2 13 1 19 2 5 43 2 14 8 13 2 72 2 29) #739# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #740=#A(t (17) (c::p1if c::c1form c::assumptions c::fmla c::true-branch c::false-branch c::p1propagate c::base-assumptions c::fmla-type c::a1 c::t1 c::a2 c::t2 c::values-type-or c::p1merge-branches #Y(c::p1if nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 13 2 13 3 19 2 6 47 1 7 45 8 13 3 13 1 19 2 6 47 1 9 45 10 13 4 13 3 19 2 6 47 1 11 45 12 13 2 13 0 19 2 13 12 13 5 13 3 10 1 6 2 12 19 2 14 12 72 2 43 2 43 2 43 2 29) #740# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #741=#A(t (9) (c::p1fmla-not c::c1form c::assumptions c::form c::p1propagate type (member t nil) #Y(c::p1fmla-not nil nil (24 45 1 24 45 2 24 45 3 26 13 0 13 1 19 2 4 47 1 2 45 5 15 6 13 1 72 2 43 2 29) #741# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #742=#A(t (23) (c::p1fmla-and c::c1form c::orig-assumptions butlast last t type c::assumptions append #:loop-list21603 c::form #:loop-list-head21604 #:loop-list-tail21605 c::assumptions-list 0 c::p1propagate rplacd null c::values-type-primary-type c::type-or c::p1merge-branches #Y(c::p1fmla-and nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 58 60 126 11 5 45 6 10 4 45 7 77 13 4 10 3 6 1 12 19 2 8 12 46 9 46 10 75 6 1 45 11 10 0 45 12 75 45 13 57 14 61 2 2 49 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 13 2 13 4 13 6 19 2 15 51 7 55 6 1 10 6 6 1 51 2 17 16 10 3 5 51 1 35 0 0 15 17 13 7 19 1 18 12 19 2 19 12 13 11 13 1 19 2 20 12 72 2 36 8 62 73 43 3 43 2 43 1 43 1 63 29) #742# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #743=#A(t (23) (c::p1fmla-or c::c1form c::orig-assumptions butlast last type t c::output-type c::assumptions append #:loop-list21610 c::form #:loop-list-head21611 #:loop-list-tail21612 c::assumptions-list 0 c::p1propagate c::values-type-primary-type c::type-or rplacd c::p1merge-branches #Y(c::p1fmla-or nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 58 60 134 75 45 5 11 6 45 7 10 5 45 8 77 13 5 10 4 6 1 12 19 2 9 12 46 10 46 11 75 6 1 45 12 10 0 45 13 75 45 14 57 15 61 2 2 62 10 5 2 39 4 35 0 1 10 5 4 51 4 10 5 5 51 5 13 2 13 4 13 6 19 2 16 51 8 55 6 1 13 8 19 1 17 12 13 7 19 2 18 51 7 10 6 6 1 51 2 17 19 10 3 5 51 1 35 0 0 13 7 13 12 13 1 19 2 20 12 72 2 36 9 62 73 43 3 43 2 43 1 43 1 43 1 63 29) #743# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #744=#A(t (11) (c::p1lambda c::c1form c::assumptions c::lambda-list c::doc c::body c::not-used c::p1propagate type #Y(c::p1lambda nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 27 45 6 13 1 13 4 19 2 7 45 8 13 0 13 5 72 2 43 1 29) #744# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #745=#A(t (11) (c::p1propagate-function c::fun c::assumptions c::fun-lambda c::p1propagate c::output-type #:g21616 #:g21617 si::structure-set #Y(c::p1propagate-function nil nil (24 45 1 24 45 2 26 13 1 19 1 3 12 13 0 19 2 4 47 1 2 45 5 10 3 45 6 10 1 45 7 13 1 15 1 9 19 13 0 19 4 8 12 43 1 43 1 13 1 72 2 43 2 29) #745# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #746=#A(t (27) (c::p1let* c::c1form c::base-assumptions c::vars c::forms c::body c::assumptions type #:loop-list21625 c::v #:loop-list21626 c::f 0 c::global-var-p c::var-set-nodes c::p1propagate #:g21629 c::values-type-primary-type c::var-type c::type-and #:g21630 c::var si::structure-set #:loop-list21631 c::revise-var-type #Y(c::p1let* nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 10 3 45 6 75 45 7 77 13 4 46 8 46 9 77 13 5 46 10 46 11 57 12 61 2 2 103 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 3 19 1 13 40 6 13 3 19 1 14 76 39 49 13 1 13 6 19 2 15 51 5 55 6 1 10 3 45 16 13 6 19 1 17 12 13 4 19 1 18 12 19 2 19 45 20 13 1 15 21 9 11 13 0 19 4 22 43 1 43 1 35 0 0 62 43 2 43 2 43 1 13 1 13 0 19 2 15 47 1 6 45 7 77 13 5 46 23 46 9 57 12 61 2 2 31 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 4 13 9 19 3 24 35 0 0 62 43 2 13 0 13 1 72 2 43 2 43 1 29) #746# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #747=#A(t (13) (c::p1locals c::c1form c::assumptions c::funs c::body labels #:loop-list21633 c::f 0 c::p1propagate-function c::p1propagate #Y(c::p1locals nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 77 13 2 46 6 46 7 57 8 61 2 2 29 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 6 19 2 9 35 0 0 62 43 2 13 1 13 3 19 2 10 29) #747# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 23 12 19 2 24 1 0 73 29) #748=#A(t (25) (c::p1multiple-value-bind c::c1form c::assumptions c::vars-list c::init-c1form c::body c::p1propagate c::init-form-type #:loop-list21640 c::v length c::values-type-to-n-types #:loop-list21641 type 0 c::global-var-p c::var-set-nodes #:g21644 c::var-type c::type-and #:g21645 c::var si::structure-set #Y(c::p1multiple-value-bind nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 13 1 13 3 19 2 6 47 1 2 45 7 77 13 4 46 8 46 9 77 13 2 10 6 16 10 12 19 2 11 12 46 12 46 13 57 14 61 2 2 87 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 3 19 1 15 40 6 13 3 19 1 16 76 39 33 10 3 45 17 13 4 19 1 18 12 13 2 19 2 19 45 20 13 1 15 21 9 11 13 0 19 4 22 43 1 43 1 35 0 0 62 43 2 43 2 13 2 13 1 19 2 6 43 2 29) #748# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #749=#A(t (9) (c::p1multiple-value-setq c::c1form c::assumptions c::vars-list c::value-c1form c::p1propagate c::init-form-type #Y(c::p1multiple-value-setq nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 0 13 2 19 2 5 47 1 2 45 6 13 0 13 1 72 2 43 2 29) #749# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #750=#A(t (7) (c::p1progn c::c1form c::assumptions c::forms c::p1propagate-list #Y(c::p1progn nil nil (24 45 1 24 45 2 24 45 3 26 13 0 13 1 19 2 4 29) #750# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 17 12 19 2 18 1 0 73 29) #751=#A(t (19) (c::p1compiler-typecase c::c1form c::assumptions variable c::expressions c::var-type t c::output-type #:loop-list21648 c::a-type c::c1form-type 0 #72# c::p1propagate (t otherwise) member subtypep #Y(c::p1compiler-typecase nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 1 19 1 5 45 5 58 60 110 11 6 45 7 77 77 13 3 46 8 46 1 46 9 75 45 10 57 11 61 2 2 70 10 4 2 39 4 35 0 1 10 4 4 45 12 10 0 4 51 3 10 0 5 51 0 10 0 4 51 4 43 1 10 4 5 51 4 13 3 13 10 19 2 13 51 1 13 2 15 14 19 2 15 40 8 13 7 13 2 19 2 16 39 5 10 1 51 5 35 0 0 13 5 13 10 72 2 36 6 62 73 43 1 43 3 43 1 63 43 1 29) #751# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #752=#A(t (12) (c::p1checked-value c::c1form c::assumptions type c::value c::let-form c::p1propagate c::value-type c::alt-type subtypep #Y(c::p1checked-value nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 13 1 13 3 19 2 6 45 7 13 1 13 4 19 2 6 45 8 13 1 13 4 19 2 9 39 6 10 1 73 38 4 10 4 73 43 2 29) #752# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #753=#A(t (10) (c::p1progv c::c1form c::assumptions c::variables values c::body type c::p1propagate #Y(c::p1progv nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 26 75 45 6 13 3 13 4 19 2 7 51 0 55 4 1 13 2 13 4 19 2 7 51 0 55 4 1 13 1 13 4 19 2 7 43 1 29) #753# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #754=#A(t (11) (c::p1setq c::c1form c::assumptions c::var c::p1propagate c::value-type c::var-type c::values-type-primary-type c::type-and #Y(c::p1setq nil nil (24 45 1 24 45 2 24 45 3 24 45 1 26 13 0 13 2 19 2 4 47 1 2 45 5 13 3 19 1 6 12 13 0 19 1 7 12 19 2 8 12 13 1 72 2 43 2 29) #754# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #755=#A(t (13) (c::p1psetq c::c1form c::assumptions c::vars c::c1forms #:loop-list21651 c::form 0 c::p1propagate c::new-type null #Y(c::p1psetq nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 77 13 0 46 5 46 6 57 7 61 2 2 36 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 13 5 19 2 8 47 1 2 45 9 43 2 35 0 0 62 43 2 15 10 13 2 72 2 29) #755# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #756=#A(t (7) (c::p1with-stack c::c1form c::assumptions c::body c::p1propagate #Y(c::p1with-stack nil nil (24 45 1 24 45 2 24 45 3 26 13 0 13 1 19 2 4 29) #756# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #757=#A(t (9) (c::p1stack-push-values c::c1form c::assumptions c::form inline c::p1propagate c::form-type #Y(c::p1stack-push-values nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 1 13 2 19 2 5 47 1 2 45 6 77 13 1 72 2 43 2 29) #757# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 5 8 -1 52 0 1 0 73 29) #A(t (3) (c::*tagbody-depth* si::*make-special boundp)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #758=#A(t (8) (c::p1go c::c1form c::assumptions c::tag-var c::return-type t #Y(c::p1go nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 14 5 13 2 72 2 29) #758# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #759=#A(t (7) (c::filter-only-declarations c::assumptions :format-control "FILTER-ONLY-DECLARATIONS gets a non-empty assumption list" c::baboon #Y(c::filter-only-declarations nil nil (24 45 1 26 10 0 39 8 14 2 15 3 19 2 4 75 73 29) #759# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #760=#A(t (14) (c::p1tagbody c::c1form c::orig-assumptions c::tag-loc c::body c::filter-only-declarations c::assumptions c::p1tagbody-one-pass c::ass-list null c::p1merge-branches append #Y(c::p1tagbody nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 2 19 1 5 45 6 13 4 13 0 13 2 13 1 19 4 7 45 8 15 9 77 13 0 19 2 10 12 13 4 19 2 11 12 72 2 43 2 29) #760# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #761=#A(t (17) (c::p1tagbody-one-pass c::c1form c::assumptions c::tag-loc c::body c::local-ass c::ass-list c::aux #:loop-list21655 c::f 0 c::tag-p ldiff c::diff c::p1propagate #Y(c::p1tagbody-one-pass nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 58 60 129 10 3 45 5 75 45 6 75 45 7 77 13 4 46 8 46 9 57 10 61 2 2 68 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 19 1 11 39 28 13 5 10 9 17 12 45 13 10 0 39 8 13 0 10 5 3 51 5 10 10 51 6 43 1 38 13 13 1 13 5 19 2 14 51 3 55 5 1 35 0 0 13 5 10 9 17 12 45 13 10 0 39 9 13 0 10 5 3 73 38 4 10 5 73 43 1 36 6 62 73 43 2 43 1 43 1 43 1 63 29) #761# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #762=#A(t (9) (c::p1unwind-protect c::c1form c::assumptions c::form c::body c::p1propagate c::output-type #Y(c::p1unwind-protect nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 13 1 13 2 19 2 5 47 1 2 45 6 13 2 13 1 19 2 5 13 0 13 1 72 2 43 2 29) #762# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #763=#A(t (22) (c::type-from-array-elt array c::name string eq character base-string base-char c::expand-deftype (array vector simple-array) member t atom or mapcar and (array vector simple-array) second c::x * #Y(c::type-from-array-elt nil nil (24 45 1 26 75 45 2 13 1 1 3 17 4 39 6 1 5 73 38 163 13 1 1 6 17 4 39 6 1 7 73 38 150 13 1 19 1 8 51 1 12 15 9 19 2 10 39 6 11 11 73 38 130 10 1 16 12 39 10 1 1 51 1 11 11 73 38 115 10 1 4 51 0 12 1 13 17 4 39 18 15 13 33 0 12 10 1 5 12 19 2 14 7 2 73 38 86 10 1 4 51 0 12 1 15 17 4 39 18 15 15 33 0 12 10 1 5 12 19 2 14 7 2 73 38 57 10 1 4 12 15 16 19 2 10 76 39 10 1 1 51 1 11 11 73 38 36 10 1 5 76 39 6 11 11 73 38 25 10 1 16 17 45 18 13 0 1 19 17 4 39 6 11 11 73 38 4 10 0 73 43 1 12 13 1 72 2 29) #763# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 13 12 19 3 14 29) #764=#A(t (15) (si::aset c::*p0-dispatch-table* c::fname c::array-type c::indices-and-object c::type-from-array-elt c::elt-type length 1- :initial-element si::index make-list nconc #Y(nil nil nil (24 45 2 24 45 3 27 45 4 13 1 19 1 5 47 1 3 45 6 13 1 10 2 16 7 16 8 12 14 9 15 10 19 3 11 12 10 0 6 1 12 19 2 12 3 12 13 0 72 2 43 2 29) #764# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 11 12 19 3 12 29) #765=#A(t (13) (aref c::*p0-dispatch-table* c::fname c::array-type c::indices c::type-from-array-elt c::elt-type length :initial-element si::index make-list #Y(nil nil nil (24 45 2 24 45 3 27 45 4 13 1 19 1 5 47 1 3 45 6 13 1 10 2 16 7 12 14 8 15 9 19 3 10 7 2 12 13 0 72 2 43 2 29) #765# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 10 12 19 3 11 29) #766=#A(t (12) (si::row-major-aset c::*p0-dispatch-table* c::fname c::array-type c::index c::obj #:g21674 c::type-from-array-elt c::elt-type si::index #Y(nil nil nil (24 45 2 24 45 3 24 45 4 24 45 5 27 45 6 13 3 19 1 7 47 1 3 45 8 13 1 15 9 10 0 6 3 12 13 0 72 2 43 2 29) #766# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (15 0 14 1 1 9 12 19 3 10 29) #767=#A(t (11) (row-major-aref c::*p0-dispatch-table* c::fname c::array-type c::index #:g21678 c::type-from-array-elt c::elt-type si::index #Y(nil nil nil (24 45 2 24 45 3 24 45 4 27 45 5 13 2 19 1 6 47 1 3 45 7 13 1 1 8 6 2 12 13 0 72 2 43 2 29) #767# #1# 0) si::hash-set)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #768=#A(t (12) (c::maybe-optimize-generic-function c::fname c::args fboundp fdefinition c::gf standard-generic-function typep c::policy-inline-slot-access c::maybe-optimize-slot-accessor #Y(c::maybe-optimize-generic-function nil nil (24 45 1 24 45 2 26 10 1 16 3 73 39 34 10 1 16 4 45 5 13 0 15 6 19 2 7 73 39 16 19 0 8 73 39 10 13 2 13 0 13 1 19 3 9 43 1 29) #768# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #769=#A(t (21) (c::precompute-applicable-methods c::methods c::c-args c::m clos::method-specializers #:loop-list21688 c::specializer #:loop-list21689 c::arg 0 c::c1form-type c::arg-type consp member second subtypep t #Y(c::applicable-method-p nil nil (24 45 3 26 58 60 118 77 13 1 19 1 4 12 46 5 46 6 77 13 4 46 7 46 8 57 9 61 2 2 82 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 13 1 19 1 10 45 11 13 0 10 4 16 12 39 12 15 13 10 4 16 14 6 2 73 38 4 10 4 73 12 19 2 15 43 1 76 39 5 75 73 36 5 35 0 0 11 16 73 36 5 62 73 43 2 43 2 63 29) #769# #1# 0) delete-if-not #Y(c::precompute-applicable-methods nil nil (24 45 1 24 45 2 26 30 1 17 32 0 12 13 2 19 2 18 43 1 29) #769# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 16 12 19 2 17 1 0 73 29) #770=#A(t (18) (c::find-slot-accessors c::gf clos::generic-function-methods #:loop-list21693 method c::readers c::writers clos::standard-reader-method find-class c::reader-class clos::standard-writer-method c::writer-class 0 class-of c::method-class si::subclassp #Y(c::find-slot-accessors nil nil (24 45 1 26 58 60 122 77 13 1 19 1 2 12 46 3 46 4 75 45 5 75 45 6 15 7 19 1 8 45 9 15 10 19 1 8 45 11 57 12 61 2 2 64 10 6 2 39 4 35 0 1 10 6 4 51 5 10 6 5 51 6 10 5 16 13 45 14 13 0 13 3 19 2 15 39 10 13 6 10 5 3 51 5 38 17 13 0 13 2 19 2 15 39 8 13 6 10 4 3 51 4 43 1 35 0 0 13 4 13 3 72 2 36 7 62 73 43 1 43 1 43 1 43 1 43 2 63 29) #770# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #771=#A(t (17) (c::maybe-optimize-slot-accessor c::fname c::gf c::args c::find-slot-accessors c::writers c::readers "When analyzing generic function ~A found both slot reader and writer methods" c::cmpwarn length clos::generic-function-spec-list /= "Too many arguments for generic function ~A" c::try-optimize-slot-reader c::try-optimize-slot-writer #Y(c::maybe-optimize-slot-accessor nil nil (24 45 1 24 45 2 24 45 3 26 13 1 19 1 4 47 1 5 45 6 10 0 39 3 10 1 39 10 15 7 13 4 19 2 8 38 68 10 0 40 3 10 1 76 39 5 75 73 38 55 10 2 16 9 12 13 3 19 1 10 16 9 12 19 2 11 39 12 15 12 13 4 19 2 8 75 73 38 26 10 0 39 10 13 0 13 2 19 2 13 38 13 10 1 73 39 8 13 1 13 2 19 2 14 43 2 29) #771# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 18 12 19 2 19 1 0 73 29) #772=#A(t (20) (c::try-optimize-slot-reader c::readers c::args ffi::object c::c1expr c::c-object c::precompute-applicable-methods length = c::reader clos::standard-reader-method typep clos::accessor-method-slot-definition c::slotd clos::safe-slot-definition-location c::index ext::fixnump clos::safe-instance-ref #Y(c::try-optimize-slot-reader nil nil (24 45 1 24 45 2 26 10 0 4 45 3 13 0 19 1 4 45 5 13 3 10 0 6 1 12 19 2 6 45 1 10 0 16 7 12 9 1 19 2 8 73 39 50 10 0 4 45 9 13 0 15 10 19 2 11 73 39 33 13 0 19 1 12 45 13 13 0 19 1 14 45 15 10 0 16 16 73 39 10 15 17 13 5 10 0 6 3 73 43 2 43 1 43 3 29) #772# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #773=#A(t (22) (c::try-optimize-slot-writer c::orig-writers c::args c::c1expr mapcar c::c-args c::precompute-applicable-methods c::writers length = c::writer clos::standard-writer-method typep clos::accessor-method-slot-definition c::slotd clos::safe-slot-definition-location c::index ext::fixnump si::instance-set second #Y(c::try-optimize-slot-writer nil nil (24 45 1 24 45 2 26 33 3 12 13 0 19 2 4 45 5 13 2 13 0 19 2 6 45 7 10 0 16 8 12 9 1 19 2 9 73 39 56 10 0 4 45 10 13 0 15 11 19 2 12 73 39 39 13 0 19 1 13 45 14 13 0 19 1 15 45 16 10 0 16 17 73 39 16 15 18 10 5 16 19 12 13 0 10 5 4 6 4 73 43 2 43 1 43 2 29) #773# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #774=#A(t (10) (c::get-slot-type c::name c::index si::structure-slot-descriptions si::get-sysprop nth third t #Y(c::get-slot-type nil nil (24 45 1 24 45 2 26 13 0 13 1 1 3 17 4 17 5 16 6 73 40 4 1 7 73 29) #774# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 1 0 73 29) #775=#A(t (28) (c::maybe-optimize-structure-access c::fname c::args si::structure-access si::get-sysprop c::slot-description c::inline-possible c::policy-inline-slot-access-p c::slot-index c::structure-type consp fixnum typep "Unable to inline access to structure slot ~A because index is corrupt: ~A" c::cmpwarn length = "Too many arguments for structure slot accessor ~A" list eq elt vector svref aref the quote #Y(c::maybe-optimize-structure-access nil nil (24 45 1 24 45 2 26 57 0 60 183 13 2 1 3 17 4 45 5 10 0 39 11 13 3 19 1 6 39 4 19 0 7 73 39 155 77 77 46 8 46 9 10 2 16 10 39 20 10 2 4 51 0 10 2 5 51 1 39 8 13 1 15 11 19 2 12 76 39 14 15 13 13 5 13 1 19 3 14 75 73 36 3 10 4 16 15 12 9 1 19 2 16 76 39 12 15 17 13 5 19 2 14 75 73 36 3 10 4 4 51 4 13 0 1 18 17 19 39 12 15 20 13 4 10 1 6 3 73 38 58 13 0 1 21 17 19 39 12 15 22 13 4 10 1 6 3 73 38 39 10 0 16 10 39 19 15 23 15 24 13 0 10 4 6 3 12 10 1 6 3 73 38 15 13 4 15 25 10 0 6 2 12 10 1 6 3 73 43 2 43 1 63 29) #775# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 26 12 19 3 27 1 0 73 29) #776=#A(t (28) (si::structure-ref compiler-macro #:g21699 c::env c::whole #:g21700 si::dm-too-few-arguments ffi::object c::structure-name c::index si::dm-too-many-arguments c::policy-inline-slot-access constantp c::cmp-eval gensym c::aux ffi::c-inline ((:object :fixnum) :object "(#0)->instance.slots[#1]" :one-liner t) c::form c::policy-assume-no-errors ext::compiler-typecase t ((:object :object :fixnum) :object "ecl_structure_ref(#0,#1,#2)" :one-liner t) let declare :read-only #Y(si::structure-ref nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 4 19 1 6 10 1 4 12 10 1 5 51 1 22 45 8 10 2 76 39 6 13 5 19 1 6 10 2 4 12 10 2 5 51 2 22 45 9 10 3 39 6 13 6 19 1 10 13 5 19 1 11 39 17 13 1 13 5 19 2 12 39 8 13 0 13 5 19 2 12 39 114 13 0 13 5 19 2 13 45 9 19 0 14 45 15 15 16 13 0 10 1 6 2 12 1 17 7 3 45 18 13 8 19 1 19 76 39 46 13 4 13 8 19 2 13 45 8 15 20 13 2 13 0 10 1 6 2 12 15 21 15 16 13 2 13 0 10 3 6 3 12 1 22 7 3 6 2 6 4 51 1 43 1 15 23 13 1 10 5 6 2 6 1 12 15 24 14 25 10 1 6 2 6 2 12 10 0 6 4 73 43 3 38 4 10 4 73 29) #776# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 28 12 19 3 29 1 0 73 29) #777=#A(t (30) (si::structure-set compiler-macro #:g21703 c::env c::whole #:g21704 si::dm-too-few-arguments ffi::object c::structure-name c::index c::value si::dm-too-many-arguments c::policy-inline-slot-access constantp c::cmp-eval gensym c::aux ffi::c-inline ((:object :fixnum :object) :object "(#0)->instance.slots[#1]=#2" :one-liner t) c::form c::policy-assume-no-errors ext::compiler-typecase t quote ((:object :object :fixnum :object) :object "ecl_structure_set(#0,#1,#2,#3)" :one-liner t) let declare :read-only #Y(si::structure-set nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 76 39 6 13 4 19 1 6 10 1 4 12 10 1 5 51 1 22 45 8 10 2 76 39 6 13 5 19 1 6 10 2 4 12 10 2 5 51 2 22 45 9 10 3 76 39 6 13 6 19 1 6 10 3 4 12 10 3 5 51 3 22 45 10 10 4 39 6 13 7 19 1 11 13 6 19 1 12 39 17 13 2 13 6 19 2 13 39 8 13 1 13 6 19 2 13 39 123 13 1 13 6 19 2 14 45 9 19 0 15 45 16 15 17 13 0 13 1 10 2 6 3 12 1 18 7 3 45 19 13 9 19 1 20 76 39 53 13 5 13 9 19 2 14 45 8 15 21 13 2 13 0 10 1 6 2 12 15 22 15 17 13 2 15 23 10 0 6 2 12 13 3 10 4 6 4 12 1 24 7 3 6 2 6 4 51 1 43 1 15 25 13 1 10 6 6 2 6 1 12 15 26 14 27 10 1 6 2 6 2 12 10 0 6 4 73 43 3 38 4 10 5 73 29) #777# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #778=#A(t (6) (c::valid-array-index-p c::x ext::array-index typep #Y(c::valid-array-index-p nil nil (24 45 1 26 13 0 15 2 19 2 3 29) #778# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #779=#A(t (8) (c::guess-array-element-type c::element-type c::extract-constant-value c::known-type-p upgraded-array-element-type * #Y(c::guess-array-element-type nil nil (24 45 1 26 13 0 19 1 2 51 0 39 6 13 0 19 1 3 39 8 13 0 19 1 4 38 4 1 5 73 29) #779# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 24 12 19 2 25 1 0 73 29) #780=#A(t (26) (c::guess-array-dimensions-type c::orig-dimensions c::dimensions consp list eq list-length c::l array-rank-limit < 1- :initial-element * make-list :failed c::extract-constant-value c::valid-array-index-p listp c::rank numberp c::valid-array-index every "The first argument to MAKE-ARRAY~%~A~%is not a valid set of dimensions" c::cmpwarn #Y(c::guess-array-dimensions-type nil nil (24 45 1 26 75 45 2 57 0 60 149 10 2 16 3 39 48 10 1 4 12 1 4 17 5 39 38 10 2 16 6 45 7 10 0 39 10 9 -1 13 0 14 8 19 3 9 39 15 10 0 16 10 12 14 11 15 12 19 3 13 36 1 43 1 13 2 14 14 19 2 15 45 2 13 0 1 14 17 5 39 6 1 12 73 38 71 13 0 19 1 16 39 8 10 0 6 1 73 38 57 10 0 16 17 39 34 10 0 16 6 45 18 10 0 16 19 40 20 9 -1 13 0 14 8 19 3 9 40 9 33 20 12 13 1 19 2 21 43 1 39 6 10 0 73 38 11 15 22 13 3 19 2 23 1 12 73 43 1 63 29) #780# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 52 12 19 3 53 1 0 73 29) #781=#A(t (54) (make-array compiler-macro #:g21709 c::env c::form #:g21710 si::dm-too-few-arguments c::dimensions :element-type si::search-keyword #:g21711 si::missing-keyword eq t c::element-type :initial-element #:g21712 c::initial-element c::initial-element-supplied-p :initial-contents #:g21713 c::initial-contents c::initial-contents-supplied-p :adjustable #:g21714 c::adjustable :fill-pointer #:g21715 fill-pointer :displaced-to #:g21716 c::displaced-to :displaced-index-offset #:g21717 c::displaced-index-offset (:displaced-index-offset :displaced-to :fill-pointer :adjustable :initial-contents :initial-element :element-type) si::check-keyword c::guess-array-dimensions-type c::dimensions-type c::guess-array-element-type c::guessed-element-type * quote si::make-pure-array function listp integerp si::make-vector ext::fill-array-with-elt (0 nil) ext::truly-the array #Y(make-array nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 13 1 15 8 19 2 9 45 10 13 0 1 11 17 12 39 5 11 13 38 3 10 0 45 14 13 3 15 15 19 2 9 45 16 13 0 1 11 17 12 39 4 75 38 3 10 0 45 17 13 1 1 11 17 12 76 45 18 13 6 15 19 19 2 9 45 20 13 0 1 11 17 12 39 4 75 38 3 10 0 45 21 13 1 1 11 17 12 76 45 22 13 9 15 23 19 2 9 45 24 13 0 1 11 17 12 39 4 75 38 3 10 0 45 25 13 11 15 26 19 2 9 45 27 13 0 1 11 17 12 39 4 75 38 3 10 0 45 28 13 13 15 29 19 2 9 45 30 13 0 1 11 17 12 39 4 75 38 3 10 0 45 31 13 15 15 32 19 2 9 45 33 13 0 1 11 17 12 39 5 8 0 38 3 10 0 45 34 13 17 15 35 19 2 36 13 16 19 1 37 45 38 13 15 19 1 39 45 40 10 10 76 39 103 13 0 1 41 17 12 76 39 9 15 42 10 0 6 2 51 16 1 43 45 44 10 2 16 45 39 12 10 2 5 76 39 6 10 2 4 16 46 39 10 1 47 51 0 10 2 4 51 19 13 0 13 17 13 19 13 9 13 7 13 5 10 3 6 7 51 21 43 1 10 13 39 13 15 48 13 20 13 14 1 49 7 4 51 20 15 50 15 51 13 0 10 1 6 3 12 10 20 6 3 51 20 43 2 10 18 73 29) #781# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #782=#A(t (23) (c::expand-vector-push c::whole c::env c::extend c::args #783=#:value eq c::policy-open-code-aref/aset let* #784=#:vector second (declare (:read-only #783# #784#) (optimize (safety 0))) (c::optional-type-assertion #784# #784#) let ((#785=#:index (fill-pointer #784#)) (#786=#:dimension (array-total-size #784#))) (declare (fixnum #785# #786#) (:read-only #785# #786#)) cond ((< #785# #786#) (si::fill-pointer-set #784# (ext::truly-the fixnum (+ 1 #785#))) (si::aset #784# #785# #783#) #785#) t vector-push-extend cddr #Y(c::expand-vector-push nil nil (24 45 1 24 45 2 24 45 3 26 10 2 5 45 4 10 0 4 12 1 5 17 6 40 5 19 0 7 76 76 39 67 15 8 15 5 10 0 4 6 2 12 15 9 10 0 16 10 6 2 6 2 12 15 11 15 12 15 13 15 14 15 15 15 16 15 17 15 18 10 1 39 15 15 19 15 5 15 9 10 0 16 20 7 4 38 2 75 6 2 6 3 6 4 6 5 51 3 43 1 10 2 73 29) #782# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 8 12 19 3 9 1 0 73 29) #787=#A(t (10) (vector-push compiler-macro #:g21732 c::env c::whole #:g21733 c::args c::expand-vector-push #Y(vector-push nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 13 2 13 3 77 19 3 7 29) #787# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 9 12 19 3 10 1 0 73 29) #788=#A(t (11) (vector-push-extend compiler-macro #:g21734 c::env c::whole #:g21735 c::args t c::expand-vector-push #Y(vector-push-extend nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 45 6 13 2 13 3 14 7 19 3 8 29) #788# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 11 12 19 3 12 1 0 73 29) #789=#A(t (13) (aref compiler-macro #:g21736 c::env c::form #:g21737 si::dm-too-few-arguments array c::indices c::policy-open-code-aref/aset c::expand-aref #Y(aref nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 45 8 13 4 19 1 9 39 12 13 1 13 0 13 4 19 3 10 38 4 10 3 73 29) #789# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 9 12 19 2 10 1 0 73 29) #790=#A(t (11) (c::expand-aref array c::indices c::env let #791=#:%array (declare (:read-only #791#) (optimize (safety 0))) row-major-aref c::expand-row-major-index #Y(c::expand-aref nil nil (24 45 1 24 45 2 24 45 3 26 15 4 15 5 10 2 6 2 6 1 12 15 6 15 7 15 5 15 5 13 1 13 0 19 3 8 6 3 6 4 73 29) #790# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 17 12 19 3 18 1 0 73 29) #792=#A(t (19) (si::aset compiler-macro #:g21738 c::env c::form #:g21739 si::dm-too-few-arguments array c::indices-and-value "Too few arguments to SI::ASET form~%~4I~A" c::cmpwarn c::policy-open-code-aref/aset butlast c::indices last c::value c::expand-aset #Y(si::aset nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 45 8 10 0 76 39 13 15 9 13 3 19 2 10 10 3 73 38 41 13 4 19 1 11 39 31 13 0 19 1 12 45 13 13 1 19 1 14 4 45 15 13 3 13 1 13 0 13 6 19 4 16 43 2 38 4 10 3 73 29) #792# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #793=#A(t (16) (c::expand-aset array c::indices c::value c::env "%ARRAY" gensym c::%array let* declare :read-only (optimize (safety 0)) si::row-major-aset c::expand-row-major-index #Y(c::expand-aset nil nil (24 45 1 24 45 2 24 45 3 24 45 4 26 15 5 19 1 6 45 7 15 8 13 0 10 4 6 2 6 1 12 15 9 14 10 10 0 6 2 12 1 11 6 3 12 15 12 13 0 13 0 13 3 13 1 19 3 13 12 10 2 6 4 6 4 73 43 1 29) #793# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 1 14 12 19 3 15 1 0 73 29) #794=#A(t (16) (array-row-major-index compiler-macro #:g21740 c::env c::form #:g21741 si::dm-too-few-arguments array c::indices c::policy-open-code-aref/aset let #795=#:%array (declare (:read-only #795#) (optimize (safety 0))) c::expand-row-major-index #Y(array-row-major-index nil nil (24 45 2 24 45 3 26 10 1 45 4 10 2 5 45 5 10 0 76 39 6 13 3 19 1 6 10 0 4 12 10 0 5 51 0 22 45 7 10 1 45 8 13 4 19 1 9 39 28 15 10 15 11 10 1 6 2 6 1 12 15 12 15 11 13 0 13 4 19 3 13 6 4 73 38 4 10 3 73 29) #794# #1# 0) si::put-sysprop)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 19 2 9 1 0 73 29) #796=#A(t (10) (c::expand-zero-dim-index-check c::a c::env c::policy-type-assertions progn c::optional-type-assertion array c::check-expected-rank #Y(c::expand-zero-dim-index-check nil nil (24 45 1 24 45 2 26 13 0 19 1 3 39 28 15 4 15 5 13 1 1 6 6 3 12 15 7 13 1 8 0 6 3 12 8 0 6 4 73 38 4 8 0 73 29) #796# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #797=#A(t (16) (c::expand-vector-index-check c::a c::index c::env progn c::optional-type-assertion vector c::check-vector-in-bounds #Y(c::expansion nil nil (24 45 1 24 45 2 26 15 4 15 5 13 1 1 6 6 3 12 15 7 13 1 10 0 6 3 12 10 0 6 4 73 29) #797# #1# 0) c::policy-type-assertions constantp let #798=#:%array-index (declare (:read-only #798#)) #Y(c::expand-vector-index-check nil nil (24 45 1 24 45 2 24 45 3 26 30 1 8 13 1 19 1 9 39 44 13 2 19 1 10 39 11 13 3 13 2 32 0 18 2 38 25 15 11 15 12 10 2 6 2 6 1 12 15 13 13 3 15 12 32 0 18 2 6 4 73 38 4 10 2 73 43 1 29) #797# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 54 12 19 2 55 1 0 73 29) #799=#A(t (56) (c::expand-row-major-index c::a c::indices c::env c::expand-zero-dim-index-check c::expand-vector-index-check length c::expected-rank c::policy-array-bounds-check c::check c::i #:loop-list21742 c::index #:loop-list-head21743 #:loop-list-tail21744 0 "DIM" gentemp c::array-dimension-fast rplacd 1+ c::dims first mapcar c::dim-names let* ((#800=#:%output-var 0)) append declare type ext::array-index #800# ignorable c::policy-type-assertions c::optional-type-assertion array c::check-expected-rank #:loop-list21745 c::l #:loop-list21746 #:loop-list21747 c::dim-var #:loop-list-head21748 #:loop-list-tail21749 plusp setf ext::truly-the * let #801=#:%ndx-var (declare (ext::array-index #801#)) c::check-index-in-bounds (setf #800# (ext::truly-the ext::array-index (+ #800# #801#))) (#800#) #Y(c::expand-row-major-index nil nil (24 45 1 24 45 2 24 45 3 26 57 0 60 427 10 2 76 39 10 13 3 13 1 19 2 4 36 0 10 2 5 76 39 14 13 3 10 2 4 12 13 1 19 3 5 36 0 10 2 16 6 45 7 13 2 19 1 8 45 9 58 60 92 8 0 45 10 77 13 6 46 11 46 12 75 6 1 45 13 10 0 45 14 57 15 61 2 2 52 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 1 15 16 19 1 17 12 15 18 13 12 10 5 6 3 6 2 6 1 51 1 17 19 10 5 16 20 51 5 35 0 0 10 2 5 73 36 6 62 43 2 43 2 43 1 63 45 21 33 22 12 13 0 19 2 23 45 24 15 25 13 1 15 26 19 2 27 12 15 28 15 29 15 30 15 31 10 0 7 4 12 15 32 10 0 7 2 6 3 12 13 5 19 1 33 73 39 21 15 34 13 7 1 35 6 3 12 15 36 13 7 10 3 6 3 6 2 73 12 58 60 199 8 0 45 10 77 13 8 46 37 46 38 77 13 10 46 39 46 12 77 13 6 46 40 46 41 75 6 1 45 42 10 0 45 43 57 15 61 2 2 140 10 8 2 39 4 35 0 1 10 8 4 51 7 10 8 5 51 8 10 6 2 39 4 35 0 1 10 6 4 51 5 10 6 5 51 6 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 10 9 16 44 39 29 13 1 15 45 15 31 15 46 15 30 15 47 15 31 10 3 6 3 6 3 6 3 6 1 51 1 17 19 13 1 15 48 15 49 10 5 6 2 6 1 12 15 50 10 13 73 39 12 15 51 13 18 15 49 10 3 6 4 73 12 1 52 6 5 6 1 51 1 17 19 10 9 16 20 51 9 35 0 0 10 2 5 73 36 10 62 73 43 2 43 2 43 2 43 2 43 1 63 12 15 53 19 3 27 7 4 73 43 4 63 29) #799# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 14 11 9 3 19 4 12 1 0 73 29) #802=#A(t (13) (c::check-expected-rank #:g21751 #:g21750 #:g21752 si::dm-too-few-arguments c::a c::expected-rank si::dm-too-many-arguments ffi::c-inline ((:object :fixnum) :void "if (ecl_unlikely((#0)->array.rank != (#1)))
            FEwrong_dimensions(#0,#1);" :one-liner nil) #Y(c::check-expected-rank nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 39 6 13 4 19 1 7 15 8 13 1 10 0 6 2 12 1 9 7 3 73 29) #802# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 14 12 9 4 19 4 13 1 0 73 29) #803=#A(t (14) (c::check-index-in-bounds #:g21754 #:g21753 #:g21755 si::dm-too-few-arguments array c::index c::limit si::dm-too-many-arguments ffi::c-inline ((:object :fixnum :fixnum) :void "if (ecl_unlikely((#1)>=(#2)))
           FEwrong_index(ECL_NIL,#0,-1,ecl_make_fixnum(#1),#2);" :one-liner nil) #Y(c::check-index-in-bounds nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 76 39 6 13 4 19 1 4 10 2 4 12 10 2 5 51 2 22 45 7 10 3 39 6 13 5 19 1 8 15 9 13 2 13 1 10 0 6 3 12 1 10 7 3 73 29) #803# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 14 11 9 3 19 4 12 1 0 73 29) #804=#A(t (13) (c::check-vector-in-bounds #:g21757 #:g21756 #:g21758 si::dm-too-few-arguments vector c::index si::dm-too-many-arguments ffi::c-inline ((:object :fixnum) :void "if (ecl_unlikely((#1)>=(#0)->vector.dim))
           FEwrong_index(ECL_NIL,#0,-1,ecl_make_fixnum(#1),(#0)->vector.dim);" :one-liner nil) #Y(c::check-vector-in-bounds nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 39 6 13 4 19 1 7 15 8 13 1 10 0 6 2 12 1 9 7 3 73 29) #804# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+array-dimension-accessor+ ("(#0)->array.dims[0]" "(#0)->array.dims[1]" "(#0)->array.dims[2]" "(#0)->array.dims[3]" "(#0)->array.dims[4]" "(#0)->array.dims[5]" "(#0)->array.dims[6]" "(#0)->array.dims[7]" "(#0)->array.dims[8]" "(#0)->array.dims[9]" "(#0)->array.dims[10]" "(#0)->array.dims[11]" "(#0)->array.dims[12]" "(#0)->array.dims[13]" "(#0)->array.dims[14]" "(#0)->array.dims[15]" "(#0)->array.dims[16]" "(#0)->array.dims[17]" "(#0)->array.dims[18]" "(#0)->array.dims[19]" "(#0)->array.dims[20]" "(#0)->array.dims[21]" "(#0)->array.dims[22]" "(#0)->array.dims[23]" "(#0)->array.dims[24]" "(#0)->array.dims[25]" "(#0)->array.dims[26]" "(#0)->array.dims[27]" "(#0)->array.dims[28]" "(#0)->array.dims[29]" "(#0)->array.dims[30]" "(#0)->array.dims[31]" "(#0)->array.dims[32]" "(#0)->array.dims[33]" "(#0)->array.dims[34]" "(#0)->array.dims[35]" "(#0)->array.dims[36]" "(#0)->array.dims[37]" "(#0)->array.dims[38]" "(#0)->array.dims[39]" "(#0)->array.dims[40]" "(#0)->array.dims[41]" "(#0)->array.dims[42]" "(#0)->array.dims[43]" "(#0)->array.dims[44]" "(#0)->array.dims[45]" "(#0)->array.dims[46]" "(#0)->array.dims[47]" "(#0)->array.dims[48]" "(#0)->array.dims[49]" "(#0)->array.dims[50]" "(#0)->array.dims[51]" "(#0)->array.dims[52]" "(#0)->array.dims[53]" "(#0)->array.dims[54]" "(#0)->array.dims[55]" "(#0)->array.dims[56]" "(#0)->array.dims[57]" "(#0)->array.dims[58]" "(#0)->array.dims[59]" "(#0)->array.dims[60]" "(#0)->array.dims[61]" "(#0)->array.dims[62]" "(#0)->array.dims[63]") si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #805=#A(t (9) (c::array-dimension-accessor array c::n #A(t (64) ((#806=(:object) :fixnum "(#0)->array.dims[0]" . #807=(:one-liner t :side-effects nil)) (#806# :fixnum "(#0)->array.dims[1]" . #807#) (#806# :fixnum "(#0)->array.dims[2]" . #807#) (#806# :fixnum "(#0)->array.dims[3]" . #807#) (#806# :fixnum "(#0)->array.dims[4]" . #807#) (#806# :fixnum "(#0)->array.dims[5]" . #807#) (#806# :fixnum "(#0)->array.dims[6]" . #807#) (#806# :fixnum "(#0)->array.dims[7]" . #807#) (#806# :fixnum "(#0)->array.dims[8]" . #807#) (#806# :fixnum "(#0)->array.dims[9]" . #807#) (#806# :fixnum "(#0)->array.dims[10]" . #807#) (#806# :fixnum "(#0)->array.dims[11]" . #807#) (#806# :fixnum "(#0)->array.dims[12]" . #807#) (#806# :fixnum "(#0)->array.dims[13]" . #807#) (#806# :fixnum "(#0)->array.dims[14]" . #807#) (#806# :fixnum "(#0)->array.dims[15]" . #807#) (#806# :fixnum "(#0)->array.dims[16]" . #807#) (#806# :fixnum "(#0)->array.dims[17]" . #807#) (#806# :fixnum "(#0)->array.dims[18]" . #807#) (#806# :fixnum "(#0)->array.dims[19]" . #807#) (#806# :fixnum "(#0)->array.dims[20]" . #807#) (#806# :fixnum "(#0)->array.dims[21]" . #807#) (#806# :fixnum "(#0)->array.dims[22]" . #807#) (#806# :fixnum "(#0)->array.dims[23]" . #807#) (#806# :fixnum "(#0)->array.dims[24]" . #807#) (#806# :fixnum "(#0)->array.dims[25]" . #807#) (#806# :fixnum "(#0)->array.dims[26]" . #807#) (#806# :fixnum "(#0)->array.dims[27]" . #807#) (#806# :fixnum "(#0)->array.dims[28]" . #807#) (#806# :fixnum "(#0)->array.dims[29]" . #807#) (#806# :fixnum "(#0)->array.dims[30]" . #807#) (#806# :fixnum "(#0)->array.dims[31]" . #807#) (#806# :fixnum "(#0)->array.dims[32]" . #807#) (#806# :fixnum "(#0)->array.dims[33]" . #807#) (#806# :fixnum "(#0)->array.dims[34]" . #807#) (#806# :fixnum "(#0)->array.dims[35]" . #807#) (#806# :fixnum "(#0)->array.dims[36]" . #807#) (#806# :fixnum "(#0)->array.dims[37]" . #807#) (#806# :fixnum "(#0)->array.dims[38]" . #807#) (#806# :fixnum "(#0)->array.dims[39]" . #807#) (#806# :fixnum "(#0)->array.dims[40]" . #807#) (#806# :fixnum "(#0)->array.dims[41]" . #807#) (#806# :fixnum "(#0)->array.dims[42]" . #807#) (#806# :fixnum "(#0)->array.dims[43]" . #807#) (#806# :fixnum "(#0)->array.dims[44]" . #807#) (#806# :fixnum "(#0)->array.dims[45]" . #807#) (#806# :fixnum "(#0)->array.dims[46]" . #807#) (#806# :fixnum "(#0)->array.dims[47]" . #807#) (#806# :fixnum "(#0)->array.dims[48]" . #807#) (#806# :fixnum "(#0)->array.dims[49]" . #807#) (#806# :fixnum "(#0)->array.dims[50]" . #807#) (#806# :fixnum "(#0)->array.dims[51]" . #807#) (#806# :fixnum "(#0)->array.dims[52]" . #807#) (#806# :fixnum "(#0)->array.dims[53]" . #807#) (#806# :fixnum "(#0)->array.dims[54]" . #807#) (#806# :fixnum "(#0)->array.dims[55]" . #807#) (#806# :fixnum "(#0)->array.dims[56]" . #807#) (#806# :fixnum "(#0)->array.dims[57]" . #807#) (#806# :fixnum "(#0)->array.dims[58]" . #807#) (#806# :fixnum "(#0)->array.dims[59]" . #807#) (#806# :fixnum "(#0)->array.dims[60]" . #807#) (#806# :fixnum "(#0)->array.dims[61]" . #807#) (#806# :fixnum "(#0)->array.dims[62]" . #807#) (#806# :fixnum "(#0)->array.dims[63]" . #807#))) c::tails ffi::c-inline aref #Y(c::array-dimension-accessor nil nil (24 45 1 24 45 2 26 1 3 45 4 15 5 10 2 6 1 12 13 0 13 1 19 2 6 7 3 73 43 1 29) #805# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 13 12 14 14 9 3 19 4 15 1 0 73 29) #808=#A(t (16) (c::array-dimension-fast #:g21764 #:g21763 #:g21765 si::dm-too-few-arguments array c::n si::dm-too-many-arguments (integer 0 63) typep c::array-dimension-accessor "In macro ARRAY-DIMENSION-FAST, the index is not a constant integer: ~A" error #Y(c::array-dimension-fast nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 76 39 6 13 3 19 1 4 10 1 4 12 10 1 5 51 1 22 45 6 10 2 39 6 13 4 19 1 7 13 0 15 8 19 2 9 39 10 13 1 13 0 19 2 10 38 8 15 11 13 0 19 2 12 29) #808# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 10 12 19 2 11 1 0 73 29) #809=#A(t (12) (c::safe-system string "Invoking external command:~%  ~A~%" c::cmpnote ext::system c::result zerop "Continues anyway." "(SYSTEM ~S) returned non-zero value ~D" cerror #Y(c::safe-system nil nil (24 45 1 26 15 2 13 0 19 2 3 13 0 19 1 4 45 5 10 0 16 6 76 39 12 15 7 15 8 13 1 13 0 19 4 9 10 0 73 43 1 29) #809# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #810=#A(t (13) (c::save-directory c::forms :name :type :defaults *default-pathname-defaults* make-pathname probe-file directory ext::chdir c::old-directory #Y(c::save-directory nil nil (24 45 1 26 14 2 77 14 3 77 14 4 14 5 19 6 6 16 7 45 8 10 0 39 33 13 0 13 0 19 1 9 12 46 10 49 5 64 7 13 2 20 0 23 65 13 0 19 1 9 66 43 1 44 1 38 6 13 1 20 0 23 43 1 29) #810# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 14 9 9 1 19 4 10 1 0 73 29) #811=#A(t (11) (c::with-current-directory #:g21767 #:g21766 #:g21768 c::forms c::save-directory function lambda #Y(c::with-current-directory nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 45 4 15 5 15 6 15 7 77 10 0 7 3 6 2 6 2 73 29) #811# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 26 12 19 2 27 1 0 73 29) #812=#A(t (28) (c::safe-run-program c::program c::args "Invoking external command:~%  ~A ~{~A ~}" c::cmpnote ext::+process-standard-output+ *standard-output* ext::+process-error-output+ *error-output* :input :output t :error :wait ext::run-program #Y(nil nil nil (26 13 1 13 0 14 9 77 14 10 14 11 14 12 14 11 14 13 14 11 19 10 14 29) #812# #1# 0) c::save-directory mp::process c::result stream "Continues anyway." "Unable to execute:~%(RUN-PROGRAM ~S ~S)" cerror zerop "Continues anyway." "Error code ~D when executing~%(RUN-PROGRAM ~S ~S)" #Y(c::safe-run-program nil nil (24 45 1 24 45 2 26 15 3 13 1 13 0 19 3 4 11 5 48 6 11 7 48 8 34 15 12 19 1 16 44 2 47 2 17 47 1 18 45 19 10 1 76 39 16 15 20 15 21 13 4 13 3 13 1 19 5 22 38 21 10 1 16 23 76 39 14 15 24 15 25 13 1 13 4 13 3 19 5 22 10 1 73 43 3 29) #812# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 37 12 19 2 38 1 0 73 29) #813=#A(t (39) (c::split-program-options string c::options c::current #Y(c::maybe-push nil nil (24 45 2 24 45 3 26 10 0 39 9 13 0 10 1 3 73 38 4 10 1 73 29) #813# #1# 0) :element-type base-char :adjustable t :fill-pointer make-array #Y(c::new-string nil nil (26 9 32 14 5 15 6 14 7 14 8 14 9 9 0 19 7 10 29) #813# #1# 0) c::c c::s vector-push-extend #Y(c::push-char nil nil (24 45 12 24 45 13 26 10 0 76 39 7 32 3 18 0 51 0 13 1 13 0 19 2 14 10 0 73 29) #813# #1# 0) c::output c::option c::status length #:loop-limit21784 c::i c::now 0 >= char #\' eq #\\ #\" (#\\ #\' #\") member (#\  #\Tab #\Return #\Newline) 1+ "In split-program-options, unterminated option list:~%~S" error nreverse #Y(c::split-program-options nil nil (24 45 1 26 31 3 4 11 15 58 60 254 75 45 16 75 45 17 75 45 18 9 0 10 7 16 19 12 46 20 46 21 75 45 12 75 45 22 57 23 61 2 2 182 13 3 13 4 19 2 24 39 4 35 0 1 13 12 10 3 17 25 51 2 10 5 4 51 1 13 1 1 26 17 27 39 28 13 2 1 26 17 27 39 8 10 5 5 51 5 38 11 13 2 13 6 32 9 18 2 51 6 38 113 13 1 1 28 17 27 39 18 13 2 13 6 32 9 18 2 51 6 10 5 5 51 5 38 88 13 1 1 29 17 27 39 28 13 2 1 29 17 27 39 8 10 5 5 51 5 38 11 13 2 13 6 32 9 18 2 51 6 38 53 13 2 15 30 19 2 31 39 10 13 2 10 5 3 51 5 38 35 13 2 15 32 19 2 31 39 16 13 7 13 6 32 11 18 2 51 7 75 51 6 38 11 13 2 13 6 32 9 18 2 51 6 10 3 16 33 51 3 35 0 0 10 5 39 10 15 34 13 12 19 2 35 38 13 13 7 13 6 32 11 18 2 16 36 36 8 62 73 43 1 43 1 43 2 43 1 43 1 43 1 63 43 3 29) #813# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 37 12 19 2 38 1 0 73 29) #814=#A(t (39) (c::run-and-collect c::command c::args c::file stream c::line #:loop-list-head21804 #:loop-list-tail21805 0 read-line rplacd #Y(c::collect-lines nil nil (24 45 4 26 58 60 62 75 45 5 75 6 1 45 6 10 0 45 7 57 8 61 2 2 31 13 5 77 77 19 3 9 51 3 10 3 76 39 4 35 0 1 13 1 10 3 6 1 51 1 17 10 35 0 0 10 2 5 73 36 4 62 73 43 2 43 1 63 29) #814# #1# 0) #:g21806 #:g21807 error si::temp #Y(nil nil nil (24 45 15 26 10 0 51 2 35 1 0 29) #814# #1# 0) si::*handler-clusters* :input :output :stream :error ext::run-program mp::process c::lines probe-file :direction open c::s close :abort t "Unable to find file ~A" warn c::c "~&;;; Unable to execute program ~S~&;;; Condition~&;;; ~A" format #Y(c::run-and-collect nil nil (24 45 1 24 45 2 25 40 2 77 46 3 26 30 1 11 57 12 60 157 75 45 13 57 8 61 1 125 15 14 34 16 3 6 1 12 11 17 3 48 17 13 6 13 5 14 18 77 14 19 14 20 14 21 14 19 19 8 22 47 1 23 45 4 13 0 32 5 18 1 45 24 10 7 76 39 6 10 0 73 38 63 10 7 16 25 39 50 13 7 14 26 14 18 19 3 27 45 28 64 19 13 0 32 7 18 1 69 10 0 39 6 13 0 19 1 29 70 65 10 0 39 10 13 0 14 30 14 31 19 3 29 66 43 1 38 8 15 32 13 7 19 2 33 43 1 43 2 36 2 44 1 10 1 45 34 14 31 15 35 13 7 13 0 19 4 36 43 1 36 2 62 73 43 1 63 43 1 29) #814# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 19 12 19 2 20 1 0 73 29) #815=#A(t (21) (c::split-words string c::output c::word length #:loop-limit21813 c::i c::c 0 >= elt (#\  #\Tab #\Newline) member :element-type base-char :initial-contents nreverse make-array 1+ #Y(c::split-words nil nil (24 45 1 26 58 60 122 75 45 2 75 45 3 9 0 10 3 16 4 12 46 5 46 6 75 45 7 57 8 61 2 2 80 13 2 13 3 19 2 9 39 4 35 0 1 13 7 10 2 17 10 51 1 13 1 15 11 19 2 12 39 35 10 4 39 29 10 4 16 4 12 14 13 15 14 14 15 10 4 16 16 12 19 5 17 12 10 5 3 51 5 75 51 4 38 8 13 1 10 4 3 51 4 10 2 16 18 51 2 35 0 0 10 5 73 36 6 62 73 43 1 43 2 43 1 43 1 63 29) #815# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+known-keywords+ ("sparc*" "x86*" "*-bit" "32*" "64*" "*32" "*64" "elf" "coff" "mach-o" "universal" "gcc" "icc") si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #816=#A(t (17) (c::known-keyword string c::+known-keywords+ c::patterns :directory :name string-upcase make-pathname c::base #:loop-list21819 c::p c::pattern-path #:loop-it-21820 0 pathname-match-p #Y(c::known-keyword nil nil (24 45 1 25 40 3 14 2 46 3 26 58 60 99 14 4 77 14 5 13 2 19 1 6 12 19 4 7 45 8 77 13 2 46 9 46 10 75 45 11 75 45 12 57 13 61 2 2 53 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 14 4 77 14 5 13 3 19 1 6 12 19 4 7 51 2 13 5 10 2 17 14 51 1 39 6 10 1 73 36 6 35 0 0 62 73 43 1 43 1 43 2 43 1 63 29) #816# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 15 12 19 2 16 1 0 73 29) #817=#A(t (17) (c::gather-keywords c::strings c::patterns append c::split-words mapcar reduce c::s string-upcase :keyword find-package intern #Y(nil nil nil (24 45 7 26 13 0 19 1 8 12 11 9 16 10 12 19 2 11 29) #817# #1# 0) c::known-keyword remove-if-not #Y(c::gather-keywords nil nil (24 45 1 24 45 2 26 33 3 12 33 4 12 13 1 19 2 5 12 19 2 6 45 1 34 12 12 33 13 12 13 0 19 2 14 12 19 2 5 43 1 29) #817# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 55 12 19 2 56 1 0 73 29) #818=#A(t (57) (c::compiler-defines c::macros "tmp:foo" ext::mkstemp c::f :type "c" :defaults make-pathname c::fc "i" c::fs :direction :output :if-exists :overwrite :if-does-not-exist :create open c::s c::i #:loop-list21826 rest si::macro 0 #72# "~%#ifdef ~A~%ECLVALUE ~4,'0D ~A~%#endif" format 1+ close :abort t list first mapcar c::*cc* c::*cc-flags* c::split-program-options "-E" namestring "-o" append c::run-and-collect c::lines #:loop-list21827 c::l "ECLVALUE" search eql subseq parse-integer number c::defines elt si::elt-set #Y(c::compiler-defines nil nil (24 45 1 26 1 2 16 3 45 4 14 5 15 6 14 7 13 0 19 4 8 45 9 14 5 15 10 14 7 13 1 19 4 8 45 11 13 1 14 12 14 13 14 14 14 15 14 16 14 17 19 7 18 45 19 64 95 8 0 45 20 77 77 13 5 46 21 46 22 46 23 57 24 61 2 2 57 10 3 2 39 4 35 0 1 10 3 4 45 25 10 0 4 51 2 10 0 5 51 0 10 0 51 3 43 1 10 3 5 51 3 13 5 15 26 13 1 13 4 13 1 19 5 27 10 4 16 28 51 4 35 0 0 62 73 43 3 43 1 69 10 0 39 6 13 0 19 1 29 70 65 10 0 39 10 13 0 14 30 14 31 19 3 29 66 43 1 58 60 155 33 32 12 33 33 12 13 4 19 2 34 12 19 2 34 45 32 14 35 14 36 19 1 37 12 15 38 10 3 16 39 12 15 40 10 2 16 39 6 4 12 19 2 41 12 13 2 19 3 42 45 43 77 13 0 46 44 46 45 57 24 61 2 2 76 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 15 46 13 1 19 2 47 12 8 0 17 48 39 41 13 1 9 9 9 13 19 3 49 12 19 1 50 45 51 13 2 9 14 19 2 49 45 52 13 6 13 1 13 11 10 1 17 53 12 19 3 54 43 2 35 0 0 10 4 73 36 5 62 73 43 2 43 1 43 1 63 43 3 29) #818# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+compiler-macros+ (("__INTEL_COMPILER" :intel-compiler) ("__GNUC__" :gcc-compiler) ("__SUNPRO_CC" :sun-c++-compiler) ("__SUNPRO_C" :sun-c-compiler) ("__xlc__" :ibm-c-compiler) ("__xlC__" :ibm-c++-compiler) ("__MMX__" :mmx) ("__SSE__" :sse) ("__SSE2__" :sse2) ("__ELF__" :elf) ("__i386" :i386) ("__i386__" :i386) ("__amd64" :amd64) ("__x86_64__" :x86-64) ("__X86_64__" :x86-64) ("__LP64__" :lp64) ("_LP64" :lp64) ("__ILP32__" :ilp32) ("_ILP32" :ilp32) ("__powerpc" :powerpc) ("__PPC" :ppc) ("__PPC__" :ppc) ("__PPC64__" :ppc64) ("_PPC64_" :ppc64)) si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 6 12 19 2 7 1 0 73 29) #819=#A(t (8) (c::run-and-collect-keywords c::args c::run-and-collect apply c::+known-keywords+ c::gather-keywords #Y(c::run-and-collect-keywords nil nil (27 45 1 33 2 12 13 0 19 2 3 12 14 4 19 2 5 29) #819# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 24 12 19 2 25 1 0 73 29) #820=#A(t (26) (c::gather-system-features (nil :executable) "sys:ecl_min" c::executable truename namestring c::ecl-binary "file" c::run-and-collect-keywords c::executable-features c::*cc* ("--version") c::compiler-version append rest c::+compiler-macros+ c::compiler-defines mapcar reduce c::compiler-features nconc :test string-equal delete-duplicates #Y(c::gather-system-features nil nil (28 1 22 40 3 15 2 46 3 10 0 16 4 16 5 45 6 15 7 10 0 6 1 12 19 2 8 45 9 14 10 15 11 19 2 8 45 12 33 13 12 33 14 12 14 15 19 1 16 12 19 2 17 12 19 2 18 45 19 13 2 13 1 13 0 19 3 20 12 14 21 33 22 12 19 3 23 43 4 29) #820# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #821=#A(t (7) (c::update-compiler-features c::args c::gather-system-features apply c::*compiler-features* #Y(c::update-compiler-features nil nil (27 45 1 33 2 12 13 0 19 2 3 52 4 73 29) #821# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 75 17 1 29) #A(t (2) ("CL" ext::package-lock)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #822=#A(t (23) (c::safe-mkstemp c::template ext::mkstemp c::base :name string pathname-name pathname-type "" concatenate :type "tmp" :defaults make-pathname c::output probe-file ext::copy-file truename delete-file "Unable to create temporay file~%~
	~AXXXXXX
Make sure you have enough free space in disk, check permissions or set~%~
the environment variable TMPDIR to a different value." error #Y(c::safe-mkstemp nil nil (24 45 1 26 10 0 16 2 45 3 10 0 39 79 14 4 15 5 13 0 19 1 6 12 13 0 19 1 7 73 40 4 1 8 73 12 19 3 9 12 14 10 15 11 14 12 13 0 19 6 13 45 14 10 0 16 15 76 39 7 13 1 10 0 17 16 39 16 10 0 16 17 12 10 1 16 17 6 2 51 1 38 8 10 1 16 18 75 51 1 43 1 10 0 76 39 8 15 19 13 1 19 2 20 10 0 73 43 1 29) #822# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 48 12 19 2 49 1 0 73 29) #823=#A(t (50) (compile-file-pathname c::name (nil :source-offset :source-truename :external-format :load :system-p :data-file :h-file :c-file :print :verbose :type :output-file) t c::output-file c::type-supplied-p type c::verbose print c::c-file c::h-file c::data-file c::system-p load c::external-format c::source-truename c::source-offset format c::extension :object :fasl :shared-library :dll c::+shared-library-format+ :static-library :library :lib c::+static-library-format+ :data "data" :sdata "sdat" :c "c" :h "eclh" c::+object-file-extension+ :program c::+executable-file-format+ :fas "fas" (t nil) member pathname-name merge-pathnames :type :defaults make-pathname #Y(compile-file-pathname nil nil (24 45 1 28 2 22 40 3 14 3 46 4 22 40 3 77 75 45 5 46 6 22 40 2 77 46 7 22 40 2 77 46 8 22 40 2 77 46 9 22 40 2 77 46 10 22 40 2 77 46 11 22 40 2 77 46 12 22 40 2 77 46 13 22 40 2 77 46 14 22 40 2 77 46 15 22 40 2 77 46 16 75 45 17 75 45 18 10 13 76 39 13 10 6 39 5 11 19 38 3 11 20 51 12 10 12 41 21 4 42 22 7 11 23 51 1 38 80 41 24 7 41 25 4 42 26 7 11 27 51 1 38 65 42 28 7 1 29 51 0 38 56 42 30 7 1 31 51 0 38 47 42 32 7 1 33 51 0 38 38 42 34 7 1 35 51 0 38 29 42 19 7 11 36 51 0 38 20 42 37 7 11 38 51 1 38 11 41 20 4 42 39 5 1 40 51 0 13 14 15 41 19 2 42 76 39 6 10 14 73 38 36 10 1 39 21 77 13 1 13 15 19 1 43 12 19 3 17 12 13 15 19 2 44 38 12 14 45 13 0 14 46 13 15 19 4 47 43 2 29) #823# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #824=#A(t (13) (c::cmp-delete-file c::file c::*delete-files* "ECL_PRESERVE_FILES" ext::getenv probe-file c::*debug-compiler* "~%Postponing deletion of ~A" c::cmpprogress c::*files-to-be-deleted* delete-file #Y(c::cmp-delete-file nil nil (24 45 1 26 11 2 76 73 40 41 1 3 16 4 73 40 34 10 0 16 5 76 73 40 26 11 6 39 18 15 7 13 0 19 2 8 13 0 11 9 3 52 9 73 38 5 10 0 16 10 29) #824# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (1 3 12 11 4 3 52 4 73 29) #825=#A(t (5) (delete-file c::*files-to-be-deleted* mapc #Y(nil nil nil (26 33 0 12 14 1 19 2 2 29) #825# #1# 0) si::*exit-hooks*)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 14 8 9 2 19 4 9 1 0 73 29) #826=#A(t (10) (c::fix-for-mingw #:g21861 #:g21860 #:g21862 si::dm-too-few-arguments directory-namestring si::dm-too-many-arguments #Y(c::fix-for-mingw nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 39 6 13 3 19 1 6 10 0 73 29) #826# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 20 12 19 2 21 1 0 73 29) #827=#A(t (22) (c::linker-cc c::o-pathname c::object-files (nil :ld-flags :type) :program type c::*ld-flags* c::split-program-options c::ld-flags c::*ld* "-o" c::brief-namestring string "-L" c::ecl-library-directory concatenate c::*ld-rpath* c::*user-ld-flags* append c::safe-run-program #Y(c::linker-cc nil nil (24 45 1 24 45 2 28 3 22 40 3 14 4 46 5 22 40 7 14 6 19 1 7 12 46 8 14 9 15 10 13 3 19 1 11 12 15 12 15 13 19 0 14 12 19 3 15 12 13 2 11 16 73 39 6 11 16 6 1 73 12 14 17 19 1 7 12 13 0 19 4 18 7 4 12 19 2 19 29) #827# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #828=#A(t (9) (c::linker-ar c::output-name c::o-name c::ld-flags namestring c::brief-namestring c::static-lib-ar #Y(c::linker-ar nil nil (24 45 1 24 45 2 24 45 3 26 10 2 16 4 12 13 1 19 1 5 12 10 0 7 2 12 19 2 6 29) #828# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #829=#A(t (13) (c::static-lib-ar c::lib c::object-files c::brief-namestring probe-file delete-file c::*ar* "cr" mapcar c::safe-run-program c::*ranlib* #Y(c::static-lib-ar nil nil (24 45 1 24 45 2 26 13 1 19 1 3 45 1 10 0 16 4 39 5 10 0 16 5 14 6 15 7 13 0 33 3 12 13 1 19 2 8 7 3 12 19 2 9 14 10 10 0 6 1 12 19 2 9 43 1 29) #829# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+lisp-program-header+ "
#include <ecl/ecl.h>

#ifdef __cplusplus
#define ECL_CPP_TAG \"C\"
#else
#define ECL_CPP_TAG
#endif

~:{	extern ECL_CPP_TAG void ~*~A(cl_object);~%~}

" si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+lisp-program-init+ "
#ifdef __cplusplus
extern \"C\"
#endif
ECL_DLLEXPORT
void ~A(cl_object cblock)
{
        /*
         * This function is first invoked with a pointer to a Cblock
         * structure, so that the function initializes it, and then
         * it is invoked with OBJNULL, to force initialization.
         */
	static cl_object Cblock = OBJNULL;
        if (cblock != OBJNULL) {
		Cblock = cblock;
#ifndef ECL_DYNAMIC_VV
		cblock->cblock.data = NULL;
#endif
		cblock->cblock.data_size = 0;
		return;
	}
	~A
{
	/*
         * At this point Cblock contains the cblock of the parent.
         * Notice how the modules are linked to the parent forming a
         * circular chain. This disables the garbage collection of
         * the library until _ALL_ functions in all modules are unlinked.
         */
	cl_index i = 0;
	cl_object current, next = Cblock;
~:{
	current = ecl_make_codeblock();
	current->cblock.data_text = next->cblock.data_text + i;
	current->cblock.data_text_size = i = ~D;
	current->cblock.next = next;
	next = current;
	ecl_init_module(current, ~A);
~}
	Cblock->cblock.next = current;
}
	~A
}" si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+lisp-program-main+ "
extern int
main(int argc, char **argv)
{
	cl_boot(argc, argv);
	ECL_CATCH_ALL_BEGIN(ecl_process_env()) {
	~A
	ecl_init_module(OBJNULL, ~A);
	~A
	} ECL_CATCH_ALL_END;
	si_exit(0);
}" si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 1 17 2 1 0 73 29) #A(t (3) (c::+lisp-library-main+ "
extern int
~A(int argc, char **argv)
{
	cl_boot(argc, argv);
	ECL_CATCH_ALL_BEGIN(ecl_process_env()) {
	~A
	ecl_init_module(OBJNULL, ~A);
	~A
	} ECL_CATCH_ALL_END;
}" si::*make-constant)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #830=#A(t (14) (c::guess-kind pathname pathname-type (("o" :object) ("o" :object) ("obj" :object) ("c" :c) ("a" :static-library) ("lib" :static-library) ("a" :static-library) ("dylib" :shared-library) ("dylib" :shared-library) ("dll" :shared-library) ("so" :shared-library) ("fas" :fasl)) :test string-equal assoc c::record second "File ~s is of no known file type. Assuming it is an object file." warn :object #Y(c::guess-kind nil nil (24 45 1 26 13 0 19 1 2 12 15 3 14 4 33 5 12 19 4 6 45 7 10 0 39 7 10 0 16 8 38 11 15 9 13 1 19 2 10 11 11 73 43 1 29) #830# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 21 12 19 2 22 1 0 73 29) #831=#A(t (23) (c::guess-ld-flags pathname (nil :kind) c::guess-kind c::kind :object :c c::brief-namestring :fasl :fas :static-library :lib :standalone-static-library :standalone-lib :shared-library :dll :standalone-shared-library :standalone-dll :program "C::BUILDER cannot accept files of kind ~s" error #Y(c::guess-ld-flags nil nil (24 45 1 28 2 22 40 7 13 0 19 1 3 12 46 4 10 0 41 5 4 42 6 8 13 1 19 1 7 38 63 41 8 4 42 9 5 75 73 38 53 41 10 10 41 11 7 41 12 4 42 13 8 13 1 19 1 7 38 34 41 14 10 41 15 7 41 16 4 42 17 8 13 1 19 1 7 38 15 42 18 5 75 73 38 8 15 19 13 0 19 2 20 29) #831# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 33 12 19 2 34 1 0 73 29) #832=#A(t (35) (c::system-ld-flag c::library ext::system c::asdf c::x string find-symbol #Y(c::asdfsym nil nil (24 45 4 26 10 0 16 5 12 13 7 19 2 6 29) #832# #1# 0) c::fun rest apply #Y(c::asdfcall nil nil (24 45 8 27 45 9 13 1 32 7 18 1 12 13 0 19 2 10 29) #832# #1# 0) type :build-op :type make-instance c::build :output-files #Y(c::system-output nil nil (24 45 2 24 45 12 26 14 13 32 7 18 1 12 14 14 13 0 19 3 15 45 16 14 17 13 0 13 2 32 7 18 3 4 73 43 1 29) #832# #1# 0) c::o probe-file namestring #Y(c::existing-system-output nil nil (24 45 2 24 45 12 26 13 1 13 0 32 5 18 2 45 19 10 0 73 39 14 10 0 16 20 51 0 73 39 5 10 0 16 21 43 1 29) #832# #1# 0) :library :shared-library #Y(c::find-archive nil nil (24 45 2 26 13 0 14 23 32 3 18 2 73 40 9 13 0 14 24 32 3 18 2 29) #832# #1# 0) "SYS:" string-downcase compile-file-pathname merge-pathnames translate-logical-pathname #Y(c::fallback nil nil (26 15 26 13 8 19 1 27 12 14 14 14 23 19 3 28 12 19 2 29 12 19 1 30 29) #832# #1# 0) :find-system #Y(c::system-ld-flag nil nil (24 45 1 26 77 77 46 2 46 3 31 6 7 11 18 22 25 31 10 6 39 20 14 32 13 8 77 32 4 18 3 51 7 39 7 13 7 32 1 18 1 73 40 5 32 0 18 0 43 6 43 2 29) #832# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 128 12 19 2 129 1 0 73 29) #833=#A(t (130) (c::builder c::target c::output-name (nil :epilogue-code :prologue-code :main-name :init-name :ld-flags :lisp-files) c::lisp-files c::ld-flags c::init-name c::main-name "" c::prologue-code :program eq (si::top-level t) c::epilogue-code c::*suppress-compiler-messages* *compile-verbose* c::*suppress-compiler-notes* or c::compiler-note c::*suppress-compiler-warnings* c::compiler-warning "" stringp si::+io-syntax-progv-list+ #:%progv-list make-string-output-stream stream "{ const char *lisp_code = " princ write-to-string c::wt-filtered-data ";
cl_object output;
si_select_package(ecl_make_simple_base_string(\"CL-USER\", 7));
output = si_safe_eval(2, ecl_read_from_cstring(lisp_code), ECL_NIL);
}" get-output-stream-string "" "{ const char *lisp_code = " ";
cl_object output;
si_select_package(ecl_make_simple_base_string(\"CL-USER\", 7));
output = si_safe_eval(2, ecl_read_from_cstring(lisp_code), ECL_NIL);
}" #P"TMP:ECLINIT" c::safe-mkstemp c::tmp-names c::tmp-name :type :c compile-file-pathname si::coerce-to-filename c::c-name :object c::o-name c::submodules c::submodules-data c::c-file reverse si::%dolist-var c::item #:g21897 symbol typep c::system-ld-flag pathname string parse-namestring (symbol pathname string) si::etypecase-error c::path c::guess-kind c::kind (:shared-library :dll :static-library :lib :object :c) member "C::BUILDER does not accept a file ~s of kind ~s" error c::guess-init-name c::init-fn c::guess-ld-flags c::flags si::get-cdata array map copy-seq length ext::munmap concatenate (array base-char (*)) apply :direction :output :external-format :default open c::+lisp-program-header+ format symbolp :kind c::compute-init-name c::compute-main-name :fasl #:loop-list21905 c::name c::size #:loop-list-head21906 #:loop-list-tail21907 0 #72# plusp rplacd c::files-with-binary-data "In C:BUILDER, when building file~%~T~A~%~
tried to link together files that contained split binary data.~%~
Unfortunately this is currently not possible. To avoid this~%~
recompile the files setting C::*COMPILE-IN-CONSTANTS* to T.~%~
List of offending files:~{~%~T~S~}" #:g21908 c::+lisp-program-init+ "" "" c::+lisp-program-main+ close c::compiler-cc namestring c::linker-cc :library :static-library :lib "Library initialization function is ~A" c::cmpnote c::+lisp-library-main+ probe-file delete-file c::linker-ar (:program :lib :static-library :library) si::ecase-error c::data-binary-dump c::cmp-delete-file mapc #Y(c::builder nil nil (24 45 1 24 45 2 28 3 22 40 2 77 46 4 22 40 2 77 46 5 22 40 2 77 46 6 22 40 2 77 46 7 22 40 3 15 8 46 9 22 40 14 13 6 11 10 17 11 73 39 4 1 12 73 12 46 13 11 14 40 4 11 15 76 48 14 11 16 39 11 15 17 14 14 1 18 6 3 52 14 11 19 39 11 15 17 14 14 1 20 6 3 52 14 10 0 76 39 7 1 21 51 0 38 61 10 0 16 22 40 55 11 23 45 24 10 0 4 12 10 0 5 67 19 0 25 45 26 15 27 13 0 19 2 28 13 2 19 1 29 12 13 0 19 2 30 15 31 13 0 19 2 28 10 0 16 32 43 1 51 1 73 68 43 1 10 1 76 39 7 1 33 51 1 38 61 10 1 16 22 40 55 11 23 45 24 10 0 4 12 10 0 5 67 19 0 25 45 26 15 34 13 0 19 2 28 13 3 19 1 29 12 13 0 19 2 30 15 35 13 0 19 2 28 10 0 16 32 43 1 51 2 73 68 43 1 15 36 19 1 37 45 38 10 0 4 45 39 13 0 14 40 14 41 19 3 42 16 43 45 44 13 1 14 40 14 45 19 3 42 16 43 45 46 75 45 47 75 45 48 75 45 49 10 12 16 50 45 51 75 45 52 38 174 10 1 4 51 0 10 0 45 53 13 0 15 54 19 2 55 39 8 13 1 19 1 56 38 37 13 0 15 57 19 2 55 39 5 10 1 38 24 13 0 15 58 19 2 55 39 8 13 1 19 1 59 38 8 13 0 15 60 19 2 61 43 1 45 62 13 0 19 1 63 45 64 13 0 15 65 19 2 66 76 39 10 15 67 13 2 13 0 19 3 68 13 1 13 1 19 1 63 12 19 2 69 45 70 13 2 19 1 71 45 72 10 0 39 8 13 0 10 17 3 51 17 10 3 16 73 47 1 74 45 75 10 1 16 76 12 10 9 3 51 9 10 1 16 77 12 13 3 10 5 6 3 12 10 10 3 51 10 10 0 16 78 43 2 43 2 43 2 10 1 5 51 1 10 1 40 -176 43 2 33 79 12 15 80 13 1 19 3 81 51 1 13 4 14 82 14 83 14 84 14 85 19 5 86 51 0 13 0 14 87 13 2 19 3 88 10 13 16 89 40 5 10 13 16 22 39 12 13 13 14 40 13 14 19 3 42 51 13 10 10 76 39 12 13 13 14 90 13 14 19 3 91 51 10 10 9 76 39 12 13 13 14 90 13 14 19 3 92 51 9 13 14 11 93 17 11 76 39 125 58 60 105 77 77 77 13 3 46 94 46 62 46 95 46 96 75 6 1 45 97 10 0 45 98 57 99 61 2 2 65 10 6 2 39 4 35 0 1 10 6 4 45 100 10 0 4 51 4 10 0 5 51 0 10 0 4 51 5 10 0 5 51 0 10 0 4 51 6 43 1 10 6 5 51 6 10 3 16 101 39 11 13 1 10 5 6 1 51 1 17 102 35 0 0 10 2 5 73 36 7 62 43 2 43 4 63 45 103 10 0 39 10 15 104 13 14 13 0 19 3 68 43 1 10 14 45 105 10 0 42 10 58 13 1 14 106 13 11 15 107 13 3 15 108 19 6 88 13 1 14 109 13 9 13 11 13 8 19 5 88 13 1 19 1 110 13 5 13 4 19 2 111 13 14 10 4 16 112 12 10 12 7 2 12 19 2 113 38 87 41 114 7 41 115 4 42 116 71 13 1 14 106 13 11 13 9 13 3 13 8 19 6 88 15 117 13 10 19 2 118 13 1 14 119 13 10 13 9 13 11 13 8 19 6 88 13 1 19 1 110 13 5 13 4 19 2 111 10 14 16 120 39 5 10 14 16 121 13 14 13 4 13 12 19 3 122 38 8 13 0 15 123 19 2 124 43 1 13 13 13 1 19 2 125 15 126 13 6 19 2 127 13 4 19 1 126 13 3 19 1 126 10 13 73 43 7 44 1 29) #833# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #834=#A(t (7) (c::build-fasl c::args c::builder :fasl apply #Y(c::build-fasl nil nil (27 45 1 33 2 12 14 3 13 0 19 3 4 29) #834# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #835=#A(t (7) (c::build-program c::args c::builder :program apply #Y(c::build-program nil nil (27 45 1 33 2 12 14 3 13 0 19 3 4 29) #835# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 5 12 19 2 6 1 0 73 29) #836=#A(t (7) (c::build-static-library c::args c::builder :static-library apply #Y(c::build-static-library nil nil (27 45 1 33 2 12 14 3 13 0 19 3 4 29) #836# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 4 12 19 2 5 1 0 73 29) #837=#A(t (6) (c::build-shared-library c::args "Dynamically loadable libraries not supported in this system." error #Y(c::build-shared-library nil nil (27 45 1 15 2 19 1 3 29) #837# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 183 12 19 2 184 1 0 73 29) #838=#A(t (185) (compile-file c::input-pathname c::args (nil :output-file :external-format :load :system-p :data-file :h-file :c-file :source-offset :source-truename :print :verbose) *compile-verbose* *compile-print* c::source-truename c::source-offset c::c-file c::h-file c::data-file c::system-p load :default c::external-format c::output-file *standard-output* *error-output* c::*compiler-in-use* *package* *print-pretty* *compile-file-pathname* *compile-file-truename* ext::*source-location* c::*suppress-compiler-messages* c::input-file c::init-name c::*suppress-compiler-notes* or c::compiler-note c::*suppress-compiler-warnings* c::compiler-warning t "~%;;;~
~%;;; This system does not support loading dynamically linked libraries.~
~%;;; Therefore, COMPILE-FILE without :SYSTEM-P T is unsupported.~
~%;;;" format merge-pathnames pathname probe-file pathname-type file-error :pathname error ("lsp" "LSP" "lisp" "LISP") si::%dolist-var c::ext :type :defaults make-pathname truename "Cannot load system files." "~&;;;~%;;; Compiling ~a." namestring c::cmpprogress (nil) c::eof c::*load-time-values* compile-file-pathname apply c::true-output-file :output-file :c c::c-pathname :h c::h-pathname :data c::data-pathname c::compiler-conditions nconc c::to-delete c::*compiler-conditions* #:g21940 #:g21941 0 :name abort :function si::temp #Y(nil nil nil (27 45 76 10 0 51 2 35 1 0 29) #838# #1# 0) si::make-restart si::*restart-clusters* c::handle-compiler-note warning c::handle-compiler-warning c::compiler-error c::handle-compiler-error c::compiler-internal-error c::handle-compiler-internal-error serious-condition si::*handler-clusters* mp::+load-compile-lock+ #:lock21944 mp::lock-owner #:owner21945 mp::lock-count #:count21946 ext::*interrupts-enabled* #:outer-interrupts-enabled21948 si::*allow-with-interrupts* #:outer-allow-with-interrupts21947 mp::get-lock c::t1 c::*cmp-env-root* copy-tree :size :test equal make-hash-table c::maybe-install-inline-function si::*defun-inline-hook* c::*open-c-braces* c::*inline-blocks* c::*clines-string-list* c::*compile-time-too* c::*top-level-forms* c::*undefined-vars* c::*global-entries* c::*linking-calls* c::*global-cfuns-array* c::*global-funs* c::*global-vars* c::*local-funs* c::*temporary-objects* c::*permanent-objects* c::*static-constants* c::*make-forms* c::*setf-definitions* c::*load-objects* c::*last-label* c::*next-cfun* c::*next-cmacro* c::*temp* c::*max-temp* c::*cmp-env* c::*callbacks* c::*compiler-phase* *gensym-counter* c::print-compiler-info "./cmpinit.lsp" "./cmpinit.lsp" :verbose c::data-init :external-format open c::*compiler-input* #:g21958 #:g21959 rplaca c::*compile-file-position* ext::read-object-or-ignore c::form #:g21962 + #:g21963 rplacd c::t1expr file-position eq close :abort "~&;;; End of Pass 1." :kind :object :fasl c::compute-init-name :input-designator c::compiler-pass2 c::data-c-dump c::o-pathname c::compiler-cc c::data-binary-dump "~&;;; Finished compiling ~a.~%;;;~%" "The C compiler failed to compile the intermediate file." c::cmperr c::cmp-delete-file mapc #Y(nil nil nil (26 19 0 136 1 137 16 37 39 10 15 138 14 139 14 4 19 3 12 19 0 140 14 21 14 141 13 20 19 3 142 48 143 64 115 10 27 76 39 21 11 23 45 144 11 21 45 145 13 1 10 0 17 146 10 0 43 1 43 1 8 0 48 147 14 143 10 16 17 148 45 149 38 50 10 0 39 31 11 23 45 150 13 28 14 147 19 2 151 45 152 13 1 10 0 17 153 10 0 43 1 43 1 13 0 19 1 154 14 143 19 1 155 52 147 14 143 10 17 17 148 51 0 13 0 10 17 17 156 39 -56 75 73 43 1 44 1 69 11 143 39 6 14 143 19 1 157 70 65 11 143 39 10 14 143 14 158 14 32 19 3 157 66 44 1 15 159 19 1 52 13 15 14 160 10 22 39 6 11 161 73 38 4 11 162 73 12 19 3 163 51 17 13 13 13 12 13 11 13 17 14 164 10 29 16 51 12 19 6 165 13 11 19 1 166 10 22 39 5 10 15 38 10 13 15 14 45 14 161 19 3 56 45 167 13 14 13 0 19 2 168 13 0 19 1 169 43 1 10 15 16 37 51 14 39 13 15 170 10 29 16 51 12 19 2 52 38 6 15 171 19 1 172 33 173 12 13 9 19 2 174 10 21 39 8 10 14 39 4 10 22 76 73 39 10 13 14 14 139 14 4 19 3 12 29) #838# #1# 0) c::do-compilation-unit mp::*current-process* > mp::giveup-lock si::check-pending-interrupts #Y(nil nil nil (26 75 73 29) #838# #1# 0) c::compiler-output-values #Y(compile-file nil nil (24 45 1 27 45 2 28 3 22 40 3 14 4 49 4 22 40 3 14 5 49 5 22 40 2 77 46 6 22 40 3 9 0 46 7 22 40 2 77 46 8 22 40 2 77 46 9 22 40 2 77 46 10 22 40 2 77 46 11 22 40 2 77 46 12 22 40 3 14 13 46 14 22 40 2 77 46 15 11 16 48 16 11 17 48 17 11 18 48 18 11 19 48 19 75 48 20 75 48 21 75 48 22 13 8 8 0 3 48 23 11 24 40 4 11 4 76 48 24 75 45 25 75 45 26 11 27 39 11 15 28 14 24 1 29 6 3 52 24 11 30 39 11 15 28 14 24 1 31 6 3 52 24 10 5 76 39 8 14 32 15 33 19 2 34 13 12 19 1 35 16 36 52 21 11 21 16 37 76 39 83 13 12 19 1 38 39 12 15 39 14 40 13 12 19 3 41 38 65 58 60 62 1 42 45 43 75 45 44 38 34 10 1 4 51 0 14 45 13 0 14 46 13 15 19 4 47 52 21 11 21 16 37 39 5 75 73 36 2 10 1 5 51 1 10 1 40 -36 75 51 0 15 39 14 40 13 15 19 3 41 43 2 63 11 21 16 48 51 1 10 1 52 22 10 5 39 3 10 4 39 6 15 49 19 1 41 15 50 10 12 16 51 12 19 2 52 1 53 45 54 11 18 48 18 75 48 55 33 56 12 13 2 13 12 19 3 57 45 15 75 45 58 33 56 12 13 1 14 59 13 11 14 45 14 60 13 14 19 7 57 45 61 33 56 12 13 2 14 59 13 11 14 45 14 62 13 15 19 7 57 45 63 33 56 12 13 3 14 59 13 11 14 45 14 64 13 16 19 7 57 45 65 75 45 66 10 15 76 73 39 6 10 3 6 1 73 12 10 14 76 73 39 6 10 2 6 1 73 12 10 13 76 73 39 6 10 1 6 1 73 12 19 3 67 45 68 75 48 69 57 70 60 308 75 45 71 57 72 61 1 286 14 73 15 74 14 75 34 77 12 19 4 78 6 1 12 11 79 3 48 79 15 29 33 80 3 12 15 81 33 82 3 12 15 83 33 84 3 12 15 85 33 86 3 12 15 87 33 86 3 6 5 12 11 88 3 48 88 11 89 45 90 10 0 16 91 45 92 10 1 16 93 45 94 11 95 45 96 75 48 95 11 97 45 98 75 48 97 64 140 10 1 48 95 13 4 19 1 99 9 0 14 32 15 100 77 11 101 16 102 12 77 9 0 9 0 9 0 9 0 9 0 14 103 9 128 14 104 33 105 12 19 4 106 12 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 9 0 9 0 15 107 49 108 46 109 49 110 49 111 49 112 49 113 49 114 49 115 49 116 49 117 49 118 49 119 49 120 49 121 49 122 49 123 49 124 49 125 49 126 49 127 49 128 49 129 49 130 49 131 49 132 49 101 49 133 49 134 49 18 49 135 34 175 12 19 1 176 43 1 44 29 44 1 65 14 177 10 4 16 91 17 156 39 20 13 3 11 177 17 156 76 40 11 10 4 16 93 12 13 2 19 2 178 39 5 10 4 16 179 66 43 2 44 2 69 11 95 39 4 19 0 180 70 43 3 44 1 36 2 44 1 34 181 12 13 1 19 2 57 36 2 62 43 1 63 11 69 51 1 44 1 13 5 13 1 19 2 182 43 8 44 2 44 11 29) #838# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 12 12 19 2 13 1 0 73 29) #839=#A(t (14) (c::compiler-output-values c::main-value c::conditions #:loop-list21971 c::i c::warning-p c::failure-p 0 style-warning typep t (or c::compiler-error warning) #Y(c::compiler-output-values nil nil (24 45 1 24 45 2 26 58 60 92 77 13 1 46 3 46 4 75 45 5 75 45 6 57 7 61 2 2 54 10 4 2 39 4 35 0 1 10 4 4 51 3 10 4 5 51 4 13 3 15 8 19 2 9 39 7 11 10 51 2 38 18 13 3 15 11 19 2 9 39 9 11 10 51 2 11 10 51 1 35 0 0 13 7 13 2 13 1 72 3 36 5 62 73 43 1 43 1 43 2 63 29) #839# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #840=#A(t (9) (compile c::name c::supplied-p c::def t "~%;;;~
~%;;; This system does not support loading dynamically linked libraries.~
~%;;; Therefore, COMPILE is unsupported.~
~%;;;" format #Y(compile nil nil (24 45 1 25 40 3 77 75 45 2 46 3 26 14 4 15 5 19 2 6 29) #840# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 135 12 19 2 116 1 0 73 29) #841=#A(t (136) (disassemble c::thing (nil :data-file :h-file) c::h-file c::data-file c::def c::disassembled-form c::*compiler-in-use* *print-pretty* si::valid-function-name-p fdefinition functionp si::bc-disassemble "Cannot disassemble the binary function ~S because I do not have its source code." warn atom simple-type-error :datum :expected-type (or function (satisfies si::valid-function-name-p)) :format-control "DISASSEMBLE cannot accept ~A" :format-arguments error lambda eq defun c::gazonk ext::lambda-block (or function (satisfies si::valid-function-name-p)) "DISASSEMBLE cannot accept ~A" make-broadcast-stream c::null-stream c::*compiler-output1* :direction :output :external-format :default open c::*compiler-output2* c::t3local-fun symbol-function c::compiler-conditions c::*compiler-conditions* #:g21975 #:g21976 0 :name abort :function si::temp #Y(nil nil nil (27 45 50 10 0 51 2 35 1 0 29) #841# #1# 0) si::make-restart si::*restart-clusters* c::compiler-note c::handle-compiler-note warning c::handle-compiler-warning c::compiler-error c::handle-compiler-error c::compiler-internal-error c::handle-compiler-internal-error serious-condition si::*handler-clusters* mp::+load-compile-lock+ #:lock21979 mp::lock-owner #:owner21980 mp::lock-count #:count21981 ext::*interrupts-enabled* #:outer-interrupts-enabled21983 si::*allow-with-interrupts* #:outer-allow-with-interrupts21982 mp::get-lock t c::t1 c::*cmp-env-root* copy-tree :size :test equal make-hash-table c::maybe-install-inline-function si::*defun-inline-hook* c::*open-c-braces* c::*inline-blocks* c::*clines-string-list* c::*compile-time-too* c::*top-level-forms* c::*undefined-vars* c::*global-entries* c::*linking-calls* c::*global-cfuns-array* c::*global-funs* c::*global-vars* c::*local-funs* c::*temporary-objects* c::*permanent-objects* c::*static-constants* c::*make-forms* c::*setf-definitions* c::*load-objects* c::*last-label* c::*next-cfun* c::*next-cmacro* c::*temp* c::*max-temp* c::*cmp-env* c::*callbacks* c::*compiler-phase* *gensym-counter* c::args *standard-output* apply #Y(nil nil nil (27 45 112 11 113 48 33 13 11 13 0 19 2 114 44 1 29) #841# #1# 0) si::fset c::data-init c::t1expr "foo" :kind :fasl c::compute-init-name "" "" c::ctop-write c::data-c-dump close #Y(nil nil nil (26 64 67 15 40 34 115 12 19 2 116 19 0 117 13 13 19 1 118 15 119 14 120 14 121 19 3 122 12 10 16 39 6 10 16 73 38 4 1 123 73 12 10 15 39 6 10 15 73 38 4 1 124 73 12 19 3 125 10 15 73 39 6 13 15 19 1 126 65 15 40 13 10 19 2 116 10 16 39 6 14 39 19 1 127 66 29) #841# #1# 0) c::do-compilation-unit mp::*current-process* > mp::giveup-lock si::check-pending-interrupts #Y(nil nil nil (26 75 73 29) #841# #1# 0) #Y(disassemble nil nil (24 45 1 28 2 22 40 2 77 46 3 22 40 2 77 46 4 75 45 5 75 45 6 11 7 48 7 75 48 8 57 0 60 512 10 5 16 9 39 7 10 5 16 10 51 5 10 5 76 40 127 10 5 16 11 39 21 10 5 16 12 76 39 12 15 13 13 5 19 2 14 75 73 36 0 38 101 10 5 16 15 39 27 15 16 14 17 13 5 14 18 15 19 14 20 15 21 14 22 10 5 6 1 12 19 9 23 38 69 10 5 4 12 1 24 17 25 39 14 15 26 15 27 10 5 5 7 3 51 1 38 46 10 5 4 12 1 28 17 25 39 12 15 26 10 5 5 7 2 51 1 38 25 15 16 14 17 13 5 14 18 15 29 14 20 15 30 14 22 10 5 6 1 12 19 9 23 19 0 31 45 32 10 0 48 33 10 5 39 16 13 5 14 34 14 35 14 36 14 37 19 5 38 38 3 10 0 48 39 1 40 16 41 45 40 75 45 42 75 48 43 57 44 60 308 75 45 45 57 46 61 1 286 14 47 15 48 14 49 34 51 12 19 4 52 6 1 12 11 53 3 48 53 15 54 33 55 3 12 15 56 33 57 3 12 15 58 33 59 3 12 15 60 33 61 3 12 15 62 33 61 3 6 5 12 11 63 3 48 63 11 64 45 65 10 0 16 66 45 67 10 1 16 68 45 69 11 70 45 71 75 48 70 11 72 45 73 75 48 72 64 140 10 1 48 70 13 4 19 1 74 9 0 14 75 15 76 77 11 77 16 78 12 77 9 0 9 0 9 0 9 0 9 0 14 79 9 128 14 80 33 81 12 19 4 82 12 77 77 77 77 77 77 77 77 77 77 77 77 77 77 77 9 0 9 0 15 83 49 84 46 85 49 86 49 87 49 88 49 89 49 90 49 91 49 92 49 93 49 94 49 95 49 96 49 97 49 98 49 99 49 100 49 101 49 102 49 103 49 104 49 105 49 106 49 107 49 108 49 77 49 109 49 110 49 7 49 111 34 128 12 19 1 129 43 1 44 29 44 1 65 14 130 10 4 16 66 17 25 39 20 13 3 11 130 17 25 76 40 11 10 4 16 68 12 13 2 19 2 131 39 5 10 4 16 132 66 43 2 44 2 69 11 70 39 4 19 0 133 70 43 3 44 1 36 2 44 1 34 134 12 13 1 19 2 114 36 2 62 43 1 63 11 43 51 0 44 1 43 3 44 2 75 73 63 44 2 29) #841# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (15 0 1 41 12 19 2 42 1 0 73 29) #842=#A(t (43) (c::compiler-pass2 c::c-pathname c::h-pathname c::data-pathname c::init-name (nil :input-designator) c::input-designator :direction :output :if-does-not-exist :create :if-exists :supersede open c::*compiler-output1* "Compiler: ~A ~A" lisp-implementation-type lisp-implementation-version c::wt-comment-nl get-decoded-time c::year c::month c::day c::hour c::minute second "Date: ~D/~D/~D ~2,'0D:~2,'0D (yyyy/mm/dd)" "Machine: ~A ~A ~A" software-type software-version machine-type "Source: ~A" c::*compiler-output2* "#include " c::*cmpinclude* c::wt-nl1 c::ctop-write terpri close :abort t #Y(c::compiler-pass2 nil nil (24 45 1 24 45 2 24 45 3 24 45 4 28 5 22 40 2 77 46 6 13 4 14 7 14 8 14 9 14 10 14 11 14 12 19 7 13 48 14 64 162 15 15 19 0 16 12 19 0 17 12 19 3 18 19 0 19 47 5 20 47 4 21 47 3 22 47 2 23 47 1 24 45 25 15 26 13 5 13 4 13 3 13 2 13 1 19 6 18 15 27 19 0 28 12 19 0 29 12 19 0 30 12 19 4 18 43 6 15 31 13 0 19 2 18 13 3 14 7 14 8 14 9 14 10 14 11 14 12 19 7 13 48 32 64 39 15 33 14 34 19 2 35 13 1 13 3 13 2 19 3 36 14 14 19 1 37 14 32 19 1 37 69 11 32 39 6 14 32 19 1 38 70 65 11 32 39 10 14 32 14 39 14 40 19 3 38 66 44 1 69 11 14 39 6 14 14 19 1 38 70 65 11 14 39 10 14 14 14 39 14 40 19 3 38 66 44 1 29) #842# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 11 12 19 2 12 1 0 73 29) #843=#A(t (13) (c::ecl-include-directory c::*ecl-include-directory* "ecl/config.h" merge-pathnames probe-file "SYS:ecl;config.h" "SYS:" translate-logical-pathname namestring "Unable to find include directory" error #Y(c::ecl-include-directory nil nil (26 11 1 39 10 15 2 14 1 19 2 3 16 4 39 6 11 1 73 38 27 1 5 16 4 39 13 15 6 19 1 7 16 8 52 1 73 38 9 15 9 19 1 10 12 72 1 29) #843# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 14 12 19 2 15 1 0 73 29) #844=#A(t (16) (c::ecl-library-directory c::*ecl-library-directory* "ecl" :type :static-library compile-file-pathname merge-pathnames probe-file "SYS:BUILD-STAMP" "SYS:" translate-logical-pathname namestring "Unable to find library directory" error #Y(c::ecl-library-directory nil nil (26 11 1 39 18 15 2 14 3 14 4 19 3 5 12 14 1 19 2 6 16 7 39 6 11 1 73 38 27 1 8 16 7 39 13 15 9 19 1 10 16 11 52 1 73 38 9 15 12 19 1 13 12 72 1 29) #844# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 22 12 19 2 23 1 0 73 29) #845=#A(t (24) (c::compiler-cc c::c-pathname c::o-pathname c::*cc* "-I." string "-I" c::ecl-include-directory concatenate c::*cc-flags* c::split-program-options speed c::cmp-env-optimization >= c::*cc-optimize* "-w" "-c" c::brief-namestring "-o" c::*user-cc-flags* append c::safe-run-program #Y(c::compiler-cc nil nil (24 45 1 24 45 2 26 14 3 15 4 15 5 15 6 19 0 7 12 19 3 8 12 14 9 19 1 10 12 15 11 19 1 12 12 9 2 19 2 13 73 39 6 14 14 19 1 10 12 15 15 15 16 13 1 19 1 17 12 15 18 13 0 19 1 17 6 2 12 14 19 19 1 10 12 19 2 20 7 4 12 19 3 20 7 3 12 19 2 21 29) #845# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 7 12 19 2 8 1 0 73 29) #846=#A(t (9) (c::print-compiler-info "~&;;; OPTIMIZE levels: Safety=~d, Space=~d, Speed=~d, Debug=~d~%;;;~%" c::*safety* c::*space* c::*speed* c::*debug* c::cmpprogress #Y(c::print-compiler-info nil nil (26 15 1 14 2 14 3 14 4 14 5 19 5 6 29) #846# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 8 12 14 9 9 2 19 4 10 1 0 73 29) #847=#A(t (11) (with-compilation-unit #:g22003 #:g22002 #:g22004 si::dm-too-few-arguments c::options c::body progn #Y(with-compilation-unit nil nil (24 45 1 24 45 2 26 10 1 5 45 3 10 0 76 39 6 13 2 19 1 4 10 0 4 12 10 0 5 51 0 22 45 5 10 1 45 6 15 7 10 0 7 2 73 29) #847# #1# 0) t si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 11 1 17 2 29) #A(t (3) ("CL" t ext::package-lock)) #1# 0) #Y(si::bytecodes nil nil (14 0 14 1 19 2 2 52 1 73 29) #A(t (3) (:ecl-bytecmp *features* delete)) #1# 0) #Y(si::bytecodes nil nil (33 0 45 0 33 1 45 1 33 2 45 2 33 3 45 3 15 4 34 13 12 19 2 11 1 4 73 43 4 29) #848=#A(t (14) (compile disassemble compile-file compile-file-pathname ext::install-c-compiler :cl find-package ext::package-lock :ecl-bytecmp *features* delete si::fset t #Y(ext::install-c-compiler nil nil (26 11 5 16 6 12 75 17 7 14 8 14 9 19 2 10 52 9 15 1 13 2 19 2 11 15 0 13 3 19 2 11 15 2 33 2 12 19 2 11 15 3 33 3 12 19 2 11 11 5 16 6 12 11 12 17 7 29) #848# #1# 0))) #1# 0) #Y(si::bytecodes nil nil (15 0 19 1 1 29) #A(t (2) (c::cmp provide)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("C" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 25 12 19 2 26 1 0 73 29) #849=#A(t (27) (c::parse-function-proclamation c::name c::arg-types c::return-type c::properties c::proclaimed-arg-types si::get-sysprop "Duplicate proclamation for ~A" warn c::proclaim-function #:loop-list22025 c::p 0 :no-sp-change c::no-sp-change t si::put-sysprop :predicate :pure c::pure c::no-side-effects :no-side-effects :reader "Unknown property ~S in function proclamation for ~S" error #Y(c::parse-function-proclamation nil nil (24 45 1 24 45 2 24 45 3 27 45 4 13 3 1 5 17 6 39 8 15 7 13 3 19 2 8 13 3 13 2 10 1 6 2 12 19 2 9 77 13 0 46 10 46 11 57 12 61 2 2 90 10 2 2 39 4 35 0 1 10 2 4 51 1 10 2 5 51 2 10 1 42 13 12 13 6 15 14 14 15 19 3 16 38 53 41 17 4 42 18 21 13 6 15 19 14 15 19 3 16 13 6 15 20 14 15 19 3 16 38 27 41 21 4 42 22 12 13 6 15 20 14 15 19 3 16 38 10 15 23 13 1 13 6 19 3 24 35 0 0 62 73 43 2 29) #849# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::array-rank-index (deftype c::array-rank-index nil '#850=(integer 0 63)) #850# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::bit-array (deftype c::bit-array nil '#851=(array bit *)) #851# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::association-list (deftype c::association-list nil 'list) list si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::byte-specifier (deftype c::byte-specifier nil '#852=(cons integer-length integer-length)) #852# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::character-code (deftype c::character-code nil '#853=(integer 0 1114111)) #853# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::character-designator (deftype c::character-designator nil '#854=(or character c::string-designator)) #854# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::external-file-format (deftype c::external-file-format nil '#855=(or symbol list)) #855# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::declaration-specifier (deftype c::declaration-specifier nil 'list) list si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::digit-weight (deftype c::digit-weight nil '#856=(integer 0 35)) #856# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::environment (deftype c::environment nil 'list) list si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 14 2 19 3 3 29) #A(t (4) (c::form (deftype c::form nil t) t si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::format-control (deftype c::format-control nil '#857=(or string function)) #857# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::function-designator (deftype c::function-designator nil '#858=(or symbol function)) #858# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::function-name (deftype c::function-name nil '#859=(or list symbol)) #859# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::gen-bool (deftype c::gen-bool nil 't) t si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (integer-length (deftype integer-length nil 'ext::array-index) ext::array-index si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::natural (deftype c::natural nil '#860=(integer 0 *)) #860# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::package-designator (deftype c::package-designator nil '#861=(or c::string-designator package)) #861# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::pathname-designator (deftype c::pathname-designator nil '#862=(or pathname string file-stream)) #862# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (pathname-device (deftype pathname-device nil '#863=(or string (member nil :unspecific))) #863# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (pathname-directory (deftype pathname-directory nil '#864=(or string list (member :wild :unspecific))) #864# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (pathname-host (deftype pathname-host nil '#865=(or string list (member nil :unspecific))) #865# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (pathname-name (deftype pathname-name nil '#866=(or string (member nil :wild :unspecific))) #866# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (pathname-type (deftype pathname-type nil '#867=(or string (member nil :wild :unspecific))) #867# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (pathname-version (deftype pathname-version nil '#868=(or unsigned-byte (member nil :wild :newest :unspecific))) #868# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::proper-list (deftype c::proper-list nil 'list) list si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::property-list (deftype c::property-list nil 'list) list si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::radix (deftype c::radix nil '#869=(integer 2 36)) #869# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::readtable-designator (deftype c::readtable-designator nil '#870=(or null readtable)) #870# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::restart-designator (deftype c::restart-designator nil '#871=(or (and symbol (not null)) restart)) #871# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::sequence-index (deftype c::sequence-index nil '#872=(integer 0 2305843009213693951)) #872# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::stream-designator (deftype c::stream-designator nil '#873=(or stream (member t nil))) #873# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::string-designator (deftype c::string-designator nil '#874=(or symbol string character)) #874# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::tree (deftype c::tree nil 't) t si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::type-specifier (deftype c::type-specifier nil '#875=(or symbol class list)) #875# si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (c::universal-time (deftype c::universal-time nil 'unsigned-byte) unsigned-byte si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 14 2 19 3 3 29) #A(t (4) (c::time-zone (deftype c::time-zone nil t) t si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 19 3 3 29) #A(t (4) (ext::instance (deftype ext::instance nil 'standard-object) standard-object si::do-deftype)) #1# 0) #Y(si::bytecodes nil nil (75 73 29) #A(t (0) ()) #1# 0) #Y(si::bytecodes nil nil (77 15 0 46 1 46 2 57 3 61 2 2 30 10 2 4 51 1 10 2 5 51 2 33 4 12 13 1 19 2 5 10 2 2 39 4 35 0 1 35 0 0 62 73 43 2 29) #A(t (6) (((compile (c::function-name &optional (or list function)) (values (or c::function-name function) c::gen-bool c::gen-bool)) (compiler-macro-function (c::function-name &optional c::environment) function) (constantp (t &optional c::environment) c::gen-bool :no-side-effects) (eval (c::form) (values &rest t)) (macro-function (symbol &optional c::environment) function) (macroexpand (c::form &optional c::environment) (values c::form c::gen-bool)) (macroexpand-1 (c::form &optional c::environment) (values c::form c::gen-bool)) (proclaim (c::declaration-specifier) (values &rest t)) (special-operator-p (symbol) c::gen-bool :pure) (si::specialp (symbol) c::gen-bool :predicate) (si::do-defsetf (symbol (or symbol function)) t) (si::do-define-setf-method (symbol function) t) (coerce (t c::type-specifier) t) (subtypep (c::type-specifier c::type-specifier &optional c::environment) (values c::gen-bool c::gen-bool)) (type-of (t) c::type-specifier) (typep (t c::type-specifier &optional c::environment) c::gen-bool) (si::coerce-to-vector (t c::type-specifier t c::gen-bool) vector :no-side-effects) (si::coerce-to-function (c::function-designator) function :no-side-effects) (apply (c::function-designator &rest t) (values &rest t)) (fdefinition (c::function-name) (or list function (member 'special)) :reader) (fboundp (c::function-name) c::gen-bool :reader) (fmakunbound (c::function-name) c::function-name) (funcall (c::function-designator &rest t) (values &rest t)) (function-lambda-expression (function) (values list c::gen-bool t) :pure) (functionp (t) c::gen-bool :pure) (compiled-function-p (t) c::gen-bool :pure) (not (c::gen-bool) boolean :pure) (eq (t t) c::gen-bool :pure) (eql (t t) c::gen-bool :pure) (equal (t t) c::gen-bool :pure) (equalp (t t) c::gen-bool :pure) (identity (t) t) (complement (function) function) (constantly (t) function) (every (c::function-designator sequence &rest sequence) c::gen-bool) (some (c::function-designator sequence &rest sequence) t) (notevery (c::function-designator sequence &rest sequence) c::gen-bool) (notany (c::function-designator sequence &rest sequence) c::gen-bool) (values-list (list) (values &rest t)) (get-setf-expansion (t &optional c::environment) (values t t t t t)) (si::fset (c::function-name function &optional c::gen-bool t) function) (si::setf-definition (c::function-name c::createp) list) (ext::compiled-function-name (function) (or null c::function-name)) (si::compiled-function-block (function) (or null si::codeblock)) (ext::compiled-function-file (function) (values t t)) (si::ihs-top nil si::index) (si::ihs-fun (si::index) (or null c::function-designator)) (si::ihs-env (si::index) c::environment) (si::frs-top nil si::index) (si::frs-bds (si::index) si::index) (si::frs-tag (si::index) t) (si::frs-ihs (si::index) si::index) (si::bds-top nil si::index) (si::bds-var (si::index) symbol) (si::bds-val (si::index) t) (si::sch-frs-base (si::index si::index) (or null si::index)) (si::ccase-error (t t t) t) (si::ecase-error (t t) t) (si::etypecase-error (t t) t) (si::ctypecase-error (t t t) t) (si::do-check-type (t t t t) t) (si::dm-too-many-arguments (t) t) (si::dm-too-few-arguments (t) t) (ensure-generic-function (c::function-name &rest t) generic-function) (slot-boundp (ext::instance symbol) c::gen-bool) (slot-exists-p (ext::instance symbol) c::gen-bool) (slot-makunbound (ext::instance symbol) ext::instance) (slot-value (ext::instance symbol) t) (make-load-form-saving-slots (t &rest t) (values t t)) (find-class (symbol &optional c::gen-bool c::environment) (or class null)) (class-of (t) class :no-side-effects) (clos::standard-instance-get (ext::instance t) t) (clos::standard-instance-set (t ext::instance t) t) (clos::std-compute-applicable-methods (generic-function list) list) (clos::std-compute-effective-method (generic-function method-combination list) function) (clos::compute-effective-method-function (generic-function method-combination list) function) (clos::update-instance (ext::instance) (values)) (clos::slot-value-set (t ext::instance symbol) t) (copy-structure (t) t) (si::make-structure (t &rest t) structure-object) (si::structure-name (structure-object) symbol :reader) (si::structure-ref (structure-object t fixnum) t :reader) (si::structure-set (structure-object t fixnum t) t) (si::structurep (t) c::gen-bool :predicate) (si::structure-subtype-p (t t) c::gen-bool :predicate) (error (t &rest t) (values)) (cerror (c::format-control t &rest t) (values &rest t)) (invalid-method-error (method c::format-control &rest t) (values)) (method-combination-error (c::format-control &rest t) (values)) (signal (t &rest t) null) (warn (t &rest t) null) (invoke-debugger (condition) (values)) (break (&optional c::format-control &rest t) null) (make-condition (c::type-specifier &rest t) condition) (compute-restarts (&optional (or null condition)) list) (find-restart (c::restart-designator &optional (or null condition)) restart) (invoke-restart (c::restart-designator &rest t) (values &rest t)) (invoke-restart-interactively (c::restart-designator) (values &rest t)) (abort (&optional (or null condition)) (values)) (continue (&optional (or null condition)) null) (muffle-warning (&optional (or null condition)) (values)) (store-value (t &optional (or null condition)) null) (use-value (t &optional (or null condition)) null) (ext::catch-signal (fixnum c::gen-bool &key) null) (si::bind-simple-restarts (t t) list) (si::bind-simple-handlers (t t) list) (symbolp (t) c::gen-bool :pure) (keywordp (t) c::gen-bool :reader) (make-symbol (string) symbol) (copy-symbol (symbol &optional c::gen-bool) symbol) (gensym (&optional (or string c::natural)) symbol) (gentemp (&optional string c::package-designator) symbol) (symbol-function (symbol) (or function list (member 'special)) :reader) (symbol-name (symbol) string :pure) (symbol-package (symbol) (or package null) :reader) (symbol-plist (symbol) list :reader) (symbol-value (symbol) t :reader) (get (symbol t &optional t) t :no-side-effects) (remprop (symbol t) c::gen-bool) (boundp (symbol) c::gen-bool :reader) (makunbound (symbol) symbol) (set (symbol t) t) (si::*make-special (symbol) symbol) (si::*make-constant (symbol t) symbol) (si::put-f (list t t) list) (si::rem-f (list t) (values list boolean)) (si::set-symbol-plist (symbol list) list) (si::putprop (symbol t t) t) (si::put-sysprop (t t t) t) (si::get-sysprop (t t) (values t boolean)) (si::rem-sysprop (t t) boolean) (si::put-properties (symbol &rest t) symbol :no-sp-change) (export (list &optional c::package-designator) t) (find-symbol (string &optional c::package-designator) (values symbol (member :inherited :external :internal nil))) (find-package (c::package-designator) (or package null)) (find-all-symbols (c::string-designator) list) (import (list &optional c::package-designator) t) (list-all-packages nil list) (rename-package (c::package-designator c::package-designator &optional list) package) (shadow (list &optional c::package-designator) t) (shadowing-import (list &optional c::package-designator) t) (delete-package (c::package-designator) c::gen-bool) (make-package (c::string-designator &rest t) package) (unexport (list &optional c::package-designator) t) (unintern (symbol &optional c::package-designator) c::gen-bool) (unuse-package (list &optional c::package-designator) t) (use-package (list &optional c::package-designator) t) (intern (string &optional c::package-designator) (values symbol (member :inherited :external :internal nil))) (package-name (c::package-designator) (or string null) :reader) (package-nicknames (c::package-designator) list :reader) (package-shadowing-symbols (c::package-designator) list :reader) (package-use-list (c::package-designator) list :reader) (package-used-by-list (c::package-designator) list :reader) (packagep (t) c::gen-bool :pure) (si::select-package (c::package-designator) package) (si::package-hash-tables (c::package-designator) (values hash-table hash-table list) :reader) (ext::package-lock (c::package-designator c::gen-bool) package) (= (number &rest number) c::gen-bool :pure) (/= (number &rest number) c::gen-bool :pure) (< (real &rest real) c::gen-bool :pure) (> (real &rest real) c::gen-bool :pure) (<= (real &rest real) c::gen-bool :pure) (>= (real &rest real) c::gen-bool :pure) (max (real &rest real) real :pure) (min (real &rest real) real :pure) (minusp (real) c::gen-bool :pure) (plusp (real) c::gen-bool :pure) (zerop (number) c::gen-bool :pure) (floor (real &optional real) (values integer real) :pure) (ceiling (real &optional real) (values integer real) :pure) (truncate (real &optional real) (values integer real) :pure) (round (real &optional real) (values integer real) :pure) (ffloor (real &optional real) (values float real) :pure) (fceiling (real &optional real) (values float real) :pure) (ftruncate (real &optional real) (values float real) :pure) (fround (real &optional real) (values float real) :pure) (cos (number) number :pure) (sin (number) number :pure) (tan (number) number :pure) (cosh (number) number :pure) (sinh (number) number :pure) (tanh (number) number :pure) (acos (number) number :pure) (asin (number) number :pure) (atan (number &optional real) number :pure) (acosh (number) number :pure) (asinh (number) number :pure) (atanh (number) number :pure) (* (&rest number) number :pure) (+ (&rest number) number :pure) (- (&rest number) number :pure) (/ (number &rest number) number :pure) (1+ (number) number :pure) (1- (number) number :pure) (abs (number) (real 0 *) :pure) (evenp (integer) c::gen-bool :pure) (oddp (integer) c::gen-bool :pure) (exp (number) number :pure) (expt (number number) number :pure) (gcd (&rest integer) unsigned-byte :pure) (lcm (&rest integer) unsigned-byte :pure) (log (number &optional number) number :pure) (mod (real real) real :pure) (rem (real real) real :pure) (signum (number) number :pure) (sqrt (number) number :pure) (isqrt (c::natural) c::natural :pure) (make-random-state (&optional (or random-state (member nil t))) random-state :no-side-effects) (random ((or (integer 0 *) (float 0 *)) &optional random-state) (or (integer 0 *) (float 0 *))) (random-state-p (t) c::gen-bool :pure) (numberp (t) c::gen-bool :pure) (cis (real) complex :pure) (complex (real &optional real) number :pure) (complexp (t) c::gen-bool :pure) (conjugate (number) number :pure) (phase (number) (real -3.1415926535897932385l0 3.1415926535897932385l0) :pure) (realpart (number) real :pure) (imagpart (number) real :pure) (upgraded-complex-part-type (c::type-specifier &optional c::environment) c::type-specifier :no-side-effects) (realp (t) c::gen-bool :pure) (numerator (rational) integer :pure) (denominator (rational) unsigned-byte :pure) (rational (real) rational :pure) (rationalize (real) rational :pure) (rationalp (t) c::gen-bool :pure) (ash (integer integer) integer :pure) (integer-length (integer) integer-length :pure) (integerp (t) c::gen-bool :pure) (parse-integer (string &rest t) (values integer ext::array-index) :no-side-effects) (boole ((integer 0 15) integer integer) integer :pure) (logand (&rest integer) integer :pure) (logandc1 (integer integer) integer :pure) (logandc2 (integer integer) integer :pure) (logeqv (&rest integer) integer :pure) (logior (&rest integer) integer :pure) (lognand (integer integer) integer :pure) (lognor (integer integer) integer :pure) (lognot (integer) integer :pure) (logorc1 (integer integer) integer :pure) (logorc2 (integer integer) integer :pure) (logxor (&rest integer) integer :pure) (logbitp (unsigned-byte integer) c::gen-bool :pure) (logcount (integer) integer-length :pure) (logtest (integer integer) c::gen-bool :pure) (byte (unsigned-byte unsigned-byte) c::byte-specifier :pure) (byte-size (c::byte-specifier) integer-length :pure) (byte-position (c::byte-specifier) integer-length :pure) (deposit-field (integer c::byte-specifier integer) integer :pure) (dpb (integer c::byte-specifier integer) integer :pure) (ldb (c::byte-specifier integer) unsigned-byte :pure) (ldb-test (c::byte-specifier integer) c::gen-bool :pure) (mask-field (c::byte-specifier integer) unsigned-byte :pure) (decode-float (float) (values float integer float) :pure) (scale-float (float integer) float :pure) (float-radix (float) fixnum :pure) (float-sign (float &optional float) float :pure) (float-digits (float) (integer 0 64) :pure) (float-precision (float) (integer 0 64) :pure) (integer-decode-float (float) (values integer integer (member -1 1)) :pure) (float (number &optional float) float :pure) (floatp (t) c::gen-bool :pure) (si::bit-array-op (t t t t) (array bit)) (ext::fixnump (t) c::gen-bool :pure) (c::shift>> (*) nil :pure) (c::shift<< (*) nil :pure) (c::short-float-p (*) nil :pure) (c::single-float-p (*) nil :pure) (c::double-float-p (*) nil :pure) (c::long-float-p (*) nil :pure) (c::ldb1 (fixnum fixnum fixnum) fixnum :no-side-effects) (char= (character &rest character) c::gen-bool :pure) (char/= (character &rest character) c::gen-bool :pure) (char< (character &rest character) c::gen-bool :pure) (char> (character &rest character) c::gen-bool :pure) (char<= (character &rest character) c::gen-bool :pure) (char>= (character &rest character) c::gen-bool :pure) (char-equal (character &rest character) c::gen-bool :pure) (char-not-equal (character &rest character) c::gen-bool :pure) (char-lessp (character &rest character) c::gen-bool :pure) (char-greaterp (character &rest character) c::gen-bool :pure) (char-not-greaterp (character &rest character) c::gen-bool :pure) (char-not-lessp (character &rest character) c::gen-bool :pure) (character (c::character-designator) character) (characterp (t) c::gen-bool :pure) (alpha-char-p (character) c::gen-bool :pure) (alphanumericp (character) c::gen-bool :pure) (digit-char (c::digit-weight &optional c::radix) character :pure) (digit-char-p (character &optional c::radix) (or c::digit-weight null) :pure) (graphic-char-p (character) c::gen-bool :pure) (standard-char-p (character) c::gen-bool :pure) (char-upcase (character) character :pure) (char-downcase (character) character :pure) (upper-case-p (character) c::gen-bool :pure) (lower-case-p (character) c::gen-bool :pure) (both-case-p (character) c::gen-bool :pure) (char-code (character) c::character-code :pure) (char-int (character) c::character-code :pure) (code-char (c::character-code) (or character null) :pure) (char-name (character) (or string null) :pure) (name-char (c::string-designator) (or character null) :pure) (si::base-char-p (t) c::gen-bool :predicate) (cons (t t) cons :no-side-effects) (consp (t) c::gen-bool :pure) (atom (t) c::gen-bool :pure) (rplaca (cons t) cons) (rplacd (cons t) cons) (car (list) t :reader) (cdr (list) t :reader) (caar (list) t :reader) (cadr (list) t :reader) (cdar (list) t :reader) (cddr (list) t :reader) (caaar (list) t :reader) (caadr (list) t :reader) (cadar (list) t :reader) (caddr (list) t :reader) (cdaar (list) t :reader) (cdadr (list) t :reader) (cddar (list) t :reader) (cdddr (list) t :reader) (caaaar (list) t :reader) (caaadr (list) t :reader) (caadar (list) t :reader) (caaddr (list) t :reader) (cadaar (list) t :reader) (cadadr (list) t :reader) (caddar (list) t :reader) (cadddr (list) t :reader) (cdaaar (list) t :reader) (cdaadr (list) t :reader) (cdadar (list) t :reader) (cdaddr (list) t :reader) (cddaar (list) t :reader) (cddadr (list) t :reader) (cdddar (list) t :reader) (cddddr (list) t :reader) (copy-tree (c::tree) c::tree :no-side-effects) (sublis (c::association-list c::tree &key) c::tree) (nsublis (c::association-list c::tree &key) c::tree) (subst (t t c::tree &key) c::tree) (subst-if (t c::function-designator c::tree &key) c::tree) (subst-if-not (t c::function-designator c::tree &key) c::tree) (nsubst (t t c::tree &key) c::tree) (nsubst-if (t c::function-designator c::tree &key) c::tree) (nsubst-if-not (t c::function-designator c::tree &key) c::tree) (tree-equal (c::tree c::tree &key) c::gen-bool :predicate) (copy-list (list) list :no-side-effects) (list (&rest t) list :no-side-effects) (list* (&rest t) t :no-side-effects) (list-length (list) (or null si::index) :no-side-effects) (listp (t) c::gen-bool :pure) (make-list (si::index &key) list :no-side-effects) (first (list) t :reader) (second (list) t :reader) (third (list) t :reader) (fourth (list) t :reader) (fifth (list) t :reader) (sixth (list) t :reader) (seventh (list) t :reader) (eighth (list) t :reader) (ninth (list) t :reader) (tenth (list) t :reader) (nth (unsigned-byte list) t :reader) (endp (list) c::gen-bool :predicate) (null (t) c::gen-bool :predicate) (nconc (&rest t) t) (append (&rest t) t :no-side-effects) (revappend (list t) t :no-side-effects) (nreconc (list t) t) (butlast (list &optional unsigned-byte) list :no-side-effects) (nbutlast (list &optional unsigned-byte) list) (last (list &optional unsigned-byte) t :reader) (ldiff (list t) list :no-side-effects) (tailp (t list) c::gen-bool :reader) (nthcdr (fixnum list) t :reader) (rest (list) t :no-side-effects) (member (t c::proper-list &key) c::proper-list) (member-if (c::function-designator c::proper-list &key) c::proper-list) (member-if-not (c::function-designator c::proper-list &key) c::proper-list) (mapc (c::function-designator c::proper-list &rest c::proper-list) c::proper-list) (mapcar (c::function-designator c::proper-list &rest c::proper-list) c::proper-list) (mapcan (c::function-designator c::proper-list &rest c::proper-list) c::proper-list) (mapl (c::function-designator c::proper-list &rest c::proper-list) c::proper-list) (maplist (c::function-designator c::proper-list &rest c::proper-list) c::proper-list) (mapcon (c::function-designator c::proper-list &rest c::proper-list) c::proper-list) (acons (t t c::association-list) c::association-list :no-side-effects) (assoc (t c::association-list &key) t) (assoc-if (c::function-designator c::association-list &key) t) (assoc-if-not (c::function-designator c::association-list &key) t) (copy-alist (c::association-list) c::association-list :no-side-effects) (pairlis (c::proper-list c::proper-list &optional c::association-list) c::association-list :no-side-effects) (rassoc (t c::association-list &key) t) (rassoc-if (c::function-designator c::association-list &key) t) (rassoc-if-not (c::function-designator c::association-list &key) t) (get-properties (c::property-list c::proper-list) (values t t list) :no-side-effects) (getf (c::property-list t &optional t) t :reader) (intersection (c::proper-list c::proper-list &key) c::proper-list) (nintersection (c::proper-list c::proper-list &key) c::proper-list) (adjoin (t c::proper-list &key) c::proper-list) (set-difference (c::proper-list c::proper-list &key) c::proper-list) (nset-difference (c::proper-list c::proper-list &key) c::proper-list) (set-exclusive-or (c::proper-list c::proper-list &key) c::proper-list) (nset-exclusive-or (c::proper-list c::proper-list &key) c::proper-list) (subsetp (c::proper-list c::proper-list &key) c::gen-bool :predicate) (union (c::proper-list c::proper-list &key) c::proper-list) (nunion (c::proper-list c::proper-list &key) c::proper-list) (si::member1 (t c::proper-list t t t) list) (si::memq (t c::proper-list) list) (si::cons-car (cons) t :reader) (si::cons-cdr (cons) t :reader) (si::proper-list-p (t) c::gen-bool :predicate) (make-array ((or ext::array-index list) &key) array :no-side-effects) (adjust-array (array (or ext::array-index list) &key) array) (adjustable-array-p (array) c::gen-bool :pure) (aref (array &rest ext::array-index) t :reader) (array-dimension (array c::array-rank-index) ext::array-index :reader) (array-dimensions (array) list :reader) (array-element-type (array) c::type-specifier :pure) (array-has-fill-pointer-p (array) c::gen-bool :pure) (array-displacement (array) (values (or array null) ext::array-index) :reader) (array-in-bounds-p (array &rest ext::array-index) c::gen-bool :no-side-effects) (array-rank (array) c::array-rank-index :reader) (array-row-major-index (array &rest ext::array-index) ext::array-index :no-side-effects) (array-total-size (array) ext::array-index :reader) (arrayp (t) c::gen-bool :pure) (fill-pointer (vector) ext::array-index :reader) (row-major-aref (array ext::array-index) t :reader) (upgraded-array-element-type (c::type-specifier &optional c::environment) c::type-specifier :no-side-effects) (simple-vector-p (t) c::gen-bool :pure) (svref (simple-vector ext::array-index) t :reader) (vector (&rest t) vector :no-side-effects) (vector-pop (vector) t) (vector-push (t vector) (or ext::array-index null)) (vector-push-extend (t vector &optional ext::array-index) ext::array-index) (vectorp (t) c::gen-bool :pure) (bit (c::bit-array &rest ext::array-index) bit :reader) (sbit ((simple-array bit) &rest ext::array-index) bit :reader) (bit-and (c::bit-array c::bit-array &optional (or c::bit-array (member t nil))) c::bit-array :no-side-effects) (bit-andc1 (c::bit-array c::bit-array &optional (or c::bit-array (member t nil))) c::bit-array :no-side-effects) (bit-andc2 (c::bit-array c::bit-array &optional (or c::bit-array (member t nil))) c::bit-array :no-side-effects) (bit-eqv (c::bit-array c::bit-array &optional (or c::bit-array (member t nil))) c::bit-array :no-side-effects) (bit-ior (c::bit-array c::bit-array &optional (or c::bit-array (member t nil))) c::bit-array :no-side-effects) (bit-nand (c::bit-array c::bit-array &optional (or c::bit-array (member t nil))) c::bit-array :no-side-effects) (bit-nor (c::bit-array c::bit-array &optional (or c::bit-array (member t nil))) c::bit-array :no-side-effects) (bit-orc1 (c::bit-array c::bit-array &optional (or c::bit-array (member t nil))) c::bit-array :no-side-effects) (bit-orc2 (c::bit-array c::bit-array &optional (or c::bit-array (member t nil))) c::bit-array :no-side-effects) (bit-xor (c::bit-array c::bit-array &optional (or c::bit-array (member t nil))) c::bit-array :no-side-effects) (bit-not (c::bit-array &optional (or c::bit-array (member t nil))) c::bit-array :no-side-effects) (bit-vector-p (t) c::gen-bool :pure) (simple-bit-vector-p (t) t :pure) (si::make-pure-array (t t t t t t) array) (si::make-vector (t t t t t t) vector) (si::aset (array t &rest t) t) (si::row-major-aset (array ext::array-index t) t) (si::svset (simple-vector ext::array-index t) t) (si::fill-pointer-set (vector ext::array-index) ext::array-index) (si::replace-array (array array) array) (simple-string-p (t) c::gen-bool :pure) (char (string ext::array-index) character :reader) (schar (simple-string ext::array-index) character :reader) (string (c::string-designator) string :no-side-effects) (string-upcase (c::string-designator &key) string :no-side-effects) (string-downcase (c::string-designator &key) string :no-side-effects) (string-capitalize (c::string-designator &key) string :no-side-effects) (nstring-upcase (string &key) string) (nstring-downcase (string &key) string) (nstring-capitalize (string &key) string) (string-trim (sequence c::string-designator) string :no-side-effects) (string-left-trim (sequence c::string-designator) string :no-side-effects) (string-right-trim (sequence c::string-designator) string :no-side-effects) (string= (c::string-designator c::string-designator &key) c::gen-bool :no-side-effects) (string/= (c::string-designator c::string-designator &key) (or ext::array-index null) :no-side-effects) (string< (c::string-designator c::string-designator &key) (or ext::array-index null) :no-side-effects) (string> (c::string-designator c::string-designator &key) (or ext::array-index null) :no-side-effects) (string<= (c::string-designator c::string-designator &key) (or ext::array-index null) :no-side-effects) (string>= (c::string-designator c::string-designator &key) (or ext::array-index null) :no-side-effects) (string-equal (c::string-designator c::string-designator &key) c::gen-bool :no-side-effects) (string-not-equal (c::string-designator c::string-designator &key) (or ext::array-index null) :no-side-effects) (string-lessp (c::string-designator c::string-designator &key) (or ext::array-index null) :no-side-effects) (string-greaterp (c::string-designator c::string-designator &key) (or ext::array-index null) :no-side-effects) (string-not-lessp (c::string-designator c::string-designator &key) (or ext::array-index null) :no-side-effects) (string-not-greaterp (c::string-designator c::string-designator &key) (or ext::array-index null) :no-side-effects) (stringp (t) c::gen-bool :predicate) (make-string (ext::array-index &key) string :no-side-effects) (si::base-string-p (t) c::gen-bool :pure) (si::char-set (string ext::array-index character) character) (si::schar-set (string ext::array-index character) character) (si::base-string-concatenate (&rest base-string) base-string) (copy-seq (sequence) sequence :no-side-effects) (elt (sequence c::sequence-index) t :no-side-effects) (fill (sequence t &key) sequence) (make-sequence (c::type-specifier c::sequence-index &key) sequence :no-side-effects) (subseq (sequence c::sequence-index &optional (or c::sequence-index null)) sequence :no-side-effects) (map (c::type-specifier c::function-designator sequence &rest sequence) sequence) (map-into (sequence c::function-designator &rest sequence) sequence) (reduce (c::function-designator sequence &key) t) (count (t sequence &key) c::sequence-index) (count-if (c::function-designator sequence &key) c::sequence-index) (count-if-not (c::function-designator sequence &key) c::sequence-index) (length (sequence) c::sequence-index :no-side-effects) (reverse (sequence) sequence :no-side-effects) (nreverse (sequence) sequence) (sort (sequence c::function-designator &key) sequence) (stable-sort (sequence c::function-designator &key) sequence) (find (t sequence &key) t :no-side-effects) (find-if (c::function-designator sequence &key) t) (find-if-not (c::function-designator sequence &key) t) (position (t sequence &key) (or null c::sequence-index)) (position-if (c::function-designator sequence &key) (or null c::sequence-index)) (position-if-not (c::function-designator sequence &key) (or null c::sequence-index)) (search (sequence sequence &key) (or null c::sequence-index) :no-side-effects) (mismatch (sequence sequence &key) (or null c::sequence-index) :no-side-effects) (replace (sequence sequence &key) sequence) (substitute (t t sequence &key) sequence) (substitute-if (t c::function-designator sequence &key) sequence) (substitute-if-not (t c::function-designator sequence &key) sequence) (nsubstitute (t t sequence &key) sequence) (nsubstitute-if (t c::function-designator sequence &key) sequence) (nsubstitute-if-not (t c::function-designator sequence &key) sequence) (concatenate (c::type-specifier &rest sequence) sequence :no-side-effects) (merge (c::type-specifier sequence sequence c::function-designator &key) sequence) (remove (t sequence &key) sequence) (remove-if (c::function-designator sequence &key) sequence) (remove-if-not (c::function-designator sequence &key) sequence) (delete (t sequence &key) sequence) (delete-if (c::function-designator sequence &key) sequence) (delete-if-not (c::function-designator sequence &key) sequence) (remove-duplicates (sequence &key) sequence) (delete-duplicates (sequence &key) sequence) (si::elt-set (sequence c::sequence-index t) t) (si::make-seq-iterator (sequence &optional c::sequence-index) t :no-side-effects) (si::seq-iterator-ref (sequence t) t :reader) (si::seq-iterator-set (sequence t t) t :no-sp-change) (si::seq-iterator-next (sequence t) t :reader) (si::sequence-start-end (t sequence c::sequence-index (or null c::sequence-index)) (values fixnum fixnum fixnum) :no-side-effects) (si::sequence-count ((or null integer)) fixnum :no-side-effects) (make-hash-table (&key) hash-table :no-side-effects) (hash-table-p (t) c::gen-bool :pure) (hash-table-count (hash-table) ext::array-index :reader) (hash-table-rehash-size (hash-table) (or (integer 1 *) (float (1.0) *)) :pure) (hash-table-rehash-threshold (hash-table) (real 0 1) :pure) (hash-table-size (hash-table) ext::array-index :reader) (hash-table-test (hash-table) c::function-designator :pure) (gethash (t hash-table &optional t) (values t c::gen-bool) :reader) (remhash (t hash-table) c::gen-bool) (maphash (c::function-designator hash-table) null) (clrhash (hash-table) hash-table) (sxhash (t) (integer 0 2305843009213693951) :no-side-effects) (si::hash-set (t hash-table t) t) (pathname (c::pathname-designator) pathname :no-side-effects) (make-pathname (&key) pathname :no-side-effects) (pathnamep (t) c::gen-bool :pure) (pathname-host (c::pathname-designator) pathname-host :no-side-effects) (pathname-device (c::pathname-designator) pathname-device :no-side-effects) (pathname-directory (c::pathname-designator) pathname-directory :no-side-effects) (pathname-name (c::pathname-designator) pathname-name :no-side-effects) (pathname-type (c::pathname-designator) pathname-type :no-side-effects) (pathname-version (c::pathname-designator) pathname-version :no-side-effects) (load-logical-pathname-translations (string) c::gen-bool) (logical-pathname-translations (string) list) (logical-pathname (c::pathname-designator) logical-pathname) (namestring (c::pathname-designator) (or string null) :no-side-effects) (file-namestring (c::pathname-designator) (or string null) :no-side-effects) (directory-namestring (c::pathname-designator) (or string null) :no-side-effects) (host-namestring (c::pathname-designator) (or string null) :no-side-effects) (enough-namestring (c::pathname-designator &optional c::pathname-designator) (or string null) :no-side-effects) (parse-namestring (c::pathname-designator &optional pathname-host c::pathname-designator &key) (values (or pathname null) (or ext::array-index null)) :no-side-effects) (wild-pathname-p (c::pathname-designator &optional (member :host :device :directory :name :type :version nil)) c::gen-bool :no-side-effects) (pathname-match-p (c::pathname-designator c::pathname-designator) c::gen-bool :no-side-effects) (translate-logical-pathname (c::pathname-designator &key) pathname :no-side-effects) (translate-pathname (c::pathname-designator c::pathname-designator c::pathname-designator &key) pathname :no-side-effects) (merge-pathnames (c::pathname-designator &optional c::pathname-designator pathname-version) pathname :no-side-effects) (directory (c::pathname-designator &key) list) (probe-file (c::pathname-designator) (or pathname null)) (ensure-directories-exist (pathname &key) (values pathname c::gen-bool)) (truename (c::pathname-designator) pathname) (file-author (c::pathname-designator) (or string null)) (file-write-date (c::pathname-designator) (or c::universal-time null)) (rename-file (c::pathname-designator c::pathname-designator) (values pathname pathname pathname)) (delete-file (c::pathname-designator) t) (ext::file-kind (c::pathname-designator c::gen-bool) symbol) (ext::chdir (c::pathname-designator &optional c::gen-bool) pathname) (ext::getcwd (&optional c::gen-bool) pathname) (ext::mkstemp (c::pathname-designator) (or null pathname)) (ext::copy-file (c::pathname-designator c::pathname-designator) c::gen-bool) (si::mkdir (c::pathname-designator unsigned-byte) string) (si::rmdir (c::pathname-designator) null) (input-stream-p (stream) c::gen-bool :reader) (output-stream-p (stream) c::gen-bool :reader) (interactive-stream-p (stream) c::gen-bool :reader) (open-stream-p (stream) c::gen-bool :reader) (stream-element-type (stream) c::type-specifier :reader) (streamp (t) c::gen-bool :pure) (read-byte (stream &optional c::gen-bool t) t) (write-byte (integer stream) integer) (peek-char (&optional (or character boolean) c::stream-designator c::gen-bool t c::gen-bool) t) (read-char (&optional c::stream-designator c::gen-bool t c::gen-bool) t) (read-char-no-hang (&optional c::stream-designator c::gen-bool t c::gen-bool) t) (terpri (&optional c::stream-designator) null) (fresh-line (&optional c::stream-designator) c::gen-bool) (unread-char (character &optional c::stream-designator) null) (write-char (character &optional c::stream-designator) character) (read-line (&optional c::stream-designator c::gen-bool t c::gen-bool) (values t c::gen-bool)) (write-string (string &optional c::stream-designator &key) string) (write-line (string &optional c::stream-designator &key) string) (read-sequence (sequence stream &key) c::sequence-index) (write-sequence (sequence stream &key) sequence) (file-length (stream) (or unsigned-byte null)) (file-position (stream &optional c::file-position-designator) t) (file-string-length (stream (or string character)) (or unsigned-byte null)) (open (c::pathname-designator &key) (or file-stream null)) (stream-external-format (stream) c::external-file-format :reader) (close (stream &key) t) (listen (&optional c::stream-designator) c::gen-bool) (clear-input (&optional c::stream-designator) null) (finish-output (&optional c::stream-designator) null) (force-output (&optional c::stream-designator) null) (clear-output (&optional c::stream-designator) null) (y-or-n-p (&optional c::format-control &rest t) c::gen-bool) (yes-or-no-p (&optional c::format-control &rest t) c::gen-bool) (make-synonym-stream (symbol) synonym-stream) (synonym-stream-symbol (synonym-stream) symbol) (broadcast-stream-streams (broadcast-stream) list :pure) (make-broadcast-stream (&rest stream) broadcast-stream) (make-two-way-stream (stream stream) two-way-stream) (two-way-stream-input-stream (two-way-stream) stream :pure) (two-way-stream-output-stream (two-way-stream) stream :pure) (echo-stream-output-stream (echo-stream) stream :pure) (echo-stream-input-stream (echo-stream) stream :pure) (make-echo-stream (stream stream) echo-stream) (concatenated-stream-streams (concatenated-stream) list :reader) (make-concatenated-stream (&rest stream) concatenated-stream) (get-output-stream-string (string-stream) string :reader) (make-string-input-stream (string &optional ext::array-index (or ext::array-index null)) string-stream :reader) (make-string-output-stream (&key) string-stream :reader) (si::make-string-output-stream-from-string (string) string-stream :reader) (si::open-client-stream (t unsigned-byte) stream) (si::open-server-stream (unsigned-byte) stream) (si::open-unix-socket-stream (base-string) stream) (si::lookup-host-entry (t) (values (or null string) list list)) (si::copy-stream (stream stream) t) (copy-pprint-dispatch (&optional (or si::pprint-dispatch-table null)) si::pprint-dispatch-table :no-side-effects) (pprint-dispatch (t &optional (or si::pprint-dispatch-table null)) (values c::function-designator c::gen-bool)) (pprint-fill (c::stream-designator t &optional c::gen-bool c::gen-bool) null) (pprint-linear (c::stream-designator t &optional c::gen-bool c::gen-bool) null) (pprint-tabular (c::stream-designator t &optional c::gen-bool c::gen-bool unsigned-byte) null) (pprint-indent ((member :block :current) real &optional c::stream-designator) null) (pprint-newline ((member :linear :fill :miser :mandatory) &optional c::stream-designator) null) (pprint-tab ((member :line :section :line-relative :section-relative) unsigned-byte unsigned-byte &optional c::stream-designator) null) (set-pprint-dispatch (c::type-specifier (or c::function-designator null) &optional real si::pprint-dispatch-table) null) (write (t &key) t) (prin1 (t &optional c::stream-designator) t) (princ (t &optional c::stream-designator) t) (print (t &optional c::stream-designator) t) (pprint (t &optional c::stream-designator) (values)) (write-to-string (t &key) string) (prin1-to-string (t) string) (princ-to-string (t) string) (format ((or c::stream-designator string) c::format-control &rest t) (or null string)) (copy-readtable (&optional c::readtable-designator (or readtable null)) readtable :no-side-effects) (make-dispatch-macro-character (character &optional c::gen-bool readtable) (member t)) (read (&optional c::stream-designator c::gen-bool t c::gen-bool) t) (read-preserving-whitespace (&optional c::stream-designator c::gen-bool t c::gen-bool) t) (read-delimited-list (character &optional c::stream-designator c::gen-bool) list) (read-from-string (string &optional c::gen-bool t &key) (values t ext::array-index)) (readtable-case (readtable) (member :upcase :downcase :preserve :invert) :reader) (readtablep (t) c::gen-bool :pure) (get-dispatch-macro-character (character character &optional c::readtable-designator) (or c::function-designator null) :reader) (set-dispatch-macro-character (character character c::function-designator &optional c::readtable-designator) (member t)) (get-macro-character (character &optional c::readtable-designator) (values (or c::function-designator null) c::gen-bool) :reader) (set-macro-character (character c::function-designator &optional c::gen-bool c::readtable-designator) (member t)) (set-syntax-from-char (character character &optional readtable c::readtable-designator) (member t)) (si::string-to-object (string &optional t) t) (si::standard-readtable nil readtable) (compile-file (c::pathname-designator &key) (values (or pathname null) c::gen-bool c::gen-bool)) (compile-file-pathname (c::pathname-designator &key) pathname :no-side-effects) (load ((or stream c::pathname-designator) &key) c::gen-bool) (provide (c::string-designator) t) (require (c::string-designator &optional list) t) (si::clear-compiler-properties (symbol) t) (decode-universal-time (c::universal-time &optional c::time-zone) (values (integer 0 59) (integer 0 59) (integer 0 23) (integer 1 31) (integer 1 12) unsigned-byte (integer 0 6) c::gen-bool c::time-zone) :pure) (encode-universal-time ((integer 0 59) (integer 0 59) (integer 0 23) (integer 1 31) (integer 1 12) unsigned-byte &optional c::time-zone) c::universal-time :pure) (get-universal-time nil c::universal-time :no-side-effects) (get-decoded-time nil (values (integer 0 59) (integer 0 59) (integer 0 23) (integer 1 31) (integer 1 12) unsigned-byte (integer 0 6) c::gen-bool c::time-zone) :no-side-effects) (sleep ((real 0 *)) null) (apropos (c::string-designator &optional (or null c::package-designator)) (values)) (apropos-list (c::string-designator &optional (or null c::package-designator)) list) (describe (t &optional c::stream-designator) (values)) (get-internal-real-time nil unsigned-byte :no-side-effects) (get-internal-run-time nil unsigned-byte :no-side-effects) (disassemble ((or c::function-designator list)) null) (room (&optional (member t nil :default)) (values &rest t)) (ed (&optional (or null pathname string c::function-name)) (values &rest t)) (inspect (t) (values &rest t)) (dribble (&optional c::pathname-designator) (values &rest t)) (lisp-implementation-type nil (or string null) :pure) (lisp-implementation-version nil (or string null) :pure) (short-site-name nil (or string null) :pure) (long-site-name nil (or string null) :pure) (machine-instance nil (or string null) :pure) (machine-type nil (or string null) :pure) (machine-version nil (or string null) :pure) (software-type nil (or string null) :pure) (software-version nil (or string null) :pure) (user-homedir-pathname (&optional pathname-host) (or pathname null) :no-side-effects) (si::room-report nil (values t t t t t t t t)) (si::reset-gbc-count nil t) (ext::gc (&optional c::gen-bool) t) (ext::quit (&optional fixnum) t) (ext::argc nil c::sequence-index) (ext::argv (unsigned-byte) base-string) (ext::getenv (string) (or null string)) (ext::environ nil list) (ext::system (string) fixnum) (ext::getpid nil si::index) (ext::make-pipe nil (or two-way-stream null)) (ext::run-program (string list &key) (values (or null two-way-stream) (or null integer) ext::external-process)) (ext::make-weak-pointer (t) ext::weak-pointer :no-side-effects) (ext::weak-pointer-value (ext::weak-pointer) t) (si::unbound nil t :pure) (si::traced-old-definition (t) t :no-side-effects) (si::allocate-raw-instance (t t fixnum) ext::instance) (clos::safe-instance-ref (t fixnum) t) (si::instance-ref (t fixnum) t :reader) (si::instance-sig (standard-object) list :reader) (si::instance-set (t fixnum t) t) (si::instance-class (t) class :reader) (si::instance-class-set (t t) t) (si::instancep (t) t :pure) (si::sl-boundp (t) t :reader) (si::sl-makunbound (t fixnum) t) (clos::standard-instance-access (standard-object fixnum) t :reader) (clos::funcallable-standard-instance-access (clos::funcallable-standard-object fixnum) t :reader) (c::associate-methods-to-gfun (generic-function *) generic-function) (clos::need-to-make-load-form-p (t t) c::gen-bool :pure) (clos::load-defclass (t t t t) t) (si::pointer (t) unsigned-byte) (si::foreign-data-p (t) c::gen-bool :pure) (ext::negative-fixnum-p (t) c::gen-bool :pure) (ext::non-negative-fixnum-p (t) c::gen-bool :pure) (ext::non-positive-fixnum-p (t) c::gen-bool :pure) (ext::positive-fixnum-p (t) c::gen-bool :pure) (ext::array-index-p (t) c::gen-bool :pure) (ext::negative-integer-p (t) c::gen-bool :pure) (ext::non-negative-integer-p (t) c::gen-bool :pure) (ext::non-positive-integer-p (t) c::gen-bool :pure) (ext::positive-integer-p (t) c::gen-bool :pure) (ext::negative-rational-p (t) c::gen-bool :pure) (ext::non-negative-rational-p (t) c::gen-bool :pure) (ext::non-positive-rational-p (t) c::gen-bool :pure) (ext::positive-rational-p (t) c::gen-bool :pure) (ext::negative-ratio-p (t) c::gen-bool :pure) (ext::non-negative-ratio-p (t) c::gen-bool :pure) (ext::non-positive-ratio-p (t) c::gen-bool :pure) (ext::positive-ratio-p (t) c::gen-bool :pure) (ext::negative-real-p (t) c::gen-bool :pure) (ext::non-negative-real-p (t) c::gen-bool :pure) (ext::non-positive-real-p (t) c::gen-bool :pure) (ext::positive-real-p (t) c::gen-bool :pure) (ext::negative-float-p (t) c::gen-bool :pure) (ext::non-negative-float-p (t) c::gen-bool :pure) (ext::non-positive-float-p (t) c::gen-bool :pure) (ext::positive-float-p (t) c::gen-bool :pure) (ext::negative-short-float-p (t) c::gen-bool :pure) (ext::non-negative-short-float-p (t) c::gen-bool :pure) (ext::non-positive-short-float-p (t) c::gen-bool :pure) (ext::positive-short-float-p (t) c::gen-bool :pure) (ext::negative-single-float-p (t) c::gen-bool :pure) (ext::non-negative-single-float-p (t) c::gen-bool :pure) (ext::non-positive-single-float-p (t) c::gen-bool :pure) (ext::positive-single-float-p (t) c::gen-bool :pure) (ext::negative-double-float-p (t) c::gen-bool :pure) (ext::non-negative-double-float-p (t) c::gen-bool :pure) (ext::non-positive-double-float-p (t) c::gen-bool :pure) (ext::positive-double-float-p (t) c::gen-bool :pure) (ext::negative-long-float-p (t) c::gen-bool :pure) (ext::non-negative-long-float-p (t) c::gen-bool :pure) (ext::non-positive-long-float-p (t) c::gen-bool :pure) (ext::positive-long-float-p (t) c::gen-bool :pure)) #:loop-list22026 c::i 0 c::parse-function-proclamation apply)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("COMPILER" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (15 0 1 47 12 19 2 48 1 0 73 29) #876=#A(t (49) (c::def-inline c::name safety c::arg-types c::return-rep-type c::expansion (nil :multiple-values :inline-or-warn :exact-return-type :one-liner) t c::one-liner c::exact-return-type c::inline-or-warn c::multiple-values c::arg-rep-types :unsafe :inline-unsafe :safe :inline-safe :always :inline-always "In DEF-INLINE, wrong value of SAFETY" error c::x * eq c::lisp-type->rep-type #Y(nil nil nil (24 45 21 26 13 0 1 22 17 23 39 6 10 0 73 38 6 13 0 19 1 24 29) #876# #1# 0) mapcar :object c::should-be-inlined si::put-sysprop consp values c::rep-type->lisp-type c::return-type :name :arg-rep-types :return-rep-type :return-type :arg-types :exact-return-type :multiple-values :one-liner :expansion c::make-inline-info c::inline-info si::get-sysprop c::previous #Y(c::def-inline nil nil (24 45 1 24 45 2 24 45 3 24 45 4 24 45 5 28 6 22 40 3 14 7 46 8 22 40 2 77 46 9 22 40 2 77 46 10 22 40 3 14 7 46 11 75 45 12 10 8 42 13 5 11 14 38 20 42 15 5 11 16 38 13 42 17 5 11 18 38 6 15 19 19 1 20 51 8 34 25 12 13 7 19 2 26 51 0 13 6 11 7 17 23 39 5 11 27 51 6 10 2 39 10 13 9 15 28 14 7 19 3 29 10 6 16 30 39 9 10 6 4 12 1 31 17 23 39 5 11 7 38 6 13 6 19 1 32 45 33 14 34 13 10 14 35 13 1 14 36 13 7 14 37 13 0 14 38 13 8 14 39 13 4 14 40 13 2 14 41 13 5 14 42 13 6 19 18 43 45 44 13 11 10 10 17 45 45 46 13 12 13 11 13 1 10 0 3 12 19 3 29 43 3 29) #876# #1# 0) si::fset)) #1# 0) #Y(si::bytecodes nil nil (75 73 29) #A(t (0) ()) #1# 0) #Y(si::bytecodes nil nil (77 15 0 46 1 46 2 57 3 61 2 2 30 10 2 4 51 1 10 2 5 51 2 33 4 12 13 1 19 2 5 10 2 2 39 4 35 0 1 35 0 0 62 73 43 2 29) #A(t (6) (((aref :unsafe (t t t) t "@0;ecl_aref_unsafe(#0,ecl_fixnum(#1)*(#0)->array.dims[1]+ecl_fixnum(#2))") (aref :unsafe ((array t) t t) t "@0;(#0)->array.self.t[ecl_fixnum(#1)*(#0)->array.dims[1]+ecl_fixnum(#2)]") (aref :unsafe ((array bit) t t) :fixnum "@0;ecl_aref_bv(#0,ecl_fixnum(#1)*(#0)->array.dims[1]+ecl_fixnum(#2))") (aref :unsafe ((array t) fixnum fixnum) t "@0;(#0)->array.self.t[#1*(#0)->array.dims[1]+#2]") (aref :unsafe ((array bit) fixnum fixnum) :fixnum "@0;ecl_aref_bv(#0,(#1)*(#0)->array.dims[1]+#2)") (aref :unsafe ((array base-char) fixnum fixnum) :unsigned-char "@0;(#0)->base_string.self[#1*(#0)->array.dims[1]+#2]") (aref :unsafe ((array double-float) fixnum fixnum) :double "@0;(#0)->array.self.df[#1*(#0)->array.dims[1]+#2]") (aref :unsafe ((array single-float) fixnum fixnum) :float "@0;(#0)->array.self.sf[#1*(#0)->array.dims[1]+#2]") (aref :unsafe ((array fixnum) fixnum fixnum) :fixnum "@0;(#0)->array.self.fix[#1*(#0)->array.dims[1]+#2]") (aref :always (t t) t "ecl_aref1(#0,ecl_to_size(#1))") (aref :always (t fixnum) t "ecl_aref1(#0,#1)") (aref :unsafe (t t) t "ecl_aref1(#0,ecl_fixnum(#1))") (aref :unsafe ((array bit) t) :fixnum "ecl_aref_bv(#0,ecl_fixnum(#1))") (aref :unsafe ((array bit) fixnum) :fixnum "ecl_aref_bv(#0,#1)") (aref :unsafe ((array character) fixnum) :wchar "(#0)->string.self[#1]") (aref :unsafe ((array base-char) fixnum) :unsigned-char "(#0)->base_string.self[#1]") (aref :unsafe ((array double-float) fixnum) :double "(#0)->array.self.df[#1]") (aref :unsafe ((array single-float) fixnum) :float "(#0)->array.self.sf[#1]") (aref :unsafe ((array fixnum) fixnum) :fixnum "(#0)->array.self.fix[#1]") (row-major-aref :always (t t) t "ecl_aref(#0,ecl_to_size(#1))") (row-major-aref :always (t fixnum) t "ecl_aref(#0,#1)") (row-major-aref :unsafe (t t) t "ecl_aref_unsafe(#0,ecl_fixnum(#1))") (row-major-aref :unsafe (t fixnum) t "ecl_aref_unsafe(#0,#1)") (row-major-aref :unsafe ((array bit) t) :fixnum "ecl_aref_bv(#0,ecl_fixnum(#1))") (row-major-aref :unsafe ((array bit) fixnum) :fixnum "ecl_aref_bv(#0,#1)") (row-major-aref :unsafe ((array character) fixnum) :wchar "(#0)->string.self[#1]") (row-major-aref :unsafe ((array base-char) fixnum) :unsigned-char "(#0)->base_string.self[#1]") (row-major-aref :unsafe ((array ext::byte8) fixnum) :uint8-t "(#0)->vector.self.b8[#1]") (row-major-aref :unsafe ((array ext::integer8) fixnum) :int8-t "(#0)->vector.self.i8[#1]") (row-major-aref :unsafe ((array ext::byte16) fixnum) :uint16-t "(#0)->vector.self.b16[#1]") (row-major-aref :unsafe ((array ext::integer16) fixnum) :int16-t "(#0)->vector.self.i16[#1]") (row-major-aref :unsafe ((array ext::byte32) fixnum) :uint32-t "(#0)->vector.self.b32[#1]") (row-major-aref :unsafe ((array ext::integer32) fixnum) :int32-t "(#0)->vector.self.i32[#1]") (row-major-aref :unsafe ((array ext::byte64) fixnum) :uint64-t "(#0)->vector.self.b64[#1]") (row-major-aref :unsafe ((array ext::integer64) fixnum) :int64-t "(#0)->vector.self.i64[#1]") (row-major-aref :unsafe ((array double-float) fixnum) :double "(#0)->array.self.df[#1]") (row-major-aref :unsafe ((array single-float) fixnum) :float "(#0)->array.self.sf[#1]") (row-major-aref :unsafe ((array fixnum) fixnum) :fixnum "(#0)->array.self.fix[#1]") (si::row-major-aset :always (t t t) t "ecl_aset(#0,ecl_to_size(#1),#2)") (si::row-major-aset :always (t fixnum t) t "ecl_aset(#0,#1,#2)") (si::row-major-aset :unsafe (t t t) t "ecl_aset_unsafe(#0,ecl_fixnum(#1),#2)") (si::row-major-aset :unsafe (t fixnum t) t "ecl_aset_unsafe(#0,#1,#2)") (si::row-major-aset :unsafe ((array t) fixnum t) t "(#0)->vector.self.t[#1]= #2") (si::row-major-aset :unsafe ((array bit) fixnum t) :fixnum "ecl_aset_bv(#0,#1,ecl_fixnum(#2))") (si::row-major-aset :unsafe ((array bit) fixnum fixnum) :fixnum "ecl_aset_bv(#0,#1,#2)") (si::row-major-aset :unsafe ((array base-char) fixnum base-char) :unsigned-char "(#0)->base_string.self[#1]= #2") (si::row-major-aset :unsafe ((array character) fixnum character) :wchar "(#0)->string.self[#1]= #2") (si::row-major-aset :unsafe ((array ext::byte8) fixnum ext::byte8) :uint8-t "(#0)->vector.self.b8[#1]= #2") (si::row-major-aset :unsafe ((array ext::integer8) fixnum ext::integer8) :int8-t "(#0)->vector.self.i8[#1]= #2") (si::row-major-aset :unsafe ((array ext::byte16) fixnum ext::byte16) :uint16-t "(#0)->vector.self.b16[#1]= #2") (si::row-major-aset :unsafe ((array ext::integer16) fixnum ext::integer16) :int16-t "(#0)->vector.self.i16[#1]= #2") (si::row-major-aset :unsafe ((array ext::byte32) fixnum ext::byte32) :uint32-t "(#0)->vector.self.b32[#1]= #2") (si::row-major-aset :unsafe ((array ext::integer32) fixnum ext::integer32) :int32-t "(#0)->vector.self.i32[#1]= #2") (si::row-major-aset :unsafe ((array ext::byte64) fixnum ext::byte64) :uint64-t "(#0)->vector.self.b64[#1]= #2") (si::row-major-aset :unsafe ((array ext::integer64) fixnum ext::integer64) :int64-t "(#0)->vector.self.i64[#1]= #2") (si::row-major-aset :unsafe ((array double-float) fixnum double-float) :double "(#0)->array.self.df[#1]= #2") (si::row-major-aset :unsafe ((array single-float) fixnum single-float) :float "(#0)->array.self.sf[#1]= #2") (si::row-major-aset :unsafe ((array fixnum) fixnum fixnum) :fixnum "(#0)->array.self.fix[#1]= #2") (si::copy-subarray :always (array ext::array-index array ext::array-index ext::array-index) array "@0;(ecl_copy_subarray(#0,#1,#2,#3,#4),#0)") (array-rank :unsafe (array) :fixnum "@0;(((#0)->d.t == t_array)?(#0)->array.rank:1)") (array-rank :always (array) :fixnum "ecl_array_rank(#0)") (array-dimension :always (t t) fixnum "ecl_array_dimension(#0,ecl_to_size(#1))") (array-dimension :always (t fixnum) fixnum "ecl_array_dimension(#0,#1)") (array-total-size :unsafe (t) :fixnum "((#0)->array.dim)") (adjustable-array-p :always (t) :bool "@0;(ECL_ARRAYP(#0)? (void)0: FEtype_error_array(#0),ECL_ADJUSTABLE_ARRAY_P(#0))") (adjustable-array-p :unsafe (array) :bool "ECL_ADJUSTABLE_ARRAY_P(#0)") (svref :always (t t) t "ecl_aref1(#0,ecl_to_size(#1))") (svref :always (t fixnum) t "ecl_aref1(#0,#1)") (svref :unsafe (t t) t "(#0)->vector.self.t[ecl_fixnum(#1)]") (svref :unsafe (t fixnum) t "(#0)->vector.self.t[#1]") (si::svset :always (t t t) t "ecl_aset1(#0,ecl_to_size(#1),#2)") (si::svset :always (t fixnum t) t "ecl_aset1(#0,#1,#2)") (si::svset :unsafe (t t t) t "((#0)->vector.self.t[ecl_fixnum(#1)]=(#2))") (si::svset :unsafe (t fixnum t) t "(#0)->vector.self.t[#1]= #2") (array-has-fill-pointer-p :always (t) :bool "@0;(ECL_ARRAYP(#0)?(void)0:FEtype_error_array(#0),ECL_ARRAY_HAS_FILL_POINTER_P(#0))") (array-has-fill-pointer-p :unsafe (array) :bool "ECL_ARRAY_HAS_FILL_POINTER_P(#0)") (fill-pointer :unsafe (t) :fixnum "((#0)->vector.fillp)") (si::fill-pointer-set :unsafe (t fixnum) :fixnum "((#0)->vector.fillp)=(#1)") (standard-char-p :always (character) :bool "ecl_standard_char_p(#0)") (graphic-char-p :always (character) :bool "ecl_graphic_char_p(#0)") (alpha-char-p :always (character) :bool "ecl_alpha_char_p(#0)") (upper-case-p :always (character) :bool "ecl_upper_case_p(#0)") (lower-case-p :always (character) :bool "ecl_lower_case_p(#0)") (both-case-p :always (character) :bool "ecl_both_case_p(#0)") (alphanumericp :always (character) :bool "ecl_alphanumericp(#0)") (char= :always (t t) :bool "ecl_char_code(#0)==ecl_char_code(#1)") (char= :always (character character) :bool "(#0)==(#1)") (char/= :always (t t) :bool "ecl_char_code(#0)!=ecl_char_code(#1)") (char/= :always (character character) :bool "(#0)!=(#1)") (char< :always (character character) :bool "(#0)<(#1)") (char> :always (character character) :bool "(#0)>(#1)") (char<= :always (character character) :bool "(#0)<=(#1)") (char>= :always (character character) :bool "(#0)>=(#1)") (char-code :always (character) :fixnum "#0") (code-char :always (fixnum) :wchar "#0") (char-upcase :always (base-char) :unsigned-char "ecl_char_upcase(#0)") (char-upcase :always (character) :wchar "ecl_char_upcase(#0)") (char-downcase :always (base-char) :unsigned-char "ecl_char_downcase(#0)") (char-downcase :always (character) :wchar "ecl_char_downcase(#0)") (char-int :always (character) :fixnum "#0") (si::foreign-data-p :always (t) :bool "@0;ECL_FOREIGN_DATA_P(#0)") (input-stream-p :always (stream) :bool "ecl_input_stream_p(#0)") (output-stream-p :always (stream) :bool "ecl_output_stream_p(#0)") (gethash :always (t t t) t "ecl_gethash_safe(#0,#1,#2)" :multiple-values nil) (gethash :always (t t) t "ecl_gethash_safe(#0,#1,ECL_NIL)" :multiple-values nil) (car :unsafe (cons) t "ECL_CONS_CAR(#0)") (car :unsafe (t) t "_ecl_car(#0)") (si::cons-car :always (t) t "_ecl_car(#0)") (si::cons-car :unsafe (t) t "ECL_CONS_CAR(#0)") (cdr :unsafe (cons) t "ECL_CONS_CDR(#0)") (cdr :unsafe (t) t "_ecl_cdr(#0)") (si::cons-cdr :always (t) t "_ecl_cdr(#0)") (si::cons-cdr :unsafe (t) t "ECL_CONS_CDR(#0)") (car :always (t) t "ecl_car(#0)") (car :unsafe (t) t "_ecl_car(#0)") (cdr :always (t) t "ecl_cdr(#0)") (cdr :unsafe (t) t "_ecl_cdr(#0)") (caar :always (t) t "ecl_caar(#0)") (caar :unsafe (t) t "_ecl_caar(#0)") (cdar :always (t) t "ecl_cdar(#0)") (cdar :unsafe (t) t "_ecl_cdar(#0)") (cadr :always (t) t "ecl_cadr(#0)") (cadr :unsafe (t) t "_ecl_cadr(#0)") (cddr :always (t) t "ecl_cddr(#0)") (cddr :unsafe (t) t "_ecl_cddr(#0)") (caaar :always (t) t "ecl_caaar(#0)") (caaar :unsafe (t) t "_ecl_caaar(#0)") (cdaar :always (t) t "ecl_cdaar(#0)") (cdaar :unsafe (t) t "_ecl_cdaar(#0)") (cadar :always (t) t "ecl_cadar(#0)") (cadar :unsafe (t) t "_ecl_cadar(#0)") (cddar :always (t) t "ecl_cddar(#0)") (cddar :unsafe (t) t "_ecl_cddar(#0)") (caadr :always (t) t "ecl_caadr(#0)") (caadr :unsafe (t) t "_ecl_caadr(#0)") (cdadr :always (t) t "ecl_cdadr(#0)") (cdadr :unsafe (t) t "_ecl_cdadr(#0)") (caddr :always (t) t "ecl_caddr(#0)") (caddr :unsafe (t) t "_ecl_caddr(#0)") (cdddr :always (t) t "ecl_cdddr(#0)") (cdddr :unsafe (t) t "_ecl_cdddr(#0)") (caaaar :always (t) t "ecl_caaaar(#0)") (caaaar :unsafe (t) t "_ecl_caaaar(#0)") (cdaaar :always (t) t "ecl_cdaaar(#0)") (cdaaar :unsafe (t) t "_ecl_cdaaar(#0)") (cadaar :always (t) t "ecl_cadaar(#0)") (cadaar :unsafe (t) t "_ecl_cadaar(#0)") (cddaar :always (t) t "ecl_cddaar(#0)") (cddaar :unsafe (t) t "_ecl_cddaar(#0)") (caadar :always (t) t "ecl_caadar(#0)") (caadar :unsafe (t) t "_ecl_caadar(#0)") (cdadar :always (t) t "ecl_cdadar(#0)") (cdadar :unsafe (t) t "_ecl_cdadar(#0)") (caddar :always (t) t "ecl_caddar(#0)") (caddar :unsafe (t) t "_ecl_caddar(#0)") (cdddar :always (t) t "ecl_cdddar(#0)") (cdddar :unsafe (t) t "_ecl_cdddar(#0)") (caaadr :always (t) t "ecl_caaadr(#0)") (caaadr :unsafe (t) t "_ecl_caaadr(#0)") (cdaadr :always (t) t "ecl_cdaadr(#0)") (cdaadr :unsafe (t) t "_ecl_cdaadr(#0)") (cadadr :always (t) t "ecl_cadadr(#0)") (cadadr :unsafe (t) t "_ecl_cadadr(#0)") (cddadr :always (t) t "ecl_cddadr(#0)") (cddadr :unsafe (t) t "_ecl_cddadr(#0)") (caaddr :always (t) t "ecl_caaddr(#0)") (caaddr :unsafe (t) t "_ecl_caaddr(#0)") (cdaddr :always (t) t "ecl_cdaddr(#0)") (cdaddr :unsafe (t) t "_ecl_cdaddr(#0)") (cadddr :always (t) t "ecl_cadddr(#0)") (cadddr :unsafe (t) t "_ecl_cadddr(#0)") (cddddr :always (t) t "ecl_cddddr(#0)") (cddddr :unsafe (t) t "_ecl_cddddr(#0)") (cons :always (t t) t "CONS(#0,#1)") (endp :safe (t) :bool "ecl_endp(#0)") (endp :unsafe (t) :bool "#0==ECL_NIL") (nth :always (t t) t "ecl_nth(ecl_to_size(#0),#1)") (nth :always (fixnum t) t "ecl_nth(#0,#1)") (nth :unsafe (t t) t "ecl_nth(ecl_fixnum(#0),#1)") (nth :unsafe (fixnum t) t "ecl_nth(#0,#1)") (nthcdr :always (t t) t "ecl_nthcdr(ecl_to_size(#0),#1)") (nthcdr :always (fixnum t) t "ecl_nthcdr(#0,#1)") (nthcdr :unsafe (t t) t "ecl_nthcdr(ecl_fixnum(#0),#1)") (nthcdr :unsafe (fixnum t) t "ecl_nthcdr(#0,#1)") (last :always (t) t "ecl_last(#0,1)") (list :always nil t "ECL_NIL") (list :always (t) t "ecl_list1(#0)") (list* :always (t) t "#0") (list* :always (t t) t "CONS(#0,#1)") (append :always (t t) t "ecl_append(#0,#1)") (nconc :always (t t) t "ecl_nconc(#0,#1)") (butlast :always (t) t "ecl_butlast(#0,1)") (nbutlast :always (t) t "ecl_nbutlast(#0,1)") (1+ :always (t) t "ecl_one_plus(#0)") (1+ :always (fixnum) t "ecl_make_integer((#0)+1)") (1+ :always (c::double-loat) :double "(double)(#0)+1") (1+ :always (single-float) :float "(float)(#0)+1") (1+ :always (fixnum) :fixnum "(#0)+1" :exact-return-type t) (1- :always (t) t "ecl_one_minus(#0)") (1- :always (fixnum) t "ecl_make_integer((#0)-1)") (1- :always (double-float) :double "(double)(#0)-1") (1- :always (single-float) :float "(float)(#0)-1") (1- :always (fixnum) :fixnum "(#0)-1" :exact-return-type t) (float :always (t single-float) :float "ecl_to_float(#0)") (float :always (t double-float) :double "ecl_to_double(#0)") (float :always (t long-float) :long-double "ecl_to_long_double(#0)") (float :always (c::fixnum-float) :double "((double)(#0))" :exact-return-type t) (float :always (c::fixnum-float) :float "((float)(#0))" :exact-return-type t) (numerator :unsafe (integer) integer "(#0)") (numerator :unsafe (ratio) integer "(#0)->ratio.num") (denominator :unsafe (integer) integer "ecl_make_fixnum(1)") (denominator :unsafe (ratio) integer "(#0)->ratio.den") (floor :always (t) (values &rest t) "ecl_floor1(#0)") (floor :always (t t) (values &rest t) "ecl_floor2(#0,#1)") (ceiling :always (t) (values &rest t) "ecl_ceiling1(#0)") (ceiling :always (t t) (values &rest t) "ecl_ceiling2(#0,#1)") (truncate :always (t) (values &rest t) "ecl_truncate1(#0)") (truncate :always (t t) (values &rest t) "ecl_truncate2(#0,#1)") (round :always (t) (values &rest t) "ecl_round1(#0)") (round :always (t t) (values &rest t) "ecl_round2(#0,#1)") (mod :always (t t) t "(ecl_floor2(#0,#1),cl_env_copy->values[1])") (mod :always (fixnum fixnum) :fixnum "@01;(#0>=0&&#1>0?(#0)%(#1):ecl_imod(#0,#1))") (rem :always (t t) t "(ecl_truncate2(#0,#1),cl_env_copy->values[1])") (rem :always (fixnum fixnum) :fixnum "(#0)%(#1)") (= :always (t t) :bool "ecl_number_equalp(#0,#1)") (= :always (c::fixnum-float c::fixnum-float) :bool "(#0)==(#1)") (/= :always (t t) :bool "!ecl_number_equalp(#0,#1)") (/= :always (c::fixnum-float c::fixnum-float) :bool "(#0)!=(#1)") (< :always (t t) :bool "ecl_number_compare(#0,#1)<0") (< :always (c::fixnum-float c::fixnum-float) :bool "(#0)<(#1)") (< :always (c::fixnum-float c::fixnum-float c::fixnum-float) :bool "@012;((#0)<(#1) && (#1)<(#2))") (> :always (t t) :bool "ecl_number_compare(#0,#1)>0") (> :always (c::fixnum-float c::fixnum-float) :bool "(#0)>(#1)") (> :always (c::fixnum-float c::fixnum-float c::fixnum-float) :bool "@012;((#0)>(#1) && (#1)>(#2))") (<= :always (t t) :bool "ecl_number_compare(#0,#1)<=0") (<= :always (c::fixnum-float c::fixnum-float) :bool "(#0)<=(#1)") (<= :always (c::fixnum-float c::fixnum-float c::fixnum-float) :bool "@012;((#0)<=(#1) && (#1)<=(#2))") (>= :always (t t) :bool "ecl_number_compare(#0,#1)>=0") (>= :always (c::fixnum-float c::fixnum-float) :bool "(#0)>=(#1)") (>= :always (c::fixnum-float c::fixnum-float c::fixnum-float) :bool "@012;((#0)>=(#1) && (#1)>=(#2))") (max :always (t t) t "@01;(ecl_number_compare(#0,#1)>=0?#0:#1)") (max :always (fixnum fixnum) :fixnum "@01;(#0)>=(#1)?#0:#1") (min :always (t t) t "@01;(ecl_number_compare(#0,#1)<=0?#0:#1)") (min :always (fixnum fixnum) :fixnum "@01;(#0)<=(#1)?#0:#1") (logand :always nil t "ecl_make_fixnum(-1)") (logand :always nil :fixnum "-1") (logand :always (t t) t "ecl_boole(ECL_BOOLAND,(#0),(#1))") (logand :always (fixnum fixnum) :fixnum "((#0) & (#1))") (logandc1 :always (t t) t "ecl_boole(ECL_BOOLANDC1,(#0),(#1))") (logandc1 :always (fixnum fixnum) :fixnum "(~(#0) & (#1))") (logandc2 :always (t t) t "ecl_boole(ECL_BOOLANDC2,(#0),(#1))") (logandc2 :always (fixnum fixnum) :fixnum "((#0) & ~(#1))") (logeqv :always nil t "ecl_make_fixnum(-1)") (logeqv :always nil :fixnum "-1") (logeqv :always (t t) t "ecl_boole(ECL_BOOLEQV,(#0),(#1))") (logeqv :always (fixnum fixnum) :fixnum "(~( (#0) ^ (#1) ))") (logior :always nil t "ecl_make_fixnum(0)") (logior :always nil :fixnum "0") (logior :always (t t) t "ecl_boole(ECL_BOOLIOR,(#0),(#1))") (logior :always (fixnum fixnum) :fixnum "((#0) | (#1))") (lognand :always (t t) t "ecl_boole(ECL_BOOLNAND,(#0),(#1))") (lognand :always (fixnum fixnum) :fixnum "(~( (#0) & (#1) ))") (lognor :always (t t) t "ecl_boole(ECL_BOOLNOR,(#0),(#1))") (lognor :always (fixnum fixnum) :fixnum "(~( (#0) | (#1) ))") (lognot :always (t) t "ecl_boole(ECL_BOOLXOR,(#0),ecl_make_fixnum(-1))") (lognot :always (fixnum) :fixnum "(~(#0))") (logorc1 :always (t t) t "ecl_boole(ECL_BOOLORC1,(#0),(#1))") (logorc1 :always (fixnum fixnum) :fixnum "(~(#0) | (#1))") (logorc2 :always (t t) t "ecl_boole(ECL_BOOLORC2,(#0),(#1))") (logorc2 :always (fixnum fixnum) :fixnum "((#0) | ~(#1))") (logxor :always nil t "ecl_make_fixnum(0)") (logxor :always nil :fixnum "0") (logxor :always (t t) t "ecl_boole(ECL_BOOLXOR,(#0),(#1))") (logxor :always (fixnum fixnum) :fixnum "((#0) ^ (#1))") (boole :always (fixnum t t) t "ecl_boole((#0),(#1),(#2))") (logbitp :always ((integer -29 29) fixnum) :bool "(#1 >> #0) & 1") (integer-length :always (t) :cl-index "ecl_integer_length(#0)") (zerop :always (t) :bool "ecl_zerop(#0)") (zerop :always (c::fixnum-float) :bool "(#0)==0") (plusp :always (t) :bool "ecl_plusp(#0)") (plusp :always (c::fixnum-float) :bool "(#0)>0") (minusp :always (t) :bool "ecl_minusp(#0)") (minusp :always (c::fixnum-float) :bool "(#0)<0") (oddp :always (t) :bool "ecl_oddp(#0)") (oddp :always (fixnum fixnum) :bool "(#0) & 1") (evenp :always (t) :bool "ecl_evenp(#0)") (evenp :always (fixnum fixnum) :bool "~(#0) & 1") (abs :always (t t) t "ecl_abs(#0,#1)") (exp :always (t) t "ecl_exp(#0)") (expt :always (t t) t "ecl_expt(#0,#1)") (expt :always ((integer 2 2) (integer 0 29)) :fixnum "(1<<(#1))") (expt :always ((integer 0 0) t) :fixnum "0") (expt :always ((integer 1 1) t) :fixnum "1") (log :always (c::fixnum-float) :double "log((double)(#0))" :exact-return-type t) (log :always (c::fixnum-float) :float "(float)log((double)(#0))" :exact-return-type t) (sqrt :always (number) number "ecl_sqrt(#0)") (sqrt :always ((long-float #157# *)) :double "sqrt((double)(#0))") (sqrt :always ((double-float #157# *)) :double "sqrt((double)(#0))") (sqrt :always ((single-float #157# *)) :float "(float)sqrt((double)(#0))") (sqrt :always ((short-float #157# *)) :float "(float)sqrt((double)(#0))") (sin :always (number) number "ecl_sin(#0)") (sin :always (c::fixnum-float) :double "sin((double)(#0))" :exact-return-type t) (sin :always (c::fixnum-float) :float "(float)sin((double)(#0))" :exact-return-type t) (cos :always (t) number "ecl_cos(#0)") (cos :always (c::fixnum-float) :double "cos((double)(#0))" :exact-return-type t) (cos :always (c::fixnum-float) :float "(float)cos((double)(#0))" :exact-return-type t) (tan :always (t) number "ecl_tan(#0)") (tan :always (c::fixnum-float) :double "tan((double)(#0))" :exact-return-type t) (tan :always (c::fixnum-float) :float "(float)tan((double)(#0))" :exact-return-type t) (sinh :always (t) number "ecl_sinh(#0)") (sinh :always (c::fixnum-float) :double "sinh((double)(#0))" :exact-return-type t) (sinh :always (c::fixnum-float) :float "(float)sinh((double)(#0))" :exact-return-type t) (cosh :always (t) number "ecl_cosh(#0)") (cosh :always (c::fixnum-float) :double "cosh((double)(#0))" :exact-return-type t) (cosh :always (c::fixnum-float) :float "(float)cosh((double)(#0))" :exact-return-type t) (tanh :always (t) number "ecl_tanh(#0)") (tanh :always (c::fixnum-float) :double "tanh((double)(#0))" :exact-return-type t) (tanh :always (c::fixnum-float) :float "(float)tanh((double)(#0))" :exact-return-type t) (null :always (t) :bool "#0==ECL_NIL") (symbolp :always (t) :bool "@0;ECL_SYMBOLP(#0)") (atom :always (t) :bool "@0;ECL_ATOM(#0)") (consp :always (t) :bool "@0;ECL_CONSP(#0)") (listp :always (t) :bool "@0;ECL_LISTP(#0)") (numberp :always (t) :bool "ecl_numberp(#0)") (integerp :always (t) :bool "@0;ECL_FIXNUMP(#0)||ECL_BIGNUMP(#0)") (floatp :always (t) :bool "floatp(#0)") (characterp :always (t) :bool "ECL_CHARACTERP(#0)") (c::base-char-p :always (character) :bool "ECL_BASE_CHAR_P(#0)") (stringp :always (t) :bool "@0;ECL_STRINGP(#0)") (c::base-string-p :always (t) :bool "@0;ECL_BASE_STRINGP(#0)") (bit-vector-p :always (t) :bool "@0;ECL_BIT_VECTOR_P(#0)") (vectorp :always (t) :bool "@0;ECL_VECTORP(#0)") (arrayp :always (t) :bool "@0;ECL_ARRAYP(#0)") (eq :always (t t) :bool "(#0)==(#1)") (eq :always (fixnum fixnum) :bool "(#0)==(#1)") (eql :always (t t) :bool "ecl_eql(#0,#1)") (eql :always (character t) :bool "(ECL_CODE_CHAR(#0)==(#1))") (eql :always (t character) :bool "((#0)==ECL_CODE_CHAR(#1))") (eql :always (character character) :bool "(#0)==(#1)") (eql :always ((not (or complex bignum ratio float)) t) :bool "(#0)==(#1)") (eql :always (t (not (or complex bignum ratio float))) :bool "(#0)==(#1)") (eql :always (fixnum fixnum) :bool "(#0)==(#1)") (equal :always (t t) :bool "ecl_equal(#0,#1)") (equal :always (fixnum fixnum) :bool "(#0)==(#1)") (equalp :always (t t) :bool "ecl_equalp(#0,#1)") (equalp :always (fixnum fixnum) :bool "(#0)==(#1)") (not :always (t) :bool "(#0)==ECL_NIL") (clear-output :always (stream) null "(ecl_clear_output(#0),ECL_NIL)") (finish-output :always (stream) null "(ecl_finish_output(#0),ECL_NIL)") (finish-output :always (stream) null "(ecl_force_output(#0),ECL_NIL)") (write-char :always (t) t "@0;(ecl_princ_char(ecl_char_code(#0),ECL_NIL),(#0))") (clear-input :always (stream) null "(ecl_clear_input(#0),ECL_NIL)") (copy-readtable :always (null null) t "standard_readtable") (boundp :always (t) :bool "ecl_boundp(cl_env_copy,#0)") (boundp :unsafe ((and symbol (not null))) :bool "ECL_SYM_VAL(cl_env_copy,#0)!=OBJNULL") (elt :always (t t) t "ecl_elt(#0,ecl_fixnum(#1))") (elt :always (t fixnum) t "ecl_elt(#0,#1)") (elt :always (vector t) t "ecl_aref1(#0,ecl_fixnum(#1))") (elt :always (vector fixnum) t "ecl_aref1(#0,#1)") (elt :unsafe (t t) t "ecl_elt(#0,ecl_fixnum(#1))") (elt :unsafe (t fixnum) t "ecl_elt(#0,#1)") (elt :unsafe (vector t) t "ecl_aref_unsafe(#0,ecl_fixnum(#1))") (elt :unsafe (vector fixnum) t "ecl_aref_unsafe(#0,#1)") (aref :unsafe ((array bit) t) :fixnum "ecl_aref_bv(#0,ecl_fixnum(#1))") (aref :unsafe ((array bit) fixnum) :fixnum "ecl_aref_bv(#0,#1)") (aref :unsafe ((array character) fixnum) :wchar "(#0)->string.self[#1]") (aref :unsafe ((array base-char) fixnum) :unsigned-char "(#0)->base_string.self[#1]") (aref :unsafe ((array double-float) fixnum) :double "(#0)->array.self.df[#1]") (aref :unsafe ((array single-float) fixnum) :float "(#0)->array.self.sf[#1]") (aref :unsafe ((array fixnum) fixnum) :fixnum "(#0)->array.self.fix[#1]") (si::elt-set :always (t t t) t "ecl_elt_set(#0,ecl_to_size(#1),#2)") (si::elt-set :always (t fixnum t) t "ecl_elt_set(#0,#1,#2)") (si::elt-set :always (vector t t) t "ecl_aset1(#0,ecl_to_size(#1),#2)") (si::elt-set :always (vector fixnum t) t "ecl_aset1(#0,#1,#2)") (si::elt-set :unsafe (t t t) t "ecl_elt_set(#0,ecl_fixnum(#1),#2)") (si::elt-set :unsafe (vector t t) t "ecl_aset_unsafe(#0,ecl_to_size(#1),#2)") (si::elt-set :unsafe (vector fixnum t) t "ecl_aset_unsafe(#0,#1,#2)") (length :always (t) :fixnum "ecl_length(#0)") (length :unsafe (vector) :fixnum "(#0)->vector.fillp") (copy-seq :always (t) t "ecl_copy_seq(#0)") (char :always (t fixnum) t "ecl_aref1(#0,#1)") (char :always (t fixnum) :wchar "ecl_char(#0,#1)") (char :unsafe (base-string fixnum) :unsigned-char "(#0)->base_string.self[#1]") (char :unsafe (ext::extended-string fixnum) :wchar "(#0)->string.self[#1]") (si::char-set :always (t t t) t "si_char_set(#0,#1,#2)") (si::char-set :always (t fixnum t) t "ecl_aset1(#0,#1,#2)") (si::char-set :always (t fixnum character) :wchar "ecl_char_set(#0,#1,#2)") (si::char-set :unsafe (base-string t t) t "@2;((#0)->base_string.self[ecl_fixnum(#1)]=ecl_char_code(#2),(#2))") (si::char-set :unsafe (base-string fixnum base-char) :unsigned-char "(#0)->base_string.self[#1]= #2") (si::char-set :unsafe (ext::extended-string t t) t "@2;((#0)->string.self[ecl_fixnum(#1)]=ecl_char_code(#2),(#2))") (si::char-set :unsafe (ext::extended-string fixnum character) :unsigned-char "(#0)->string.self[#1]= #2") (schar :always (t t) t "ecl_elt(#0,ecl_to_size(#1))") (schar :always (t fixnum) t "ecl_elt(#0,#1)") (schar :always (t fixnum) :wchar "ecl_char(#0,#1)") (schar :unsafe (base-string t) t "ECL_CODE_CHAR((#0)->base_string.self[ecl_fixnum(#1)])") (schar :unsafe (base-string fixnum) :unsigned-char "(#0)->base_string.self[#1]") (schar :unsafe (ext::extended-string fixnum) :wchar "(#0)->string.self[#1]") (si::schar-set :always (t t t) t "ecl_elt_set(#0,ecl_to_size(#1),#2)") (si::schar-set :always (t fixnum t) t "ecl_elt_set(#0,#1,#2)") (si::schar-set :always (t fixnum character) :wchar "ecl_char_set(#0,#1,#2)") (si::schar-set :unsafe (base-string t t) t "@2;((#0)->base_string.self[ecl_fixnum(#1)]=ecl_char_code(#2),(#2))") (si::schar-set :unsafe (base-string fixnum base-char) :unsigned-char "(#0)->base_string.self[#1]= #2") (si::schar-set :unsafe (ext::extended-string fixnum t) :wchar "@2;((#0)->string.self[#1]= ecl_char_code(#2),(#2))") (si::schar-set :unsafe (ext::extended-string fixnum character) :wchar "(#0)->string.self[#1]= #2") (string= :always (string string) :bool "ecl_string_eq(#0,#1)") (si::structure-name :always (structure) symbol "ECL_STRUCT_NAME(#0)") (si::structure-ref :always (t t fixnum) t "ecl_structure_ref(#0,#1,#2)") (si::structure-set :always (t t fixnum t) t "ecl_structure_set(#0,#1,#2,#3)") (get :always (t t t) t "ecl_get(#0,#1,#2)") (get :always (t t) t "ecl_get(#0,#1,ECL_NIL)") (symbol-name :always (t) string "ecl_symbol_name(#0)") (c::shift>> :always (fixnum fixnum) :fixnum "((#0) >> (- (#1)))") (c::shift<< :always (fixnum fixnum) :fixnum "((#0) << (#1))") (c::short-float-p :always (t) :bool "@0;ECL_SINGLE_FLOAT_P(#0)") (c::single-float-p :always (t) :bool "@0;ECL_SINGLE_FLOAT_P(#0)") (c::double-float-p :always (t) :bool "@0;ECL_DOUBLE_FLOAT_P(#0)") (c::long-float-p :always (t) :bool "@0;ECL_LONG_FLOAT_P(#0)") (ext::fixnump :always (t) :bool "ECL_FIXNUMP(#0)") (ext::fixnump :always (fixnum) :bool "1") (c::ldb1 :always (fixnum fixnum fixnum) :fixnum "((((~((cl_fixnum)-1 << (#0))) << (#1)) & (cl_fixnum)(#2)) >> (#1))") (c::ldb1 :always (fixnum fixnum fixnum) t "ecl_make_fixnum((((~((cl_fixnum)-1 << (#0))) << (#1)) & (cl_fixnum)(#2)) >> (#1))") (mp::lock-count :unsafe (mp::lock) fixnum "((#0)->lock.count)") (si::instance-ref :always (t fixnum) t "ecl_instance_ref((#0),(#1))") (si::instance-ref :unsafe (standard-object fixnum) t "(#0)->instance.slots[#1]") (si::instance-sig :unsafe (standard-object) list "(#0)->instance.sig") (si::instance-set :unsafe (t fixnum t) t "ecl_instance_set((#0),(#1),(#2))") (si::instance-set :unsafe (standard-object fixnum t) t "(#0)->instance.slots[#1]=(#2)") (si::instance-class :always (standard-object) t "ECL_CLASS_OF(#0)") (class-of :unsafe (standard-object) t "ECL_CLASS_OF(#0)") (si::instancep :always (t) :bool "@0;ECL_INSTANCEP(#0)") (si::unbound :always nil t "ECL_UNBOUND") (si::sl-boundp :always (t) :bool "(#0)!=ECL_UNBOUND") (clos::standard-instance-access :always (t t) t "ecl_instance_ref((#0),ecl_to_size(#1))") (clos::standard-instance-access :always (t fixnum) t "ecl_instance_ref((#0),(#1))") (clos::standard-instance-access :unsafe (standard-object fixnum) t "(#0)->instance.slots[#1]") (clos::funcallable-standard-instance-access :always (t t) t "ecl_instance_ref((#0),ecl_to_size(#1))") (clos::funcallable-standard-instance-access :always (t fixnum) t "ecl_instance_ref((#0),(#1))") (clos::funcallable-standard-instance-access :unsafe (clos::funcallable-standard-object fixnum) t "(#0)->instance.slots[#1]")) #:loop-list22033 c::i 0 c::def-inline apply)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 29) #A(t (2) ("SI" si::select-package)) #1# 0) #Y(si::bytecodes nil nil (1 0 16 1 1 0 16 2 76 39 332 15 3 15 4 15 5 15 6 15 7 15 8 15 9 15 10 15 11 15 12 15 13 15 14 15 15 15 16 15 17 15 18 15 19 15 20 15 21 15 22 15 23 15 24 15 25 15 26 15 27 15 28 15 29 15 30 15 31 15 32 15 33 15 34 15 35 15 36 15 37 15 38 15 39 15 40 15 41 15 42 15 43 15 44 15 45 15 46 15 47 15 48 15 49 15 50 15 51 15 52 15 53 15 54 15 55 15 56 15 57 15 58 15 59 15 60 15 61 15 62 15 63 15 64 15 65 15 66 15 67 15 68 15 69 15 70 15 71 15 72 15 73 15 74 15 75 15 76 15 77 15 78 15 79 15 80 15 81 15 82 15 83 15 84 15 85 15 86 15 87 15 88 15 89 15 90 15 91 15 92 15 93 15 94 15 95 15 96 15 97 15 98 15 99 15 100 15 101 15 102 15 103 15 104 15 105 15 106 15 107 15 108 15 109 15 110 15 111 15 112 15 113 15 114 15 115 15 116 15 117 15 118 15 119 15 120 15 121 15 122 15 123 15 124 15 125 15 126 15 127 15 128 15 129 15 130 15 131 15 132 15 133 15 134 15 135 15 136 15 137 15 138 15 139 15 140 15 141 15 142 15 143 15 144 15 145 15 146 15 147 15 148 15 149 15 150 15 151 15 152 15 153 15 154 15 155 15 156 15 157 15 158 15 159 15 160 15 161 15 162 15 163 15 164 19 2 165 7 161 52 0 1 0 73 29) #A(t (166) (c::*in-all-symbols-functions* si::*make-special boundp make-array vector array-dimensions array-in-bounds-p array-row-major-index bit sbit bit-and bit-ior bit-xor bit-eqv bit-nand bit-nor bit-andc1 bit-andc2 bit-orc1 bit-orc2 bit-not vector-pop adjust-array si::do-check-type si::ecase-error si::etypecase-error si::wrong-type-argument si::ccase-error si::ctypecase-error si::setf-definition ext::safe-eval abort continue muffle-warning store-value use-value si::bind-simple-restarts si::bind-simple-handlers si::assert-failure describe inspect read-from-string write-to-string prin1-to-string princ-to-string y-or-n-p yes-or-no-p si::string-to-object union nunion intersection nintersection set-difference nset-difference set-exclusive-or nset-exclusive-or subsetp rassoc-if rassoc-if-not assoc-if assoc-if-not member-if member-if-not subst-if subst-if-not nsubst-if nsubst-if-not logical-pathname-translations load-logical-pathname-translations decode-universal-time encode-universal-time get-decoded-time ensure-directories-exist si::simple-program-error si::signal-simple-error provide require isqrt phase signum cis asin acos asinh acosh atanh ffloor fceiling ftruncate fround logtest byte byte-size byte-position ldb ldb-test mask-field dpb deposit-field find-all-symbols apropos apropos-list si::find-relative-package si::package-parent si::package-children upgraded-array-element-type upgraded-complex-part-type typep subtypep coerce si::do-deftype make-sequence concatenate map some every notany notevery map-into reduce fill replace remove remove-if remove-if-not delete delete-if delete-if-not count count-if count-if-not substitute substitute-if substitute-if-not nsubstitute nsubstitute-if nsubstitute-if-not find find-if find-if-not position position-if position-if-not remove-duplicates delete-duplicates mismatch search sort stable-sort merge constantly si::do-defsetf si::do-define-setf-method ext::system pprint-fill copy-pprint-dispatch pprint-dispatch pprint-linear pprint-newline pprint-tab pprint-tabular set-pprint-dispatch pprint-indent (method-combination-error invalid-method-error clos::std-compute-applicable-methods clos::std-compute-effective-method clos::compute-effective-method-function si::subclassp si::of-class-p slot-boundp slot-makunbound slot-value clos::slot-value-set slot-exists-p clos::need-to-make-load-form-p clos::load-defclass) (ext::array-index-p ext::negative-fixnum-p ext::non-negative-fixnum-p ext::non-positive-fixnum-p ext::positive-fixnum-p ext::negative-integer-p ext::non-negative-integer-p ext::non-positive-integer-p ext::positive-integer-p ext::negative-rational-p ext::non-negative-rational-p ext::non-positive-rational-p ext::positive-rational-p ext::negative-ratio-p ext::non-negative-ratio-p ext::non-positive-ratio-p ext::positive-ratio-p ext::negative-real-p ext::non-negative-real-p ext::non-positive-real-p ext::positive-real-p ext::negative-float-p ext::non-negative-float-p ext::non-positive-float-p ext::positive-float-p ext::negative-short-float-p ext::non-negative-short-float-p ext::non-positive-short-float-p ext::positive-short-float-p ext::negative-single-float-p ext::non-negative-single-float-p ext::non-positive-single-float-p ext::positive-single-float-p ext::negative-double-float-p ext::non-negative-double-float-p ext::non-positive-double-float-p ext::positive-double-float-p ext::negative-long-float-p ext::non-negative-long-float-p ext::non-positive-long-float-p ext::positive-long-float-p) append)) #1# 0) #Y(si::bytecodes nil nil (15 0 15 1 15 2 15 3 15 4 15 5 15 6 15 7 15 8 15 9 15 10 15 11 15 12 15 13 15 14 15 15 15 16 15 17 15 18 15 19 15 20 15 21 15 22 15 23 15 24 15 25 15 26 19 2 27 7 26 12 19 1 28 29) #A(t (29) (si::c-export-fname si::typecase-error-string si::find-documentation si::find-declarations si::search-keyword si::check-keyword si::dm-too-many-arguments si::dm-too-few-arguments si::remove-documentation si::get-documentation si::set-documentation si::expand-set-documentation si::packages-iterator si::pprint-logical-block-helper si::pprint-pop-helper si::make-seq-iterator si::seq-iterator-ref si::seq-iterator-set si::seq-iterator-next si::sequence-count si::structure-type-error si::define-structure si::coerce-to-list si::coerce-to-vector si::traced-old-definition (si::format-princ si::format-prin1 si::format-print-named-character si::format-print-integer si::format-print-cardinal si::format-print-ordinal si::format-print-old-roman si::format-print-roman si::format-fixed si::format-exponential si::format-general si::format-dollars si::format-relative-tab si::format-absolute-tab si::format-justification) (clos::ensure-class clos::standard-instance-get clos::standard-instance-set clos::find-slot-definition clos::simple-code-walker clos::standard-instance-set clos::install-method clos::default-initargs-of clos::associate-methods-to-gfun clos::pop-next-method) append proclaim)) #1# 0))
